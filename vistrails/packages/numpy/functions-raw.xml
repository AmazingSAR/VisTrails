<specs>
  <moduleSpec code_ref="numpy.core.fromnumeric.ravel" module_name="ravel" namespace="'array'">
    <docstring>Return a contiguous flattened array.

A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.

As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)

Parameters
----------
a : array_like
    Input array.  The elements in `a` are read in the order specified by
    `order`, and packed as a 1-D array.
order : {'C','F', 'A', 'K'}, optional

    The elements of `a` are read using this index order. 'C' means
    to index the elements in row-major, C-style order,
    with the last axis index changing fastest, back to the first
    axis index changing slowest.  'F' means to index the elements
    in column-major, Fortran-style order, with the
    first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of
    the memory layout of the underlying array, and only refer to
    the order of axis indexing.  'A' means to read the elements in
    Fortran-like index order if `a` is Fortran *contiguous* in
    memory, C-like order otherwise.  'K' means to read the
    elements in the order they occur in memory, except for
    reversing the data when strides are negative.  By default, 'C'
    index order is used.

Returns
-------
y : array_like
    If `a` is a matrix, y is a 1-D ndarray, otherwise y is an array of
    the same subtype as `a`. The shape of the returned array is
    ``(a.size,)``. Matrices are special cased for backward
    compatibility.

See Also
--------
ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array
                  in row-major order.
ndarray.reshape : Change the shape of an array without changing its data.

Notes
-----
In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.

When a view is desired in as many cases as possible, ``arr.reshape(-1)``
may be preferable.

Examples
--------
It is equivalent to ``reshape(-1, order=order)``.

&gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; print np.ravel(x)
[1 2 3 4 5 6]

&gt;&gt;&gt; print x.reshape(-1)
[1 2 3 4 5 6]

&gt;&gt;&gt; print np.ravel(x, order='F')
[1 4 2 5 3 6]

When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:

&gt;&gt;&gt; print np.ravel(x.T)
[1 4 2 5 3 6]
&gt;&gt;&gt; print np.ravel(x.T, order='A')
[1 2 3 4 5 6]

When ``order`` is 'K', it will preserve orderings that are neither 'C'
nor 'F', but won't reverse axes:

&gt;&gt;&gt; a = np.arange(3)[::-1]; a
array([2, 1, 0])
&gt;&gt;&gt; a.ravel(order='C')
array([2, 1, 0])
&gt;&gt;&gt; a.ravel(order='K')
array([2, 1, 0])

&gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
array([[[ 0,  2,  4],
        [ 1,  3,  5]],
       [[ 6,  8, 10],
        [ 7,  9, 11]]])
&gt;&gt;&gt; a.ravel(order='C')
array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
&gt;&gt;&gt; a.ravel(order='K')
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.  The elements in `a` are read in the order specified by
`order`, and packed as a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>
The elements of `a` are read using this index order. 'C' means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  'F' means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  'A' means to read the elements in
Fortran-like index order if `a` is Fortran *contiguous* in
memory, C-like order otherwise.  'K' means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, 'C'
index order is used.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F', 'A', 'K']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `a` is a matrix, y is a 1-D ndarray, otherwise y is an array of
the same subtype as `a`. The shape of the returned array is
``(a.size,)``. Matrices are special cased for backward
compatibility.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.fromnumeric.swapaxes" module_name="swapaxes" namespace="'array'">
    <docstring>Interchange two axes of an array.

Parameters
----------
a : array_like
    Input array.
axis1 : int
    First axis.
axis2 : int
    Second axis.

Returns
-------
a_swapped : ndarray
    For Numpy &gt;= 1.10, if `a` is an ndarray, then a view of `a` is
    returned; otherwise a new array is created. For earlier Numpy
    versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

Examples
--------
&gt;&gt;&gt; x = np.array([[1,2,3]])
&gt;&gt;&gt; np.swapaxes(x,0,1)
array([[1],
       [2],
       [3]])

&gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
&gt;&gt;&gt; x
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])

&gt;&gt;&gt; np.swapaxes(x,0,2)
array([[[0, 4],
        [2, 6]],
       [[1, 5],
        [3, 7]]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis1" name="axis1" port_type="basic:Integer" show_port="True">
      <docstring>First axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis2" name="axis2" port_type="basic:Integer" show_port="True">
      <docstring>Second axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="a_swapped" name="a_swapped" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>For Numpy &gt;= 1.10, if `a` is an ndarray, then a view of `a` is
returned; otherwise a new array is created. For earlier Numpy
versions a view of `a` is returned only if the order of the
axes is changed, otherwise the input array is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.fromnumeric.transpose" module_name="transpose" namespace="'array'">
    <docstring>Permute the dimensions of an array.

Parameters
----------
a : array_like
    Input array.
axes : list of ints, optional
    By default, reverse the dimensions, otherwise permute the axes
    according to the values given.

Returns
-------
p : ndarray
    `a` with its axes permuted.  A view is returned whenever
    possible.

See Also
--------
rollaxis
argsort

Notes
-----
Use `transpose(a, argsort(axes))` to invert the transposition of tensors
when using the `axes` keyword argument.

Transposing a 1-D array returns an unchanged view of the original array.

Examples
--------
&gt;&gt;&gt; x = np.arange(4).reshape((2,2))
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])

&gt;&gt;&gt; np.transpose(x)
array([[0, 2],
       [1, 3]])

&gt;&gt;&gt; x = np.ones((1, 2, 3))
&gt;&gt;&gt; np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>By default, reverse the dimensions, otherwise permute the axes
according to the values given.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`a` with its axes permuted.  A view is returned whenever
possible.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.shape_base.atleast_1d" module_name="atleast_1d" namespace="'array'">
    <docstring>Convert inputs to arrays with at least one dimension.

Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.

Parameters
----------
arys1, arys2, ... : array_like
    One or more input arrays.

Returns
-------
ret : ndarray
    An array, or sequence of arrays, each with ``a.ndim &gt;= 1``.
    Copies are made only if necessary.

See Also
--------
atleast_2d, atleast_3d

Examples
--------
&gt;&gt;&gt; np.atleast_1d(1.0)
array([ 1.])

&gt;&gt;&gt; x = np.arange(9.0).reshape(3,3)
&gt;&gt;&gt; np.atleast_1d(x)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.]])
&gt;&gt;&gt; np.atleast_1d(x) is x
True

&gt;&gt;&gt; np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</docstring>
    <inputPortSpec arg="arys1" name="arys1" port_type="basic:List" show_port="True">
      <docstring>One or more input arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arys2" name="arys2" port_type="basic:List" show_port="True">
      <docstring>One or more input arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>One or more input arrays.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="ret" name="ret" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array, or sequence of arrays, each with ``a.ndim &gt;= 1``.
Copies are made only if necessary.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.shape_base.atleast_2d" module_name="atleast_2d" namespace="'array'" output_type="list">
    <docstring>View inputs as arrays with at least two dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.

Returns
-------
res, res2, ... : ndarray
    An array, or tuple of arrays, each with ``a.ndim &gt;= 2``.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.

See Also
--------
atleast_1d, atleast_3d

Examples
--------
&gt;&gt;&gt; np.atleast_2d(3.0)
array([[ 3.]])

&gt;&gt;&gt; x = np.arange(3.0)
&gt;&gt;&gt; np.atleast_2d(x)
array([[ 0.,  1.,  2.]])
&gt;&gt;&gt; np.atleast_2d(x).base is x
True

&gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]</docstring>
    <inputPortSpec arg="arys1" name="arys1" port_type="basic:List" show_port="True">
      <docstring>One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arys2" name="arys2" port_type="basic:List" show_port="True">
      <docstring>One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array, or tuple of arrays, each with ``a.ndim &gt;= 2``.
Copies are avoided where possible, and views with two or more
dimensions are returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="res2" name="res2" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array, or tuple of arrays, each with ``a.ndim &gt;= 2``.
Copies are avoided where possible, and views with two or more
dimensions are returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="..." name="..." port_type="basic:List" show_port="True" sort_key="2">
      <docstring>An array, or tuple of arrays, each with ``a.ndim &gt;= 2``.
Copies are avoided where possible, and views with two or more
dimensions are returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.shape_base.atleast_3d" module_name="atleast_3d" namespace="'array'" output_type="list">
    <docstring>View inputs as arrays with at least three dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted to
    arrays.  Arrays that already have three or more dimensions are
    preserved.

Returns
-------
res1, res2, ... : ndarray
    An array, or tuple of arrays, each with ``a.ndim &gt;= 3``.  Copies are
    avoided where possible, and views with three or more dimensions are
    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
    view of shape ``(M, N, 1)``.

See Also
--------
atleast_1d, atleast_2d

Examples
--------
&gt;&gt;&gt; np.atleast_3d(3.0)
array([[[ 3.]]])

&gt;&gt;&gt; x = np.arange(3.0)
&gt;&gt;&gt; np.atleast_3d(x).shape
(1, 3, 1)

&gt;&gt;&gt; x = np.arange(12.0).reshape(4,3)
&gt;&gt;&gt; np.atleast_3d(x).shape
(4, 3, 1)
&gt;&gt;&gt; np.atleast_3d(x).base is x
True

&gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print arr, arr.shape
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)</docstring>
    <inputPortSpec arg="arys1" name="arys1" port_type="basic:List" show_port="True">
      <docstring>One or more array-like sequences.  Non-array inputs are converted to
arrays.  Arrays that already have three or more dimensions are
preserved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arys2" name="arys2" port_type="basic:List" show_port="True">
      <docstring>One or more array-like sequences.  Non-array inputs are converted to
arrays.  Arrays that already have three or more dimensions are
preserved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>One or more array-like sequences.  Non-array inputs are converted to
arrays.  Arrays that already have three or more dimensions are
preserved.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res1" name="res1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array, or tuple of arrays, each with ``a.ndim &gt;= 3``.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
view of shape ``(M, N, 1)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="res2" name="res2" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array, or tuple of arrays, each with ``a.ndim &gt;= 3``.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
view of shape ``(M, N, 1)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="..." name="..." port_type="basic:List" show_port="True" sort_key="2">
      <docstring>An array, or tuple of arrays, each with ``a.ndim &gt;= 3``.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
view of shape ``(M, N, 1)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.array" module_name="array" namespace="'array'">
    <docstring>array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)

Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an
    object whose __array__ method returns an array, or any
    (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then
    the type will be determined as the minimum type required
    to hold the objects in the sequence.  This argument can only
    be used to 'upcast' the array.  For downcasting, use the
    .astype(t) method.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy
    will only be made if __array__ returns a copy, if obj is a
    nested sequence, or if a copy is needed to satisfy any of the other
    requirements (`dtype`, `order`, etc.).
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Returns
-------
out : ndarray
    An array object satisfying the specified requirements.

See Also
--------
empty, empty_like, zeros, zeros_like, ones, ones_like, fill

Examples
--------
&gt;&gt;&gt; np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

&gt;&gt;&gt; np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

&gt;&gt;&gt; np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

&gt;&gt;&gt; np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

&gt;&gt;&gt; np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

&gt;&gt;&gt; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
&gt;&gt;&gt; x['a']
array([1, 3])

Creating an array from sub-classes:

&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])</docstring>
    <inputPortSpec arg="object" name="object" port_type="basic:List" show_port="True">
      <docstring>An array, any object exposing the array interface, an
object whose __array__ method returns an array, or any
(nested) sequence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The desired data-type for the array.  If not given, then
the type will be determined as the minimum type required
to hold the objects in the sequence.  This argument can only
be used to 'upcast' the array.  For downcasting, use the
.astype(t) method.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>If true (default), then the object is copied.  Otherwise, a copy
will only be made if __array__ returns a copy, if obj is a
nested sequence, or if a copy is needed to satisfy any of the other
requirements (`dtype`, `order`, etc.).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Specify the order of the array.  If order is 'C', then the array
will be in C-contiguous order (last-index varies the fastest).
If order is 'F', then the returned array will be in
Fortran-contiguous order (first-index varies the fastest).
If order is 'A' (default), then the returned array may be
in any order (either C-, Fortran-contiguous, or even discontiguous),
unless a copy is required, in which case it will be C-contiguous.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['A']]</values>
      <defaults>['A']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="subok" name="subok" port_type="basic:Boolean">
      <docstring>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndmin" name="ndmin" port_type="basic:Integer">
      <docstring>Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array object satisfying the specified requirements.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.zeros" module_name="zeros" namespace="'array'">
    <docstring>zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
empty : Return a new uninitialized array.

Examples
--------
&gt;&gt;&gt; np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

&gt;&gt;&gt; np.zeros((5,), dtype=np.int)
array([0, 0, 0, 0, 0])

&gt;&gt;&gt; np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

&gt;&gt;&gt; s = (2,2)
&gt;&gt;&gt; np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

&gt;&gt;&gt; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the new array, e.g., ``(2, 3)`` or ``2``.</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The desired data-type for the array, e.g., `numpy.int8`.  Default is
`numpy.float64`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of zeros with the given shape, dtype, and order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.empty" module_name="empty" namespace="'array'">
    <docstring>empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array
dtype : data-type, optional
    Desired output data-type.
order : {'C', 'F'}, optional
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the given
    shape, dtype, and order.

See Also
--------
empty_like, zeros, ones

Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
&gt;&gt;&gt; np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #random

&gt;&gt;&gt; np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #random</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the empty array</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Desired output data-type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of uninitialized (arbitrary) data with the given
shape, dtype, and order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.numeric.asarray" module_name="asarray" namespace="'array'">
    <docstring>Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; np.asarray(a)
array([1, 2])

Existing arrays are not copied:

&gt;&gt;&gt; a = np.array([1, 2])
&gt;&gt;&gt; np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

&gt;&gt;&gt; a = np.array([1, 2], dtype=np.float32)
&gt;&gt;&gt; np.asarray(a, dtype=np.float32) is a
True
&gt;&gt;&gt; np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

&gt;&gt;&gt; issubclass(np.matrix, np.ndarray)
True
&gt;&gt;&gt; a = np.matrix([[1, 2]])
&gt;&gt;&gt; np.asarray(a) is a
False
&gt;&gt;&gt; np.asanyarray(a) is a
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>By default, the data-type is inferred from the input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array interpretation of `a`.  No copy is performed if the input
is already an ndarray.  If `a` is a subclass of ndarray, a base
class ndarray is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.concatenate" module_name="concatenate" namespace="'array'">
    <docstring>concatenate((a1, a2, ...), axis=0)

Join a sequence of arrays along an existing axis.

Parameters
----------
a1, a2, ... : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined.  Default is 0.

Returns
-------
res : ndarray
    The concatenated array.

See Also
--------
ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)

Notes
-----
When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are *not* preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; b = np.array([[5, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])

This function will not preserve masking of MaskedArray inputs.

&gt;&gt;&gt; a = np.ma.arange(3)
&gt;&gt;&gt; a[1] = np.ma.masked
&gt;&gt;&gt; b = np.arange(2, 5)
&gt;&gt;&gt; a
masked_array(data = [0 -- 2],
             mask = [False  True False],
       fill_value = 999999)
&gt;&gt;&gt; b
array([2, 3, 4])
&gt;&gt;&gt; np.concatenate([a, b])
masked_array(data = [0 1 2 2 3 4],
             mask = False,
       fill_value = 999999)
&gt;&gt;&gt; np.ma.concatenate([a, b])
masked_array(data = [0 -- 2 2 3 4],
             mask = [False  True False False False False],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="a1" name="a1" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a2" name="a2" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the arrays will be joined.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The concatenated array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.shape_base.stack" module_name="stack" namespace="'array'">
    <docstring>Join a sequence of arrays along a new axis.

The `axis` parameter specifies the index of the new axis in the dimensions
of the result. For example, if ``axis=0`` it will be the first dimension
and if ``axis=-1`` it will be the last dimension.

.. versionadded:: 1.10.0

Parameters
----------
arrays : sequence of array_like
    Each array must have the same shape.
axis : int, optional
    The axis in the result array along which the input arrays are stacked.

Returns
-------
stacked : ndarray
    The stacked array has one more dimension than the input arrays.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
split : Split array into a list of multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)]
&gt;&gt;&gt; np.stack(arrays, axis=0).shape
(10, 3, 4)

&gt;&gt;&gt; np.stack(arrays, axis=1).shape
(3, 10, 4)

&gt;&gt;&gt; np.stack(arrays, axis=2).shape
(3, 4, 10)

&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([2, 3, 4])
&gt;&gt;&gt; np.stack((a, b))
array([[1, 2, 3],
       [2, 3, 4]])

&gt;&gt;&gt; np.stack((a, b), axis=-1)
array([[1, 2],
       [2, 3],
       [3, 4]])</docstring>
    <inputPortSpec arg="arrays" name="arrays" port_type="basic:List" show_port="True">
      <docstring>Each array must have the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis in the result array along which the input arrays are stacked.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="stacked" name="stacked" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The stacked array has one more dimension than the input arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.shape_base.column_stack" module_name="column_stack" namespace="'array'">
    <docstring>Stack 1-D arrays as columns into a 2-D array.

Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with `hstack`.  1-D arrays are turned into 2-D columns
first.

Parameters
----------
tup : sequence of 1-D or 2-D arrays.
    Arrays to stack. All of them must have the same first dimension.

Returns
-------
stacked : 2-D array
    The array formed by stacking the given arrays.

See Also
--------
hstack, vstack, concatenate

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((2,3,4))
&gt;&gt;&gt; np.column_stack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])</docstring>
    <inputPortSpec arg="tup" name="tup" port_type="basic:List" show_port="True">
      <docstring>Arrays to stack. All of them must have the same first dimension.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="stacked" name="stacked" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array formed by stacking the given arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.shape_base.dstack" module_name="dstack" namespace="'array'">
    <docstring>Stack arrays in sequence depth wise (along third axis).

Takes a sequence of arrays and stack them along the third axis
to make a single array. Rebuilds arrays divided by `dsplit`.
This is a simple way to stack 2D arrays (images) into a single
3D array for processing.

Parameters
----------
tup : sequence of arrays
    Arrays to stack. All of them must have the same shape along all
    but the third axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
stack : Join a sequence of arrays along a new axis.
vstack : Stack along first axis.
hstack : Stack along second axis.
concatenate : Join a sequence of arrays along an existing axis.
dsplit : Split array along third axis.

Notes
-----
Equivalent to ``np.concatenate(tup, axis=2)``.

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((2,3,4))
&gt;&gt;&gt; np.dstack((a,b))
array([[[1, 2],
        [2, 3],
        [3, 4]]])

&gt;&gt;&gt; a = np.array([[1],[2],[3]])
&gt;&gt;&gt; b = np.array([[2],[3],[4]])
&gt;&gt;&gt; np.dstack((a,b))
array([[[1, 2]],
       [[2, 3]],
       [[3, 4]]])</docstring>
    <inputPortSpec arg="tup" name="tup" port_type="basic:List" show_port="True">
      <docstring>Arrays to stack. All of them must have the same shape along all
but the third axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="stacked" name="stacked" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array formed by stacking the given arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.shape_base.hstack" module_name="hstack" namespace="'array'">
    <docstring>Stack arrays in sequence horizontally (column wise).

Take a sequence of arrays and stack them horizontally to make
a single array. Rebuild arrays divided by `hsplit`.

Parameters
----------
tup : sequence of ndarrays
    All arrays must have the same shape along all but the second axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
concatenate : Join a sequence of arrays along an existing axis.
hsplit : Split array along second axis.

Notes
-----
Equivalent to ``np.concatenate(tup, axis=1)``

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((2,3,4))
&gt;&gt;&gt; np.hstack((a,b))
array([1, 2, 3, 2, 3, 4])
&gt;&gt;&gt; a = np.array([[1],[2],[3]])
&gt;&gt;&gt; b = np.array([[2],[3],[4]])
&gt;&gt;&gt; np.hstack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])</docstring>
    <inputPortSpec arg="tup" name="tup" port_type="basic:List" show_port="True">
      <docstring>All arrays must have the same shape along all but the second axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="stacked" name="stacked" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array formed by stacking the given arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.shape_base.vstack" module_name="vstack" namespace="'array'">
    <docstring>Stack arrays in sequence vertically (row wise).

Take a sequence of arrays and stack them vertically to make a single
array. Rebuild arrays divided by `vsplit`.

Parameters
----------
tup : sequence of ndarrays
    Tuple containing arrays to be stacked. The arrays must have the same
    shape along all but the first axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays along an existing axis.
vsplit : Split array into a list of multiple sub-arrays vertically.

Notes
-----
Equivalent to ``np.concatenate(tup, axis=0)`` if `tup` contains arrays that
are at least 2-dimensional.

Examples
--------
&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([2, 3, 4])
&gt;&gt;&gt; np.vstack((a,b))
array([[1, 2, 3],
       [2, 3, 4]])

&gt;&gt;&gt; a = np.array([[1], [2], [3]])
&gt;&gt;&gt; b = np.array([[2], [3], [4]])
&gt;&gt;&gt; np.vstack((a,b))
array([[1],
       [2],
       [3],
       [2],
       [3],
       [4]])</docstring>
    <inputPortSpec arg="tup" name="tup" port_type="basic:List" show_port="True">
      <docstring>Tuple containing arrays to be stacked. The arrays must have the same
shape along all but the first axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="stacked" name="stacked" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array formed by stacking the given arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.shape_base.split" module_name="split" namespace="'array'">
    <docstring>Split an array into multiple sub-arrays.

Parameters
----------
ary : ndarray
    Array to be divided into sub-arrays.
indices_or_sections : int or 1-D array
    If `indices_or_sections` is an integer, N, the array will be divided
    into N equal arrays along `axis`.  If such a split is not possible,
    an error is raised.

    If `indices_or_sections` is a 1-D array of sorted integers, the entries
    indicate where along `axis` the array is split.  For example,
    ``[2, 3]`` would, for ``axis=0``, result in

      - ary[:2]
      - ary[2:3]
      - ary[3:]

    If an index exceeds the dimension of the array along `axis`,
    an empty sub-array is returned correspondingly.
axis : int, optional
    The axis along which to split, default is 0.

Returns
-------
sub-arrays : list of ndarrays
    A list of sub-arrays.

Raises
------
ValueError
    If `indices_or_sections` is given as an integer, but
    a split does not result in equal division.

See Also
--------
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.  Does not raise an exception if
              an equal division cannot be made.
hsplit : Split array into multiple sub-arrays horizontally (column-wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).

Examples
--------
&gt;&gt;&gt; x = np.arange(9.0)
&gt;&gt;&gt; np.split(x, 3)
[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]

&gt;&gt;&gt; x = np.arange(8.0)
&gt;&gt;&gt; np.split(x, [3, 5, 6, 10])
[array([ 0.,  1.,  2.]),
 array([ 3.,  4.]),
 array([ 5.]),
 array([ 6.,  7.]),
 array([], dtype=float64)]</docstring>
    <inputPortSpec arg="ary" name="ary" port_type="basic:List" show_port="True">
      <docstring>Array to be divided into sub-arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="indices_or_sections" name="indices_or_sectionsScalar" port_type="basic:Integer" show_port="True">
      <docstring>If `indices_or_sections` is an integer, N, the array will be divided
into N equal arrays along `axis`.  If such a split is not possible,
an error is raised.

If `indices_or_sections` is a 1-D array of sorted integers, the entries
indicate where along `axis` the array is split.  For example,
``[2, 3]`` would, for ``axis=0``, result in

  - ary[:2]
  - ary[2:3]
  - ary[3:]

If an index exceeds the dimension of the array along `axis`,
an empty sub-array is returned correspondingly.</docstring>
      <alternateSpec arg="indices_or_sections" name="indices_or_sectionsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which to split, default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sub-arrays" name="sub-arrays" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A list of sub-arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.shape_base.array_split" module_name="array_split" namespace="'array'">
    <docstring>Split an array into multiple sub-arrays.

Please refer to the ``split`` documentation.  The only difference
between these functions is that ``array_split`` allows
`indices_or_sections` to be an integer that does *not* equally
divide the axis.

See Also
--------
split : Split array into multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; x = np.arange(8.0)
&gt;&gt;&gt; np.array_split(x, 3)
    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]</docstring>
    <inputPortSpec arg="ary" name="ary" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="indices_or_sections" name="indices_or_sections" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.shape_base.tile" module_name="tile" namespace="'array'">
    <docstring>Construct an array by repeating A the number of times given by reps.

If `reps` has length ``d``, the result will have dimension of
``max(d, A.ndim)``.

If ``A.ndim &lt; d``, `A` is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote `A` to d-dimensions manually before calling this
function.

If ``A.ndim &gt; d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.
Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as
(1, 1, 2, 2).

Parameters
----------
A : array_like
    The input array.
reps : array_like
    The number of repetitions of `A` along each axis.

Returns
-------
c : ndarray
    The tiled output array.

See Also
--------
repeat : Repeat elements of an array.

Examples
--------
&gt;&gt;&gt; a = np.array([0, 1, 2])
&gt;&gt;&gt; np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
       [[0, 1, 2, 0, 1, 2]]])

&gt;&gt;&gt; b = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.tile(b, 2)
array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
&gt;&gt;&gt; np.tile(b, (2, 1))
array([[1, 2],
       [3, 4],
       [1, 2],
       [3, 4]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="reps" name="reps" port_type="basic:List" show_port="True">
      <docstring>The number of repetitions of `A` along each axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The tiled output array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.fromnumeric.repeat" module_name="repeat" namespace="'array'">
    <docstring>Repeat elements of an array.

Parameters
----------
a : array_like
    Input array.
repeats : int or array of ints
    The number of repetitions for each element.  `repeats` is broadcasted
    to fit the shape of the given axis.
axis : int, optional
    The axis along which to repeat values.  By default, use the
    flattened input array, and return a flat output array.

Returns
-------
repeated_array : ndarray
    Output array which has the same shape as `a`, except along
    the given axis.

See Also
--------
tile : Tile an array.

Examples
--------
&gt;&gt;&gt; x = np.array([[1,2],[3,4]])
&gt;&gt;&gt; np.repeat(x, 2)
array([1, 1, 2, 2, 3, 3, 4, 4])
&gt;&gt;&gt; np.repeat(x, 3, axis=1)
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
&gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)
array([[1, 2],
       [3, 4],
       [3, 4]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="repeats" name="repeatsScalar" port_type="basic:Integer" show_port="True">
      <docstring>The number of repetitions for each element.  `repeats` is broadcasted
to fit the shape of the given axis.</docstring>
      <alternateSpec arg="repeats" depth="1" name="repeatsSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which to repeat values.  By default, use the
flattened input array, and return a flat output array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="repeated_array" name="repeated_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array which has the same shape as `a`, except along
the given axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.function_base.delete" module_name="delete" namespace="'array'">
    <docstring>Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
`arr[obj]`.

Parameters
----------
arr : array_like
  Input array.
obj : slice, int or array of ints
  Indicate which sub-arrays to remove.
axis : int, optional
  The axis along which to delete the subarray defined by `obj`.
  If `axis` is None, `obj` is applied to the flattened array.

Returns
-------
out : ndarray
    A copy of `arr` with the elements specified by `obj` removed. Note
    that `delete` does not occur in-place. If `axis` is None, `out` is
    a flattened array.

See Also
--------
insert : Insert elements into an array.
append : Append elements at the end of an array.

Notes
-----
Often it is preferable to use a boolean mask. For example:

&gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)
&gt;&gt;&gt; mask[[0,2,4]] = False
&gt;&gt;&gt; result = arr[mask,...]

Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further
use of `mask`.

Examples
--------
&gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
&gt;&gt;&gt; arr
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; np.delete(arr, 1, 0)
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])

&gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)
array([[ 2,  4],
       [ 6,  8],
       [10, 12]])
&gt;&gt;&gt; np.delete(arr, [1,3,5], None)
array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="objScalar" port_type="basic:Integer" show_port="True">
      <docstring>Indicate which sub-arrays to remove.</docstring>
      <alternateSpec arg="obj" depth="1" name="objSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which to delete the subarray defined by `obj`.
If `axis` is None, `obj` is applied to the flattened array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A copy of `arr` with the elements specified by `obj` removed. Note
that `delete` does not occur in-place. If `axis` is None, `out` is
a flattened array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.function_base.insert" module_name="insert" namespace="'array'">
    <docstring>Insert values along the given axis before the given indices.

Parameters
----------
arr : array_like
    Input array.
obj : int, slice or sequence of ints
    Object that defines the index or indices before which `values` is
    inserted.

    .. versionadded:: 1.8.0

    Support for multiple insertions when `obj` is a single scalar or a
    sequence with one element (similar to calling insert multiple
    times).
values : array_like
    Values to insert into `arr`. If the type of `values` is different
    from that of `arr`, `values` is converted to the type of `arr`.
    `values` should be shaped so that ``arr[...,obj,...] = values``
    is legal.
axis : int, optional
    Axis along which to insert `values`.  If `axis` is None then `arr`
    is flattened first.

Returns
-------
out : ndarray
    A copy of `arr` with `values` inserted.  Note that `insert`
    does not occur in-place: a new array is returned. If
    `axis` is None, `out` is a flattened array.

See Also
--------
append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.

Notes
-----
Note that for higher dimensional inserts `obj=0` behaves very different
from `obj=[0]` just like `arr[:,0,:] = values` is different from
`arr[:,[0],:] = values`.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])
&gt;&gt;&gt; a
array([[1, 1],
       [2, 2],
       [3, 3]])
&gt;&gt;&gt; np.insert(a, 1, 5)
array([1, 5, 1, 2, 2, 3, 3])
&gt;&gt;&gt; np.insert(a, 1, 5, axis=1)
array([[1, 5, 1],
       [2, 5, 2],
       [3, 5, 3]])

Difference between sequence and scalars:

&gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])
&gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
...                np.insert(a, [1], [[1],[2],[3]], axis=1))
True

&gt;&gt;&gt; b = a.flatten()
&gt;&gt;&gt; b
array([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])
array([1, 1, 5, 6, 2, 2, 3, 3])

&gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])
array([1, 1, 5, 2, 6, 2, 3, 3])

&gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting
array([1, 1, 7, 0, 2, 2, 3, 3])

&gt;&gt;&gt; x = np.arange(8).reshape(2, 4)
&gt;&gt;&gt; idx = (1, 3)
&gt;&gt;&gt; np.insert(x, idx, 999, axis=1)
array([[  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7]])</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="objScalar" port_type="basic:Integer" show_port="True">
      <docstring>Object that defines the index or indices before which `values` is
inserted.

.. versionadded:: 1.8.0

Support for multiple insertions when `obj` is a single scalar or a
sequence with one element (similar to calling insert multiple
times).</docstring>
      <alternateSpec arg="obj" depth="1" name="objSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>Values to insert into `arr`. If the type of `values` is different
from that of `arr`, `values` is converted to the type of `arr`.
`values` should be shaped so that ``arr[...,obj,...] = values``
is legal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to insert `values`.  If `axis` is None then `arr`
is flattened first.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A copy of `arr` with `values` inserted.  Note that `insert`
does not occur in-place: a new array is returned. If
`axis` is None, `out` is a flattened array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.function_base.append" module_name="append" namespace="'array'">
    <docstring>Append values to the end of an array.

Parameters
----------
arr : array_like
    Values are appended to a copy of this array.
values : array_like
    These values are appended to a copy of `arr`.  It must be of the
    correct shape (the same shape as `arr`, excluding `axis`).  If
    `axis` is not specified, `values` can be any shape and will be
    flattened before use.
axis : int, optional
    The axis along which `values` are appended.  If `axis` is not
    given, both `arr` and `values` are flattened before use.

Returns
-------
append : ndarray
    A copy of `arr` with `values` appended to `axis`.  Note that
    `append` does not occur in-place: a new array is allocated and
    filled.  If `axis` is None, `out` is a flattened array.

See Also
--------
insert : Insert elements into an array.
delete : Delete elements from an array.

Examples
--------
&gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, 4, 5, 6, 7, 8, 9])

When `axis` is specified, `values` must have the correct shape.

&gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
...
ValueError: arrays must have same number of dimensions</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Values are appended to a copy of this array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>These values are appended to a copy of `arr`.  It must be of the
correct shape (the same shape as `arr`, excluding `axis`).  If
`axis` is not specified, `values` can be any shape and will be
flattened before use.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which `values` are appended.  If `axis` is not
given, both `arr` and `values` are flattened before use.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="append" name="append" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A copy of `arr` with `values` appended to `axis`.  Note that
`append` does not occur in-place: a new array is allocated and
filled.  If `axis` is None, `out` is a flattened array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.fromnumeric.resize" module_name="resize" namespace="'array'">
    <docstring>Return a new array with the specified shape.

If the new array is larger than the original array, then the new
array is filled with repeated copies of `a`.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of `a`.

Parameters
----------
a : array_like
    Array to be resized.

new_shape : int or tuple of int
    Shape of resized array.

Returns
-------
reshaped_array : ndarray
    The new array is formed from the data in the old array, repeated
    if necessary to fill out the required number of elements.  The
    data are repeated in the order that they are stored in memory.

See Also
--------
ndarray.resize : resize an array in-place.

Examples
--------
&gt;&gt;&gt; a=np.array([[0,1],[2,3]])
&gt;&gt;&gt; np.resize(a,(2,3))
array([[0, 1, 2],
       [3, 0, 1]])
&gt;&gt;&gt; np.resize(a,(1,4))
array([[0, 1, 2, 3]])
&gt;&gt;&gt; np.resize(a,(2,4))
array([[0, 1, 2, 3],
       [0, 1, 2, 3]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to be resized.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="new_shape" name="new_shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of resized array.</docstring>
      <alternateSpec arg="new_shape" depth="1" name="new_shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="reshaped_array" name="reshaped_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The new array is formed from the data in the old array, repeated
if necessary to fill out the required number of elements.  The
data are repeated in the order that they are stored in memory.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.function_base.trim_zeros" module_name="trim_zeros" namespace="'array'">
    <docstring>Trim the leading and/or trailing zeros from a 1-D array or sequence.

Parameters
----------
filt : 1-D array or sequence
    Input array.
trim : str, optional
    A string with 'f' representing trim from front and 'b' to trim from
    back. Default is 'fb', trim zeros from both front and back of the
    array.

Returns
-------
trimmed : 1-D array or sequence
    The result of trimming the input. The input data type is preserved.

Examples
--------
&gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
&gt;&gt;&gt; np.trim_zeros(a)
array([1, 2, 3, 0, 2, 1])

&gt;&gt;&gt; np.trim_zeros(a, 'b')
array([0, 0, 0, 1, 2, 3, 0, 2, 1])

The input data type is preserved, list/tuple in means list/tuple out.

&gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])
[1, 2]</docstring>
    <inputPortSpec arg="filt" name="filt" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="trim" name="trim">
      <docstring>A string with 'f' representing trim from front and 'b' to trim from
back. Default is 'fb', trim zeros from both front and back of the
array.</docstring>
      <defaults>['fb']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of trimming the input. The input data type is preserved.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.arraysetops.unique" module_name="unique" namespace="'array'" output_type="list">
    <docstring>Find the unique elements of an array.

Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements: the indices of the input array
that give the unique values, the indices of the unique array that
reconstruct the input array, and the number of times each unique value
comes up in the input array.

Parameters
----------
ar : array_like
    Input array. This will be flattened if it is not already 1-D.
return_index : bool, optional
    If True, also return the indices of `ar` that result in the unique
    array.
return_inverse : bool, optional
    If True, also return the indices of the unique array that can be used
    to reconstruct `ar`.
return_counts : bool, optional
    If True, also return the number of times each unique value comes up
    in `ar`.

    .. versionadded:: 1.9.0

Returns
-------
unique : ndarray
    The sorted unique values.
unique_indices : ndarray, optional
    The indices of the first occurrences of the unique values in the
    (flattened) original array. Only provided if `return_index` is True.
unique_inverse : ndarray, optional
    The indices to reconstruct the (flattened) original array from the
    unique array. Only provided if `return_inverse` is True.
unique_counts : ndarray, optional
    The number of times each of the unique values comes up in the
    original array. Only provided if `return_counts` is True.

    .. versionadded:: 1.9.0

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
&gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])
&gt;&gt;&gt; np.unique(a)
array([1, 2, 3])

Return the indices of the original array that give the unique values:

&gt;&gt;&gt; a = np.array(['a', 'b', 'b', 'c', 'a'])
&gt;&gt;&gt; u, indices = np.unique(a, return_index=True)
&gt;&gt;&gt; u
array(['a', 'b', 'c'],
       dtype='|S1')
&gt;&gt;&gt; indices
array([0, 1, 3])
&gt;&gt;&gt; a[indices]
array(['a', 'b', 'c'],
       dtype='|S1')

Reconstruct the input array from the unique values:

&gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])
&gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)
&gt;&gt;&gt; u
array([1, 2, 3, 4, 6])
&gt;&gt;&gt; indices
array([0, 1, 4, 3, 1, 2, 1])
&gt;&gt;&gt; u[indices]
array([1, 2, 6, 4, 2, 3, 2])</docstring>
    <inputPortSpec arg="ar" name="ar" port_type="basic:List" show_port="True">
      <docstring>Input array. This will be flattened if it is not already 1-D.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="return_index" name="return_index" port_type="basic:Boolean">
      <docstring>If True, also return the indices of `ar` that result in the unique
array.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_inverse" name="return_inverse" port_type="basic:Boolean">
      <docstring>If True, also return the indices of the unique array that can be used
to reconstruct `ar`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_counts" name="return_counts" port_type="basic:Boolean">
      <docstring>If True, also return the number of times each unique value comes up
in `ar`.

.. versionadded:: 1.9.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="unique" name="unique" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The sorted unique values.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="unique_indices" name="unique_indices" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The indices of the first occurrences of the unique values in the
(flattened) original array. Only provided if `return_index` is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="unique_inverse" name="unique_inverse" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The indices to reconstruct the (flattened) original array from the
unique array. Only provided if `return_inverse` is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="unique_counts" name="unique_counts" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>The number of times each of the unique values comes up in the
original array. Only provided if `return_counts` is True.

.. versionadded:: 1.9.0</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.twodim_base.fliplr" module_name="fliplr" namespace="'array'">
    <docstring>Flip array in the left/right direction.

Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array, must be at least 2-D.

Returns
-------
f : ndarray
    A view of `m` with the columns reversed.  Since a view
    is returned, this operation is :math:`\mathcal O(1)`.

See Also
--------
flipud : Flip array in the up/down direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to A[:,::-1]. Requires the array to be at least 2-D.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.,2.,3.])
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  3.]])
&gt;&gt;&gt; np.fliplr(A)
array([[ 0.,  0.,  1.],
       [ 0.,  2.,  0.],
       [ 3.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.fliplr(A)==A[:,::-1,...])
True</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Input array, must be at least 2-D.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A view of `m` with the columns reversed.  Since a view
is returned, this operation is :math:`\mathcal O(1)`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.twodim_base.flipud" module_name="flipud" namespace="'array'">
    <docstring>Flip array in the up/down direction.

Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
out : array_like
    A view of `m` with the rows reversed.  Since a view is
    returned, this operation is :math:`\mathcal O(1)`.

See Also
--------
fliplr : Flip array in the left/right direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``A[::-1,...]``.
Does not require the array to be two-dimensional.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.0, 2, 3])
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  3.]])
&gt;&gt;&gt; np.flipud(A)
array([[ 0.,  0.,  3.],
       [ 0.,  2.,  0.],
       [ 1.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.flipud(A)==A[::-1,...])
True

&gt;&gt;&gt; np.flipud([1,2])
array([2, 1])</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A view of `m` with the rows reversed.  Since a view is
returned, this operation is :math:`\mathcal O(1)`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.fromnumeric.reshape" module_name="reshape" namespace="'array'">
    <docstring>Gives a new shape to an array without changing its data.

Parameters
----------
a : array_like
    Array to be reshaped.
newshape : int or tuple of ints
    The new shape should be compatible with the original shape. If
    an integer, then the result will be a 1-D array of that length.
    One shape dimension can be -1. In this case, the value is inferred
    from the length of the array and remaining dimensions.
order : {'C', 'F', 'A'}, optional
    Read the elements of `a` using this index order, and place the elements
    into the reshaped array using this index order.  'C' means to
    read / write the elements using C-like index order, with the last axis
    index changing fastest, back to the first axis index changing slowest.
    'F' means to read / write the elements using Fortran-like index order,
    with the first index changing fastest, and the last index changing
    slowest.
    Note that the 'C' and 'F' options take no account of the memory layout
    of the underlying array, and only refer to the order of indexing.  'A'
    means to read / write the elements in Fortran-like index order if `a`
    is Fortran *contiguous* in memory, C-like order otherwise.

Returns
-------
reshaped_array : ndarray
    This will be a new view object if possible; otherwise, it will
    be a copy.  Note there is no guarantee of the *memory layout* (C- or
    Fortran- contiguous) of the returned array.

See Also
--------
ndarray.reshape : Equivalent method.

Notes
-----
It is not always possible to change the shape of an array without
copying the data. If you want an error to be raise if the data is copied,
you should assign the new shape to the shape attribute of the array::

 &gt;&gt;&gt; a = np.zeros((10, 2))
 # A transpose make the array non-contiguous
 &gt;&gt;&gt; b = a.T
 # Taking a view makes it possible to modify the shape without modifying
 # the initial object.
 &gt;&gt;&gt; c = b.view()
 &gt;&gt;&gt; c.shape = (20)
 AttributeError: incompatible shape for a non-contiguous array

The `order` keyword gives the index ordering both for *fetching* the values
from `a`, and then *placing* the values into the output array.
For example, let's say you have an array:

&gt;&gt;&gt; a = np.arange(6).reshape((3, 2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3],
       [4, 5]])

You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.

&gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
array([[0, 4, 3],
       [2, 1, 5]])
&gt;&gt;&gt; np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
array([[0, 4, 3],
       [2, 1, 5]])

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; np.reshape(a, 6)
array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; np.reshape(a, 6, order='F')
array([1, 4, 2, 5, 3, 6])

&gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
array([[1, 2],
       [3, 4],
       [5, 6]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to be reshaped.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="newshape" name="newshapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>The new shape should be compatible with the original shape. If
an integer, then the result will be a 1-D array of that length.
One shape dimension can be -1. In this case, the value is inferred
from the length of the array and remaining dimensions.</docstring>
      <alternateSpec arg="newshape" depth="1" name="newshapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Read the elements of `a` using this index order, and place the elements
into the reshaped array using this index order.  'C' means to
read / write the elements using C-like index order, with the last axis
index changing fastest, back to the first axis index changing slowest.
'F' means to read / write the elements using Fortran-like index order,
with the first index changing fastest, and the last index changing
slowest.
Note that the 'C' and 'F' options take no account of the memory layout
of the underlying array, and only refer to the order of indexing.  'A'
means to read / write the elements in Fortran-like index order if `a`
is Fortran *contiguous* in memory, C-like order otherwise.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F', 'A']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="reshaped_array" name="reshaped_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This will be a new view object if possible; otherwise, it will
be a copy.  Note there is no guarantee of the *memory layout* (C- or
Fortran- contiguous) of the returned array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.numeric.roll" module_name="roll" namespace="'array'">
    <docstring>Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int
    The number of places by which elements are shifted.
axis : int, optional
    The axis along which elements are shifted.  By default, the array
    is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Examples
--------
&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])

&gt;&gt;&gt; x2 = np.reshape(x, (2,5))
&gt;&gt;&gt; x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
&gt;&gt;&gt; np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
&gt;&gt;&gt; np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
&gt;&gt;&gt; np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shift" name="shift" port_type="basic:Integer" show_port="True">
      <docstring>The number of places by which elements are shifted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which elements are shifted.  By default, the array
is flattened before shifting, after which the original
shape is restored.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array, with the same shape as `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.twodim_base.rot90" module_name="rot90" namespace="'array'">
    <docstring>Rotate an array by 90 degrees in the counter-clockwise direction.

The first two dimensions are rotated; therefore, the array must be at
least 2-D.

Parameters
----------
m : array_like
    Array of two or more dimensions.
k : integer
    Number of times the array is rotated by 90 degrees.

Returns
-------
y : ndarray
    Rotated array.

See Also
--------
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.

Examples
--------
&gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)
&gt;&gt;&gt; m
array([[1, 2],
       [3, 4]])
&gt;&gt;&gt; np.rot90(m)
array([[2, 4],
       [1, 3]])
&gt;&gt;&gt; np.rot90(m, 2)
array([[4, 3],
       [2, 1]])</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Array of two or more dimensions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Number of times the array is rotated by 90 degrees.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Rotated array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matrixlib.defmatrix.asmatrix" module_name="asmatrix" namespace="'matrix'">
    <docstring>Interpret the input as a matrix.

Unlike `matrix`, `asmatrix` does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.

Parameters
----------
data : array_like
    Input data.
dtype : data-type
   Data-type of the output matrix.

Returns
-------
mat : matrix
    `data` interpreted as a matrix.

Examples
--------
&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])

&gt;&gt;&gt; m = np.asmatrix(x)

&gt;&gt;&gt; x[0,0] = 5

&gt;&gt;&gt; m
matrix([[5, 2],
        [3, 4]])</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant" show_port="True">
      <docstring>Data-type of the output matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mat" name="mat" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>`data` interpreted as a matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matrixlib.defmatrix.bmat" module_name="bmat" namespace="'matrix'">
    <docstring>Build a matrix object from a string, nested sequence, or array.

Parameters
----------
obj : str or array_like
    Input data.  Names of variables in the current scope may be
    referenced, even if `obj` is a string.
ldict : dict, optional
    A dictionary that replaces local operands in current frame.
    Ignored if `obj` is not a string or `gdict` is `None`.
gdict : dict, optional
    A dictionary that replaces global operands in current frame.
    Ignored if `obj` is not a string.

Returns
-------
out : matrix
    Returns a matrix object, which is a specialized 2-D array.

See Also
--------
matrix

Examples
--------
&gt;&gt;&gt; A = np.mat('1 1; 1 1')
&gt;&gt;&gt; B = np.mat('2 2; 2 2')
&gt;&gt;&gt; C = np.mat('3 4; 5 6')
&gt;&gt;&gt; D = np.mat('7 8; 9 0')

All the following expressions construct the same block matrix:

&gt;&gt;&gt; np.bmat([[A, B], [C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
&gt;&gt;&gt; np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
&gt;&gt;&gt; np.bmat('A,B; C,D')
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])</docstring>
    <inputPortSpec arg="obj" name="objScalar" show_port="True">
      <docstring>Input data.  Names of variables in the current scope may be
referenced, even if `obj` is a string.</docstring>
      <alternateSpec arg="obj" name="objSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="ldict" name="ldict" port_type="basic:Dictionary">
      <docstring>A dictionary that replaces local operands in current frame.
Ignored if `obj` is not a string or `gdict` is `None`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gdict" name="gdict" port_type="basic:Dictionary">
      <docstring>A dictionary that replaces global operands in current frame.
Ignored if `obj` is not a string.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Returns a matrix object, which is a specialized 2-D array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.empty" module_name="empty" namespace="'matrix'">
    <docstring>Return a new matrix of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty matrix.
dtype : data-type, optional
    Desired output data-type.
order : {'C', 'F'}, optional
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

See Also
--------
empty_like, zeros

Notes
-----
`empty`, unlike `zeros`, does not set the matrix values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.empty((2, 2))    # filled with random data
matrix([[  6.76425276e-320,   9.79033856e-307],
        [  7.39337286e-309,   3.22135945e-309]])        #random
&gt;&gt;&gt; np.matlib.empty((2, 2), dtype=int)
matrix([[ 6600475,        0],
        [ 6586976, 22740995]])                          #random</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the empty matrix.</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Desired output data-type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.zeros" module_name="zeros" namespace="'matrix'">
    <docstring>Return a matrix of given shape and type, filled with zeros.

Parameters
----------
shape : int or sequence of ints
    Shape of the matrix
dtype : data-type, optional
    The desired data-type for the matrix, default is float.
order : {'C', 'F'}, optional
    Whether to store the result in C- or Fortran-contiguous order,
    default is 'C'.

Returns
-------
out : matrix
    Zero matrix of given shape, dtype, and order.

See Also
--------
numpy.zeros : Equivalent array function.
matlib.ones : Return a matrix of ones.

Notes
-----
If `shape` has length one i.e. ``(N,)``, or is a scalar ``N``,
`out` becomes a single row matrix of shape ``(1,N)``.

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.zeros((2, 3))
matrix([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.]])

&gt;&gt;&gt; np.matlib.zeros(2)
matrix([[ 0.,  0.]])</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the matrix</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The desired data-type for the matrix, default is float.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store the result in C- or Fortran-contiguous order,
default is 'C'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Zero matrix of given shape, dtype, and order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.ones" module_name="ones" namespace="'matrix'">
    <docstring>Matrix of ones.

Return a matrix of given shape and type, filled with ones.

Parameters
----------
shape : {sequence of ints, int}
    Shape of the matrix
dtype : data-type, optional
    The desired data-type for the matrix, default is np.float64.
order : {'C', 'F'}, optional
    Whether to store matrix in C- or Fortran-contiguous order,
    default is 'C'.

Returns
-------
out : matrix
    Matrix of ones of given shape, dtype, and order.

See Also
--------
ones : Array of ones.
matlib.zeros : Zero matrix.

Notes
-----
If `shape` has length one i.e. ``(N,)``, or is a scalar ``N``,
`out` becomes a single row matrix of shape ``(1,N)``.

Examples
--------
&gt;&gt;&gt; np.matlib.ones((2,3))
matrix([[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]])

&gt;&gt;&gt; np.matlib.ones(2)
matrix([[ 1.,  1.]])</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the matrix</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The desired data-type for the matrix, default is np.float64.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store matrix in C- or Fortran-contiguous order,
default is 'C'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Matrix of ones of given shape, dtype, and order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.eye" module_name="eye" namespace="'matrix'">
    <docstring>Return a matrix with ones on the diagonal and zeros elsewhere.

Parameters
----------
n : int
    Number of rows in the output.
M : int, optional
    Number of columns in the output, defaults to `n`.
k : int, optional
    Index of the diagonal: 0 refers to the main diagonal,
    a positive value refers to an upper diagonal,
    and a negative value to a lower diagonal.
dtype : dtype, optional
    Data-type of the returned matrix.

Returns
-------
I : matrix
    A `n` x `M` matrix where all elements are equal to zero,
    except for the `k`-th diagonal, whose values are equal to one.

See Also
--------
numpy.eye : Equivalent array function.
identity : Square identity matrix.

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.eye(3, k=1, dtype=float)
matrix([[ 0.,  1.,  0.],
        [ 0.,  0.,  1.],
        [ 0.,  0.,  0.]])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Number of rows in the output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer">
      <docstring>Number of columns in the output, defaults to `n`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Index of the diagonal: 0 refers to the main diagonal,
a positive value refers to an upper diagonal,
and a negative value to a lower diagonal.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data-type of the returned matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="I" name="I" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A `n` x `M` matrix where all elements are equal to zero,
except for the `k`-th diagonal, whose values are equal to one.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.identity" module_name="identity" namespace="'matrix'">
    <docstring>Returns the square identity matrix of given size.

Parameters
----------
n : int
    Size of the returned identity matrix.
dtype : data-type, optional
    Data-type of the output. Defaults to ``float``.

Returns
-------
out : matrix
    `n` x `n` matrix with its main diagonal set to one,
    and all other elements zero.

See Also
--------
numpy.identity : Equivalent array function.
matlib.eye : More general matrix identity function.

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.identity(3, dtype=int)
matrix([[1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Size of the returned identity matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data-type of the output. Defaults to ``float``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>`n` x `n` matrix with its main diagonal set to one,
and all other elements zero.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.repmat" module_name="repmat" namespace="'matrix'">
    <docstring>Repeat a 0-D to 2-D array or matrix MxN times.

Parameters
----------
a : array_like
    The array or matrix to be repeated.
m, n : int
    The number of times `a` is repeated along the first and second axes.

Returns
-------
out : ndarray
    The result of repeating `a`.

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; a0 = np.array(1)
&gt;&gt;&gt; np.matlib.repmat(a0, 2, 3)
array([[1, 1, 1],
       [1, 1, 1]])

&gt;&gt;&gt; a1 = np.arange(4)
&gt;&gt;&gt; np.matlib.repmat(a1, 2, 2)
array([[0, 1, 2, 3, 0, 1, 2, 3],
       [0, 1, 2, 3, 0, 1, 2, 3]])

&gt;&gt;&gt; a2 = np.asmatrix(np.arange(6).reshape(2, 3))
&gt;&gt;&gt; np.matlib.repmat(a2, 2, 3)
matrix([[0, 1, 2, 0, 1, 2, 0, 1, 2],
        [3, 4, 5, 3, 4, 5, 3, 4, 5],
        [0, 1, 2, 0, 1, 2, 0, 1, 2],
        [3, 4, 5, 3, 4, 5, 3, 4, 5]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array or matrix to be repeated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>The number of times `a` is repeated along the first and second axes.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The number of times `a` is repeated along the first and second axes.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of repeating `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.rand" module_name="rand" namespace="'matrix'">
    <docstring>Return a matrix of random values with given shape.

Create a matrix of the given shape and propagate it with
random samples from a uniform distribution over ``[0, 1)``.

Parameters
----------
\*args : Arguments
    Shape of the output.
    If given as N integers, each integer specifies the size of one
    dimension.
    If given as a tuple, this tuple gives the complete shape.

Returns
-------
out : ndarray
    The matrix of random values with shape given by `\*args`.

See Also
--------
randn, numpy.random.rand

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.rand(2, 3)
matrix([[ 0.68340382,  0.67926887,  0.83271405],
        [ 0.00793551,  0.20468222,  0.95253525]])       #random
&gt;&gt;&gt; np.matlib.rand((2, 3))
matrix([[ 0.84682055,  0.73626594,  0.11308016],
        [ 0.85429008,  0.3294825 ,  0.89139555]])       #random

If the first argument is a tuple, other arguments are ignored:

&gt;&gt;&gt; np.matlib.rand((2, 3), 4)
matrix([[ 0.46898646,  0.15163588,  0.95188261],
        [ 0.59208621,  0.09561818,  0.00583606]])       #random</docstring>
    <inputPortSpec arg="\*args" name="\*args" port_type="basic:Variant" show_port="True">
      <docstring>Shape of the output.
If given as N integers, each integer specifies the size of one
dimension.
If given as a tuple, this tuple gives the complete shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The matrix of random values with shape given by `\*args`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.matlib.randn" module_name="randn" namespace="'matrix'">
    <docstring>Return a random matrix with data from the "standard normal" distribution.

`randn` generates a matrix filled with random floats sampled from a
univariate "normal" (Gaussian) distribution of mean 0 and variance 1.

Parameters
----------
\*args : Arguments
    Shape of the output.
    If given as N integers, each integer specifies the size of one
    dimension. If given as a tuple, this tuple gives the complete shape.

Returns
-------
Z : matrix of floats
    A matrix of floating-point samples drawn from the standard normal
    distribution.

See Also
--------
rand, random.randn

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use:

``sigma * np.matlib.randn(...) + mu``

Examples
--------
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.randn(1)
matrix([[-0.09542833]])                                 #random
&gt;&gt;&gt; np.matlib.randn(1, 2, 3)
matrix([[ 0.16198284,  0.0194571 ,  0.18312985],
        [-0.7509172 ,  1.61055   ,  0.45298599]])       #random

Two-by-four matrix of samples from :math:`N(3, 6.25)`:

&gt;&gt;&gt; 2.5 * np.matlib.randn((2, 4)) + 3
matrix([[ 4.74085004,  8.89381862,  4.09042411,  4.83721922],
        [ 7.52373709,  5.07933944, -2.64043543,  0.45610557]])  #random</docstring>
    <inputPortSpec arg="\*args" name="\*args" port_type="basic:Variant" show_port="True">
      <docstring>Shape of the output.
If given as N integers, each integer specifies the size of one
dimension. If given as a tuple, this tuple gives the complete shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>A matrix of floating-point samples drawn from the standard normal
distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.bitwise_and" module_name="bitwise_and" namespace="'binary'">
    <docstring>bitwise_and(x1, x2[, out])

Compute the bit-wise AND of two arrays element-wise.

Computes the bit-wise AND of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``&amp;``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled.

Returns
-------
out : array_like
    Result.

See Also
--------
logical_and
bitwise_or
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``.  Likewise, 17 is
represented by ``00010001``.  The bit-wise AND of 13 and 17 is
therefore ``000000001``, or 1:

&gt;&gt;&gt; np.bitwise_and(13, 17)
1

&gt;&gt;&gt; np.bitwise_and(14, 13)
12
&gt;&gt;&gt; np.binary_repr(12)
'1100'
&gt;&gt;&gt; np.bitwise_and([14,3], 13)
array([12,  1])

&gt;&gt;&gt; np.bitwise_and([11,7], [4,25])
array([0, 1])
&gt;&gt;&gt; np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
array([ 2,  4, 16])
&gt;&gt;&gt; np.bitwise_and([True, True], [False, True])
array([False,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.bitwise_or" module_name="bitwise_or" namespace="'binary'">
    <docstring>bitwise_or(x1, x2[, out])

Compute the bit-wise OR of two arrays element-wise.

Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``|``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
out : array_like
    Result.

See Also
--------
logical_or
bitwise_and
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 has the binaray representation ``00001101``. Likewise,
16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is
then ``000111011``, or 29:

&gt;&gt;&gt; np.bitwise_or(13, 16)
29
&gt;&gt;&gt; np.binary_repr(29)
'11101'

&gt;&gt;&gt; np.bitwise_or(32, 2)
34
&gt;&gt;&gt; np.bitwise_or([33, 4], 1)
array([33,  5])
&gt;&gt;&gt; np.bitwise_or([33, 4], [1, 2])
array([33,  6])

&gt;&gt;&gt; np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
array([  6,   5, 255])
&gt;&gt;&gt; np.array([2, 5, 255]) | np.array([4, 4, 4])
array([  6,   5, 255])
&gt;&gt;&gt; np.bitwise_or(np.array([2, 5, 255, 2147483647L], dtype=np.int32),
...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))
array([         6,          5,        255, 2147483647])
&gt;&gt;&gt; np.bitwise_or([True, True], [False, True])
array([ True,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.bitwise_xor" module_name="bitwise_xor" namespace="'binary'">
    <docstring>bitwise_xor(x1, x2[, out])

Compute the bit-wise XOR of two arrays element-wise.

Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``^``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled.

Returns
-------
out : array_like
    Result.

See Also
--------
logical_xor
bitwise_and
bitwise_or
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``. Likewise, 17 is
represented by ``00010001``.  The bit-wise XOR of 13 and 17 is
therefore ``00011100``, or 28:

&gt;&gt;&gt; np.bitwise_xor(13, 17)
28
&gt;&gt;&gt; np.binary_repr(28)
'11100'

&gt;&gt;&gt; np.bitwise_xor(31, 5)
26
&gt;&gt;&gt; np.bitwise_xor([31,3], 5)
array([26,  6])

&gt;&gt;&gt; np.bitwise_xor([31,3], [5,6])
array([26,  5])
&gt;&gt;&gt; np.bitwise_xor([True, True], [False, True])
array([ True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.invert" module_name="invert" namespace="'binary'">
    <docstring>invert(x[, out])

Compute bit-wise inversion, or bit-wise NOT, element-wise.

Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``~``.

For signed integer inputs, the two's complement is returned.  In a
two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit
two's-complement system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
x1 : array_like
    Only integer and boolean types are handled.

Returns
-------
out : array_like
    Result.

See Also
--------
bitwise_and, bitwise_or, bitwise_xor
logical_not
binary_repr :
    Return the binary representation of the input number as a string.

Notes
-----
`bitwise_not` is an alias for `invert`:

&gt;&gt;&gt; np.bitwise_not is np.invert
True

References
----------
.. [1] Wikipedia, "Two's complement",
    http://en.wikipedia.org/wiki/Two's_complement

Examples
--------
We've seen that 13 is represented by ``00001101``.
The invert or bit-wise NOT of 13 is then:

&gt;&gt;&gt; np.invert(np.array([13], dtype=uint8))
array([242], dtype=uint8)
&gt;&gt;&gt; np.binary_repr(x, width=8)
'00001101'
&gt;&gt;&gt; np.binary_repr(242, width=8)
'11110010'

The result depends on the bit-width:

&gt;&gt;&gt; np.invert(np.array([13], dtype=uint16))
array([65522], dtype=uint16)
&gt;&gt;&gt; np.binary_repr(x, width=16)
'0000000000001101'
&gt;&gt;&gt; np.binary_repr(65522, width=16)
'1111111111110010'

When using signed integer types the result is the two's complement of
the result for the unsigned type:

&gt;&gt;&gt; np.invert(np.array([13], dtype=int8))
array([-14], dtype=int8)
&gt;&gt;&gt; np.binary_repr(-14, width=8)
'11110010'

Booleans are accepted as well:

&gt;&gt;&gt; np.invert(array([True, False]))
array([False,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Only integer and boolean types are handled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.left_shift" module_name="left_shift" namespace="'binary'">
    <docstring>left_shift(x1, x2[, out])

Shift the bits of an integer to the left.

Bits are shifted to the left by appending `x2` 0s at the right of `x1`.
Since the internal representation of numbers is in binary format, this
operation is equivalent to multiplying `x1` by ``2**x2``.

Parameters
----------
x1 : array_like of integer type
    Input values.
x2 : array_like of integer type
    Number of zeros to append to `x1`. Has to be non-negative.

Returns
-------
out : array of integer type
    Return `x1` with bits shifted `x2` times to the left.

See Also
--------
right_shift : Shift the bits of an integer to the right.
binary_repr : Return the binary representation of the input number
    as a string.

Examples
--------
&gt;&gt;&gt; np.binary_repr(5)
'101'
&gt;&gt;&gt; np.left_shift(5, 2)
20
&gt;&gt;&gt; np.binary_repr(20)
'10100'

&gt;&gt;&gt; np.left_shift(5, [1,2,3])
array([10, 20, 40])</docstring>
    <inputPortSpec arg="x1" depth="1" name="x1" port_type="basic:Integer" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" depth="1" name="x2" port_type="basic:Integer" show_port="True">
      <docstring>Number of zeros to append to `x1`. Has to be non-negative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Return `x1` with bits shifted `x2` times to the left.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.right_shift" module_name="right_shift" namespace="'binary'">
    <docstring>right_shift(x1, x2[, out])

Shift the bits of an integer to the right.

Bits are shifted to the right `x2`.  Because the internal
representation of numbers is in binary format, this operation is
equivalent to dividing `x1` by ``2**x2``.

Parameters
----------
x1 : array_like, int
    Input values.
x2 : array_like, int
    Number of bits to remove at the right of `x1`.

Returns
-------
out : ndarray, int
    Return `x1` with bits shifted `x2` times to the right.

See Also
--------
left_shift : Shift the bits of an integer to the left.
binary_repr : Return the binary representation of the input number
    as a string.

Examples
--------
&gt;&gt;&gt; np.binary_repr(10)
'1010'
&gt;&gt;&gt; np.right_shift(10, 1)
5
&gt;&gt;&gt; np.binary_repr(5)
'101'

&gt;&gt;&gt; np.right_shift(10, [1,2,3])
array([5, 2, 1])</docstring>
    <inputPortSpec arg="x1" depth="1" name="x1" port_type="basic:Integer" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" depth="1" name="x2" port_type="basic:Integer" show_port="True">
      <docstring>Number of bits to remove at the right of `x1`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Return `x1` with bits shifted `x2` times to the right.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.packbits" module_name="packbits" namespace="'binary'">
    <docstring>packbits(myarray, axis=None)

Packs the elements of a binary-valued array into bits in a uint8 array.

The result is padded to full bytes by inserting zero bits at the end.

Parameters
----------
myarray : array_like
    An integer type array whose elements should be packed to bits.
axis : int, optional
    The dimension over which bit-packing is done.
    ``None`` implies packing the flattened array.

Returns
-------
packed : ndarray
    Array of type uint8 whose elements represent bits corresponding to the
    logical (0 or nonzero) value of the input elements. The shape of
    `packed` has the same number of dimensions as the input (unless `axis`
    is None, in which case the output is 1-D).

See Also
--------
unpackbits: Unpacks elements of a uint8 array into a binary-valued output
            array.

Examples
--------
&gt;&gt;&gt; a = np.array([[[1,0,1],
...                [0,1,0]],
...               [[1,1,0],
...                [0,0,1]]])
&gt;&gt;&gt; b = np.packbits(a, axis=-1)
&gt;&gt;&gt; b
array([[[160],[64]],[[192],[32]]], dtype=uint8)

Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.</docstring>
    <inputPortSpec arg="myarray" name="myarray" port_type="basic:List" show_port="True">
      <docstring>An integer type array whose elements should be packed to bits.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The dimension over which bit-packing is done.
``None`` implies packing the flattened array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="packed" name="packed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of type uint8 whose elements represent bits corresponding to the
logical (0 or nonzero) value of the input elements. The shape of
`packed` has the same number of dimensions as the input (unless `axis`
is None, in which case the output is 1-D).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.unpackbits" module_name="unpackbits" namespace="'binary'">
    <docstring>unpackbits(myarray, axis=None)

Unpacks elements of a uint8 array into a binary-valued output array.

Each element of `myarray` represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is either
1-D (if `axis` is None) or the same shape as the input array with unpacking
done along the axis specified.

Parameters
----------
myarray : ndarray, uint8 type
   Input array.
axis : int, optional
   Unpacks along this axis.

Returns
-------
unpacked : ndarray, uint8 type
   The elements are binary-valued (0 or 1).

See Also
--------
packbits : Packs the elements of a binary-valued array into bits in a uint8
           array.

Examples
--------
&gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)
&gt;&gt;&gt; a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
&gt;&gt;&gt; b = np.unpackbits(a, axis=1)
&gt;&gt;&gt; b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)</docstring>
    <inputPortSpec arg="myarray" depth="1" name="myarray" port_type="basic:Integer" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Unpacks along this axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="unpacked" depth="1" name="unpacked" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The elements are binary-valued (0 or 1).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.binary_repr" module_name="binary_repr" namespace="'binary'">
    <docstring>Return the binary representation of the input number as a string.

For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
num : int
    Only an integer decimal number can be used.
width : int, optional
    The length of the returned string if `num` is positive, the length of
    the two's complement if `num` is negative.

Returns
-------
bin : str
    Binary representation of `num` or two's complement of `num`.

See Also
--------
base_repr: Return a string representation of a number in the given base
           system.

Notes
-----
`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
faster.

References
----------
.. [1] Wikipedia, "Two's complement",
    http://en.wikipedia.org/wiki/Two's_complement

Examples
--------
&gt;&gt;&gt; np.binary_repr(3)
'11'
&gt;&gt;&gt; np.binary_repr(-3)
'-11'
&gt;&gt;&gt; np.binary_repr(3, width=4)
'0011'

The two's complement is returned when the input number is negative and
width is specified:

&gt;&gt;&gt; np.binary_repr(-3, width=4)
'1101'</docstring>
    <inputPortSpec arg="num" name="num" port_type="basic:Integer" show_port="True">
      <docstring>Only an integer decimal number can be used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="width" name="width" port_type="basic:Integer">
      <docstring>The length of the returned string if `num` is positive, the length of
the two's complement if `num` is negative.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="bin" name="bin" show_port="True" sort_key="0">
      <docstring>Binary representation of `num` or two's complement of `num`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.load" module_name="load" namespace="'io'">
    <docstring>Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.

Parameters
----------
file : file-like object or string
    The file to read. File-like objects must support the
    ``seek()`` and ``read()`` methods. Pickled files require that the
    file-like object support the ``readline()`` method as well.
mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional
    If not None, then memory-map the file, using the given mode (see
    `numpy.memmap` for a detailed description of the modes).  A
    memory-mapped array is kept on disk. However, it can be accessed
    and sliced like any ndarray.  Memory mapping is especially useful
    for accessing small fragments of large files without reading the
    entire file into memory.
allow_pickle : bool, optional
    Allow loading pickled object arrays stored in npy files. Reasons for
    disallowing pickles include security, as loading pickled data can
    execute arbitrary code. If pickles are disallowed, loading object
    arrays will fail.
    Default: True
fix_imports : bool, optional
    Only useful when loading Python 2 generated pickled files on Python 3,
    which includes npy/npz files containing object arrays. If `fix_imports`
    is True, pickle will try to map the old Python 2 names to the new names
    used in Python 3.
encoding : str, optional
    What encoding to use when reading Python 2 strings. Only useful when
    loading Python 2 generated pickled files on Python 3, which includes
    npy/npz files containing object arrays. Values other than 'latin1',
    'ASCII', and 'bytes' are not allowed, as they can corrupt numerical
    data. Default: 'ASCII'

Returns
-------
result : array, tuple, dict, etc.
    Data stored in the file. For ``.npz`` files, the returned instance
    of NpzFile class must be closed to avoid leaking file descriptors.

Raises
------
IOError
    If the input file does not exist or cannot be read.
ValueError
    The file contains an object array, but allow_pickle=False given.

See Also
--------
save, savez, savez_compressed, loadtxt
memmap : Create a memory-map to an array stored in a file on disk.

Notes
-----
- If the file contains pickle data, then whatever object is stored
  in the pickle is returned.
- If the file is a ``.npy`` file, then a single array is returned.
- If the file is a ``.npz`` file, then a dictionary-like object is
  returned, containing ``{filename: array}`` key-value pairs, one for
  each file in the archive.
- If the file is a ``.npz`` file, the returned value supports the
  context manager protocol in a similar fashion to the open function::

    with load('foo.npz') as data:
        a = data['a']

  The underlying file descriptor is closed when exiting the 'with'
  block.

Examples
--------
Store data to disk, and load it again:

&gt;&gt;&gt; np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))
&gt;&gt;&gt; np.load('/tmp/123.npy')
array([[1, 2, 3],
       [4, 5, 6]])

Store compressed data to disk, and load it again:

&gt;&gt;&gt; a=np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; b=np.array([1, 2])
&gt;&gt;&gt; np.savez('/tmp/123.npz', a=a, b=b)
&gt;&gt;&gt; data = np.load('/tmp/123.npz')
&gt;&gt;&gt; data['a']
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; data['b']
array([1, 2])
&gt;&gt;&gt; data.close()

Mem-map the stored array, and then access the second row
directly from disk:

&gt;&gt;&gt; X = np.load('/tmp/123.npy', mmap_mode='r')
&gt;&gt;&gt; X[1, :]
memmap([4, 5, 6])</docstring>
    <inputPortSpec arg="file" name="fileScalar" show_port="True">
      <docstring>The file to read. File-like objects must support the
``seek()`` and ``read()`` methods. Pickled files require that the
file-like object support the ``readline()`` method as well.</docstring>
      <alternateSpec arg="file" name="fileSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="mmap_mode" name="mmap_mode">
      <docstring>If not None, then memory-map the file, using the given mode (see
`numpy.memmap` for a detailed description of the modes).  A
memory-mapped array is kept on disk. However, it can be accessed
and sliced like any ndarray.  Memory mapping is especially useful
for accessing small fragments of large files without reading the
entire file into memory.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['r+', 'r', 'w+', 'c']]</values>
    </inputPortSpec>
    <inputPortSpec arg="allow_pickle" name="allow_pickle" port_type="basic:Boolean">
      <docstring>Allow loading pickled object arrays stored in npy files. Reasons for
disallowing pickles include security, as loading pickled data can
execute arbitrary code. If pickles are disallowed, loading object
arrays will fail.
Default: True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fix_imports" name="fix_imports" port_type="basic:Boolean">
      <docstring>Only useful when loading Python 2 generated pickled files on Python 3,
which includes npy/npz files containing object arrays. If `fix_imports`
is True, pickle will try to map the old Python 2 names to the new names
used in Python 3.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="encoding" name="encoding">
      <docstring>What encoding to use when reading Python 2 strings. Only useful when
loading Python 2 generated pickled files on Python 3, which includes
npy/npz files containing object arrays. Values other than 'latin1',
'ASCII', and 'bytes' are not allowed, as they can corrupt numerical
data. Default: 'ASCII'</docstring>
      <defaults>['ASCII']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Data stored in the file. For ``.npz`` files, the returned instance
of NpzFile class must be closed to avoid leaking file descriptors.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.save" module_name="save" namespace="'io'">
    <docstring>Save an array to a binary file in NumPy ``.npy`` format.

Parameters
----------
file : file or str
    File or filename to which the data is saved.  If file is a file-object,
    then the filename is unchanged.  If file is a string, a ``.npy``
    extension will be appended to the file name if it does not already
    have one.
allow_pickle : bool, optional
    Allow saving object arrays using Python pickles. Reasons for disallowing
    pickles include security (loading pickled data can execute arbitrary
    code) and portability (pickled objects may not be loadable on different
    Python installations, for example if the stored objects require libraries
    that are not available, and not all pickled data is compatible between
    Python 2 and Python 3).
    Default: True
fix_imports : bool, optional
    Only useful in forcing objects in object arrays on Python 3 to be
    pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
    will try to map the new Python 3 names to the old module names used in
    Python 2, so that the pickle data stream is readable with Python 2.
arr : array_like
    Array data to be saved.

See Also
--------
savez : Save several arrays into a ``.npz`` archive
savetxt, load

Notes
-----
For a description of the ``.npy`` format, see the module docstring
of `numpy.lib.format` or the Numpy Enhancement Proposal
http://docs.scipy.org/doc/numpy/neps/npy-format.html

Examples
--------
&gt;&gt;&gt; from tempfile import TemporaryFile
&gt;&gt;&gt; outfile = TemporaryFile()

&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; np.save(outfile, x)

&gt;&gt;&gt; outfile.seek(0) # Only needed here to simulate closing &amp; reopening file
&gt;&gt;&gt; np.load(outfile)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>File or filename to which the data is saved.  If file is a file-object,
then the filename is unchanged.  If file is a string, a ``.npy``
extension will be appended to the file name if it does not already
have one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="allow_pickle" name="allow_pickle" port_type="basic:Boolean">
      <docstring>Allow saving object arrays using Python pickles. Reasons for disallowing
pickles include security (loading pickled data can execute arbitrary
code) and portability (pickled objects may not be loadable on different
Python installations, for example if the stored objects require libraries
that are not available, and not all pickled data is compatible between
Python 2 and Python 3).
Default: True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fix_imports" name="fix_imports" port_type="basic:Boolean">
      <docstring>Only useful in forcing objects in object arrays on Python 3 to be
pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
will try to map the new Python 3 names to the old module names used in
Python 2, so that the pickle data stream is readable with Python 2.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Array data to be saved.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.savez" module_name="savez" namespace="'io'">
    <docstring>Save several arrays into a single file in uncompressed ``.npz`` format.

If arguments are passed in with no keywords, the corresponding variable
names, in the ``.npz`` file, are 'arr_0', 'arr_1', etc. If keyword
arguments are given, the corresponding variable names, in the ``.npz``
file will match the keyword names.

Parameters
----------
file : str or file
    Either the file name (string) or an open file (file-like object)
    where the data will be saved. If file is a string, the ``.npz``
    extension will be appended to the file name if it is not already there.
args : Arguments, optional
    Arrays to save to the file. Since it is not possible for Python to
    know the names of the arrays outside `savez`, the arrays will be saved
    with names "arr_0", "arr_1", and so on. These arguments can be any
    expression.
kwds : Keyword arguments, optional
    Arrays to save to the file. Arrays will be saved in the file with the
    keyword names.

Returns
-------
None

See Also
--------
save : Save a single array to a binary file in NumPy format.
savetxt : Save an array to a file as plain text.
savez_compressed : Save several arrays into a compressed ``.npz`` archive

Notes
-----
The ``.npz`` file format is a zipped archive of files named after the
variables they contain.  The archive is not compressed and each file
in the archive contains one variable in ``.npy`` format. For a
description of the ``.npy`` format, see `numpy.lib.format` or the
Numpy Enhancement Proposal
http://docs.scipy.org/doc/numpy/neps/npy-format.html

When opening the saved ``.npz`` file with `load` a `NpzFile` object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the ``.files`` attribute), and for the arrays
themselves.

Examples
--------
&gt;&gt;&gt; from tempfile import TemporaryFile
&gt;&gt;&gt; outfile = TemporaryFile()
&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; y = np.sin(x)

Using `savez` with \*args, the arrays are saved with default names.

&gt;&gt;&gt; np.savez(outfile, x, y)
&gt;&gt;&gt; outfile.seek(0) # Only needed here to simulate closing &amp; reopening file
&gt;&gt;&gt; npzfile = np.load(outfile)
&gt;&gt;&gt; npzfile.files
['arr_1', 'arr_0']
&gt;&gt;&gt; npzfile['arr_0']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

Using `savez` with \**kwds, the arrays are saved with the keyword names.

&gt;&gt;&gt; outfile = TemporaryFile()
&gt;&gt;&gt; np.savez(outfile, x=x, y=y)
&gt;&gt;&gt; outfile.seek(0)
&gt;&gt;&gt; npzfile = np.load(outfile)
&gt;&gt;&gt; npzfile.files
['y', 'x']
&gt;&gt;&gt; npzfile['x']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>Either the file name (string) or an open file (file-like object)
where the data will be saved. If file is a string, the ``.npz``
extension will be appended to the file name if it is not already there.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:Variant">
      <docstring>Arrays to save to the file. Since it is not possible for Python to
know the names of the arrays outside `savez`, the arrays will be saved
with names "arr_0", "arr_1", and so on. These arguments can be any
expression.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwds" name="kwds" port_type="basic:Variant">
      <docstring>Arrays to save to the file. Arrays will be saved in the file with the
keyword names.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.savez_compressed" module_name="savez_compressed" namespace="'io'">
    <docstring>Save several arrays into a single file in compressed ``.npz`` format.

If keyword arguments are given, then filenames are taken from the keywords.
If arguments are passed in with no keywords, then stored file names are
arr_0, arr_1, etc.

Parameters
----------
file : str
    File name of ``.npz`` file.
args : Arguments
    Function arguments.
kwds : Keyword arguments
    Keywords.

See Also
--------
numpy.savez : Save several arrays into an uncompressed ``.npz`` file format
numpy.load : Load the files created by savez_compressed.</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>File name of ``.npz`` file.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:Variant" show_port="True">
      <docstring>Function arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwds" name="kwds" port_type="basic:Variant" show_port="True">
      <docstring>Keywords.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.loadtxt" module_name="loadtxt" namespace="'io'">
    <docstring>Load data from a text file.

Each row in the text file must have the same number of values.

Parameters
----------
fname : file or str
    File, filename, or generator to read.  If the filename extension is
    ``.gz`` or ``.bz2``, the file is first decompressed. Note that
    generators should return byte strings for Python 3k.
dtype : data-type, optional
    Data-type of the resulting array; default: float.  If this is a
    structured data-type, the resulting array will be 1-dimensional, and
    each row will be interpreted as an element of the array.  In this
    case, the number of columns used must match the number of fields in
    the data-type.
comments : str or sequence, optional
    The characters or list of characters used to indicate the start of a
    comment;
    default: '#'.
delimiter : str, optional
    The string used to separate values.  By default, this is any
    whitespace.
converters : dict, optional
    A dictionary mapping column number to a function that will convert
    that column to a float.  E.g., if column 0 is a date string:
    ``converters = {0: datestr2num}``.  Converters can also be used to
    provide a default value for missing data (but see also `genfromtxt`):
    ``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.
skiprows : int, optional
    Skip the first `skiprows` lines; default: 0.
usecols : sequence, optional
    Which columns to read, with 0 being the first.  For example,
    ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
    The default, None, results in all columns being read.
unpack : bool, optional
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = loadtxt(...)``.  When used with a structured
    data-type, arrays are returned for each field.  Default is False.
ndmin : int, optional
    The returned array will have at least `ndmin` dimensions.
    Otherwise mono-dimensional axes will be squeezed.
    Legal values: 0 (default), 1 or 2.

    .. versionadded:: 1.6.0

Returns
-------
out : ndarray
    Data read from the text file.

See Also
--------
load, fromstring, fromregex
genfromtxt : Load data with missing values handled as specified.
scipy.io.loadmat : reads MATLAB data files

Notes
-----
This function aims to be a fast reader for simply formatted files.  The
`genfromtxt` function provides more sophisticated handling of, e.g.,
lines with missing values.

.. versionadded:: 1.10.0

The strings produced by the Python float.hex method can be used as
input for floats.

Examples
--------
&gt;&gt;&gt; from io import StringIO   # StringIO behaves like a file object
&gt;&gt;&gt; c = StringIO("0 1\n2 3")
&gt;&gt;&gt; np.loadtxt(c)
array([[ 0.,  1.],
       [ 2.,  3.]])

&gt;&gt;&gt; d = StringIO("M 21 72\nF 35 58")
&gt;&gt;&gt; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([('M', 21, 72.0), ('F', 35, 58.0)],
      dtype=[('gender', '|S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])

&gt;&gt;&gt; c = StringIO("1,0,2\n3,0,4")
&gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
&gt;&gt;&gt; x
array([ 1.,  3.])
&gt;&gt;&gt; y
array([ 2.,  4.])</docstring>
    <inputPortSpec arg="fname" name="fname" show_port="True">
      <docstring>File, filename, or generator to read.  If the filename extension is
``.gz`` or ``.bz2``, the file is first decompressed. Note that
generators should return byte strings for Python 3k.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data-type of the resulting array; default: float.  If this is a
structured data-type, the resulting array will be 1-dimensional, and
each row will be interpreted as an element of the array.  In this
case, the number of columns used must match the number of fields in
the data-type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="comments" name="commentsScalar">
      <docstring>The characters or list of characters used to indicate the start of a
comment;
default: '#'.</docstring>
      <defaults>['#']</defaults>
      <alternateSpec arg="comments" name="commentsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="delimiter" name="delimiter">
      <docstring>The string used to separate values.  By default, this is any
whitespace.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="converters" name="converters" port_type="basic:Dictionary">
      <docstring>A dictionary mapping column number to a function that will convert
that column to a float.  E.g., if column 0 is a date string:
``converters = {0: datestr2num}``.  Converters can also be used to
provide a default value for missing data (but see also `genfromtxt`):
``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="skiprows" name="skiprows" port_type="basic:Integer">
      <docstring>Skip the first `skiprows` lines; default: 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="usecols" name="usecols" port_type="basic:List">
      <docstring>Which columns to read, with 0 being the first.  For example,
``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
The default, None, results in all columns being read.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="unpack" name="unpack" port_type="basic:Boolean">
      <docstring>If True, the returned array is transposed, so that arguments may be
unpacked using ``x, y, z = loadtxt(...)``.  When used with a structured
data-type, arrays are returned for each field.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndmin" name="ndmin" port_type="basic:Integer">
      <docstring>The returned array will have at least `ndmin` dimensions.
Otherwise mono-dimensional axes will be squeezed.
Legal values: 0 (default), 1 or 2.

.. versionadded:: 1.6.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Data read from the text file.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.savetxt" module_name="savetxt" namespace="'io'">
    <docstring>Save an array to a text file.

Parameters
----------
fname : filename or file handle
    If the filename ends in ``.gz``, the file is automatically saved in
    compressed gzip format.  `loadtxt` understands gzipped files
    transparently.
X : array_like
    Data to be saved to a text file.
fmt : str or sequence of strs, optional
    A single format (%10.5f), a sequence of formats, or a
    multi-format string, e.g. 'Iteration %d -- %10.5f', in which
    case `delimiter` is ignored. For complex `X`, the legal options
    for `fmt` are:
        a) a single specifier, `fmt='%.4e'`, resulting in numbers formatted
            like `' (%s+%sj)' % (fmt, fmt)`
        b) a full string specifying every real and imaginary part, e.g.
            `' %.4e %+.4j %.4e %+.4j %.4e %+.4j'` for 3 columns
        c) a list of specifiers, one per column - in this case, the real
            and imaginary part must have separate specifiers,
            e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns
delimiter : str, optional
    String or character separating columns.
newline : str, optional
    String or character separating lines.

    .. versionadded:: 1.5.0
header : str, optional
    String that will be written at the beginning of the file.

    .. versionadded:: 1.7.0
footer : str, optional
    String that will be written at the end of the file.

    .. versionadded:: 1.7.0
comments : str, optional
    String that will be prepended to the ``header`` and ``footer`` strings,
    to mark them as comments. Default: '# ',  as expected by e.g.
    ``numpy.loadtxt``.

    .. versionadded:: 1.7.0


See Also
--------
save : Save an array to a binary file in NumPy ``.npy`` format
savez : Save several arrays into an uncompressed ``.npz`` archive
savez_compressed : Save several arrays into a compressed ``.npz`` archive

Notes
-----
Further explanation of the `fmt` parameter
(``%[flag]width[.precision]specifier``):

flags:
    ``-`` : left justify

    ``+`` : Forces to precede result with + or -.

    ``0`` : Left pad the number with zeros instead of space (see width).

width:
    Minimum number of characters to be printed. The value is not truncated
    if it has more characters.

precision:
    - For integer specifiers (eg. ``d,i,o,x``), the minimum number of
      digits.
    - For ``e, E`` and ``f`` specifiers, the number of digits to print
      after the decimal point.
    - For ``g`` and ``G``, the maximum number of significant digits.
    - For ``s``, the maximum number of characters.

specifiers:
    ``c`` : character

    ``d`` or ``i`` : signed decimal integer

    ``e`` or ``E`` : scientific notation with ``e`` or ``E``.

    ``f`` : decimal floating point

    ``g,G`` : use the shorter of ``e,E`` or ``f``

    ``o`` : signed octal

    ``s`` : string of characters

    ``u`` : unsigned decimal integer

    ``x,X`` : unsigned hexadecimal integer

This explanation of ``fmt`` is not complete, for an exhaustive
specification see [1]_.

References
----------
.. [1] `Format Specification Mini-Language
       &lt;http://docs.python.org/library/string.html#
       format-specification-mini-language&gt;`_, Python Documentation.

Examples
--------
&gt;&gt;&gt; x = y = z = np.arange(0.0,5.0,1.0)
&gt;&gt;&gt; np.savetxt('test.out', x, delimiter=',')   # X is an array
&gt;&gt;&gt; np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays
&gt;&gt;&gt; np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation</docstring>
    <inputPortSpec arg="fname" name="fname" show_port="True">
      <docstring>If the filename ends in ``.gz``, the file is automatically saved in
compressed gzip format.  `loadtxt` understands gzipped files
transparently.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['filename']]</values>
    </inputPortSpec>
    <inputPortSpec arg="X" name="X" port_type="basic:List" show_port="True">
      <docstring>Data to be saved to a text file.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fmt" name="fmtScalar">
      <docstring>A single format (%10.5f), a sequence of formats, or a
multi-format string, e.g. 'Iteration %d -- %10.5f', in which
case `delimiter` is ignored. For complex `X`, the legal options
for `fmt` are:
    a) a single specifier, `fmt='%.4e'`, resulting in numbers formatted
        like `' (%s+%sj)' % (fmt, fmt)`
    b) a full string specifying every real and imaginary part, e.g.
        `' %.4e %+.4j %.4e %+.4j %.4e %+.4j'` for 3 columns
    c) a list of specifiers, one per column - in this case, the real
        and imaginary part must have separate specifiers,
        e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns</docstring>
      <defaults>['%.18e']</defaults>
      <alternateSpec arg="fmt" depth="1" name="fmtSequence" />
    </inputPortSpec>
    <inputPortSpec arg="delimiter" name="delimiter">
      <docstring>String or character separating columns.</docstring>
      <defaults>[' ']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="newline" name="newline">
      <docstring>String or character separating lines.

.. versionadded:: 1.5.0</docstring>
      <defaults>['\n']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="header" name="header">
      <docstring>String that will be written at the beginning of the file.

.. versionadded:: 1.7.0</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="footer" name="footer">
      <docstring>String that will be written at the end of the file.

.. versionadded:: 1.7.0</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="comments" name="comments">
      <docstring>String that will be prepended to the ``header`` and ``footer`` strings,
to mark them as comments. Default: '# ',  as expected by e.g.
``numpy.loadtxt``.

.. versionadded:: 1.7.0</docstring>
      <defaults>['# ']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.genfromtxt" module_name="genfromtxt" namespace="'io'">
    <docstring>Load data from a text file, with missing values handled as specified.

Each line past the first `skip_header` lines is split at the `delimiter`
character, and characters following the `comments` character are discarded.

Parameters
----------
fname : file or str
    File, filename, or generator to read.  If the filename extension is
    `.gz` or `.bz2`, the file is first decompressed. Note that
    generators must return byte strings in Python 3k.
dtype : dtype, optional
    Data type of the resulting array.
    If None, the dtypes will be determined by the contents of each
    column, individually.
comments : str, optional
    The character used to indicate the start of a comment.
    All the characters occurring on a line after a comment are discarded
delimiter : str, int, or sequence, optional
    The string used to separate values.  By default, any consecutive
    whitespaces act as delimiter.  An integer or sequence of integers
    can also be provided as width(s) of each field.
skiprows : int, optional
    `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.
skip_header : int, optional
    The number of lines to skip at the beginning of the file.
skip_footer : int, optional
    The number of lines to skip at the end of the file.
converters : variable, optional
    The set of functions that convert the data of a column to a value.
    The converters can also be used to provide a default value
    for missing data: ``converters = {3: lambda s: float(s or 0)}``.
missing : variable, optional
    `missing` was removed in numpy 1.10. Please use `missing_values`
    instead.
missing_values : variable, optional
    The set of strings corresponding to missing data.
filling_values : variable, optional
    The set of values to be used as default when the data are missing.
usecols : sequence, optional
    Which columns to read, with 0 being the first.  For example,
    ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.
names : {None, True, str, sequence}, optional
    If `names` is True, the field names are read from the first valid line
    after the first `skip_header` lines.
    If `names` is a sequence or a single-string of comma-separated names,
    the names will be used to define the field names in a structured dtype.
    If `names` is None, the names of the dtype fields will be used, if any.
excludelist : sequence, optional
    A list of names to exclude. This list is appended to the default list
    ['return','file','print']. Excluded names are appended an underscore:
    for example, `file` would become `file_`.
deletechars : str, optional
    A string combining invalid characters that must be deleted from the
    names.
defaultfmt : str, optional
    A format used to define default field names, such as "f%i" or "f_%02i".
autostrip : bool, optional
    Whether to automatically strip white spaces from the variables.
replace_space : char, optional
    Character(s) used in replacement of white spaces in the variables
    names. By default, use a '_'.
case_sensitive : {True, False, 'upper', 'lower'}, optional
    If True, field names are case sensitive.
    If False or 'upper', field names are converted to upper case.
    If 'lower', field names are converted to lower case.
unpack : bool, optional
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = loadtxt(...)``
usemask : bool, optional
    If True, return a masked array.
    If False, return a regular array.
loose : bool, optional
    If True, do not raise errors for invalid values.
invalid_raise : bool, optional
    If True, an exception is raised if an inconsistency is detected in the
    number of columns.
    If False, a warning is emitted and the offending lines are skipped.
max_rows : int,  optional
    The maximum number of rows to read. Must not be used with skip_footer
    at the same time.  If given, the value must be at least 1. Default is
    to read the entire file.

    .. versionadded:: 1.10.0

Returns
-------
out : ndarray
    Data read from the text file. If `usemask` is True, this is a
    masked array.

See Also
--------
numpy.loadtxt : equivalent function when no data is missing.

Notes
-----
* When spaces are used as delimiters, or when no delimiter has been given
  as input, there should not be any missing data between two fields.
* When the variables are named (either by a flexible dtype or with `names`,
  there must not be any header in the file (else a ValueError
  exception is raised).
* Individual values are not stripped of spaces by default.
  When using a custom converter, make sure the function does remove spaces.

References
----------
.. [1] Numpy User Guide, section `I/O with Numpy
       &lt;http://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&gt;`_.

Examples
---------
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; import numpy as np

Comma delimited file with mixed dtype

&gt;&gt;&gt; s = StringIO("1,1.3,abcde")
&gt;&gt;&gt; data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),
... ('mystring','S5')], delimiter=",")
&gt;&gt;&gt; data
array((1, 1.3, 'abcde'),
      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', '|S5')])

Using dtype = None

&gt;&gt;&gt; s.seek(0) # needed for StringIO example only
&gt;&gt;&gt; data = np.genfromtxt(s, dtype=None,
... names = ['myint','myfloat','mystring'], delimiter=",")
&gt;&gt;&gt; data
array((1, 1.3, 'abcde'),
      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', '|S5')])

Specifying dtype and names

&gt;&gt;&gt; s.seek(0)
&gt;&gt;&gt; data = np.genfromtxt(s, dtype="i8,f8,S5",
... names=['myint','myfloat','mystring'], delimiter=",")
&gt;&gt;&gt; data
array((1, 1.3, 'abcde'),
      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', '|S5')])

An example with fixed-width columns

&gt;&gt;&gt; s = StringIO("11.3abcde")
&gt;&gt;&gt; data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],
...     delimiter=[1,3,5])
&gt;&gt;&gt; data
array((1, 1.3, 'abcde'),
      dtype=[('intvar', '&lt;i8'), ('fltvar', '&lt;f8'), ('strvar', '|S5')])</docstring>
    <inputPortSpec arg="fname" name="fname" show_port="True">
      <docstring>File, filename, or generator to read.  If the filename extension is
`.gz` or `.bz2`, the file is first decompressed. Note that
generators must return byte strings in Python 3k.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the resulting array.
If None, the dtypes will be determined by the contents of each
column, individually.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="comments" name="comments">
      <docstring>The character used to indicate the start of a comment.
All the characters occurring on a line after a comment are discarded</docstring>
      <defaults>['#']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="delimiter" name="delimiterScalar" port_type="basic:Integer">
      <docstring>The string used to separate values.  By default, any consecutive
whitespaces act as delimiter.  An integer or sequence of integers
can also be provided as width(s) of each field.</docstring>
      <alternateSpec arg="delimiter" name="delimiterSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="skiprows" name="skiprows" port_type="basic:Integer">
      <docstring>`skiprows` was removed in numpy 1.10. Please use `skip_header` instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="skip_header" name="skip_header" port_type="basic:Integer">
      <docstring>The number of lines to skip at the beginning of the file.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="skip_footer" name="skip_footer" port_type="basic:Integer">
      <docstring>The number of lines to skip at the end of the file.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="converters" name="converters" port_type="basic:Variant">
      <docstring>The set of functions that convert the data of a column to a value.
The converters can also be used to provide a default value
for missing data: ``converters = {3: lambda s: float(s or 0)}``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="missing" name="missing" port_type="basic:Variant">
      <docstring>`missing` was removed in numpy 1.10. Please use `missing_values`
instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="missing_values" name="missing_values" port_type="basic:Variant">
      <docstring>The set of strings corresponding to missing data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="filling_values" name="filling_values" port_type="basic:Variant">
      <docstring>The set of values to be used as default when the data are missing.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="usecols" name="usecols" port_type="basic:List">
      <docstring>Which columns to read, with 0 being the first.  For example,
``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="names" name="namesScalar">
      <docstring>If `names` is True, the field names are read from the first valid line
after the first `skip_header` lines.
If `names` is a sequence or a single-string of comma-separated names,
the names will be used to define the field names in a structured dtype.
If `names` is None, the names of the dtype fields will be used, if any.</docstring>
      <alternateSpec arg="names" name="namesSequence" port_type="basic:List" />
      <alternateSpec arg="names" name="namesBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="excludelist" name="excludelist" port_type="basic:List">
      <docstring>A list of names to exclude. This list is appended to the default list
['return','file','print']. Excluded names are appended an underscore:
for example, `file` would become `file_`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deletechars" name="deletechars">
      <docstring>A string combining invalid characters that must be deleted from the
names.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="defaultfmt" name="defaultfmt">
      <docstring>A format used to define default field names, such as "f%i" or "f_%02i".</docstring>
      <defaults>['f%i']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="autostrip" name="autostrip" port_type="basic:Boolean">
      <docstring>Whether to automatically strip white spaces from the variables.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="replace_space" name="replace_space">
      <docstring>Character(s) used in replacement of white spaces in the variables
names. By default, use a '_'.</docstring>
      <defaults>['_']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="case_sensitive" name="case_sensitiveScalar">
      <docstring>If True, field names are case sensitive.
If False or 'upper', field names are converted to upper case.
If 'lower', field names are converted to lower case.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['upper', 'lower']]</values>
      <defaults>[True]</defaults>
      <alternateSpec arg="case_sensitive" name="case_sensitiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="unpack" name="unpack" port_type="basic:Boolean">
      <docstring>If True, the returned array is transposed, so that arguments may be
unpacked using ``x, y, z = loadtxt(...)``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="usemask" name="usemask" port_type="basic:Boolean">
      <docstring>If True, return a masked array.
If False, return a regular array.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="loose" name="loose" port_type="basic:Boolean">
      <docstring>If True, do not raise errors for invalid values.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="invalid_raise" name="invalid_raise" port_type="basic:Boolean">
      <docstring>If True, an exception is raised if an inconsistency is detected in the
number of columns.
If False, a warning is emitted and the offending lines are skipped.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="max_rows" name="max_rows" port_type="basic:Integer">
      <docstring>The maximum number of rows to read. Must not be used with skip_footer
at the same time.  If given, the value must be at least 1. Default is
to read the entire file.

.. versionadded:: 1.10.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Data read from the text file. If `usemask` is True, this is a
masked array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.npyio.fromregex" module_name="fromregex" namespace="'io'">
    <docstring>Construct an array from a text file, using regular expression parsing.

The returned array is always a structured array, and is constructed from
all matches of the regular expression in the file. Groups in the regular
expression are converted to fields of the structured array.

Parameters
----------
file : str or file
    File name or file object to read.
regexp : str or regexp
    Regular expression used to parse the file.
    Groups in the regular expression correspond to fields in the dtype.
dtype : dtype or list of dtypes
    Dtype for the structured array.

Returns
-------
output : ndarray
    The output array, containing the part of the content of `file` that
    was matched by `regexp`. `output` is always a structured array.

Raises
------
TypeError
    When `dtype` is not a valid dtype for a structured array.

See Also
--------
fromstring, loadtxt

Notes
-----
Dtypes for structured arrays can be specified in several forms, but all
forms specify at least the data type and field name. For details see
`doc.structured_arrays`.

Examples
--------
&gt;&gt;&gt; f = open('test.dat', 'w')
&gt;&gt;&gt; f.write("1312 foo\n1534  bar\n444   qux")
&gt;&gt;&gt; f.close()

&gt;&gt;&gt; regexp = r"(\d+)\s+(...)"  # match [digits, whitespace, anything]
&gt;&gt;&gt; output = np.fromregex('test.dat', regexp,
...                       [('num', np.int64), ('key', 'S3')])
&gt;&gt;&gt; output
array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],
      dtype=[('num', '&lt;i8'), ('key', '|S3')])
&gt;&gt;&gt; output['num']
array([1312, 1534,  444], dtype=int64)</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>File name or file object to read.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="regexp" name="regexp" show_port="True">
      <docstring>Regular expression used to parse the file.
Groups in the regular expression correspond to fields in the dtype.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['regexp']]</values>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtypeScalar" show_port="True">
      <docstring>Dtype for the structured array.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dtype']]</values>
      <alternateSpec arg="dtype" name="dtypeSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The output array, containing the part of the content of `file` that
was matched by `regexp`. `output` is always a structured array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.fromstring" module_name="fromstring" namespace="'io'">
    <docstring>fromstring(string, dtype=float, count=-1, sep='')

A new 1-D array initialized from raw binary or text data in a string.

Parameters
----------
string : str
    A string containing the data.
dtype : data-type, optional
    The data type of the array; default: float.  For binary input data,
    the data must be in exactly this format.
count : int, optional
    Read this number of `dtype` elements from the data.  If this is
    negative (the default), the count will be determined from the
    length of the data.
sep : str, optional
    If not provided or, equivalently, the empty string, the data will
    be interpreted as binary data; otherwise, as ASCII text with
    decimal numbers.  Also in this latter case, this argument is
    interpreted as the string separating numbers in the data; extra
    whitespace between elements is also ignored.

Returns
-------
arr : ndarray
    The constructed array.

Raises
------
ValueError
    If the string is not the correct size to satisfy the requested
    `dtype` and `count`.

See Also
--------
frombuffer, fromfile, fromiter

Examples
--------
&gt;&gt;&gt; np.fromstring('\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
&gt;&gt;&gt; np.fromstring('1 2', dtype=int, sep=' ')
array([1, 2])
&gt;&gt;&gt; np.fromstring('1, 2', dtype=int, sep=',')
array([1, 2])
&gt;&gt;&gt; np.fromstring('\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)</docstring>
    <inputPortSpec arg="string" name="string" show_port="True">
      <docstring>A string containing the data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data type of the array; default: float.  For binary input data,
the data must be in exactly this format.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="count" name="count" port_type="basic:Integer">
      <docstring>Read this number of `dtype` elements from the data.  If this is
negative (the default), the count will be determined from the
length of the data.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sep" name="sep">
      <docstring>If not provided or, equivalently, the empty string, the data will
be interpreted as binary data; otherwise, as ASCII text with
decimal numbers.  Also in this latter case, this argument is
interpreted as the string separating numbers in the data; extra
whitespace between elements is also ignored.</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The constructed array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.fromfile" module_name="fromfile" namespace="'io'">
    <docstring>fromfile(file, dtype=float, count=-1, sep='')

Construct an array from data in a text or binary file.

A highly efficient way of reading binary data with a known data-type,
as well as parsing simply formatted text files.  Data written using the
`tofile` method can be read using this function.

Parameters
----------
file : file or str
    Open file object or filename.
dtype : data-type
    Data type of the returned array.
    For binary files, it is used to determine the size and byte-order
    of the items in the file.
count : int
    Number of items to read. ``-1`` means all items (i.e., the complete
    file).
sep : str
    Separator between items if file is a text file.
    Empty ("") separator means the file should be treated as binary.
    Spaces (" ") in the separator match zero or more whitespace characters.
    A separator consisting only of spaces must match at least one
    whitespace.

See also
--------
load, save
ndarray.tofile
loadtxt : More flexible way of loading data from a text file.

Notes
-----
Do not rely on the combination of `tofile` and `fromfile` for
data storage, as the binary files generated are are not platform
independent.  In particular, no byte-order or data-type information is
saved.  Data can be stored in the platform independent ``.npy`` format
using `save` and `load` instead.

Examples
--------
Construct an ndarray:

&gt;&gt;&gt; dt = np.dtype([('time', [('min', int), ('sec', int)]),
...                ('temp', float)])
&gt;&gt;&gt; x = np.zeros((1,), dtype=dt)
&gt;&gt;&gt; x['time']['min'] = 10; x['temp'] = 98.25
&gt;&gt;&gt; x
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '&lt;i4'), ('sec', '&lt;i4')]), ('temp', '&lt;f8')])

Save the raw data to disk:

&gt;&gt;&gt; import os
&gt;&gt;&gt; fname = os.tmpnam()
&gt;&gt;&gt; x.tofile(fname)

Read the raw data from disk:

&gt;&gt;&gt; np.fromfile(fname, dtype=dt)
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '&lt;i4'), ('sec', '&lt;i4')]), ('temp', '&lt;f8')])

The recommended way to store and load data:

&gt;&gt;&gt; np.save(fname, x)
&gt;&gt;&gt; np.load(fname + '.npy')
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '&lt;i4'), ('sec', '&lt;i4')]), ('temp', '&lt;f8')])</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>Open file object or filename.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant" show_port="True">
      <docstring>Data type of the returned array.
For binary files, it is used to determine the size and byte-order
of the items in the file.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="count" name="count" port_type="basic:Integer">
      <docstring>Number of items to read. ``-1`` means all items (i.e., the complete
file).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sep" name="sep">
      <docstring>Separator between items if file is a text file.
Empty ("") separator means the file should be treated as binary.
Spaces (" ") in the separator match zero or more whitespace characters.
A separator consisting only of spaces must match at least one
whitespace.</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.arrayprint.array2string" module_name="array2string" namespace="'io'">
    <docstring>Return a string representation of an array.

Parameters
----------
a : ndarray
    Input array.
max_line_width : int, optional
    The maximum number of columns the string should span. Newline
    characters splits the string appropriately after array elements.
precision : int, optional
    Floating point precision. Default is the current printing
    precision (usually 8), which can be altered using `set_printoptions`.
suppress_small : bool, optional
    Represent very small numbers as zero. A number is "very small" if it
    is smaller than the current printing precision.
separator : str, optional
    Inserted between elements.
prefix : str, optional
    An array is typically printed as::

      'prefix(' + array2string(a) + ')'

    The length of the prefix string is used to align the
    output correctly.
style : function, optional
    A function that accepts an ndarray and returns a string.  Used only
    when the shape of `a` is equal to ``()``, i.e. for 0-D arrays.
formatter : dict of callables, optional
    If not None, the keys should indicate the type(s) that the respective
    formatting function applies to.  Callables should return a string.
    Types that are not specified (by their corresponding keys) are handled
    by the default formatters.  Individual types for which a formatter
    can be set are::

        - 'bool'
        - 'int'
        - 'timedelta' : a `numpy.timedelta64`
        - 'datetime' : a `numpy.datetime64`
        - 'float'
        - 'longfloat' : 128-bit floats
        - 'complexfloat'
        - 'longcomplexfloat' : composed of two 128-bit floats
        - 'numpy_str' : types `numpy.string_` and `numpy.unicode_`
        - 'str' : all other strings

    Other keys that can be used to set a group of types at once are::

        - 'all' : sets all types
        - 'int_kind' : sets 'int'
        - 'float_kind' : sets 'float' and 'longfloat'
        - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
        - 'str_kind' : sets 'str' and 'numpystr'

Returns
-------
array_str : str
    String representation of the array.

Raises
------
TypeError
    if a callable in `formatter` does not return a string.

See Also
--------
array_str, array_repr, set_printoptions, get_printoptions

Notes
-----
If a formatter is specified for a certain type, the `precision` keyword is
ignored for that type.

This is a very flexible function; `array_repr` and `array_str` are using
`array2string` internally so keywords with the same name should work
identically in all three functions.

Examples
--------
&gt;&gt;&gt; x = np.array([1e-16,1,2,3])
&gt;&gt;&gt; print np.array2string(x, precision=2, separator=',',
...                       suppress_small=True)
[ 0., 1., 2., 3.]

&gt;&gt;&gt; x  = np.arange(3.)
&gt;&gt;&gt; np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x})
'[0.00 1.00 2.00]'

&gt;&gt;&gt; x  = np.arange(3)
&gt;&gt;&gt; np.array2string(x, formatter={'int':lambda x: hex(x)})
'[0x0L 0x1L 0x2L]'</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max_line_width" name="max_line_width" port_type="basic:Integer">
      <docstring>The maximum number of columns the string should span. Newline
characters splits the string appropriately after array elements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="precision" name="precision" port_type="basic:Integer">
      <docstring>Floating point precision. Default is the current printing
precision (usually 8), which can be altered using `set_printoptions`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="suppress_small" name="suppress_small" port_type="basic:Boolean">
      <docstring>Represent very small numbers as zero. A number is "very small" if it
is smaller than the current printing precision.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="separator" name="separator">
      <docstring>Inserted between elements.</docstring>
      <defaults>[' ']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefix" name="prefix">
      <docstring>An array is typically printed as::

  'prefix(' + array2string(a) + ')'

The length of the prefix string is used to align the
output correctly.</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="style" name="style" port_type="basic:Variant">
      <docstring>A function that accepts an ndarray and returns a string.  Used only
when the shape of `a` is equal to ``()``, i.e. for 0-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="formatter" name="formatter" port_type="basic:Dictionary">
      <docstring>If not None, the keys should indicate the type(s) that the respective
formatting function applies to.  Callables should return a string.
Types that are not specified (by their corresponding keys) are handled
by the default formatters.  Individual types for which a formatter
can be set are::

    - 'bool'
    - 'int'
    - 'timedelta' : a `numpy.timedelta64`
    - 'datetime' : a `numpy.datetime64`
    - 'float'
    - 'longfloat' : 128-bit floats
    - 'complexfloat'
    - 'longcomplexfloat' : composed of two 128-bit floats
    - 'numpy_str' : types `numpy.string_` and `numpy.unicode_`
    - 'str' : all other strings

Other keys that can be used to set a group of types at once are::

    - 'all' : sets all types
    - 'int_kind' : sets 'int'
    - 'float_kind' : sets 'float' and 'longfloat'
    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
    - 'str_kind' : sets 'str' and 'numpystr'</docstring>
    </inputPortSpec>
    <outputPortSpec arg="array_str" name="array_str" show_port="True" sort_key="0">
      <docstring>String representation of the array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.numeric.array_repr" module_name="array_repr" namespace="'io'">
    <docstring>Return the string representation of an array.

Parameters
----------
arr : ndarray
    Input array.
max_line_width : int, optional
    The maximum number of columns the string should span. Newline
    characters split the string appropriately after array elements.
precision : int, optional
    Floating point precision. Default is the current printing precision
    (usually 8), which can be altered using `set_printoptions`.
suppress_small : bool, optional
    Represent very small numbers as zero, default is False. Very small
    is defined by `precision`, if the precision is 8 then
    numbers smaller than 5e-9 are represented as zero.

Returns
-------
string : str
  The string representation of an array.

See Also
--------
array_str, array2string, set_printoptions

Examples
--------
&gt;&gt;&gt; np.array_repr(np.array([1,2]))
'array([1, 2])'
&gt;&gt;&gt; np.array_repr(np.ma.array([0.]))
'MaskedArray([ 0.])'
&gt;&gt;&gt; np.array_repr(np.array([], np.int32))
'array([], dtype=int32)'

&gt;&gt;&gt; x = np.array([1e-6, 4e-7, 2, 3])
&gt;&gt;&gt; np.array_repr(x, precision=6, suppress_small=True)
'array([ 0.000001,  0.      ,  2.      ,  3.      ])'</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max_line_width" name="max_line_width" port_type="basic:Integer">
      <docstring>The maximum number of columns the string should span. Newline
characters split the string appropriately after array elements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="precision" name="precision" port_type="basic:Integer">
      <docstring>Floating point precision. Default is the current printing precision
(usually 8), which can be altered using `set_printoptions`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="suppress_small" name="suppress_small" port_type="basic:Boolean">
      <docstring>Represent very small numbers as zero, default is False. Very small
is defined by `precision`, if the precision is 8 then
numbers smaller than 5e-9 are represented as zero.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="string" name="string" show_port="True" sort_key="0">
      <docstring>The string representation of an array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.numeric.array_str" module_name="array_str" namespace="'io'">
    <docstring>Return a string representation of the data in an array.

The data in the array is returned as a single string.  This function is
similar to `array_repr`, the difference being that `array_repr` also
returns information on the kind of array and its data type.

Parameters
----------
a : ndarray
    Input array.
max_line_width : int, optional
    Inserts newlines if text is longer than `max_line_width`.  The
    default is, indirectly, 75.
precision : int, optional
    Floating point precision.  Default is the current printing precision
    (usually 8), which can be altered using `set_printoptions`.
suppress_small : bool, optional
    Represent numbers "very close" to zero as zero; default is False.
    Very close is defined by precision: if the precision is 8, e.g.,
    numbers smaller (in absolute value) than 5e-9 are represented as
    zero.

See Also
--------
array2string, array_repr, set_printoptions

Examples
--------
&gt;&gt;&gt; np.array_str(np.arange(3))
'[0 1 2]'</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max_line_width" name="max_line_width" port_type="basic:Integer">
      <docstring>Inserts newlines if text is longer than `max_line_width`.  The
default is, indirectly, 75.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="precision" name="precision" port_type="basic:Integer">
      <docstring>Floating point precision.  Default is the current printing precision
(usually 8), which can be altered using `set_printoptions`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="suppress_small" name="suppress_small" port_type="basic:Boolean">
      <docstring>Represent numbers "very close" to zero as zero; default is False.
Very close is defined by precision: if the precision is 8, e.g.,
numbers smaller (in absolute value) than 5e-9 are represented as
zero.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.memmap.memmap" module_name="memmap" namespace="'io'">
    <docstring>Create a memory-map to an array stored in a *binary* file on disk.

Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory.  Numpy's
memmap's are array-like objects.  This differs from Python's ``mmap``
module, which uses file-like objects.

This subclass of ndarray has some unpleasant interactions with
some operations, because it doesn't quite fit properly as a subclass.
An alternative to using this subclass is to create the ``mmap``
object yourself, then create an ndarray with ndarray.__new__ directly,
passing the object created in its 'buffer=' parameter.

This class may at some point be turned into a factory function
which returns a view into an mmap buffer.

Delete the memmap instance to close.


Parameters
----------
filename : str or file-like object
    The file name or file object to be used as the array data buffer.
dtype : data-type, optional
    The data-type used to interpret the file contents.
    Default is `uint8`.
mode : {'r+', 'r', 'w+', 'c'}, optional
    The file is opened in this mode:

    +------+-------------------------------------------------------------+
    | 'r'  | Open existing file for reading only.                        |
    +------+-------------------------------------------------------------+
    | 'r+' | Open existing file for reading and writing.                 |
    +------+-------------------------------------------------------------+
    | 'w+' | Create or overwrite existing file for reading and writing.  |
    +------+-------------------------------------------------------------+
    | 'c'  | Copy-on-write: assignments affect data in memory, but       |
    |      | changes are not saved to disk.  The file on disk is         |
    |      | read-only.                                                  |
    +------+-------------------------------------------------------------+

    Default is 'r+'.
offset : int, optional
    In the file, array data starts at this offset. Since `offset` is
    measured in bytes, it should normally be a multiple of the byte-size
    of `dtype`. When ``mode != 'r'``, even positive offsets beyond end of
    file are valid; The file will be extended to accommodate the
    additional data. By default, ``memmap`` will start at the beginning of
    the file, even if ``filename`` is a file pointer ``fp`` and
    ``fp.tell() != 0``.
shape : tuple, optional
    The desired shape of the array. If ``mode == 'r'`` and the number
    of remaining bytes after `offset` is not a multiple of the byte-size
    of `dtype`, you must specify `shape`. By default, the returned array
    will be 1-D with the number of elements determined by file size
    and data-type.
order : {'C', 'F'}, optional
    Specify the order of the ndarray memory layout:
    :term:`row-major`, C-style or :term:`column-major`,
    Fortran-style.  This only has an effect if the shape is
    greater than 1-D.  The default order is 'C'.

Attributes
----------
filename : str
    Path to the mapped file.
offset : int
    Offset position in the file.
mode : str
    File mode.

Methods
-------
flush
    Flush any changes in memory to file on disk.
    When you delete a memmap object, flush is called first to write
    changes to disk before removing the object.


Notes
-----
The memmap object can be used anywhere an ndarray is accepted.
Given a memmap ``fp``, ``isinstance(fp, numpy.ndarray)`` returns
``True``.

Memory-mapped arrays use the Python memory-map object which
(prior to Python 2.5) does not allow files to be larger than a
certain size depending on the platform. This size is always &lt; 2GB
even on 64-bit systems.

When a memmap causes a file to be created or extended beyond its
current size in the filesystem, the contents of the new part are
unspecified. On systems with POSIX filesystem semantics, the extended
part will be filled with zero bytes.

Examples
--------
&gt;&gt;&gt; data = np.arange(12, dtype='float32')
&gt;&gt;&gt; data.resize((3,4))

This example uses a temporary file so that doctest doesn't write
files to your directory. You would use a 'normal' filename.

&gt;&gt;&gt; from tempfile import mkdtemp
&gt;&gt;&gt; import os.path as path
&gt;&gt;&gt; filename = path.join(mkdtemp(), 'newfile.dat')

Create a memmap with dtype and shape that matches our data:

&gt;&gt;&gt; fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))
&gt;&gt;&gt; fp
memmap([[ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.],
        [ 0.,  0.,  0.,  0.]], dtype=float32)

Write data to memmap array:

&gt;&gt;&gt; fp[:] = data[:]
&gt;&gt;&gt; fp
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

&gt;&gt;&gt; fp.filename == path.abspath(filename)
True

Deletion flushes memory changes to disk before removing the object:

&gt;&gt;&gt; del fp

Load the memmap and verify data was stored:

&gt;&gt;&gt; newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
&gt;&gt;&gt; newfp
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

Read-only memmap:

&gt;&gt;&gt; fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
&gt;&gt;&gt; fpr.flags.writeable
False

Copy-on-write memmap:

&gt;&gt;&gt; fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))
&gt;&gt;&gt; fpc.flags.writeable
True

It's possible to assign to copy-on-write array, but values are only
written into the memory copy of the array, and not written to disk:

&gt;&gt;&gt; fpc
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
&gt;&gt;&gt; fpc[0,:] = 0
&gt;&gt;&gt; fpc
memmap([[  0.,   0.,   0.,   0.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

File on disk is unchanged:

&gt;&gt;&gt; fpr
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

Offset into a memmap:

&gt;&gt;&gt; fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)
&gt;&gt;&gt; fpo
memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)</docstring>
    <inputPortSpec arg="filename" name="filenameScalar" show_port="True">
      <docstring>The file name or file object to be used as the array data buffer.</docstring>
      <alternateSpec arg="filename" name="filenameSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data-type used to interpret the file contents.
Default is `uint8`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The file is opened in this mode:

+------+-------------------------------------------------------------+
| 'r'  | Open existing file for reading only.                        |
+------+-------------------------------------------------------------+
| 'r+' | Open existing file for reading and writing.                 |
+------+-------------------------------------------------------------+
| 'w+' | Create or overwrite existing file for reading and writing.  |
+------+-------------------------------------------------------------+
| 'c'  | Copy-on-write: assignments affect data in memory, but       |
|      | changes are not saved to disk.  The file on disk is         |
|      | read-only.                                                  |
+------+-------------------------------------------------------------+

Default is 'r+'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['r', '+------+-------------------------------------------------------------+', 'r+', '+------+-------------------------------------------------------------+', 'w+', '+------+-------------------------------------------------------------+', 'c', '', '', '', '', 'read-only.']]</values>
      <defaults>['r+']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="offset" name="offset" port_type="basic:Integer">
      <docstring>In the file, array data starts at this offset. Since `offset` is
measured in bytes, it should normally be a multiple of the byte-size
of `dtype`. When ``mode != 'r'``, even positive offsets beyond end of
file are valid; The file will be extended to accommodate the
additional data. By default, ``memmap`` will start at the beginning of
the file, even if ``filename`` is a file pointer ``fp`` and
``fp.tell() != 0``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shape" name="shape" port_type="basic:List">
      <docstring>The desired shape of the array. If ``mode == 'r'`` and the number
of remaining bytes after `offset` is not a multiple of the byte-size
of `dtype`, you must specify `shape`. By default, the returned array
will be 1-D with the number of elements determined by file size
and data-type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Specify the order of the ndarray memory layout:
:term:`row-major`, C-style or :term:`column-major`,
Fortran-style.  This only has an effect if the shape is
greater than 1-D.  The default order is 'C'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.dot" module_name="dot" namespace="'linalg'">
    <docstring>dot(a, b, out=None)

Dot product of two arrays.

For 2-D arrays it is equivalent to matrix multiplication, and for 1-D
arrays to inner product of vectors (without complex conjugation). For
N dimensions it is a sum product over the last axis of `a` and
the second-to-last of `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.

Examples
--------
&gt;&gt;&gt; np.dot(3, 4)
12

Neither argument is complex-conjugated:

&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it is the matrix product:

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.dot(a, b)
array([[4, 1],
       [2, 2]])

&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))
&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]
499128
&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])
499128</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for `dot(a,b)`. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns the dot product of `a` and `b`.  If `a` and `b` are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If `out` is given, then it is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.vdot" module_name="vdot" namespace="'linalg'">
    <docstring>vdot(a, b)

Return the dot product of two vectors.

The vdot(`a`, `b`) function handles complex numbers differently than
dot(`a`, `b`).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.

Note that `vdot` handles multidimensional arrays differently than `dot`:
it does *not* perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.

Parameters
----------
a : array_like
    If `a` is complex the complex conjugate is taken before calculation
    of the dot product.
b : array_like
    Second argument to the dot product.

Returns
-------
output : ndarray
    Dot product of `a` and `b`.  Can be an int, float, or
    complex depending on the types of `a` and `b`.

See Also
--------
dot : Return the dot product without using the complex conjugate of the
      first argument.

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j,3+4j])
&gt;&gt;&gt; b = np.array([5+6j,7+8j])
&gt;&gt;&gt; np.vdot(a, b)
(70-8j)
&gt;&gt;&gt; np.vdot(b, a)
(70+8j)

Note that higher-dimensional arrays are flattened!

&gt;&gt;&gt; a = np.array([[1, 4], [5, 6]])
&gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])
&gt;&gt;&gt; np.vdot(a, b)
30
&gt;&gt;&gt; np.vdot(b, a)
30
&gt;&gt;&gt; 1*4 + 4*1 + 5*2 + 6*2
30</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>If `a` is complex the complex conjugate is taken before calculation
of the dot product.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second argument to the dot product.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Dot product of `a` and `b`.  Can be an int, float, or
complex depending on the types of `a` and `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.inner" module_name="inner" namespace="'linalg'">
    <docstring>inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions of must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r &gt; 0` and `ndim(b) = s &gt; 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2

A multidimensional example:

&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[ 7.,  0.],
       [ 0.,  7.]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>If `a` and `b` are nonscalar, their last dimensions of must match.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>If `a` and `b` are nonscalar, their last dimensions of must match.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`out.shape = a.shape[:-1] + b.shape[:-1]`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.numeric.outer" module_name="outer" namespace="'linalg'">
    <docstring>Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner, einsum

References
----------
.. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a (*very* coarse) grid for computing a Mandelbrot set:

&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
&gt;&gt;&gt; rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
&gt;&gt;&gt; im
array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
&gt;&gt;&gt; grid = rl + im
&gt;&gt;&gt; grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a "vector" of letters:

&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)
&gt;&gt;&gt; np.outer(x, [1, 2, 3])
array([[a, aa, aaa],
       [b, bb, bbb],
       [c, cc, ccc]], dtype=object)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First input vector.  Input is flattened if
not already 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second input vector.  Input is flattened if
not already 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>A location where the result is stored

.. versionadded:: 1.9.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>``out[i, j] = a[i] * b[j]``</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.matmul" module_name="matmul" namespace="'linalg'">
    <docstring>matmul(a, b, out=None)

Matrix product of two arrays.

The behavior depends on the arguments in the following way.

- If both arguments are 2-D they are multiplied like conventional
  matrices.
- If either argument is N-D, N &gt; 2, it is treated as a stack of
  matrices residing in the last two indexes and broadcast accordingly.
- If the first argument is 1-D, it is promoted to a matrix by
  prepending a 1 to its dimensions. After matrix multiplication
  the prepended 1 is removed.
- If the second argument is 1-D, it is promoted to a matrix by
  appending a 1 to its dimensions. After matrix multiplication
  the appended 1 is removed.

Multiplication by a scalar is not allowed, use ``*`` instead. Note that
multiplying a stack of matrices with a vector will result in a stack of
vectors, but matmul will not recognize it as such.

``matmul`` differs from ``dot`` in two important ways.

- Multiplication by scalars is not allowed.
- Stacks of matrices are broadcast together as if the matrices
  were elements.

.. warning::
   This function is preliminary and included in Numpy 1.10 for testing
   and documentation. Its semantics will not change, but the number and
   order of the optional arguments will.

.. versionadded:: 1.10.0

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    1-D arrays then a scalar is returned; otherwise an array is
    returned.  If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

    If scalar value is passed.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
dot : alternative matrix product with different broadcasting rules.

Notes
-----
The matmul function implements the semantics of the `@` operator introduced
in Python 3.5 following PEP465.

Examples
--------
For 2-D arrays it is the matrix product:

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.matmul(a, b)
array([[4, 1],
       [2, 2]])

For 2-D mixed with 1-D, the result is the usual.

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [1, 2]
&gt;&gt;&gt; np.matmul(a, b)
array([1, 2])
&gt;&gt;&gt; np.matmul(b, a)
array([1, 2])


Broadcasting is conventional for stacks of arrays

&gt;&gt;&gt; a = np.arange(2*2*4).reshape((2,2,4))
&gt;&gt;&gt; b = np.arange(2*2*4).reshape((2,4,2))
&gt;&gt;&gt; np.matmul(a,b).shape
(2, 2, 2)
&gt;&gt;&gt; np.matmul(a,b)[0,1,1]
98
&gt;&gt;&gt; sum(a[0,1,:] * b[0,:,1])
98

Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated:

&gt;&gt;&gt; np.matmul([2j, 3j], [2j, 3j])
(-13+0j)

Scalar multiplication raises an error.

&gt;&gt;&gt; np.matmul([1,2], 3)
Traceback (most recent call last):
...
ValueError: Scalar operands are not allowed, use '*' instead</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for `dot(a,b)`. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns the dot product of `a` and `b`.  If `a` and `b` are both
1-D arrays then a scalar is returned; otherwise an array is
returned.  If `out` is given, then it is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.numeric.tensordot" module_name="tensordot" namespace="'linalg'">
    <docstring>Compute tensor dot product along specified axes for arrays &gt;= 1-D.

Given two tensors (arrays of dimension greater than or equal to one),
`a` and `b`, and an array_like object containing two array_like
objects, ``(a_axes, b_axes)``, sum the products of `a`'s and `b`'s
elements (components) over the axes specified by ``a_axes`` and
``b_axes``. The third argument can be a single non-negative
integer_like scalar, ``N``; if it is such, then the last ``N``
dimensions of `a` and the first ``N`` dimensions of `b` are summed
over.

Parameters
----------
a, b : array_like, len(shape) &gt;= 1
    Tensors to "dot".

axes : int or (2,) array_like
    * integer_like
      If an int N, sum over the last N axes of `a` and the first N axes
      of `b` in order. The sizes of the corresponding axes must match.
    * (2,) array_like
      Or, a list of axes to be summed over, first sequence applying to `a`,
      second to `b`. Both elements array_like must be of the same length.

See Also
--------
dot, einsum

Notes
-----
Three common use cases are:
    ``axes = 0`` : tensor product $a\otimes b$
    ``axes = 1`` : tensor dot product $a\cdot b$
    ``axes = 2`` : (default) tensor double contraction $a:b$

When `axes` is integer_like, the sequence for evaluation will be: first
the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
Nth axis in `b` last.

When there is more than one axis to sum over - and they are not the last
(first) axes of `a` (`b`) - the argument `axes` should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.

Examples
--------
A "traditional" example:

&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)
&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)
&gt;&gt;&gt; c = np.tensordot(a,b, axes=([1,0],[0,1]))
&gt;&gt;&gt; c.shape
(5, 2)
&gt;&gt;&gt; c
array([[ 4400.,  4730.],
       [ 4532.,  4874.],
       [ 4664.,  5018.],
       [ 4796.,  5162.],
       [ 4928.,  5306.]])
&gt;&gt;&gt; # A slower but equivalent way of computing the same...
&gt;&gt;&gt; d = np.zeros((5,2))
&gt;&gt;&gt; for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
&gt;&gt;&gt; c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]], dtype=bool)

An extended example taking advantage of the overloading of + and \*:

&gt;&gt;&gt; a = np.array(range(1, 9))
&gt;&gt;&gt; a.shape = (2, 2, 2)
&gt;&gt;&gt; A = np.array(('a', 'b', 'c', 'd'), dtype=object)
&gt;&gt;&gt; A.shape = (2, 2)
&gt;&gt;&gt; a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([[a, b],
       [c, d]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A) # third argument default is 2 for double-contraction
array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, 1)
array([[[acc, bdd],
        [aaacccc, bbbdddd]],
       [[aaaaacccccc, bbbbbdddddd],
        [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[[a, b],
          [c, d]],
          ...

&gt;&gt;&gt; np.tensordot(a, A, (0, 1))
array([[[abbbbb, cddddd],
        [aabbbbbb, ccdddddd]],
       [[aaabbbbbbb, cccddddddd],
        [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, (2, 1))
array([[[abb, cdd],
        [aaabbbb, cccdddd]],
       [[aaaaabbbbbb, cccccdddddd],
        [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, ((0, 1), (0, 1)))
array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, ((2, 1), (1, 0)))
array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Tensors to "dot".
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Tensors to "dot".
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axesScalar" port_type="basic:Integer">
      <docstring>* integer_like
  If an int N, sum over the last N axes of `a` and the first N axes
  of `b` in order. The sizes of the corresponding axes must match.
* (2,) array_like
  Or, a list of axes to be summed over, first sequence applying to `a`,
  second to `b`. Both elements array_like must be of the same length.</docstring>
      <defaults>[2]</defaults>
      <alternateSpec arg="axes" name="axesSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.multiarray.einsum" module_name="einsum" namespace="'linalg'">
    <docstring>einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')

Evaluates the Einstein summation convention on the operands.

Using the Einstein summation convention, many common multi-dimensional
array operations can be represented in a simple fashion.  This function
provides a way compute such summations. The best way to understand this
function is to try the examples below, which show how many common NumPy
functions can be implemented as calls to `einsum`.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation.
operands : list of array_like
    These are the arrays for the operation.
out : ndarray, optional
    If provided, the calculation is done into this array.
dtype : data-type, optional
    If provided, forces the calculation to use the data type specified.
    Note that you may have to also give a more liberal `casting`
    parameter to allow the conversions.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the output. 'C' means it should
    be C contiguous. 'F' means it should be Fortran contiguous,
    'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
    'K' means it should be as close to the layout as the inputs as
    is possible, including arbitrarily permuted axes.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.  Setting this to
    'unsafe' is not recommended, as it can adversely affect accumulations.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

Returns
-------
output : ndarray
    The calculation based on the Einstein summation convention.

See Also
--------
dot, inner, outer, tensordot

Notes
-----
.. versionadded:: 1.6.0

The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Repeated subscripts labels in one operand take the diagonal.  For example,
``np.einsum('ii', a)`` is equivalent to ``np.trace(a)``.

Whenever a label is repeated, it is summed, so ``np.einsum('i,i', a, b)``
is equivalent to ``np.inner(a,b)``.  If a label appears only once,
it is not summed, so ``np.einsum('i', a)`` produces a view of ``a``
with no changes.

The order of labels in the output is by default alphabetical.  This
means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while
``np.einsum('ji', a)`` takes its transpose.

The output can be controlled by specifying output subscript labels
as well.  This specifies the label order, and allows summing to
be disallowed or forced when desired.  The call ``np.einsum('i-&gt;', a)``
is like ``np.sum(a, axis=-1)``, and ``np.einsum('ii-&gt;i', a)``
is like ``np.diag(a)``.  The difference is that `einsum` does not
allow broadcasting by default.

To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like ``np.einsum('...ii-&gt;...i', a)``.
To take the trace along the first and last axes,
you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix
product with the left-most indices instead of rightmost, you can do
``np.einsum('ij...,jk...-&gt;ik...', a, b)``.

When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as ``np.einsum('ii-&gt;i', a)``
produces a view.

An alternative way to provide the subscripts and operands is as
``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``. The examples
below have corresponding `einsum` calls with the two parameter methods.

.. versionadded:: 1.10.0

Views returned from einsum are now writeable whenever the input array
is writeable. For example, ``np.einsum('ijk...-&gt;kji...', a)`` will now
have the same effect as ``np.swapaxes(a, 0, 2)`` and
``np.einsum('ii-&gt;i', a)`` will return a writeable view of the diagonal
of a 2D array.

Examples
--------
&gt;&gt;&gt; a = np.arange(25).reshape(5,5)
&gt;&gt;&gt; b = np.arange(5)
&gt;&gt;&gt; c = np.arange(6).reshape(2,3)

&gt;&gt;&gt; np.einsum('ii', a)
60
&gt;&gt;&gt; np.einsum(a, [0,0])
60
&gt;&gt;&gt; np.trace(a)
60

&gt;&gt;&gt; np.einsum('ii-&gt;i', a)
array([ 0,  6, 12, 18, 24])
&gt;&gt;&gt; np.einsum(a, [0,0], [0])
array([ 0,  6, 12, 18, 24])
&gt;&gt;&gt; np.diag(a)
array([ 0,  6, 12, 18, 24])

&gt;&gt;&gt; np.einsum('ij,j', a, b)
array([ 30,  80, 130, 180, 230])
&gt;&gt;&gt; np.einsum(a, [0,1], b, [1])
array([ 30,  80, 130, 180, 230])
&gt;&gt;&gt; np.dot(a, b)
array([ 30,  80, 130, 180, 230])
&gt;&gt;&gt; np.einsum('...j,j', a, b)
array([ 30,  80, 130, 180, 230])

&gt;&gt;&gt; np.einsum('ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
&gt;&gt;&gt; np.einsum(c, [1,0])
array([[0, 3],
       [1, 4],
       [2, 5]])
&gt;&gt;&gt; c.T
array([[0, 3],
       [1, 4],
       [2, 5]])

&gt;&gt;&gt; np.einsum('..., ...', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
&gt;&gt;&gt; np.einsum(3, [Ellipsis], c, [Ellipsis])
array([[ 0,  3,  6],
       [ 9, 12, 15]])
&gt;&gt;&gt; np.multiply(3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])

&gt;&gt;&gt; np.einsum('i,i', b, b)
30
&gt;&gt;&gt; np.einsum(b, [0], b, [0])
30
&gt;&gt;&gt; np.inner(b,b)
30

&gt;&gt;&gt; np.einsum('i,j', np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
&gt;&gt;&gt; np.einsum(np.arange(2)+1, [0], b, [1])
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
&gt;&gt;&gt; np.outer(np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])

&gt;&gt;&gt; np.einsum('i...-&gt;...', a)
array([50, 55, 60, 65, 70])
&gt;&gt;&gt; np.einsum(a, [0,Ellipsis], [Ellipsis])
array([50, 55, 60, 65, 70])
&gt;&gt;&gt; np.sum(a, axis=0)
array([50, 55, 60, 65, 70])

&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)
&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)
&gt;&gt;&gt; np.einsum('ijk,jil-&gt;kl', a, b)
array([[ 4400.,  4730.],
       [ 4532.,  4874.],
       [ 4664.,  5018.],
       [ 4796.,  5162.],
       [ 4928.,  5306.]])
&gt;&gt;&gt; np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
array([[ 4400.,  4730.],
       [ 4532.,  4874.],
       [ 4664.,  5018.],
       [ 4796.,  5162.],
       [ 4928.,  5306.]])
&gt;&gt;&gt; np.tensordot(a,b, axes=([1,0],[0,1]))
array([[ 4400.,  4730.],
       [ 4532.,  4874.],
       [ 4664.,  5018.],
       [ 4796.,  5162.],
       [ 4928.,  5306.]])

&gt;&gt;&gt; a = np.arange(6).reshape((3,2))
&gt;&gt;&gt; b = np.arange(12).reshape((4,3))
&gt;&gt;&gt; np.einsum('ki,jk-&gt;ij', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
&gt;&gt;&gt; np.einsum('ki,...k-&gt;i...', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
&gt;&gt;&gt; np.einsum('k...,jk', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])

&gt;&gt;&gt; # since version 1.10.0
&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; np.einsum('ii-&gt;i', a)[:] = 1
&gt;&gt;&gt; a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])</docstring>
    <inputPortSpec arg="subscripts" name="subscripts" show_port="True">
      <docstring>Specifies the subscripts for summation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="operands" name="operands" port_type="basic:List" show_port="True">
      <docstring>These are the arrays for the operation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>If provided, the calculation is done into this array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>If provided, forces the calculation to use the data type specified.
Note that you may have to also give a more liberal `casting`
parameter to allow the conversions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Controls the memory layout of the output. 'C' means it should
be C contiguous. 'F' means it should be Fortran contiguous,
'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
'K' means it should be as close to the layout as the inputs as
is possible, including arbitrarily permuted axes.
Default is 'K'.</docstring>
      <defaults>['K']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="casting" name="casting">
      <docstring>Controls what kind of data casting may occur.  Setting this to
'unsafe' is not recommended, as it can adversely affect accumulations.

  * 'no' means the data types should not be cast at all.
  * 'equiv' means only byte-order changes are allowed.
  * 'safe' means only casts which can preserve values are allowed.
  * 'same_kind' means only safe casts or casts within a kind,
    like float64 to float32, are allowed.
  * 'unsafe' means any data conversions may be done.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['no', 'equiv', 'safe', 'same_kind', 'unsafe']]</values>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The calculation based on the Einstein summation convention.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.core.fromnumeric.trace" module_name="trace" namespace="'linalg'">
    <docstring>Return the sum along diagonals of the array.

If `a` is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.

If `a` has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of `a` with `axis1`
and `axis2` removed.

Parameters
----------
a : array_like
    Input array, from which the diagonals are taken.
offset : int, optional
    Offset of the diagonal from the main diagonal. Can be both positive
    and negative. Defaults to 0.
axis1, axis2 : int, optional
    Axes to be used as the first and second axis of the 2-D sub-arrays
    from which the diagonals should be taken. Defaults are the first two
    axes of `a`.
dtype : dtype, optional
    Determines the data-type of the returned array and of the accumulator
    where the elements are summed. If dtype has the value None and `a` is
    of integer type of precision less than the default integer
    precision, then the default integer precision is used. Otherwise,
    the precision is the same as that of `a`.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and
    it must be of the right shape to hold the output.

Returns
-------
sum_along_diagonals : ndarray
    If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
    larger dimensions, then an array of sums along diagonals is returned.

See Also
--------
diag, diagonal, diagflat

Examples
--------
&gt;&gt;&gt; np.trace(np.eye(3))
3.0
&gt;&gt;&gt; a = np.arange(8).reshape((2,2,2))
&gt;&gt;&gt; np.trace(a)
array([6, 8])

&gt;&gt;&gt; a = np.arange(24).reshape((2,2,2,3))
&gt;&gt;&gt; np.trace(a).shape
(2, 3)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, from which the diagonals are taken.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="offset" name="offset" port_type="basic:Integer">
      <docstring>Offset of the diagonal from the main diagonal. Can be both positive
and negative. Defaults to 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis1" name="axis1" port_type="basic:Integer">
      <docstring>Axes to be used as the first and second axis of the 2-D sub-arrays
from which the diagonals should be taken. Defaults are the first two
axes of `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis2" name="axis2" port_type="basic:Integer">
      <docstring>Axes to be used as the first and second axis of the 2-D sub-arrays
from which the diagonals should be taken. Defaults are the first two
axes of `a`.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Determines the data-type of the returned array and of the accumulator
where the elements are summed. If dtype has the value None and `a` is
of integer type of precision less than the default integer
precision, then the default integer precision is used. Otherwise,
the precision is the same as that of `a`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and
it must be of the right shape to hold the output.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sum_along_diagonals" name="sum_along_diagonals" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
larger dimensions, then an array of sums along diagonals is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.fv" module_name="fv" namespace="'fft'">
    <docstring>Compute the future value.

Given:
 * a present value, `pv`
 * an interest `rate` compounded once per period, of which
   there are
 * `nper` total
 * a (fixed) payment, `pmt`, paid either
 * at the beginning (`when` = {'begin', 1}) or the end
   (`when` = {'end', 0}) of each period

Return:
   the value at the end of the `nper` periods

Parameters
----------
rate : scalar or array_like of shape(M, )
    Rate of interest as decimal (not per cent) per period
nper : scalar or array_like of shape(M, )
    Number of compounding periods
pmt : scalar or array_like of shape(M, )
    Payment
pv : scalar or array_like of shape(M, )
    Present value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0)).
    Defaults to {'end', 0}.

Returns
-------
out : ndarray
    Future values.  If all input is scalar, returns a scalar float.  If
    any input is array_like, returns future values for each input element.
    If multiple inputs are array_like, they all must have the same shape.

Notes
-----
The future value is computed by solving the equation::

 fv +
 pv*(1+rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0

or, when ``rate == 0``::

 fv + pv + pmt * nper == 0

References
----------
.. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
   OpenDocument-formula-20090508.odt

Examples
--------
What is the future value after 10 years of saving $100 now, with
an additional monthly savings of $100.  Assume the interest rate is
5% (annually) compounded monthly?

&gt;&gt;&gt; np.fv(0.05/12, 10*12, -100, -100)
15692.928894335748

By convention, the negative sign represents cash flow out (i.e. money not
available today).  Thus, saving $100 a month at 5% annual interest leads
to $15,692.93 available to spend in 10 years.

If any input is array_like, returns an array of equal shape.  Let's
compare different interest rates from the example above.

&gt;&gt;&gt; a = np.array((0.05, 0.06, 0.07))/12
&gt;&gt;&gt; np.fv(a, 10*12, -100, -100)
array([ 15692.92889434,  16569.87435405,  17509.44688102])</docstring>
    <inputPortSpec arg="rate" name="rateScalar" port_type="basic:Float" show_port="True">
      <docstring>Rate of interest as decimal (not per cent) per period</docstring>
      <alternateSpec arg="rate" name="rateSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nper" name="nperScalar" port_type="basic:Float" show_port="True">
      <docstring>Number of compounding periods</docstring>
      <alternateSpec arg="nper" name="nperSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="pmt" name="pmtScalar" port_type="basic:Float" show_port="True">
      <docstring>Payment</docstring>
      <alternateSpec arg="pmt" name="pmtSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="pv" name="pvScalar" port_type="basic:Float" show_port="True">
      <docstring>Present value</docstring>
      <alternateSpec arg="pv" name="pvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0)).
Defaults to {'end', 0}.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Future values.  If all input is scalar, returns a scalar float.  If
any input is array_like, returns future values for each input element.
If multiple inputs are array_like, they all must have the same shape.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.pv" module_name="pv" namespace="'fft'">
    <docstring>Compute the present value.

Given:
 * a future value, `fv`
 * an interest `rate` compounded once per period, of which
   there are
 * `nper` total
 * a (fixed) payment, `pmt`, paid either
 * at the beginning (`when` = {'begin', 1}) or the end
   (`when` = {'end', 0}) of each period

Return:
   the value now

Parameters
----------
rate : array_like
    Rate of interest (per period)
nper : array_like
    Number of compounding periods
pmt : array_like
    Payment
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))

Returns
-------
out : ndarray, float
    Present value of a series of payments or investments.

Notes
-----
The present value is computed by solving the equation::

 fv +
 pv*(1 + rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0

or, when ``rate = 0``::

 fv + pv + pmt * nper = 0

for `pv`, which is then returned.

References
----------
.. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
   OpenDocument-formula-20090508.odt

Examples
--------
What is the present value (e.g., the initial investment)
of an investment that needs to total $15692.93
after 10 years of saving $100 every month?  Assume the
interest rate is 5% (annually) compounded monthly.

&gt;&gt;&gt; np.pv(0.05/12, 10*12, -100, 15692.93)
-100.00067131625819

By convention, the negative sign represents cash flow out
(i.e., money not available today).  Thus, to end up with
$15,692.93 in 10 years saving $100 a month at 5% annual
interest, one's initial deposit should also be $100.

If any input is array_like, ``pv`` returns an array of equal shape.
Let's compare different interest rates in the example above:

&gt;&gt;&gt; a = np.array((0.05, 0.04, 0.03))/12
&gt;&gt;&gt; np.pv(a, 10*12, -100, 15692.93)
array([ -100.00067132,  -649.26771385, -1273.78633713])

So, to end up with the same $15692.93 under the same $100 per month
"savings plan," for annual interest rates of 4% and 3%, one would
need initial investments of $649.27 and $1273.79, respectively.</docstring>
    <inputPortSpec arg="rate" name="rate" port_type="basic:List" show_port="True">
      <docstring>Rate of interest (per period)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nper" name="nper" port_type="basic:List" show_port="True">
      <docstring>Number of compounding periods</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pmt" name="pmt" port_type="basic:List" show_port="True">
      <docstring>Payment</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fv" name="fvScalar" port_type="basic:Float">
      <docstring>Future value</docstring>
      <defaults>[0.0]</defaults>
      <alternateSpec arg="fv" name="fvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0))</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Present value of a series of payments or investments.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.npv" module_name="npv" namespace="'fft'">
    <docstring>Returns the NPV (Net Present Value) of a cash flow series.

Parameters
----------
rate : scalar
    The discount rate.
values : array_like, shape(M, )
    The values of the time series of cash flows.  The (fixed) time
    interval between cash flow "events" must be the same as that for
    which `rate` is given (i.e., if `rate` is per year, then precisely
    a year is understood to elapse between each cash flow event).  By
    convention, investments or "deposits" are negative, income or
    "withdrawals" are positive; `values` must begin with the initial
    investment, thus `values[0]` will typically be negative.

Returns
-------
out : float
    The NPV of the input cash flow series `values` at the discount
    `rate`.

Notes
-----
Returns the result of: [G]_

.. math :: \sum_{t=0}^{M-1}{\frac{values_t}{(1+rate)^{t}}}

References
----------
.. [G] L. J. Gitman, "Principles of Managerial Finance, Brief," 3rd ed.,
   Addison-Wesley, 2003, pg. 346.

Examples
--------
&gt;&gt;&gt; np.npv(0.281,[-100, 39, 59, 55, 20])
-0.0084785916384548798

(Compare with the Example given for numpy.lib.financial.irr)</docstring>
    <inputPortSpec arg="rate" name="rate" port_type="basic:Float" show_port="True">
      <docstring>The discount rate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>The values of the time series of cash flows.  The (fixed) time
interval between cash flow "events" must be the same as that for
which `rate` is given (i.e., if `rate` is per year, then precisely
a year is understood to elapse between each cash flow event).  By
convention, investments or "deposits" are negative, income or
"withdrawals" are positive; `values` must begin with the initial
investment, thus `values[0]` will typically be negative.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The NPV of the input cash flow series `values` at the discount
`rate`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.pmt" module_name="pmt" namespace="'fft'">
    <docstring>Compute the payment against loan principal plus interest.

Given:
 * a present value, `pv` (e.g., an amount borrowed)
 * a future value, `fv` (e.g., 0)
 * an interest `rate` compounded once per period, of which
   there are
 * `nper` total
 * and (optional) specification of whether payment is made
   at the beginning (`when` = {'begin', 1}) or the end
   (`when` = {'end', 0}) of each period

Return:
   the (fixed) periodic payment.

Parameters
----------
rate : array_like
    Rate of interest (per period)
nper : array_like
    Number of compounding periods
pv : array_like
    Present value
fv : array_like,  optional
    Future value (default = 0)
when : {{'begin', 1}, {'end', 0}}, {string, int}
    When payments are due ('begin' (1) or 'end' (0))

Returns
-------
out : ndarray
    Payment against loan plus interest.  If all input is scalar, returns a
    scalar float.  If any input is array_like, returns payment for each
    input element. If multiple inputs are array_like, they all must have
    the same shape.

Notes
-----
The payment is computed by solving the equation::

 fv +
 pv*(1 + rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0

or, when ``rate == 0``::

  fv + pv + pmt * nper == 0

for ``pmt``.

Note that computing a monthly mortgage payment is only
one use for this function.  For example, pmt returns the
periodic deposit one must make to achieve a specified
future balance given an initial deposit, a fixed,
periodically compounded interest rate, and the total
number of periods.

References
----------
.. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php
   ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt

Examples
--------
What is the monthly payment needed to pay off a $200,000 loan in 15
years at an annual interest rate of 7.5%?

&gt;&gt;&gt; np.pmt(0.075/12, 12*15, 200000)
-1854.0247200054619

In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained
today, a monthly payment of $1,854.02 would be required.  Note that this
example illustrates usage of `fv` having a default value of 0.</docstring>
    <inputPortSpec arg="rate" name="rate" port_type="basic:List" show_port="True">
      <docstring>Rate of interest (per period)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nper" name="nper" port_type="basic:List" show_port="True">
      <docstring>Number of compounding periods</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pv" name="pv" port_type="basic:List" show_port="True">
      <docstring>Present value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fv" name="fvScalar" port_type="basic:Integer">
      <docstring>Future value (default = 0)</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="fv" name="fvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0))</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Payment against loan plus interest.  If all input is scalar, returns a
scalar float.  If any input is array_like, returns payment for each
input element. If multiple inputs are array_like, they all must have
the same shape.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.ppmt" module_name="ppmt" namespace="'fft'">
    <docstring>Compute the payment against loan principal.

Parameters
----------
rate : array_like
    Rate of interest (per period)
per : array_like, int
    Amount paid against the loan changes.  The `per` is the period of
    interest.
nper : array_like
    Number of compounding periods
pv : array_like
    Present value
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}
    When payments are due ('begin' (1) or 'end' (0))

See Also
--------
pmt, pv, ipmt</docstring>
    <inputPortSpec arg="rate" name="rate" port_type="basic:List" show_port="True">
      <docstring>Rate of interest (per period)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="per" depth="1" name="per" port_type="basic:Integer" show_port="True">
      <docstring>Amount paid against the loan changes.  The `per` is the period of
interest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nper" name="nper" port_type="basic:List" show_port="True">
      <docstring>Number of compounding periods</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pv" name="pv" port_type="basic:List" show_port="True">
      <docstring>Present value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fv" name="fvScalar" port_type="basic:Float">
      <docstring>Future value</docstring>
      <defaults>[0.0]</defaults>
      <alternateSpec arg="fv" name="fvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0))</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.ipmt" module_name="ipmt" namespace="'fft'">
    <docstring>Compute the interest portion of a payment.

Parameters
----------
rate : scalar or array_like of shape(M, )
    Rate of interest as decimal (not per cent) per period
per : scalar or array_like of shape(M, )
    Interest paid against the loan changes during the life or the loan.
    The `per` is the payment period to calculate the interest amount.
nper : scalar or array_like of shape(M, )
    Number of compounding periods
pv : scalar or array_like of shape(M, )
    Present value
fv : scalar or array_like of shape(M, ), optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0)).
    Defaults to {'end', 0}.

Returns
-------
out : ndarray
    Interest portion of payment.  If all input is scalar, returns a scalar
    float.  If any input is array_like, returns interest payment for each
    input element. If multiple inputs are array_like, they all must have
    the same shape.

See Also
--------
ppmt, pmt, pv

Notes
-----
The total payment is made up of payment against principal plus interest.

``pmt = ppmt + ipmt``

Examples
--------
What is the amortization schedule for a 1 year loan of $2500 at
8.24% interest per year compounded monthly?

&gt;&gt;&gt; principal = 2500.00

The 'per' variable represents the periods of the loan.  Remember that
financial equations start the period count at 1!

&gt;&gt;&gt; per = np.arange(1*12) + 1
&gt;&gt;&gt; ipmt = np.ipmt(0.0824/12, per, 1*12, principal)
&gt;&gt;&gt; ppmt = np.ppmt(0.0824/12, per, 1*12, principal)

Each element of the sum of the 'ipmt' and 'ppmt' arrays should equal
'pmt'.

&gt;&gt;&gt; pmt = np.pmt(0.0824/12, 1*12, principal)
&gt;&gt;&gt; np.allclose(ipmt + ppmt, pmt)
True

&gt;&gt;&gt; fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'
&gt;&gt;&gt; for payment in per:
...     index = payment - 1
...     principal = principal + ppmt[index]
...     print fmt.format(payment, ppmt[index], ipmt[index], principal)
 1  -200.58   -17.17  2299.42
 2  -201.96   -15.79  2097.46
 3  -203.35   -14.40  1894.11
 4  -204.74   -13.01  1689.37
 5  -206.15   -11.60  1483.22
 6  -207.56   -10.18  1275.66
 7  -208.99    -8.76  1066.67
 8  -210.42    -7.32   856.25
 9  -211.87    -5.88   644.38
10  -213.32    -4.42   431.05
11  -214.79    -2.96   216.26
12  -216.26    -1.49    -0.00

&gt;&gt;&gt; interestpd = np.sum(ipmt)
&gt;&gt;&gt; np.round(interestpd, 2)
-112.98</docstring>
    <inputPortSpec arg="rate" name="rateScalar" port_type="basic:Float" show_port="True">
      <docstring>Rate of interest as decimal (not per cent) per period</docstring>
      <alternateSpec arg="rate" name="rateSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="per" name="perScalar" port_type="basic:Float" show_port="True">
      <docstring>Interest paid against the loan changes during the life or the loan.
The `per` is the payment period to calculate the interest amount.</docstring>
      <alternateSpec arg="per" name="perSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nper" name="nperScalar" port_type="basic:Float" show_port="True">
      <docstring>Number of compounding periods</docstring>
      <alternateSpec arg="nper" name="nperSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="pv" name="pvScalar" port_type="basic:Float" show_port="True">
      <docstring>Present value</docstring>
      <alternateSpec arg="pv" name="pvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="fv" name="fvScalar" port_type="basic:Float">
      <docstring>Future value</docstring>
      <defaults>[0.0]</defaults>
      <alternateSpec arg="fv" name="fvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0)).
Defaults to {'end', 0}.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interest portion of payment.  If all input is scalar, returns a scalar
float.  If any input is array_like, returns interest payment for each
input element. If multiple inputs are array_like, they all must have
the same shape.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.irr" module_name="irr" namespace="'fft'">
    <docstring>Return the Internal Rate of Return (IRR).

This is the "average" periodically compounded rate of return
that gives a net present value of 0.0; for a more complete explanation,
see Notes below.

Parameters
----------
values : array_like, shape(N,)
    Input cash flows per time period.  By convention, net "deposits"
    are negative and net "withdrawals" are positive.  Thus, for
    example, at least the first element of `values`, which represents
    the initial investment, will typically be negative.

Returns
-------
out : float
    Internal Rate of Return for periodic input values.

Notes
-----
The IRR is perhaps best understood through an example (illustrated
using np.irr in the Examples section below).  Suppose one invests 100
units and then makes the following withdrawals at regular (fixed)
intervals: 39, 59, 55, 20.  Assuming the ending value is 0, one's 100
unit investment yields 173 units; however, due to the combination of
compounding and the periodic withdrawals, the "average" rate of return
is neither simply 0.73/4 nor (1.73)^0.25-1.  Rather, it is the solution
(for :math:`r`) of the equation:

.. math:: -100 + \frac{39}{1+r} + \frac{59}{(1+r)^2}
 + \frac{55}{(1+r)^3} + \frac{20}{(1+r)^4} = 0

In general, for `values` :math:`= [v_0, v_1, ... v_M]`,
irr is the solution of the equation: [G]_

.. math:: \sum_{t=0}^M{\frac{v_t}{(1+irr)^{t}}} = 0

References
----------
.. [G] L. J. Gitman, "Principles of Managerial Finance, Brief," 3rd ed.,
   Addison-Wesley, 2003, pg. 348.

Examples
--------
&gt;&gt;&gt; round(irr([-100, 39, 59, 55, 20]), 5)
0.28095
&gt;&gt;&gt; round(irr([-100, 0, 0, 74]), 5)
-0.0955
&gt;&gt;&gt; round(irr([-100, 100, 0, -7]), 5)
-0.0833
&gt;&gt;&gt; round(irr([-100, 100, 0, 7]), 5)
0.06206
&gt;&gt;&gt; round(irr([-5, 10.5, 1, -8, 1]), 5)
0.0886

(Compare with the Example given for numpy.lib.financial.npv)</docstring>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>Input cash flows per time period.  By convention, net "deposits"
are negative and net "withdrawals" are positive.  Thus, for
example, at least the first element of `values`, which represents
the initial investment, will typically be negative.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Internal Rate of Return for periodic input values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.mirr" module_name="mirr" namespace="'fft'">
    <docstring>Modified internal rate of return.

Parameters
----------
values : array_like
    Cash flows (must contain at least one positive and one negative
    value) or nan is returned.  The first value is considered a sunk
    cost at time zero.
finance_rate : scalar
    Interest rate paid on the cash flows
reinvest_rate : scalar
    Interest rate received on the cash flows upon reinvestment

Returns
-------
out : float
    Modified internal rate of return</docstring>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>Cash flows (must contain at least one positive and one negative
value) or nan is returned.  The first value is considered a sunk
cost at time zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="finance_rate" name="finance_rate" port_type="basic:Float" show_port="True">
      <docstring>Interest rate paid on the cash flows</docstring>
    </inputPortSpec>
    <inputPortSpec arg="reinvest_rate" name="reinvest_rate" port_type="basic:Float" show_port="True">
      <docstring>Interest rate received on the cash flows upon reinvestment</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Modified internal rate of return</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.nper" module_name="nper" namespace="'fft'">
    <docstring>Compute the number of periodic payments.

Parameters
----------
rate : array_like
    Rate of interest (per period)
pmt : array_like
    Payment
pv : array_like
    Present value
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))

Notes
-----
The number of periods ``nper`` is computed by solving the equation::

 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0

but if ``rate = 0`` then::

 fv + pv + pmt*nper = 0

Examples
--------
If you only had $150/month to pay towards the loan, how long would it take
to pay-off a loan of $8,000 at 7% annual interest?

&gt;&gt;&gt; print round(np.nper(0.07/12, -150, 8000), 5)
64.07335

So, over 64 months would be required to pay off the loan.

The same analysis could be done with several different interest rates
and/or payments and/or total amounts to produce an entire table.

&gt;&gt;&gt; np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,
...                    -150   : -99     : 50    ,
...                    8000   : 9001    : 1000]))
array([[[  64.07334877,   74.06368256],
        [ 108.07548412,  127.99022654]],
       [[  66.12443902,   76.87897353],
        [ 114.70165583,  137.90124779]]])</docstring>
    <inputPortSpec arg="rate" name="rate" port_type="basic:List" show_port="True">
      <docstring>Rate of interest (per period)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pmt" name="pmt" port_type="basic:List" show_port="True">
      <docstring>Payment</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pv" name="pv" port_type="basic:List" show_port="True">
      <docstring>Present value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fv" name="fvScalar" port_type="basic:Integer">
      <docstring>Future value</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="fv" name="fvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0))</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.lib.financial.rate" module_name="rate" namespace="'fft'">
    <docstring>Compute the rate of interest per period.

Parameters
----------
nper : array_like
    Number of compounding periods
pmt : array_like
    Payment
pv : array_like
    Present value
fv : array_like
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))
guess : float, optional
    Starting guess for solving the rate of interest
tol : float, optional
    Required tolerance for the solution
maxiter : int, optional
    Maximum iterations in finding the solution

Notes
-----
The rate of interest is computed by iteratively solving the
(non-linear) equation::

 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0

for ``rate``.

References
----------
Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document
Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated
Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12.
Organization for the Advancement of Structured Information Standards
(OASIS). Billerica, MA, USA. [ODT Document]. Available:
http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
OpenDocument-formula-20090508.odt</docstring>
    <inputPortSpec arg="nper" name="nper" port_type="basic:List" show_port="True">
      <docstring>Number of compounding periods</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pmt" name="pmt" port_type="basic:List" show_port="True">
      <docstring>Payment</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pv" name="pv" port_type="basic:List" show_port="True">
      <docstring>Present value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fv" name="fv" port_type="basic:List" show_port="True">
      <docstring>Future value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="when" name="when">
      <docstring>When payments are due ('begin' (1) or 'end' (0))</docstring>
      <entry_types>['enum']</entry_types>
      <values>[["{'begin'"]]</values>
      <defaults>['end']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="guess" name="guess" port_type="basic:Float">
      <docstring>Starting guess for solving the rate of interest</docstring>
      <defaults>[0.1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Required tolerance for the solution</docstring>
      <defaults>[1e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum iterations in finding the solution</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.all" module_name="all" namespace="'logic'">
    <docstring>Test whether all array elements along a given axis evaluate to True.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical AND reduction is performed.
    The default (`axis` = `None`) is to perform a logical AND over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.
    It must have the same shape as the expected output and its
    type is preserved (e.g., if ``dtype(out)`` is float, the result
    will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section
    "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
all : ndarray, bool
    A new boolean or array is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.all : equivalent method

any : Test whether any element along a given axis evaluates to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to `True` because these are not equal to zero.

Examples
--------
&gt;&gt;&gt; np.all([[True,False],[True,True]])
False

&gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)
array([ True, False], dtype=bool)

&gt;&gt;&gt; np.all([-1, 4, 5])
True

&gt;&gt;&gt; np.all([1.0, np.nan])
True

&gt;&gt;&gt; o=np.array([False])
&gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)
&gt;&gt;&gt; id(z), id(o), z                             # doctest: +SKIP
(28293632, 28293632, array([ True], dtype=bool))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which a logical AND reduction is performed.
The default (`axis` = `None`) is to perform a logical AND over all
the dimensions of the input array. `axis` may be negative, in
which case it counts from the last to the first axis.

.. versionadded:: 1.7.0

If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if ``dtype(out)`` is float, the result
will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section
"Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="all" depth="1" name="all" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>A new boolean or array is returned unless `out` is specified,
in which case a reference to `out` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.any" module_name="any" namespace="'logic'">
    <docstring>Test whether any array element along a given axis evaluates to True.

Returns single boolean unless `axis` is not ``None``

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical OR reduction is performed.
    The default (`axis` = `None`) is to perform a logical OR over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output and its type is preserved
    (e.g., if it is of type float, then it will remain so, returning
    1.0 for True and 0.0 for False, regardless of the type of `a`).
    See `doc.ufuncs` (Section "Output arguments") for details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
any : bool or ndarray
    A new boolean or `ndarray` is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.any : equivalent method

all : Test whether all elements along a given axis evaluate to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity evaluate
to `True` because these are not equal to zero.

Examples
--------
&gt;&gt;&gt; np.any([[True, False], [True, True]])
True

&gt;&gt;&gt; np.any([[True, False], [False, False]], axis=0)
array([ True, False], dtype=bool)

&gt;&gt;&gt; np.any([-1, 0, 5])
True

&gt;&gt;&gt; np.any(np.nan)
True

&gt;&gt;&gt; o=np.array([False])
&gt;&gt;&gt; z=np.any([-1, 4, 5], out=o)
&gt;&gt;&gt; z, o
(array([ True], dtype=bool), array([ True], dtype=bool))
&gt;&gt;&gt; # Check now that z is a reference to o
&gt;&gt;&gt; z is o
True
&gt;&gt;&gt; id(z), id(o) # identity of z and o              # doctest: +SKIP
(191614240, 191614240)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which a logical OR reduction is performed.
The default (`axis` = `None`) is to perform a logical OR over all
the dimensions of the input array. `axis` may be negative, in
which case it counts from the last to the first axis.

.. versionadded:: 1.7.0

If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  It must have
the same shape as the expected output and its type is preserved
(e.g., if it is of type float, then it will remain so, returning
1.0 for True and 0.0 for False, regardless of the type of `a`).
See `doc.ufuncs` (Section "Output arguments") for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="any" name="any" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new boolean or `ndarray` is returned unless `out` is specified,
in which case a reference to `out` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isfinite" module_name="isfinite" namespace="'logic'">
    <docstring>isfinite(x[, out])

Test element-wise for finiteness (not infinity or not Not a Number).

The result is returned as a boolean array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See `doc.ufuncs`.

Returns
-------
y : ndarray, bool
    For scalar input, the result is a new boolean with value True
    if the input is finite; otherwise the value is False (input is
    either positive infinity, negative infinity or Not a Number).

    For array input, the result is a boolean array with the same
    dimensions as the input and the values are True if the
    corresponding element of the input is finite; otherwise the values
    are False (element is either positive infinity, negative infinity
    or Not a Number).

See Also
--------
isinf, isneginf, isposinf, isnan

Notes
-----
Not a Number, positive infinity and negative infinity are considered
to be non-finite.

Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when `x` is a scalar input, or if
first and second arguments have different shapes.

Examples
--------
&gt;&gt;&gt; np.isfinite(1)
True
&gt;&gt;&gt; np.isfinite(0)
True
&gt;&gt;&gt; np.isfinite(np.nan)
False
&gt;&gt;&gt; np.isfinite(np.inf)
False
&gt;&gt;&gt; np.isfinite(np.NINF)
False
&gt;&gt;&gt; np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False], dtype=bool)

&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])
&gt;&gt;&gt; y = np.array([2, 2, 2])
&gt;&gt;&gt; np.isfinite(x, y)
array([0, 1, 0])
&gt;&gt;&gt; y
array([0, 1, 0])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See `doc.ufuncs`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" depth="1" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>For scalar input, the result is a new boolean with value True
if the input is finite; otherwise the value is False (input is
either positive infinity, negative infinity or Not a Number).

For array input, the result is a boolean array with the same
dimensions as the input and the values are True if the
corresponding element of the input is finite; otherwise the values
are False (element is either positive infinity, negative infinity
or Not a Number).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isinf" module_name="isinf" namespace="'logic'">
    <docstring>isinf(x[, out])

Test element-wise for positive or negative infinity.

Returns a boolean array of the same shape as `x`, True where ``x ==
+/-inf``, otherwise False.

Parameters
----------
x : array_like
    Input values
out : array_like, optional
    An array with the same shape as `x` to store the result.

Returns
-------
y : bool (scalar) or boolean ndarray
    For scalar input, the result is a new boolean with value True if
    the input is positive or negative infinity; otherwise the value is
    False.

    For array input, the result is a boolean array with the same shape
    as the input and the values are True where the corresponding
    element of the input is positive or negative infinity; elsewhere
    the values are False.  If a second argument was supplied the result
    is stored there.  If the type of that array is a numeric type the
    result is represented as zeros and ones, if the type is boolean
    then as False and True, respectively.  The return value `y` is then
    a reference to that array.

See Also
--------
isneginf, isposinf, isnan, isfinite

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is supplied when the first
argument is a scalar, or if the first and second arguments have
different shapes.

Examples
--------
&gt;&gt;&gt; np.isinf(np.inf)
True
&gt;&gt;&gt; np.isinf(np.nan)
False
&gt;&gt;&gt; np.isinf(np.NINF)
True
&gt;&gt;&gt; np.isinf([np.inf, -np.inf, 1.0, np.nan])
array([ True,  True, False, False], dtype=bool)

&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])
&gt;&gt;&gt; y = np.array([2, 2, 2])
&gt;&gt;&gt; np.isinf(x, y)
array([1, 0, 1])
&gt;&gt;&gt; y
array([1, 0, 1])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>An array with the same shape as `x` to store the result.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" depth="1" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>For scalar input, the result is a new boolean with value True if
the input is positive or negative infinity; otherwise the value is
False.

For array input, the result is a boolean array with the same shape
as the input and the values are True where the corresponding
element of the input is positive or negative infinity; elsewhere
the values are False.  If a second argument was supplied the result
is stored there.  If the type of that array is a numeric type the
result is represented as zeros and ones, if the type is boolean
then as False and True, respectively.  The return value `y` is then
a reference to that array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isnan" module_name="isnan" namespace="'logic'">
    <docstring>isnan(x[, out])

Test element-wise for NaN and return result as a boolean array.

Parameters
----------
x : array_like
    Input array.

Returns
-------
y : ndarray or bool
    For scalar input, the result is a new boolean with value True if
    the input is NaN; otherwise the value is False.

    For array input, the result is a boolean array of the same
    dimensions as the input and the values are True if the
    corresponding element of the input is NaN; otherwise the values are
    False.

See Also
--------
isinf, isneginf, isposinf, isfinite

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.

Examples
--------
&gt;&gt;&gt; np.isnan(np.nan)
True
&gt;&gt;&gt; np.isnan(np.inf)
False
&gt;&gt;&gt; np.isnan([np.log(-1.),1.,np.log(0)])
array([ True, False, False], dtype=bool)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>For scalar input, the result is a new boolean with value True if
the input is NaN; otherwise the value is False.

For array input, the result is a boolean array of the same
dimensions as the input and the values are True if the
corresponding element of the input is NaN; otherwise the values are
False.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isneginf" module_name="isneginf" namespace="'logic'">
    <docstring>Test element-wise for negative infinity, return result as bool array.

Parameters
----------
x : array_like
    The input array.
y : array_like, optional
    A boolean array with the same shape and type as `x` to store the
    result.

Returns
-------
y : ndarray
    A boolean array with the same dimensions as the input.
    If second argument is not supplied then a numpy boolean array is
    returned with values True where the corresponding element of the
    input is negative infinity and values False where the element of
    the input is not negative infinity.

    If a second argument is supplied the result is stored there. If the
    type of that array is a numeric type the result is represented as
    zeros and ones, if the type is boolean then as False and True. The
    return value `y` is then a reference to that array.

See Also
--------
isinf, isposinf, isnan, isfinite

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is also supplied when x is a scalar
input, or if first and second arguments have different shapes.

Examples
--------
&gt;&gt;&gt; np.isneginf(np.NINF)
array(True, dtype=bool)
&gt;&gt;&gt; np.isneginf(np.inf)
array(False, dtype=bool)
&gt;&gt;&gt; np.isneginf(np.PINF)
array(False, dtype=bool)
&gt;&gt;&gt; np.isneginf([-np.inf, 0., np.inf])
array([ True, False, False], dtype=bool)

&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])
&gt;&gt;&gt; y = np.array([2, 2, 2])
&gt;&gt;&gt; np.isneginf(x, y)
array([1, 0, 0])
&gt;&gt;&gt; y
array([1, 0, 0])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>A boolean array with the same shape and type as `x` to store the
result.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A boolean array with the same dimensions as the input.
If second argument is not supplied then a numpy boolean array is
returned with values True where the corresponding element of the
input is negative infinity and values False where the element of
the input is not negative infinity.

If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as
zeros and ones, if the type is boolean then as False and True. The
return value `y` is then a reference to that array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isposinf" module_name="isposinf" namespace="'logic'">
    <docstring>Test element-wise for positive infinity, return result as bool array.

Parameters
----------
x : array_like
    The input array.
y : array_like, optional
    A boolean array with the same shape as `x` to store the result.

Returns
-------
y : ndarray
    A boolean array with the same dimensions as the input.
    If second argument is not supplied then a boolean array is returned
    with values True where the corresponding element of the input is
    positive infinity and values False where the element of the input is
    not positive infinity.

    If a second argument is supplied the result is stored there. If the
    type of that array is a numeric type the result is represented as zeros
    and ones, if the type is boolean then as False and True.
    The return value `y` is then a reference to that array.

See Also
--------
isinf, isneginf, isfinite, isnan

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is also supplied when `x` is a
scalar input, or if first and second arguments have different shapes.

Examples
--------
&gt;&gt;&gt; np.isposinf(np.PINF)
array(True, dtype=bool)
&gt;&gt;&gt; np.isposinf(np.inf)
array(True, dtype=bool)
&gt;&gt;&gt; np.isposinf(np.NINF)
array(False, dtype=bool)
&gt;&gt;&gt; np.isposinf([-np.inf, 0., np.inf])
array([False, False,  True], dtype=bool)

&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])
&gt;&gt;&gt; y = np.array([2, 2, 2])
&gt;&gt;&gt; np.isposinf(x, y)
array([0, 0, 1])
&gt;&gt;&gt; y
array([0, 0, 1])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>A boolean array with the same shape as `x` to store the result.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A boolean array with the same dimensions as the input.
If second argument is not supplied then a boolean array is returned
with values True where the corresponding element of the input is
positive infinity and values False where the element of the input is
not positive infinity.

If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as zeros
and ones, if the type is boolean then as False and True.
The return value `y` is then a reference to that array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.iscomplex" module_name="iscomplex" namespace="'logic'">
    <docstring>Returns a bool array, where True if input element is complex.

What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray of bools
    Output array.

See Also
--------
isreal
iscomplexobj : Return True if x is a complex type or an array of complex
               numbers.

Examples
--------
&gt;&gt;&gt; np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([ True, False, False, False, False,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Output array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.iscomplexobj" module_name="iscomplexobj" namespace="'logic'">
    <docstring>Check for a complex type or an array of complex numbers.

The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, `iscomplexobj` evaluates to True.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
iscomplexobj : bool
    The return value, True if `x` is of a complex type or has at least
    one complex element.

See Also
--------
isrealobj, iscomplex

Examples
--------
&gt;&gt;&gt; np.iscomplexobj(1)
False
&gt;&gt;&gt; np.iscomplexobj(1+0j)
True
&gt;&gt;&gt; np.iscomplexobj([3, 1+0j, True])
True</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True">
      <docstring>The input can be of any type and shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="iscomplexobj" name="iscomplexobj" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>The return value, True if `x` is of a complex type or has at least
one complex element.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isfortran" module_name="isfortran" namespace="'logic'">
    <docstring>Returns True if array is arranged in Fortran-order in memory
and not C-order.

Parameters
----------
a : ndarray
    Input array.


Examples
--------

np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(a)
False

&gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')
&gt;&gt;&gt; b
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(b)
True


The transpose of a C-ordered array is a FORTRAN-ordered array.

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(a)
False
&gt;&gt;&gt; b = a.T
&gt;&gt;&gt; b
array([[1, 4],
       [2, 5],
       [3, 6]])
&gt;&gt;&gt; np.isfortran(b)
True

C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.

&gt;&gt;&gt; np.isfortran(np.array([1, 2], order='FORTRAN'))
False</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.isreal" module_name="isreal" namespace="'logic'">
    <docstring>Returns a bool array, where True if input element is real.

If element has complex type with zero complex part, the return value
for that element is True.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray, bool
    Boolean array of same shape as `x`.

See Also
--------
iscomplex
isrealobj : Return True if x is not a complex type.

Examples
--------
&gt;&gt;&gt; np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([False,  True,  True,  True,  True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Boolean array of same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isrealobj" module_name="isrealobj" namespace="'logic'">
    <docstring>Return True if x is a not complex type or an array of complex numbers.

The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, `isrealobj` evaluates to False
if the data type is complex.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
y : bool
    The return value, False if `x` is of a complex type.

See Also
--------
iscomplexobj, isreal

Examples
--------
&gt;&gt;&gt; np.isrealobj(1)
True
&gt;&gt;&gt; np.isrealobj(1+0j)
False
&gt;&gt;&gt; np.isrealobj([3, 1+0j, True])
False</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True">
      <docstring>The input can be of any type and shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>The return value, False if `x` is of a complex type.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isscalar" module_name="isscalar" namespace="'logic'">
    <docstring>Returns True if the type of `num` is a scalar type.

Parameters
----------
num : any
    Input argument, can be of any type and shape.

Returns
-------
val : bool
    True if `num` is a scalar type, False if it is not.

Examples
--------
&gt;&gt;&gt; np.isscalar(3.1)
True
&gt;&gt;&gt; np.isscalar([3.1])
False
&gt;&gt;&gt; np.isscalar(False)
True</docstring>
    <inputPortSpec arg="num" name="num" port_type="basic:Variant" show_port="True">
      <docstring>Input argument, can be of any type and shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="val" name="val" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if `num` is a scalar type, False if it is not.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.logical_and" module_name="logical_and" namespace="'logic'">
    <docstring>logical_and(x1, x2[, out])

Compute the truth value of x1 AND x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. `x1` and `x2` must be of the same shape.


Returns
-------
y : ndarray or bool
    Boolean result with the same shape as `x1` and `x2` of the logical
    AND operation on corresponding elements of `x1` and `x2`.

See Also
--------
logical_or, logical_not, logical_xor
bitwise_and

Examples
--------
&gt;&gt;&gt; np.logical_and(True, False)
False
&gt;&gt;&gt; np.logical_and([True, False], [False, False])
array([False, False], dtype=bool)

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.logical_and(x&gt;1, x&lt;4)
array([False, False,  True,  True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays. `x1` and `x2` must be of the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays. `x1` and `x2` must be of the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Boolean result with the same shape as `x1` and `x2` of the logical
AND operation on corresponding elements of `x1` and `x2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.logical_or" module_name="logical_or" namespace="'logic'">
    <docstring>logical_or(x1, x2[, out])

Compute the truth value of x1 OR x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Logical OR is applied to the elements of `x1` and `x2`.
    They have to be of the same shape.

Returns
-------
y : ndarray or bool
    Boolean result with the same shape as `x1` and `x2` of the logical
    OR operation on elements of `x1` and `x2`.

See Also
--------
logical_and, logical_not, logical_xor
bitwise_or

Examples
--------
&gt;&gt;&gt; np.logical_or(True, False)
True
&gt;&gt;&gt; np.logical_or([True, False], [False, False])
array([ True, False], dtype=bool)

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.logical_or(x &lt; 1, x &gt; 3)
array([ True, False, False, False,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Logical OR is applied to the elements of `x1` and `x2`.
They have to be of the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Logical OR is applied to the elements of `x1` and `x2`.
They have to be of the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Boolean result with the same shape as `x1` and `x2` of the logical
OR operation on elements of `x1` and `x2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.logical_not" module_name="logical_not" namespace="'logic'">
    <docstring>logical_not(x[, out])

Compute the truth value of NOT x element-wise.

Parameters
----------
x : array_like
    Logical NOT is applied to the elements of `x`.

Returns
-------
y : bool or ndarray of bool
    Boolean result with the same shape as `x` of the NOT operation
    on elements of `x`.

See Also
--------
logical_and, logical_or, logical_xor

Examples
--------
&gt;&gt;&gt; np.logical_not(3)
False
&gt;&gt;&gt; np.logical_not([True, False, 0, 1])
array([False,  True,  True, False], dtype=bool)

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.logical_not(x&lt;3)
array([False, False, False,  True,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Logical NOT is applied to the elements of `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" depth="1" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Boolean result with the same shape as `x` of the NOT operation
on elements of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.logical_xor" module_name="logical_xor" namespace="'logic'">
    <docstring>logical_xor(x1, x2[, out])

Compute the truth value of x1 XOR x2, element-wise.

Parameters
----------
x1, x2 : array_like
    Logical XOR is applied to the elements of `x1` and `x2`.  They must
    be broadcastable to the same shape.

Returns
-------
y : bool or ndarray of bool
    Boolean result of the logical XOR operation applied to the elements
    of `x1` and `x2`; the shape is determined by whether or not
    broadcasting of one or both arrays was required.

See Also
--------
logical_and, logical_or, logical_not, bitwise_xor

Examples
--------
&gt;&gt;&gt; np.logical_xor(True, False)
True
&gt;&gt;&gt; np.logical_xor([True, True, False, False], [True, False, True, False])
array([False,  True,  True, False], dtype=bool)

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.logical_xor(x &lt; 1, x &gt; 3)
array([ True, False, False, False,  True], dtype=bool)

Simple example showing support of broadcasting

&gt;&gt;&gt; np.logical_xor(0, np.eye(2))
array([[ True, False],
       [False,  True]], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Logical XOR is applied to the elements of `x1` and `x2`.  They must
be broadcastable to the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Logical XOR is applied to the elements of `x1` and `x2`.  They must
be broadcastable to the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" depth="1" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Boolean result of the logical XOR operation applied to the elements
of `x1` and `x2`; the shape is determined by whether or not
broadcasting of one or both arrays was required.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.allclose" module_name="allclose" namespace="'logic'">
    <docstring>Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

If either array contains one or more NaNs, False is returned.
Infs are treated as equal if they are in the same place and of the same
sign in both arrays.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

    .. versionadded:: 1.10.0

Returns
-------
allclose : bool
    Returns True if the two arrays are equal within the given
    tolerance; False otherwise.

See Also
--------
isclose, all, any

Notes
-----
If the following equation is element-wise True, then allclose returns
True.

 absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))

The above equation is not symmetric in `a` and `b`, so that
`allclose(a, b)` might be different from `allclose(b, a)` in
some rare cases.

Examples
--------
&gt;&gt;&gt; np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False
&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True
&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False
&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan])
False
&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The relative tolerance parameter (see Notes).</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>The absolute tolerance parameter (see Notes).</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="equal_nan" name="equal_nan" port_type="basic:Boolean">
      <docstring>Whether to compare NaN's as equal.  If True, NaN's in `a` will be
considered equal to NaN's in `b` in the output array.

.. versionadded:: 1.10.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="allclose" name="allclose" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Returns True if the two arrays are equal within the given
tolerance; False otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.isclose" module_name="isclose" namespace="'logic'">
    <docstring>Returns a boolean array where two arrays are element-wise equal within a
tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

Returns
-------
y : array_like
    Returns a boolean array of where `a` and `b` are equal within the
    given tolerance. If both `a` and `b` are scalars, returns a single
    boolean value.

See Also
--------
allclose

Notes
-----
.. versionadded:: 1.7.0

For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.

 absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))

The above equation is not symmetric in `a` and `b`, so that
`isclose(a, b)` might be different from `isclose(b, a)` in
some rare cases.

Examples
--------
&gt;&gt;&gt; np.isclose([1e10,1e-7], [1.00001e10,1e-8])
array([True, False])
&gt;&gt;&gt; np.isclose([1e10,1e-8], [1.00001e10,1e-9])
array([True, True])
&gt;&gt;&gt; np.isclose([1e10,1e-8], [1.0001e10,1e-9])
array([False, True])
&gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan])
array([True, False])
&gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
array([True, True])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The relative tolerance parameter (see Notes).</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>The absolute tolerance parameter (see Notes).</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="equal_nan" name="equal_nan" port_type="basic:Boolean">
      <docstring>Whether to compare NaN's as equal.  If True, NaN's in `a` will be
considered equal to NaN's in `b` in the output array.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns a boolean array of where `a` and `b` are equal within the
given tolerance. If both `a` and `b` are scalars, returns a single
boolean value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.array_equal" module_name="array_equal" namespace="'logic'">
    <docstring>True if two arrays have the same shape and elements, False otherwise.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
b : bool
    Returns True if the arrays are equal.

See Also
--------
allclose: Returns True if two arrays are element-wise equal within a
          tolerance.
array_equiv: Returns True if input arrays are shape consistent and all
             elements equal.

Examples
--------
&gt;&gt;&gt; np.array_equal([1, 2], [1, 2])
True
&gt;&gt;&gt; np.array_equal(np.array([1, 2]), np.array([1, 2]))
True
&gt;&gt;&gt; np.array_equal([1, 2], [1, 2, 3])
False
&gt;&gt;&gt; np.array_equal([1, 2], [1, 4])
False</docstring>
    <inputPortSpec arg="a1" name="a1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a2" name="a2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Returns True if the arrays are equal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.array_equiv" module_name="array_equiv" namespace="'logic'">
    <docstring>Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
out : bool
    True if equivalent, False otherwise.

Examples
--------
&gt;&gt;&gt; np.array_equiv([1, 2], [1, 2])
True
&gt;&gt;&gt; np.array_equiv([1, 2], [1, 3])
False

Showing the shape equivalence:

&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 2]])
True
&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
False

&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 3]])
False</docstring>
    <inputPortSpec arg="a1" name="a1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a2" name="a2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if equivalent, False otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.greater" module_name="greater" namespace="'logic'">
    <docstring>greater(x1, x2[, out])

Return the truth value of (x1 &gt; x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be
    broadcastable to a common shape (which may be the shape of one or
    the other).

Returns
-------
out : bool or ndarray of bool
    Array of bools, or a single bool if `x1` and `x2` are scalars.


See Also
--------
greater_equal, less, less_equal, equal, not_equal

Examples
--------
&gt;&gt;&gt; np.greater([4,2],[2,2])
array([ True, False], dtype=bool)

If the inputs are ndarrays, then np.greater is equivalent to '&gt;'.

&gt;&gt;&gt; a = np.array([4,2])
&gt;&gt;&gt; b = np.array([2,2])
&gt;&gt;&gt; a &gt; b
array([ True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Array of bools, or a single bool if `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.greater_equal" module_name="greater_equal" namespace="'logic'">
    <docstring>greater_equal(x1, x2[, out])

Return the truth value of (x1 &gt;= x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be
    broadcastable to a common shape (which may be the shape of one or
    the other).

Returns
-------
out : bool or ndarray of bool
    Array of bools, or a single bool if `x1` and `x2` are scalars.

See Also
--------
greater, less, less_equal, equal, not_equal

Examples
--------
&gt;&gt;&gt; np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Array of bools, or a single bool if `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.less" module_name="less" namespace="'logic'">
    <docstring>less(x1, x2[, out])

Return the truth value of (x1 &lt; x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be
    broadcastable to a common shape (which may be the shape of one or
    the other).

Returns
-------
out : bool or ndarray of bool
    Array of bools, or a single bool if `x1` and `x2` are scalars.

See Also
--------
greater, less_equal, greater_equal, equal, not_equal

Examples
--------
&gt;&gt;&gt; np.less([1, 2], [2, 2])
array([ True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Array of bools, or a single bool if `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.less_equal" module_name="less_equal" namespace="'logic'">
    <docstring>less_equal(x1, x2[, out])

Return the truth value of (x1 =&lt; x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be
    broadcastable to a common shape (which may be the shape of one or
    the other).

Returns
-------
out : bool or ndarray of bool
    Array of bools, or a single bool if `x1` and `x2` are scalars.

See Also
--------
greater, less, greater_equal, equal, not_equal

Examples
--------
&gt;&gt;&gt; np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Array of bools, or a single bool if `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.equal" module_name="equal" namespace="'logic'">
    <docstring>equal(x1, x2[, out])

Return (x1 == x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays of the same shape.

Returns
-------
out : ndarray or bool
    Output array of bools, or a single bool if x1 and x2 are scalars.

See Also
--------
not_equal, greater_equal, less_equal, greater, less

Examples
--------
&gt;&gt;&gt; np.equal([0, 1, 3], np.arange(3))
array([ True,  True, False], dtype=bool)

What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:

&gt;&gt;&gt; np.equal(1, np.ones(1))
array([ True], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays of the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays of the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array of bools, or a single bool if x1 and x2 are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.not_equal" module_name="not_equal" namespace="'logic'">
    <docstring>not_equal(x1, x2[, out])

Return (x1 != x2) element-wise.

Parameters
----------
x1, x2 : array_like
  Input arrays.
out : ndarray, optional
  A placeholder the same shape as `x1` to store the result.
  See `doc.ufuncs` (Section "Output arguments") for more details.

Returns
-------
not_equal : ndarray bool, scalar bool
  For each element in `x1, x2`, return True if `x1` is not equal
  to `x2` and False otherwise.


See Also
--------
equal, greater, greater_equal, less, less_equal

Examples
--------
&gt;&gt;&gt; np.not_equal([1.,2.], [1., 3.])
array([False,  True], dtype=bool)
&gt;&gt;&gt; np.not_equal([1, 2], [[1, 3],[1, 4]])
array([[False,  True],
       [False,  True]], dtype=bool)</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>A placeholder the same shape as `x1` to store the result.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="not_equal" depth="1" name="not_equal" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>For each element in `x1, x2`, return True if `x1` is not equal
to `x2` and False otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sin" module_name="sin" namespace="'math'">
    <docstring>sin(x[, out])

Trigonometric sine, element-wise.

Parameters
----------
x : array_like
    Angle, in radians (:math:`2 \pi` rad equals 360 degrees).

Returns
-------
y : array_like
    The sine of each element of x.

See Also
--------
arcsin, sinh, cos

Notes
-----
The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:`+x` axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:`y` coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:`x=3\pi / 2` to +1 for :math:`\pi / 2.`  The
function has zeroes where the angle is a multiple of :math:`\pi`.
Sines of angles between :math:`\pi` and :math:`2\pi` are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.

Examples
--------
Print sine of one angle:

&gt;&gt;&gt; np.sin(np.pi/2.)
1.0

Print sines of an array of angles given in degrees:

&gt;&gt;&gt; np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])

Plot the sine function:

&gt;&gt;&gt; import matplotlib.pylab as plt
&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 201)
&gt;&gt;&gt; plt.plot(x, np.sin(x))
&gt;&gt;&gt; plt.xlabel('Angle [rad]')
&gt;&gt;&gt; plt.ylabel('sin(x)')
&gt;&gt;&gt; plt.axis('tight')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Angle, in radians (:math:`2 \pi` rad equals 360 degrees).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The sine of each element of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.cos" module_name="cos" namespace="'math'">
    <docstring>cos(x[, out])

Cosine element-wise.

Parameters
----------
x : array_like
    Input array in radians.
out : ndarray, optional
    Output array of same shape as `x`.

Returns
-------
y : ndarray
    The corresponding cosine values.

Raises
------
ValueError: invalid return array shape
    if `out` is provided and `out.shape` != `x.shape` (See Examples)

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
&gt;&gt;&gt; np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
&gt;&gt;&gt;
&gt;&gt;&gt; # Example of providing the optional output parameter
&gt;&gt;&gt; out2 = np.cos([0.1], out1)
&gt;&gt;&gt; out2 is out1
True
&gt;&gt;&gt;
&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`
&gt;&gt;&gt; np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid return array shape</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array in radians.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output array of same shape as `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The corresponding cosine values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.tan" module_name="tan" namespace="'math'">
    <docstring>tan(x[, out])

Compute tangent element-wise.

Equivalent to ``np.sin(x)/np.cos(x)`` element-wise.

Parameters
----------
x : array_like
  Input array.
out : ndarray, optional
    Output array of same shape as `x`.

Returns
-------
y : ndarray
  The corresponding tangent values.

Raises
------
ValueError: invalid return array shape
    if `out` is provided and `out.shape` != `x.shape` (See Examples)

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
&gt;&gt;&gt;
&gt;&gt;&gt; # Example of providing the optional output parameter illustrating
&gt;&gt;&gt; # that what is returned is a reference to said parameter
&gt;&gt;&gt; out2 = np.cos([0.1], out1)
&gt;&gt;&gt; out2 is out1
True
&gt;&gt;&gt;
&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`
&gt;&gt;&gt; np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid return array shape</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output array of same shape as `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The corresponding tangent values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arcsin" module_name="arcsin" namespace="'math'">
    <docstring>arcsin(x[, out])

Inverse sine, element-wise.

Parameters
----------
x : array_like
    `y`-coordinate on the unit circle.

out : ndarray, optional
    Array of the same shape as `x`, in which to store the results.
    See `doc.ufuncs` (Section "Output arguments") for more details.

Returns
-------
angle : ndarray
    The inverse sine of each element in `x`, in radians and in the
    closed interval ``[-pi/2, pi/2]``.  If `x` is a scalar, a scalar
    is returned, otherwise an array.

See Also
--------
sin, cos, arccos, tan, arctan, arctan2, emath.arcsin

Notes
-----
`arcsin` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that :math:`sin(z) = x`.  The convention is to
return the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, *arcsin* always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arcsin` is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.

The inverse sine is also known as `asin` or sin^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79ff.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
&gt;&gt;&gt; np.arcsin(1)     # pi/2
1.5707963267948966
&gt;&gt;&gt; np.arcsin(-1)    # -pi/2
-1.5707963267948966
&gt;&gt;&gt; np.arcsin(0)
0.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>`y`-coordinate on the unit circle.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array of the same shape as `x`, in which to store the results.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="angle" name="angle" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The inverse sine of each element in `x`, in radians and in the
closed interval ``[-pi/2, pi/2]``.  If `x` is a scalar, a scalar
is returned, otherwise an array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arccos" module_name="arccos" namespace="'math'">
    <docstring>arccos(x[, out])

Trigonometric inverse cosine, element-wise.

The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.

Parameters
----------
x : array_like
    `x`-coordinate on the unit circle.
    For real arguments, the domain is [-1, 1].

out : ndarray, optional
    Array of the same shape as `a`, to store results in. See
    `doc.ufuncs` (Section "Output arguments") for more details.

Returns
-------
angle : ndarray
    The angle of the ray intersecting the unit circle at the given
    `x`-coordinate in radians [0, pi]. If `x` is a scalar then a
    scalar is returned, otherwise an array of the same shape as `x`
    is returned.

See Also
--------
cos, arctan, arcsin, emath.arccos

Notes
-----
`arccos` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cos(z) = x`. The convention is to return
the angle `z` whose real part lies in `[0, pi]`.

For real-valued input data types, `arccos` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytic function that
has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse `cos` is also known as `acos` or cos^-1.

References
----------
M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arccos of 1 to be 0, and of -1 to be pi:

&gt;&gt;&gt; np.arccos([1, -1])
array([ 0.        ,  3.14159265])

Plot arccos:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(-1, 1, num=100)
&gt;&gt;&gt; plt.plot(x, np.arccos(x))
&gt;&gt;&gt; plt.axis('tight')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>`x`-coordinate on the unit circle.
For real arguments, the domain is [-1, 1].
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array of the same shape as `a`, to store results in. See
`doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="angle" name="angle" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The angle of the ray intersecting the unit circle at the given
`x`-coordinate in radians [0, pi]. If `x` is a scalar then a
scalar is returned, otherwise an array of the same shape as `x`
is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arctan" module_name="arctan" namespace="'math'">
    <docstring>arctan(x[, out])

Trigonometric inverse tangent, element-wise.

The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.

Parameters
----------
x : array_like
    Input values.  `arctan` is applied to each element of `x`.

Returns
-------
out : ndarray
    Out has the same shape as `x`.  Its real part is in
    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).
    It is a scalar if `x` is a scalar.

See Also
--------
arctan2 : The "four quadrant" arctan of the angle formed by (`x`, `y`)
    and the positive `x`-axis.
angle : Argument of complex values.

Notes
-----
`arctan` is a multi-valued function: for each `x` there are infinitely
many numbers `z` such that tan(`z`) = `x`.  The convention is to return
the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, `arctan` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctan` is a complex analytic function that
has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous
from the left on the former and from the right on the latter.

The inverse tangent is also known as `atan` or tan^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arctan of 0 to be 0, and of 1 to be pi/4:

&gt;&gt;&gt; np.arctan([0, 1])
array([ 0.        ,  0.78539816])

&gt;&gt;&gt; np.pi/4
0.78539816339744828

Plot arctan:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(-10, 10)
&gt;&gt;&gt; plt.plot(x, np.arctan(x))
&gt;&gt;&gt; plt.axis('tight')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.  `arctan` is applied to each element of `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Out has the same shape as `x`.  Its real part is in
``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).
It is a scalar if `x` is a scalar.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.hypot" module_name="hypot" namespace="'math'">
    <docstring>hypot(x1, x2[, out])

Given the "legs" of a right triangle, return its hypotenuse.

Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or
`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),
it is broadcast for use with each element of the other argument.
(See Examples)

Parameters
----------
x1, x2 : array_like
    Leg of the triangle(s).
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
z : ndarray
    The hypotenuse of the triangle(s).

Examples
--------
&gt;&gt;&gt; np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])

Example showing broadcast of scalar_like argument:

&gt;&gt;&gt; np.hypot(3*np.ones((3, 3)), [4])
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Leg of the triangle(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Leg of the triangle(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The hypotenuse of the triangle(s).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arctan2" module_name="arctan2" namespace="'math'">
    <docstring>arctan2(x1, x2[, out])

Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.

The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (`x2`, `x1`).  (Note the role reversal: the
"`y`-coordinate" is the first function parameter, the "`x`-coordinate"
is the second.)  By IEEE convention, this function is defined for
`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see
Notes for specific values).

This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use `angle`.

Parameters
----------
x1 : array_like, real-valued
    `y`-coordinates.
x2 : array_like, real-valued
    `x`-coordinates. `x2` must be broadcastable to match the shape of
    `x1` or vice versa.

Returns
-------
angle : ndarray
    Array of angles in radians, in the range ``[-pi, pi]``.

See Also
--------
arctan, tan, angle

Notes
-----
*arctan2* is identical to the `atan2` function of the underlying
C library.  The following special values are defined in the C
standard: [1]_

====== ====== ================
`x1`   `x2`   `arctan2(x1,x2)`
====== ====== ================
+/- 0  +0     +/- 0
+/- 0  -0     +/- pi
 &gt; 0   +/-inf +0 / +pi
 &lt; 0   +/-inf -0 / -pi
+/-inf +inf   +/- (pi/4)
+/-inf -inf   +/- (3*pi/4)
====== ====== ================

Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.

References
----------
.. [1] ISO/IEC standard 9899:1999, "Programming language C."

Examples
--------
Consider four points in different quadrants:

&gt;&gt;&gt; x = np.array([-1, +1, +1, -1])
&gt;&gt;&gt; y = np.array([-1, -1, +1, +1])
&gt;&gt;&gt; np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])

Note the order of the parameters. `arctan2` is defined also when `x2` = 0
and at several other special points, obtaining values in
the range ``[-pi, pi]``:

&gt;&gt;&gt; np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
&gt;&gt;&gt; np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([ 0.        ,  3.14159265,  0.78539816])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>`y`-coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>`x`-coordinates. `x2` must be broadcastable to match the shape of
`x1` or vice versa.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="angle" name="angle" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of angles in radians, in the range ``[-pi, pi]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.degrees" module_name="degrees" namespace="'math'">
    <docstring>degrees(x[, out])

Convert angles from radians to degrees.

Parameters
----------
x : array_like
    Input array in radians.
out : ndarray, optional
    Output array of same shape as x.

Returns
-------
y : ndarray of floats
    The corresponding degree values; if `out` was supplied this is a
    reference to it.

See Also
--------
rad2deg : equivalent function

Examples
--------
Convert a radian array to degrees

&gt;&gt;&gt; rad = np.arange(12.)*np.pi/6
&gt;&gt;&gt; np.degrees(rad)
array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,
        270.,  300.,  330.])

&gt;&gt;&gt; out = np.zeros((rad.shape))
&gt;&gt;&gt; r = degrees(rad, out)
&gt;&gt;&gt; np.all(r == out)
True</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array in radians.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output array of same shape as x.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" depth="1" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The corresponding degree values; if `out` was supplied this is a
reference to it.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.radians" module_name="radians" namespace="'math'">
    <docstring>radians(x[, out])

Convert angles from degrees to radians.

Parameters
----------
x : array_like
    Input array in degrees.
out : ndarray, optional
    Output array of same shape as `x`.

Returns
-------
y : ndarray
    The corresponding radian values.

See Also
--------
deg2rad : equivalent function

Examples
--------
Convert a degree array to radians

&gt;&gt;&gt; deg = np.arange(12.) * 30.
&gt;&gt;&gt; np.radians(deg)
array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,
        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,
        5.23598776,  5.75958653])

&gt;&gt;&gt; out = np.zeros((deg.shape))
&gt;&gt;&gt; ret = np.radians(deg, out)
&gt;&gt;&gt; ret is out
True</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array in degrees.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output array of same shape as `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The corresponding radian values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.unwrap" module_name="unwrap" namespace="'math'">
    <docstring>Unwrap by changing deltas between values to 2*pi complement.

Unwrap radian phase `p` by changing absolute jumps greater than
`discont` to their 2*pi complement along the given axis.

Parameters
----------
p : array_like
    Input array.
discont : float, optional
    Maximum discontinuity between values, default is ``pi``.
axis : int, optional
    Axis along which unwrap will operate, default is the last axis.

Returns
-------
out : ndarray
    Output array.

See Also
--------
rad2deg, deg2rad

Notes
-----
If the discontinuity in `p` is smaller than ``pi``, but larger than
`discont`, no unwrapping is done because taking the 2*pi complement
would only make the discontinuity larger.

Examples
--------
&gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)
&gt;&gt;&gt; phase[3:] += np.pi
&gt;&gt;&gt; phase
array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])
&gt;&gt;&gt; np.unwrap(phase)
array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])</docstring>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="discont" name="discont" port_type="basic:Float">
      <docstring>Maximum discontinuity between values, default is ``pi``.</docstring>
      <defaults>[3.141592653589793]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which unwrap will operate, default is the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.deg2rad" module_name="deg2rad" namespace="'math'">
    <docstring>deg2rad(x[, out])

Convert angles from degrees to radians.

Parameters
----------
x : array_like
    Angles in degrees.

Returns
-------
y : ndarray
    The corresponding angle in radians.

See Also
--------
rad2deg : Convert angles from radians to degrees.
unwrap : Remove large jumps in angle by wrapping.

Notes
-----
.. versionadded:: 1.3.0

``deg2rad(x)`` is ``x * pi / 180``.

Examples
--------
&gt;&gt;&gt; np.deg2rad(180)
3.1415926535897931</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Angles in degrees.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The corresponding angle in radians.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.rad2deg" module_name="rad2deg" namespace="'math'">
    <docstring>rad2deg(x[, out])

Convert angles from radians to degrees.

Parameters
----------
x : array_like
    Angle in radians.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
y : ndarray
    The corresponding angle in degrees.

See Also
--------
deg2rad : Convert angles from degrees to radians.
unwrap : Remove large jumps in angle by wrapping.

Notes
-----
.. versionadded:: 1.3.0

rad2deg(x) is ``180 * x / pi``.

Examples
--------
&gt;&gt;&gt; np.rad2deg(np.pi/2)
90.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Angle in radians.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The corresponding angle in degrees.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sinh" module_name="sinh" namespace="'math'">
    <docstring>sinh(x[, out])

Hyperbolic sine, element-wise.

Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or
``-1j * np.sin(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, optional
    Output array of same shape as `x`.

Returns
-------
y : ndarray
    The corresponding hyperbolic sine values.

Raises
------
ValueError: invalid return array shape
    if `out` is provided and `out.shape` != `x.shape` (See Examples)

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.

Examples
--------
&gt;&gt;&gt; np.sinh(0)
0.0
&gt;&gt;&gt; np.sinh(np.pi*1j/2)
1j
&gt;&gt;&gt; np.sinh(np.pi*1j) # (exact value is 0)
1.2246063538223773e-016j
&gt;&gt;&gt; # Discrepancy due to vagaries of floating point arithmetic.

&gt;&gt;&gt; # Example of providing the optional output parameter
&gt;&gt;&gt; out2 = np.sinh([0.1], out1)
&gt;&gt;&gt; out2 is out1
True

&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`
&gt;&gt;&gt; np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid return array shape</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output array of same shape as `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The corresponding hyperbolic sine values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.cosh" module_name="cosh" namespace="'math'">
    <docstring>cosh(x[, out])

Hyperbolic cosine, element-wise.

Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray
    Output array of same shape as `x`.

Examples
--------
&gt;&gt;&gt; np.cosh(0)
1.0

The hyperbolic cosine describes the shape of a hanging cable:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(-4, 4, 1000)
&gt;&gt;&gt; plt.plot(x, np.cosh(x))
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array of same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arcsinh" module_name="arcsinh" namespace="'math'">
    <docstring>arcsinh(x[, out])

Inverse hyperbolic sine element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See `doc.ufuncs`.

Returns
-------
out : ndarray
    Array of of the same shape as `x`.

Notes
-----
`arcsinh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `sinh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arcsinh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytical function that
has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from
the right on the former and from the left on the latter.

The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse hyperbolic function",
       http://en.wikipedia.org/wiki/Arcsinh

Examples
--------
&gt;&gt;&gt; np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See `doc.ufuncs`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of of the same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arccosh" module_name="arccosh" namespace="'math'">
    <docstring>arccosh(x[, out])

Inverse hyperbolic cosine, element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, optional
    Array of the same shape as `x`, to store results in.
    See `doc.ufuncs` (Section "Output arguments") for details.


Returns
-------
arccosh : ndarray
    Array of the same shape as `x`.

See Also
--------

cosh, arcsinh, sinh, arctanh, tanh

Notes
-----
`arccosh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cosh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]` and the real part in
``[0, inf]``.

For real-valued input data types, `arccosh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccosh` is a complex analytical function that
has a branch cut `[-inf, 1]` and is continuous from above on it.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse hyperbolic function",
       http://en.wikipedia.org/wiki/Arccosh

Examples
--------
&gt;&gt;&gt; np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
&gt;&gt;&gt; np.arccosh(1)
0.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array of the same shape as `x`, to store results in.
See `doc.ufuncs` (Section "Output arguments") for details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="arccosh" name="arccosh" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.arctanh" module_name="arctanh" namespace="'math'">
    <docstring>arctanh(x[, out])

Inverse hyperbolic tangent element-wise.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray
    Array of the same shape as `x`.

See Also
--------
emath.arctanh

Notes
-----
`arctanh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `tanh(z) = x`. The convention is to return
the `z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arctanh` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctanh` is a complex analytical function
that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Inverse hyperbolic function",
       http://en.wikipedia.org/wiki/Arctanh

Examples
--------
&gt;&gt;&gt; np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.around" module_name="around" namespace="'math'">
    <docstring>Evenly round to the given number of decimals.

Parameters
----------
a : array_like
    Input data.
decimals : int, optional
    Number of decimal places to round to (default: 0).  If
    decimals is negative, it specifies the number of positions to
    the left of the decimal point.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary. See `doc.ufuncs` (Section
    "Output arguments") for details.

Returns
-------
rounded_array : ndarray
    An array of the same type as `a`, containing the rounded values.
    Unless `out` was specified, a new array is created.  A reference to
    the result is returned.

    The real and imaginary parts of complex numbers are rounded
    separately.  The result of rounding a float is a float.

See Also
--------
ndarray.round : equivalent method

ceil, fix, floor, rint, trunc


Notes
-----
For values exactly halfway between rounded decimal values, Numpy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
to the inexact representation of decimal fractions in the IEEE
floating point standard [1]_ and errors introduced when scaling
by powers of ten.

References
----------
.. [1] "Lecture Notes on the Status of  IEEE 754", William Kahan,
       http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
.. [2] "How Futile are Mindless Assessments of
       Roundoff in Floating-Point Computation?", William Kahan,
       http://www.cs.berkeley.edu/~wkahan/Mindless.pdf

Examples
--------
&gt;&gt;&gt; np.around([0.37, 1.64])
array([ 0.,  2.])
&gt;&gt;&gt; np.around([0.37, 1.64], decimals=1)
array([ 0.4,  1.6])
&gt;&gt;&gt; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
array([ 0.,  2.,  2.,  4.,  4.])
&gt;&gt;&gt; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
array([ 1,  2,  3, 11])
&gt;&gt;&gt; np.around([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="decimals" name="decimals" port_type="basic:Integer">
      <docstring>Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary. See `doc.ufuncs` (Section
"Output arguments") for details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="rounded_array" name="rounded_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of the same type as `a`, containing the rounded values.
Unless `out` was specified, a new array is created.  A reference to
the result is returned.

The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.round_" module_name="round_" namespace="'math'">
    <docstring>Round an array to the given number of decimals.

Refer to `around` for full documentation.

See Also
--------
around : equivalent function</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="decimals" name="decimals" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.rint" module_name="rint" namespace="'math'">
    <docstring>rint(x[, out])

Round elements of the array to the nearest integer.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray or scalar
    Output array is same shape and type as `x`.

See Also
--------
ceil, floor, trunc

Examples
--------
&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
&gt;&gt;&gt; np.rint(a)
array([-2., -2., -0.,  0.,  2.,  2.,  2.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Output array is same shape and type as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fix" module_name="fix" namespace="'math'">
    <docstring>Round to nearest integer towards zero.

Round an array of floats element-wise to nearest integer towards zero.
The rounded values are returned as floats.

Parameters
----------
x : array_like
    An array of floats to be rounded
y : ndarray, optional
    Output array

Returns
-------
out : ndarray of floats
    The array of rounded numbers

See Also
--------
trunc, floor, ceil
around : Round to given number of decimals

Examples
--------
&gt;&gt;&gt; np.fix(3.14)
3.0
&gt;&gt;&gt; np.fix(3)
3.0
&gt;&gt;&gt; np.fix([2.1, 2.9, -2.1, -2.9])
array([ 2.,  2., -2., -2.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>An array of floats to be rounded</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>Output array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The array of rounded numbers</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.floor" module_name="floor" namespace="'math'">
    <docstring>floor(x[, out])

Return the floor of the input, element-wise.

The floor of the scalar `x` is the largest integer `i`, such that
`i &lt;= x`.  It is often denoted as :math:`\lfloor x \rfloor`.

Parameters
----------
x : array_like
    Input data.

Returns
-------
y : ndarray or scalar
    The floor of each element in `x`.

See Also
--------
ceil, trunc, rint

Notes
-----
Some spreadsheet programs calculate the "floor-towards-zero", in other
words ``floor(-2.5) == -2``.  NumPy instead uses the definition of
`floor` where `floor(-2.5) == -3`.

Examples
--------
&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
&gt;&gt;&gt; np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The floor of each element in `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ceil" module_name="ceil" namespace="'math'">
    <docstring>ceil(x[, out])

Return the ceiling of the input, element-wise.

The ceil of the scalar `x` is the smallest integer `i`, such that
`i &gt;= x`.  It is often denoted as :math:`\lceil x \rceil`.

Parameters
----------
x : array_like
    Input data.

Returns
-------
y : ndarray or scalar
    The ceiling of each element in `x`, with `float` dtype.

See Also
--------
floor, trunc, rint

Examples
--------
&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
&gt;&gt;&gt; np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The ceiling of each element in `x`, with `float` dtype.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.trunc" module_name="trunc" namespace="'math'">
    <docstring>trunc(x[, out])

Return the truncated value of the input, element-wise.

The truncated value of the scalar `x` is the nearest integer `i` which
is closer to zero than `x` is. In short, the fractional part of the
signed number `x` is discarded.

Parameters
----------
x : array_like
    Input data.

Returns
-------
y : ndarray or scalar
    The truncated value of each element in `x`.

See Also
--------
ceil, floor, rint

Notes
-----
.. versionadded:: 1.3.0

Examples
--------
&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
&gt;&gt;&gt; np.trunc(a)
array([-1., -1., -0.,  0.,  1.,  1.,  2.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The truncated value of each element in `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.prod" module_name="prod" namespace="'math'">
    <docstring>Return the product of array elements over a given axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which a product is performed.
    The default (`axis` = `None`) is perform a product over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a product is performed on multiple
    axes, instead of a single axis or all the axes as before.
dtype : data-type, optional
    The data-type of the returned array, as well as of the accumulator
    in which the elements are multiplied.  By default, if `a` is of
    integer type, `dtype` is the default platform integer. (Note: if
    the type of `a` is unsigned, then so is `dtype`.)  Otherwise,
    the dtype is the same as that of `a`.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the
    output values will be cast if necessary.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
product_along_axis : ndarray, see `dtype` parameter above.
    An array shaped as `a` but with the specified axis removed.
    Returns a reference to `out` if specified.

See Also
--------
ndarray.prod : equivalent method
numpy.doc.ufuncs : Section "Output arguments"

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:

&gt;&gt;&gt; x = np.array([536870910, 536870910, 536870910, 536870910])
&gt;&gt;&gt; np.prod(x) #random
16

The product of an empty array is the neutral element 1:

&gt;&gt;&gt; np.prod([])
1.0

Examples
--------
By default, calculate the product of all elements:

&gt;&gt;&gt; np.prod([1.,2.])
2.0

Even when the input array is two-dimensional:

&gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]])
24.0

But we can also specify the axis over which to multiply:

&gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])

If the type of `x` is unsigned, then the output type is
the unsigned platform integer:

&gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.uint8)
&gt;&gt;&gt; np.prod(x).dtype == np.uint
True

If `x` is of a signed integer type, then the output type
is the default platform integer:

&gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.int8)
&gt;&gt;&gt; np.prod(x).dtype == np.int
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which a product is performed.
The default (`axis` = `None`) is perform a product over all
the dimensions of the input array. `axis` may be negative, in
which case it counts from the last to the first axis.

.. versionadded:: 1.7.0

If this is a tuple of ints, a product is performed on multiple
axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data-type of the returned array, as well as of the accumulator
in which the elements are multiplied.  By default, if `a` is of
integer type, `dtype` is the default platform integer. (Note: if
the type of `a` is unsigned, then so is `dtype`.)  Otherwise,
the dtype is the same as that of `a`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the
output values will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="product_along_axis" name="product_along_axis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array shaped as `a` but with the specified axis removed.
Returns a reference to `out` if specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sum" module_name="sum" namespace="'math'">
    <docstring>Sum of array elements over a given axis.

Parameters
----------
a : array_like
    Elements to sum.
axis : None or int or tuple of ints, optional
    Axis or axes along which a sum is performed.
    The default (`axis` = `None`) is perform a sum over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a sum is performed on multiple
    axes, instead of a single axis or all the axes as before.
dtype : dtype, optional
    The type of the returned array and of the accumulator in which
    the elements are summed.  By default, the dtype of `a` is used.
    An exception is when `a` has an integer type with less precision
    than the default platform integer.  In that case, the default
    platform integer is used instead.
out : ndarray, optional
    Array into which the output is placed.  By default, a new array is
    created.  If `out` is given, it must be of the appropriate shape
    (the shape of `a` with `axis` removed, i.e.,
    ``numpy.delete(a.shape, axis)``).  Its type is preserved. See
    `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
sum_along_axis : ndarray
    An array with the same shape as `a`, with the specified
    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
    is returned.  If an output array is specified, a reference to
    `out` is returned.

See Also
--------
ndarray.sum : Equivalent method.

cumsum : Cumulative sum of array elements.

trapz : Integration of array values using the composite trapezoidal rule.

mean, average

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

The sum of an empty array is the neutral element 0:

&gt;&gt;&gt; np.sum([])
0.0

Examples
--------
&gt;&gt;&gt; np.sum([0.5, 1.5])
2.0
&gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
1
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])
6
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)
array([1, 5])

If the accumulator is too small, overflow occurs:

&gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)
-128</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Elements to sum.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which a sum is performed.
The default (`axis` = `None`) is perform a sum over all
the dimensions of the input array. `axis` may be negative, in
which case it counts from the last to the first axis.

.. versionadded:: 1.7.0

If this is a tuple of ints, a sum is performed on multiple
axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The type of the returned array and of the accumulator in which
the elements are summed.  By default, the dtype of `a` is used.
An exception is when `a` has an integer type with less precision
than the default platform integer.  In that case, the default
platform integer is used instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed.  By default, a new array is
created.  If `out` is given, it must be of the appropriate shape
(the shape of `a` with `axis` removed, i.e.,
``numpy.delete(a.shape, axis)``).  Its type is preserved. See
`doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sum_along_axis" name="sum_along_axis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array with the same shape as `a`, with the specified
axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
is returned.  If an output array is specified, a reference to
`out` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nansum" module_name="nansum" namespace="'math'">
    <docstring>Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.

In Numpy versions &lt;= 1.8 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.

Parameters
----------
a : array_like
    Array containing numbers whose sum is desired. If `a` is not an
    array, a conversion is attempted.
axis : int, optional
    Axis along which the sum is computed. The default is to compute the
    sum of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.

    .. versionadded:: 1.8.0
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    `doc.ufuncs` for details. The casting of NaN to integer can yield
    unexpected results.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If True, the axes which are reduced are left in the result as
    dimensions with size one. With this option, the result will
    broadcast correctly against the original `arr`.

    .. versionadded:: 1.8.0

Returns
-------
y : ndarray or numpy scalar

See Also
--------
numpy.sum : Sum across array propagating NaNs.
isnan : Show which elements are NaN.
isfinite: Show which elements are not NaN or +/-inf.

Notes
-----
If both positive and negative infinity are present, the sum will be Not
A Number (NaN).

Numpy integer arithmetic is modular. If the size of a sum exceeds the
size of an integer accumulator, its value will wrap around and the
result will be incorrect. Specifying ``dtype=double`` can alleviate
that problem.

Examples
--------
&gt;&gt;&gt; np.nansum(1)
1
&gt;&gt;&gt; np.nansum([1])
1
&gt;&gt;&gt; np.nansum([1, np.nan])
1.0
&gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])
&gt;&gt;&gt; np.nansum(a)
3.0
&gt;&gt;&gt; np.nansum(a, axis=0)
array([ 2.,  1.])
&gt;&gt;&gt; np.nansum([1, np.nan, np.inf])
inf
&gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])
-inf
&gt;&gt;&gt; np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
nan</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose sum is desired. If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the sum is computed. The default is to compute the
sum of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of `a` is used.  An
exception is when `a` has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.

.. versionadded:: 1.8.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  The default
is ``None``. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
`doc.ufuncs` for details. The casting of NaN to integer can yield
unexpected results.

.. versionadded:: 1.8.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdimsScalar" port_type="basic:Integer">
      <docstring>If True, the axes which are reduced are left in the result as
dimensions with size one. With this option, the result will
broadcast correctly against the original `arr`.

.. versionadded:: 1.8.0</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="keepdims" name="keepdimsBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.cumprod" module_name="cumprod" namespace="'math'">
    <docstring>Return the cumulative product of elements along a given axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative product is computed.  By default
    the input is flattened.
dtype : dtype, optional
    Type of the returned array, as well as of the accumulator in which
    the elements are multiplied.  If *dtype* is not specified, it
    defaults to the dtype of `a`, unless `a` has an integer dtype with
    a precision less than that of the default platform integer.  In
    that case, the default platform integer is used instead.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type of the resulting values will be cast if necessary.

Returns
-------
cumprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to out is returned.

See Also
--------
numpy.doc.ufuncs : Section "Output arguments"

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

Examples
--------
&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; np.cumprod(a) # intermediate results 1, 1*2
...               # total product 1*2*3 = 6
array([1, 2, 6])
&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; np.cumprod(a, dtype=float) # specify type of output
array([   1.,    2.,    6.,   24.,  120.,  720.])

The cumulative product for each column (i.e., over the rows) of `a`:

&gt;&gt;&gt; np.cumprod(a, axis=0)
array([[ 1,  2,  3],
       [ 4, 10, 18]])

The cumulative product for each row (i.e. over the columns) of `a`:

&gt;&gt;&gt; np.cumprod(a,axis=1)
array([[  1,   2,   6],
       [  4,  20, 120]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the cumulative product is computed.  By default
the input is flattened.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If *dtype* is not specified, it
defaults to the dtype of `a`, unless `a` has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="cumprod" name="cumprod" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result is returned unless `out` is
specified, in which case a reference to out is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.cumsum" module_name="cumsum" namespace="'math'">
    <docstring>Return the cumulative sum of the elements along a given axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative sum is computed. The default
    (None) is to compute the cumsum over the flattened array.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed.  If `dtype` is not specified, it defaults
    to the dtype of `a`, unless `a` has an integer dtype with a
    precision less than that of the default platform integer.  In
    that case, the default platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary. See `doc.ufuncs`
    (Section "Output arguments") for more details.

Returns
-------
cumsum_along_axis : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to `out` is returned. The
    result has the same size as `a`, and the same shape as `a` if
    `axis` is not None or `a` is a 1-d array.


See Also
--------
sum : Sum array elements.

trapz : Integration of array values using the composite trapezoidal rule.

diff :  Calculate the n-th order discrete difference along given axis.

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.cumsum(a)
array([ 1,  3,  6, 10, 15, 21])
&gt;&gt;&gt; np.cumsum(a, dtype=float)     # specifies type of output value(s)
array([  1.,   3.,   6.,  10.,  15.,  21.])

&gt;&gt;&gt; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
array([[1, 2, 3],
       [5, 7, 9]])
&gt;&gt;&gt; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
array([[ 1,  3,  6],
       [ 4,  9, 15]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type of the returned array and of the accumulator in which the
elements are summed.  If `dtype` is not specified, it defaults
to the dtype of `a`, unless `a` has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See `doc.ufuncs`
(Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="cumsum_along_axis" name="cumsum_along_axis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result is returned unless `out` is
specified, in which case a reference to `out` is returned. The
result has the same size as `a`, and the same shape as `a` if
`axis` is not None or `a` is a 1-d array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.diff" module_name="diff" namespace="'math'">
    <docstring>Calculate the n-th order discrete difference along given axis.

The first order difference is given by ``out[n] = a[n+1] - a[n]`` along
the given axis, higher order differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced.
axis : int, optional
    The axis along which the difference is taken, default is the last axis.

Returns
-------
diff : ndarray
    The `n` order differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`.

See Also
--------
gradient, ediff1d, cumsum

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])
&gt;&gt;&gt; np.diff(x)
array([ 1,  2,  3, -7])
&gt;&gt;&gt; np.diff(x, n=2)
array([  1,   1, -10])

&gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
&gt;&gt;&gt; np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
&gt;&gt;&gt; np.diff(x, axis=0)
array([[-1,  2,  0, -2]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>The number of times values are differenced.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the difference is taken, default is the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="diff" name="diff" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The `n` order differences. The shape of the output is the same as `a`
except along `axis` where the dimension is smaller by `n`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ediff1d" module_name="ediff1d" namespace="'math'">
    <docstring>The differences between consecutive elements of an array.

Parameters
----------
ary : array_like
    If necessary, will be flattened before the differences are taken.
to_end : array_like, optional
    Number(s) to append at the end of the returned differences.
to_begin : array_like, optional
    Number(s) to prepend at the beginning of the returned differences.

Returns
-------
ediff1d : ndarray
    The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.

See Also
--------
diff, gradient

Notes
-----
When applied to masked arrays, this function drops the mask information
if the `to_begin` and/or `to_end` parameters are used.

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])
&gt;&gt;&gt; np.ediff1d(x)
array([ 1,  2,  3, -7])

&gt;&gt;&gt; np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
array([-99,   1,   2,   3,  -7,  88,  99])

The returned array is always 1D.

&gt;&gt;&gt; y = [[1, 2, 4], [1, 6, 24]]
&gt;&gt;&gt; np.ediff1d(y)
array([ 1,  2, -3,  5, 18])</docstring>
    <inputPortSpec arg="ary" name="ary" port_type="basic:List" show_port="True">
      <docstring>If necessary, will be flattened before the differences are taken.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="to_end" name="to_end" port_type="basic:List">
      <docstring>Number(s) to append at the end of the returned differences.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="to_begin" name="to_begin" port_type="basic:List">
      <docstring>Number(s) to prepend at the beginning of the returned differences.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="ediff1d" name="ediff1d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.gradient" module_name="gradient" namespace="'math'">
    <docstring>Return the gradient of an N-dimensional array.

The gradient is computed using second order accurate central differences
in the interior and either first differences or second order accurate
one-sides (forward or backwards) differences at the boundaries. The
returned gradient hence has the same shape as the input array.

Parameters
----------
f : array_like
    An N-dimensional array containing samples of a scalar function.
varargs : list of scalar, optional
    N scalars specifying the sample distances for each dimension,
    i.e. `dx`, `dy`, `dz`, ... Default distance: 1.
edge_order : {1, 2}, optional
    Gradient is calculated using N\ :sup:`th` order accurate differences
    at the boundaries. Default: 1.

    .. versionadded:: 1.9.1

Returns
-------
gradient : list of ndarray
    Each element of `list` has the same shape as `f` giving the derivative 
    of `f` with respect to each dimension.

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)
&gt;&gt;&gt; np.gradient(x)
array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
&gt;&gt;&gt; np.gradient(x, 2)
array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])

For two dimensional arrays, the return will be two arrays ordered by 
axis. In this example the first array stands for the gradient in 
rows and the second one in columns direction:

&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float))
[array([[ 2.,  2., -1.],
        [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],
        [ 1. ,  1. ,  1. ]])]

&gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])
&gt;&gt;&gt; dx = np.gradient(x)
&gt;&gt;&gt; y = x**2
&gt;&gt;&gt; np.gradient(y, dx, edge_order=2)
array([-0.,  2.,  4.,  6.,  8.])</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:List" show_port="True">
      <docstring>An N-dimensional array containing samples of a scalar function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="varargs" name="varargs" port_type="basic:List">
      <docstring>N scalars specifying the sample distances for each dimension,
i.e. `dx`, `dy`, `dz`, ... Default distance: 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="edge_order" name="edge_order" port_type="basic:Integer">
      <docstring>Gradient is calculated using N\ :sup:`th` order accurate differences
at the boundaries. Default: 1.

.. versionadded:: 1.9.1</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2]]</values>
    </inputPortSpec>
    <outputPortSpec arg="gradient" name="gradient" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Each element of `list` has the same shape as `f` giving the derivative 
of `f` with respect to each dimension.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.cross" module_name="cross" namespace="'math'">
    <docstring>Return the cross product of two (arrays of) vectors.

The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
are defined by the last axis of `a` and `b` by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.

Parameters
----------
a : array_like
    Components of the first vector(s).
b : array_like
    Components of the second vector(s).
axisa : int, optional
    Axis of `a` that defines the vector(s).  By default, the last axis.
axisb : int, optional
    Axis of `b` that defines the vector(s).  By default, the last axis.
axisc : int, optional
    Axis of `c` containing the cross product vector(s).  Ignored if
    both input vectors have dimension 2, as the return is scalar.
    By default, the last axis.
axis : int, optional
    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.

Returns
-------
c : ndarray
    Vector cross product(s).

Raises
------
ValueError
    When the dimension of the vector(s) in `a` and/or `b` does not
    equal 2 or 3.

See Also
--------
inner : Inner product
outer : Outer product.
ix_ : Construct index arrays.

Notes
-----
.. versionadded:: 1.9.0

Supports full broadcasting of the inputs.

Examples
--------
Vector cross-product.

&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([-3,  6, -3])

One vector with dimension 2.

&gt;&gt;&gt; x = [1, 2]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([12, -6, -3])

Equivalently:

&gt;&gt;&gt; x = [1, 2, 0]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([12, -6, -3])

Both vectors with dimension 2.

&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; y = [4,5]
&gt;&gt;&gt; np.cross(x, y)
-3

Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the `right-hand rule`.

&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; y = np.array([[4,5,6], [1,2,3]])
&gt;&gt;&gt; np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])

The orientation of `c` can be changed using the `axisc` keyword.

&gt;&gt;&gt; np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])

Change the vector definition of `x` and `y` using `axisa` and `axisb`.

&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
&gt;&gt;&gt; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
&gt;&gt;&gt; np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
&gt;&gt;&gt; np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Components of the first vector(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Components of the second vector(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axisa" name="axisa" port_type="basic:Integer">
      <docstring>Axis of `a` that defines the vector(s).  By default, the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axisb" name="axisb" port_type="basic:Integer">
      <docstring>Axis of `b` that defines the vector(s).  By default, the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axisc" name="axisc" port_type="basic:Integer">
      <docstring>Axis of `c` containing the cross product vector(s).  Ignored if
both input vectors have dimension 2, as the return is scalar.
By default, the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>If defined, the axis of `a`, `b` and `c` that defines the vector(s)
and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Vector cross product(s).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.trapz" module_name="trapz" namespace="'math'">
    <docstring>Integrate along the given axis using the composite trapezoidal rule.

Integrate `y` (`x`) along given axis.

Parameters
----------
y : array_like
    Input array to integrate.
x : array_like, optional
    If `x` is None, then spacing between all `y` elements is `dx`.
dx : scalar, optional
    If `x` is None, spacing given by `dx` is assumed. Default is 1.
axis : int, optional
    Specify the axis.

Returns
-------
trapz : float
    Definite integral as approximated by trapezoidal rule.

See Also
--------
sum, cumsum

Notes
-----
Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
will be taken from `y` array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with `x` array
or with `dx` scalar.  Return value will be equal to combined area under
the red lines.


References
----------
.. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule

.. [2] Illustration image:
       http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

Examples
--------
&gt;&gt;&gt; np.trapz([1,2,3])
4.0
&gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])
8.0
&gt;&gt;&gt; np.trapz([1,2,3], dx=2)
8.0
&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.trapz(a, axis=0)
array([ 1.5,  2.5,  3.5])
&gt;&gt;&gt; np.trapz(a, axis=1)
array([ 2.,  8.])</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input array to integrate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>If `x` is None, then spacing between all `y` elements is `dx`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <docstring>If `x` is None, spacing given by `dx` is assumed. Default is 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Specify the axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trapz" name="trapz" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Definite integral as approximated by trapezoidal rule.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.exp" module_name="exp" namespace="'math'">
    <docstring>exp(x[, out])

Calculate the exponential of all elements in the input array.

Parameters
----------
x : array_like
    Input values.

Returns
-------
out : ndarray
    Output array, element-wise exponential of `x`.

See Also
--------
expm1 : Calculate ``exp(x) - 1`` for all elements in the array.
exp2  : Calculate ``2**x`` for all elements in the array.

Notes
-----
The irrational number ``e`` is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
``ln`` (this means that, if :math:`x = \ln y = \log_e y`,
then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.

For complex arguments, ``x = a + ib``, we can write
:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already
known (it is the real argument, described above).  The second term,
:math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with
magnitude 1 and a periodic phase.

References
----------
.. [1] Wikipedia, "Exponential function",
       http://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, "Handbook of Mathematical Functions
       with Formulas, Graphs, and Mathematical Tables," Dover, 1964, p. 69,
       http://www.math.sfu.ca/~cbm/aands/page_69.htm

Examples
--------
Plot the magnitude and phase of ``exp(x)`` in the complex plane:

&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; x = np.linspace(-2*np.pi, 2*np.pi, 100)
&gt;&gt;&gt; xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
&gt;&gt;&gt; out = np.exp(xx)

&gt;&gt;&gt; plt.subplot(121)
&gt;&gt;&gt; plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi])
&gt;&gt;&gt; plt.title('Magnitude of exp(x)')

&gt;&gt;&gt; plt.subplot(122)
&gt;&gt;&gt; plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi])
&gt;&gt;&gt; plt.title('Phase (angle) of exp(x)')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array, element-wise exponential of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.expm1" module_name="expm1" namespace="'math'">
    <docstring>expm1(x[, out])

Calculate ``exp(x) - 1`` for all elements in the array.

Parameters
----------
x : array_like
   Input values.

Returns
-------
out : ndarray
    Element-wise exponential minus one: ``out = exp(x) - 1``.

See Also
--------
log1p : ``log(1 + x)``, the inverse of expm1.


Notes
-----
This function provides greater precision than ``exp(x) - 1``
for small values of ``x``.

Examples
--------
The true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to
about 32 significant digits. This example shows the superiority of
expm1 in this case.

&gt;&gt;&gt; np.expm1(1e-10)
1.00000000005e-10
&gt;&gt;&gt; np.exp(1e-10) - 1
1.000000082740371e-10</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Element-wise exponential minus one: ``out = exp(x) - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.exp2" module_name="exp2" namespace="'math'">
    <docstring>exp2(x[, out])

Calculate `2**p` for all `p` in the input array.

Parameters
----------
x : array_like
    Input values.

out : ndarray, optional
    Array to insert results into.

Returns
-------
out : ndarray
    Element-wise 2 to the power `x`.

See Also
--------
power

Notes
-----
.. versionadded:: 1.3.0



Examples
--------
&gt;&gt;&gt; np.exp2([2, 3])
array([ 4.,  8.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array to insert results into.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Element-wise 2 to the power `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.log" module_name="log" namespace="'math'">
    <docstring>log(x[, out])

Natural logarithm, element-wise.

The natural logarithm `log` is the inverse of the exponential function,
so that `log(exp(x)) = x`. The natural logarithm is logarithm in base
`e`.

Parameters
----------
x : array_like
    Input value.

Returns
-------
y : ndarray
    The natural logarithm of `x`, element-wise.

See Also
--------
log10, log2, log1p, emath.log

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm

Examples
--------
&gt;&gt;&gt; np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -Inf])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input value.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The natural logarithm of `x`, element-wise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.log10" module_name="log10" namespace="'math'">
    <docstring>log10(x[, out])

Return the base 10 logarithm of the input array, element-wise.

Parameters
----------
x : array_like
    Input values.

Returns
-------
y : ndarray
    The logarithm to the base 10 of `x`, element-wise. NaNs are
    returned where x is negative.

See Also
--------
emath.log10

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `10**z = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log10` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log10` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it.
`log10` handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm

Examples
--------
&gt;&gt;&gt; np.log10([1e-15, -3.])
array([-15.,  NaN])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The logarithm to the base 10 of `x`, element-wise. NaNs are
returned where x is negative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.log2" module_name="log2" namespace="'math'">
    <docstring>log2(x[, out])

Base-2 logarithm of `x`.

Parameters
----------
x : array_like
    Input values.

Returns
-------
y : ndarray
    Base-2 logarithm of `x`.

See Also
--------
log, log10, log1p, emath.log2

Notes
-----
.. versionadded:: 1.3.0

Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `2**z = x`. The convention is to return the `z`
whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log2` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log2` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

Examples
--------
&gt;&gt;&gt; x = np.array([0, 1, 2, 2**4])
&gt;&gt;&gt; np.log2(x)
array([-Inf,   0.,   1.,   4.])

&gt;&gt;&gt; xi = np.array([0+1.j, 1, 2+0.j, 4.j])
&gt;&gt;&gt; np.log2(xi)
array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Base-2 logarithm of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.log1p" module_name="log1p" namespace="'math'">
    <docstring>log1p(x[, out])

Return the natural logarithm of one plus the input array, element-wise.

Calculates ``log(1 + x)``.

Parameters
----------
x : array_like
    Input values.

Returns
-------
y : ndarray
    Natural logarithm of `1 + x`, element-wise.

See Also
--------
expm1 : ``exp(x) - 1``, the inverse of `log1p`.

Notes
-----
For real-valued input, `log1p` is accurate also for `x` so small
that `1 + x == 1` in floating-point accuracy.

Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = 1 + x`. The convention is to return
the `z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log1p` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log1p` is a complex analytical function that
has a branch cut `[-inf, -1]` and is continuous from above on it.
`log1p` handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm

Examples
--------
&gt;&gt;&gt; np.log1p(1e-99)
1e-99
&gt;&gt;&gt; np.log(1 + 1e-99)
0.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Natural logarithm of `1 + x`, element-wise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.logaddexp" module_name="logaddexp" namespace="'math'">
    <docstring>logaddexp(x1, x2[, out])

Logarithm of the sum of exponentiations of the inputs.

Calculates ``log(exp(x1) + exp(x2))``. This function is useful in
statistics where the calculated probabilities of events may be so small
as to exceed the range of normal floating point numbers.  In such cases
the logarithm of the calculated probability is stored. This function
allows adding probabilities stored in such a fashion.

Parameters
----------
x1, x2 : array_like
    Input values.

Returns
-------
result : ndarray
    Logarithm of ``exp(x1) + exp(x2)``.

See Also
--------
logaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.

Notes
-----
.. versionadded:: 1.3.0

Examples
--------
&gt;&gt;&gt; prob1 = np.log(1e-50)
&gt;&gt;&gt; prob2 = np.log(2.5e-50)
&gt;&gt;&gt; prob12 = np.logaddexp(prob1, prob2)
&gt;&gt;&gt; prob12
-113.87649168120691
&gt;&gt;&gt; np.exp(prob12)
3.5000000000000057e-50</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Logarithm of ``exp(x1) + exp(x2)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.logaddexp2" module_name="logaddexp2" namespace="'math'">
    <docstring>logaddexp2(x1, x2[, out])

Logarithm of the sum of exponentiations of the inputs in base-2.

Calculates ``log2(2**x1 + 2**x2)``. This function is useful in machine
learning when the calculated probabilities of events may be so small as
to exceed the range of normal floating point numbers.  In such cases
the base-2 logarithm of the calculated probability can be used instead.
This function allows adding probabilities stored in such a fashion.

Parameters
----------
x1, x2 : array_like
    Input values.
out : ndarray, optional
    Array to store results in.

Returns
-------
result : ndarray
    Base-2 logarithm of ``2**x1 + 2**x2``.

See Also
--------
logaddexp: Logarithm of the sum of exponentiations of the inputs.

Notes
-----
.. versionadded:: 1.3.0

Examples
--------
&gt;&gt;&gt; prob1 = np.log2(1e-50)
&gt;&gt;&gt; prob2 = np.log2(2.5e-50)
&gt;&gt;&gt; prob12 = np.logaddexp2(prob1, prob2)
&gt;&gt;&gt; prob1, prob2, prob12
(-166.09640474436813, -164.77447664948076, -164.28904982231052)
&gt;&gt;&gt; 2**prob12
3.4999999999999914e-50</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array to store results in.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Base-2 logarithm of ``2**x1 + 2**x2``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.i0" module_name="i0" namespace="'math'">
    <docstring>Modified Bessel function of the first kind, order 0.

Usually denoted :math:`I_0`.  This function does broadcast, but will *not*
"up-cast" int dtype arguments unless accompanied by at least one float or
complex dtype argument (see Raises below).

Parameters
----------
x : array_like, dtype float or complex
    Argument of the Bessel function.

Returns
-------
out : ndarray, shape = x.shape, dtype = x.dtype
    The modified Bessel function evaluated at each of the elements of `x`.

Raises
------
TypeError: array cannot be safely cast to required type
    If argument consists exclusively of int dtypes.

See Also
--------
scipy.special.iv, scipy.special.ive

Notes
-----
We use the algorithm published by Clenshaw [1]_ and referenced by
Abramowitz and Stegun [2]_, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).

References
----------
.. [1] C. W. Clenshaw, "Chebyshev series for mathematical functions", in
       *National Physical Laboratory Mathematical Tables*, vol. 5, London:
       Her Majesty's Stationery Office, 1962.
.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
       Functions*, 10th printing, New York: Dover, 1964, pp. 379.
       http://www.math.sfu.ca/~cbm/aands/page_379.htm
.. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html

Examples
--------
&gt;&gt;&gt; np.i0([0.])
array(1.0)
&gt;&gt;&gt; np.i0([0., 1. + 2j])
array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])</docstring>
    <inputPortSpec arg="x" depth="1" name="x" port_type="basic:Float" show_port="True">
      <docstring>Argument of the Bessel function.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The modified Bessel function evaluated at each of the elements of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sinc" module_name="sinc" namespace="'math'">
    <docstring>Return the sinc function.

The sinc function is :math:`\sin(\pi x)/(\pi x)`.

Parameters
----------
x : ndarray
    Array (possibly multi-dimensional) of values for which to to
    calculate ``sinc(x)``.

Returns
-------
out : ndarray
    ``sinc(x)``, which has the same shape as the input.

Notes
-----
``sinc(0)`` is the limit value 1.

The name sinc is short for "sine cardinal" or "sinus cardinalis".

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
.. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
       Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, "Sinc function",
       http://en.wikipedia.org/wiki/Sinc_function

Examples
--------
&gt;&gt;&gt; x = np.linspace(-4, 4, 41)
&gt;&gt;&gt; np.sinc(x)
array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])

&gt;&gt;&gt; plt.plot(x, np.sinc(x))
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Sinc Function")
&lt;matplotlib.text.Text object at 0x...&gt;
&gt;&gt;&gt; plt.ylabel("Amplitude")
&lt;matplotlib.text.Text object at 0x...&gt;
&gt;&gt;&gt; plt.xlabel("X")
&lt;matplotlib.text.Text object at 0x...&gt;
&gt;&gt;&gt; plt.show()

It works in 2-D as well:

&gt;&gt;&gt; x = np.linspace(-4, 4, 401)
&gt;&gt;&gt; xx = np.outer(x, x)
&gt;&gt;&gt; plt.imshow(np.sinc(xx))
&lt;matplotlib.image.AxesImage object at 0x...&gt;</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array (possibly multi-dimensional) of values for which to to
calculate ``sinc(x)``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>``sinc(x)``, which has the same shape as the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.signbit" module_name="signbit" namespace="'math'">
    <docstring>signbit(x[, out])

Returns element-wise True where signbit is set (less than zero).

Parameters
----------
x : array_like
    The input value(s).
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output.  See `doc.ufuncs`.

Returns
-------
result : ndarray of bool
    Output array, or reference to `out` if that was supplied.

Examples
--------
&gt;&gt;&gt; np.signbit(-1.2)
True
&gt;&gt;&gt; np.signbit(np.array([1, -2.3, 2.1]))
array([False,  True, False], dtype=bool)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input value(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output.  See `doc.ufuncs`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" depth="1" name="result" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Output array, or reference to `out` if that was supplied.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.copysign" module_name="copysign" namespace="'math'">
    <docstring>copysign(x1, x2[, out])

Change the sign of x1 to that of x2, element-wise.

If both arguments are arrays or sequences, they have to be of the same
length. If `x2` is a scalar, its sign will be copied to all elements of
`x1`.

Parameters
----------
x1 : array_like
    Values to change the sign of.
x2 : array_like
    The sign of `x2` is copied to `x1`.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
out : array_like
    The values of `x1` with the sign of `x2`.

Examples
--------
&gt;&gt;&gt; np.copysign(1.3, -1)
-1.3
&gt;&gt;&gt; 1/np.copysign(0, 1)
inf
&gt;&gt;&gt; 1/np.copysign(0, -1)
-inf

&gt;&gt;&gt; np.copysign([-1, 0, 1], -1.1)
array([-1., -0., -1.])
&gt;&gt;&gt; np.copysign([-1, 0, 1], np.arange(3)-1)
array([-1.,  0.,  1.])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Values to change the sign of.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The sign of `x2` is copied to `x1`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of `x1` with the sign of `x2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.frexp" module_name="frexp" namespace="'math'" output_type="list">
    <docstring>frexp(x[, out1, out2])

Decompose the elements of x into mantissa and twos exponent.

Returns (`mantissa`, `exponent`), where `x = mantissa * 2**exponent``.
The mantissa is lies in the open interval(-1, 1), while the twos
exponent is a signed integer.

Parameters
----------
x : array_like
    Array of numbers to be decomposed.
out1 : ndarray, optional
    Output array for the mantissa. Must have the same shape as `x`.
out2 : ndarray, optional
    Output array for the exponent. Must have the same shape as `x`.

Returns
-------
(mantissa, exponent) : tuple of ndarrays, (float, int)
    `mantissa` is a float array with values between -1 and 1.
    `exponent` is an int array which represents the exponent of 2.

See Also
--------
ldexp : Compute ``y = x1 * 2**x2``, the inverse of `frexp`.

Notes
-----
Complex dtypes are not supported, they will raise a TypeError.

Examples
--------
&gt;&gt;&gt; x = np.arange(9)
&gt;&gt;&gt; y1, y2 = np.frexp(x)
&gt;&gt;&gt; y1
array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,
        0.5  ])
&gt;&gt;&gt; y2
array([0, 1, 2, 2, 3, 3, 3, 3, 4])
&gt;&gt;&gt; y1 * 2**y2
array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of numbers to be decomposed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out1" name="out1" port_type="basic:List">
      <docstring>Output array for the mantissa. Must have the same shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out2" name="out2" port_type="basic:List">
      <docstring>Output array for the exponent. Must have the same shape as `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="(mantissa" depth="1" name="(mantissa" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>`mantissa` is a float array with values between -1 and 1.
`exponent` is an int array which represents the exponent of 2.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="exponent)" depth="1" name="exponent)" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>`mantissa` is a float array with values between -1 and 1.
`exponent` is an int array which represents the exponent of 2.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ldexp" module_name="ldexp" namespace="'math'">
    <docstring>ldexp(x1, x2[, out])

Returns x1 * 2**x2, element-wise.

The mantissas `x1` and twos exponents `x2` are used to construct
floating point numbers ``x1 * 2**x2``.

Parameters
----------
x1 : array_like
    Array of multipliers.
x2 : array_like, int
    Array of twos exponents.
out : ndarray, optional
    Output array for the result.

Returns
-------
y : ndarray or scalar
    The result of ``x1 * 2**x2``.

See Also
--------
frexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.

Notes
-----
Complex dtypes are not supported, they will raise a TypeError.

`ldexp` is useful as the inverse of `frexp`, if used by itself it is
more clear to simply use the expression ``x1 * 2**x2``.

Examples
--------
&gt;&gt;&gt; np.ldexp(5, np.arange(4))
array([  5.,  10.,  20.,  40.], dtype=float32)

&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; np.ldexp(*np.frexp(x))
array([ 0.,  1.,  2.,  3.,  4.,  5.])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Array of multipliers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" depth="1" name="x2" port_type="basic:Integer" show_port="True">
      <docstring>Array of twos exponents.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output array for the result.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The result of ``x1 * 2**x2``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.add" module_name="add" namespace="'math'">
    <docstring>add(x1, x2[, out])

Add arguments element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be added.  If ``x1.shape != x2.shape``, they must be
    broadcastable to a common shape (which may be the shape of one or
    the other).

Returns
-------
add : ndarray or scalar
    The sum of `x1` and `x2`, element-wise.  Returns a scalar if
    both  `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.

Examples
--------
&gt;&gt;&gt; np.add(1.0, 4.0)
5.0
&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))
&gt;&gt;&gt; x2 = np.arange(3.0)
&gt;&gt;&gt; np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>The arrays to be added.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The arrays to be added.  If ``x1.shape != x2.shape``, they must be
broadcastable to a common shape (which may be the shape of one or
the other).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="add" name="add" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The sum of `x1` and `x2`, element-wise.  Returns a scalar if
both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.reciprocal" module_name="reciprocal" namespace="'math'">
    <docstring>reciprocal(x[, out])

Return the reciprocal of the argument, element-wise.

Calculates ``1/x``.

Parameters
----------
x : array_like
    Input array.

Returns
-------
y : ndarray
    Return array.

Notes
-----
.. note::
    This function is not designed to work with integers.

For integer arguments with absolute value larger than 1 the result is
always zero because of the way Python handles integer division.  For
integer zero the result is an overflow.

Examples
--------
&gt;&gt;&gt; np.reciprocal(2.)
0.5
&gt;&gt;&gt; np.reciprocal([1, 2., 3.33])
array([ 1.       ,  0.5      ,  0.3003003])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Return array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.negative" module_name="negative" namespace="'math'">
    <docstring>negative(x[, out])

Numerical negative, element-wise.

Parameters
----------
x : array_like or scalar
    Input array.

Returns
-------
y : ndarray or scalar
    Returned array or scalar: `y = -x`.

Examples
--------
&gt;&gt;&gt; np.negative([1.,-1.])
array([-1.,  1.])</docstring>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Float" show_port="True">
      <docstring>Input array.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Returned array or scalar: `y = -x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.multiply" module_name="multiply" namespace="'math'">
    <docstring>multiply(x1, x2[, out])

Multiply arguments element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays to be multiplied.

Returns
-------
y : ndarray
    The product of `x1` and `x2`, element-wise. Returns a scalar if
    both  `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` * `x2` in terms of array broadcasting.

Examples
--------
&gt;&gt;&gt; np.multiply(2.0, 4.0)
8.0

&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))
&gt;&gt;&gt; x2 = np.arange(3.0)
&gt;&gt;&gt; np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Input arrays to be multiplied.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Input arrays to be multiplied.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The product of `x1` and `x2`, element-wise. Returns a scalar if
both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.divide" module_name="divide" namespace="'math'">
    <docstring>divide(x1, x2[, out])

Divide arguments element-wise.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
y : ndarray or scalar
    The quotient ``x1/x2``, element-wise. Returns a scalar if
    both ``x1`` and ``x2`` are scalars.

See Also
--------
seterr : Set whether to raise or warn on overflow, underflow and
         division by zero.

Notes
-----
Equivalent to ``x1`` / ``x2`` in terms of array-broadcasting.

Behavior on division by zero can be changed using ``seterr``.

In Python 2, when both ``x1`` and ``x2`` are of an integer type,
``divide`` will behave like ``floor_divide``. In Python 3, it behaves
like ``true_divide``.

Examples
--------
&gt;&gt;&gt; np.divide(2.0, 4.0)
0.5
&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))
&gt;&gt;&gt; x2 = np.arange(3.0)
&gt;&gt;&gt; np.divide(x1, x2)
array([[ NaN,  1. ,  1. ],
       [ Inf,  4. ,  2.5],
       [ Inf,  7. ,  4. ]])

Note the behavior with integer types (Python 2 only):

&gt;&gt;&gt; np.divide(2, 4)
0
&gt;&gt;&gt; np.divide(2, 4.)
0.5

Division by zero always yields zero in integer arithmetic (again,
Python 2 only), and does not raise an exception or a warning:

&gt;&gt;&gt; np.divide(np.array([0, 1], dtype=int), np.array([0, 0], dtype=int))
array([0, 0])

Division by zero can, however, be caught using ``seterr``:

&gt;&gt;&gt; old_err_state = np.seterr(divide='raise')
&gt;&gt;&gt; np.divide(1, 0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
FloatingPointError: divide by zero encountered in divide

&gt;&gt;&gt; ignored_states = np.seterr(**old_err_state)
&gt;&gt;&gt; np.divide(1, 0)
0</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Dividend array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Divisor array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The quotient ``x1/x2``, element-wise. Returns a scalar if
both ``x1`` and ``x2`` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.power" module_name="power" namespace="'math'">
    <docstring>power(x1, x2[, out])

First array elements raised to powers from second array, element-wise.

Raise each base in `x1` to the positionally-corresponding power in
`x2`.  `x1` and `x2` must be broadcastable to the same shape.

Parameters
----------
x1 : array_like
    The bases.
x2 : array_like
    The exponents.

Returns
-------
y : ndarray
    The bases in `x1` raised to the exponents in `x2`.

Examples
--------
Cube each element in a list.

&gt;&gt;&gt; x1 = range(6)
&gt;&gt;&gt; x1
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; np.power(x1, 3)
array([  0,   1,   8,  27,  64, 125])

Raise the bases to different exponents.

&gt;&gt;&gt; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
&gt;&gt;&gt; np.power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])

The effect of broadcasting.

&gt;&gt;&gt; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
&gt;&gt;&gt; x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
&gt;&gt;&gt; np.power(x1, x2)
array([[ 0,  1,  8, 27, 16,  5],
       [ 0,  1,  8, 27, 16,  5]])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>The bases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The exponents.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The bases in `x1` raised to the exponents in `x2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.subtract" module_name="subtract" namespace="'math'">
    <docstring>subtract(x1, x2[, out])

Subtract arguments, element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be subtracted from each other.

Returns
-------
y : ndarray
    The difference of `x1` and `x2`, element-wise.  Returns a scalar if
    both  `x1` and `x2` are scalars.

Notes
-----
Equivalent to ``x1 - x2`` in terms of array broadcasting.

Examples
--------
&gt;&gt;&gt; np.subtract(1.0, 4.0)
-3.0

&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))
&gt;&gt;&gt; x2 = np.arange(3.0)
&gt;&gt;&gt; np.subtract(x1, x2)
array([[ 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.]])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>The arrays to be subtracted from each other.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The arrays to be subtracted from each other.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The difference of `x1` and `x2`, element-wise.  Returns a scalar if
both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.true_divide" module_name="true_divide" namespace="'math'">
    <docstring>true_divide(x1, x2[, out])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array.

Returns
-------
out : ndarray
    Result is scalar if both inputs are scalar, ndarray otherwise.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

&gt;&gt;&gt; x/4
array([0, 0, 0, 0, 1])
&gt;&gt;&gt; x//4
array([0, 0, 0, 0, 1])

&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
&gt;&gt;&gt; x//4
array([0, 0, 0, 0, 1])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Dividend array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Divisor array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result is scalar if both inputs are scalar, ndarray otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.floor_divide" module_name="floor_divide" namespace="'math'">
    <docstring>floor_divide(x1, x2[, out])

Return the largest integer smaller or equal to the division of the
inputs.

Parameters
----------
x1 : array_like
    Numerator.
x2 : array_like
    Denominator.

Returns
-------
y : ndarray
    y = floor(`x1`/`x2`)


See Also
--------
divide : Standard division.
floor : Round a number to the nearest integer toward minus infinity.
ceil : Round a number to the nearest integer toward infinity.

Examples
--------
&gt;&gt;&gt; np.floor_divide(7,3)
2
&gt;&gt;&gt; np.floor_divide([1., 2., 3., 4.], 2.5)
array([ 0.,  0.,  1.,  1.])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Numerator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Denominator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>y = floor(`x1`/`x2`)</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fmod" module_name="fmod" namespace="'math'">
    <docstring>fmod(x1, x2[, out])

Return the element-wise remainder of division.

This is the NumPy implementation of the C library function fmod, the
remainder has the same sign as the dividend `x1`. It is equivalent to
the Matlab(TM) ``rem`` function and should not be confused with the
Python modulus operator ``x1 % x2``.

Parameters
----------
x1 : array_like
  Dividend.
x2 : array_like
  Divisor.

Returns
-------
y : array_like
  The remainder of the division of `x1` by `x2`.

See Also
--------
remainder : Equivalent to the Python ``%`` operator.
divide

Notes
-----
The result of the modulo operation for negative dividend and divisors
is bound by conventions. For `fmod`, the sign of result is the sign of
the dividend, while for `remainder` the sign of the result is the sign
of the divisor. The `fmod` function is equivalent to the Matlab(TM)
``rem`` function.

Examples
--------
&gt;&gt;&gt; np.fmod([-3, -2, -1, 1, 2, 3], 2)
array([-1,  0, -1,  1,  0,  1])
&gt;&gt;&gt; np.remainder([-3, -2, -1, 1, 2, 3], 2)
array([1, 0, 1, 1, 0, 1])

&gt;&gt;&gt; np.fmod([5, 3], [2, 2.])
array([ 1.,  1.])
&gt;&gt;&gt; a = np.arange(-3, 3).reshape(3, 2)
&gt;&gt;&gt; a
array([[-3, -2],
       [-1,  0],
       [ 1,  2]])
&gt;&gt;&gt; np.fmod(a, [2,2])
array([[-1,  0],
       [-1,  0],
       [ 1,  0]])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Dividend.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Divisor.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The remainder of the division of `x1` by `x2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.mod" module_name="mod" namespace="'math'">
    <docstring>remainder(x1, x2[, out])

Return element-wise remainder of division.

Computes ``x1 - floor(x1 / x2) * x2``, the result has the same sign as
the divisor `x2`. It is equivalent to the Python modulus operator
``x1 % x2`` and should not be confused with the Matlab(TM) ``rem``
function.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
y : ndarray
    The remainder of the quotient ``x1/x2``, element-wise. Returns a
    scalar if both  `x1` and `x2` are scalars.

See Also
--------
fmod : Equivalent of the Matlab(TM) ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.

Examples
--------
&gt;&gt;&gt; np.remainder([4, 7], [2, 3])
array([0, 1])
&gt;&gt;&gt; np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Dividend array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Divisor array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The remainder of the quotient ``x1/x2``, element-wise. Returns a
scalar if both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.modf" module_name="modf" namespace="'math'" output_type="list">
    <docstring>modf(x[, out1, out2])

Return the fractional and integral parts of an array, element-wise.

The fractional and integral parts are negative if the given number is
negative.

Parameters
----------
x : array_like
    Input array.

Returns
-------
y1 : ndarray
    Fractional part of `x`.
y2 : ndarray
    Integral part of `x`.

Notes
-----
For integer input the return values are floats.

Examples
--------
&gt;&gt;&gt; np.modf([0, 3.5])
(array([ 0. ,  0.5]), array([ 0.,  3.]))
&gt;&gt;&gt; np.modf(-0.5)
(-0.5, -0)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out2" name="out2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="out1" name="out1" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y1" name="y1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Fractional part of `x`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y2" name="y2" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Integral part of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.remainder" module_name="remainder" namespace="'math'">
    <docstring>remainder(x1, x2[, out])

Return element-wise remainder of division.

Computes ``x1 - floor(x1 / x2) * x2``, the result has the same sign as
the divisor `x2`. It is equivalent to the Python modulus operator
``x1 % x2`` and should not be confused with the Matlab(TM) ``rem``
function.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
y : ndarray
    The remainder of the quotient ``x1/x2``, element-wise. Returns a
    scalar if both  `x1` and `x2` are scalars.

See Also
--------
fmod : Equivalent of the Matlab(TM) ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.

Examples
--------
&gt;&gt;&gt; np.remainder([4, 7], [2, 3])
array([0, 1])
&gt;&gt;&gt; np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>Dividend array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>Divisor array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The remainder of the quotient ``x1/x2``, element-wise. Returns a
scalar if both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.angle" module_name="angle" namespace="'math'">
    <docstring>Return the angle of the complex argument.

Parameters
----------
z : array_like
    A complex number or sequence of complex numbers.
deg : bool, optional
    Return angle in degrees if True, radians if False (default).

Returns
-------
angle : ndarray or scalar
    The counterclockwise angle from the positive real axis on
    the complex plane, with dtype as numpy.float64.

See Also
--------
arctan2
absolute



Examples
--------
&gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816])
&gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees
45.0</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>A complex number or sequence of complex numbers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="degScalar" port_type="basic:Integer">
      <docstring>Return angle in degrees if True, radians if False (default).</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="deg" name="degBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="angle" name="angle" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The counterclockwise angle from the positive real axis on
the complex plane, with dtype as numpy.float64.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.real" module_name="real" namespace="'math'">
    <docstring>Return the real part of the elements of the array.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray
    Output array. If `val` is real, the type of `val` is used for the
    output.  If `val` has complex elements, the returned type is float.

See Also
--------
real_if_close, imag, angle

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j])
&gt;&gt;&gt; a.real
array([ 1.,  3.,  5.])
&gt;&gt;&gt; a.real = 9
&gt;&gt;&gt; a
array([ 9.+2.j,  9.+4.j,  9.+6.j])
&gt;&gt;&gt; a.real = np.array([9, 8, 7])
&gt;&gt;&gt; a
array([ 9.+2.j,  8.+4.j,  7.+6.j])</docstring>
    <inputPortSpec arg="val" name="val" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array. If `val` is real, the type of `val` is used for the
output.  If `val` has complex elements, the returned type is float.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.imag" module_name="imag" namespace="'math'">
    <docstring>Return the imaginary part of the elements of the array.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray
    Output array. If `val` is real, the type of `val` is used for the
    output.  If `val` has complex elements, the returned type is float.

See Also
--------
real, angle, real_if_close

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j])
&gt;&gt;&gt; a.imag
array([ 2.,  4.,  6.])
&gt;&gt;&gt; a.imag = np.array([8, 10, 12])
&gt;&gt;&gt; a
array([ 1. +8.j,  3.+10.j,  5.+12.j])</docstring>
    <inputPortSpec arg="val" name="val" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array. If `val` is real, the type of `val` is used for the
output.  If `val` has complex elements, the returned type is float.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.conj" module_name="conj" namespace="'math'">
    <docstring>conjugate(x[, out])

Return the complex conjugate, element-wise.

The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.

Parameters
----------
x : array_like
    Input value.

Returns
-------
y : ndarray
    The complex conjugate of `x`, with same dtype as `y`.

Examples
--------
&gt;&gt;&gt; np.conjugate(1+2j)
(1-2j)

&gt;&gt;&gt; x = np.eye(2) + 1j * np.eye(2)
&gt;&gt;&gt; np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input value.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The complex conjugate of `x`, with same dtype as `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.convolve" module_name="convolve" namespace="'math'">
    <docstring>Returns the discrete, linear convolution of two one-dimensional sequences.

The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal [1]_.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.

If `v` is longer than `a`, the arrays are swapped before computation.

Parameters
----------
a : (N,) array_like
    First one-dimensional input array.
v : (M,) array_like
    Second one-dimensional input array.
mode : {'full', 'valid', 'same'}, optional
    'full':
      By default, mode is 'full'.  This returns the convolution
      at each point of overlap, with an output shape of (N+M-1,). At
      the end-points of the convolution, the signals do not overlap
      completely, and boundary effects may be seen.

    'same':
      Mode `same` returns output of length ``max(M, N)``.  Boundary
      effects are still visible.

    'valid':
      Mode `valid` returns output of length
      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
      for points where the signals overlap completely.  Values outside
      the signal boundary have no effect.

Returns
-------
out : ndarray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
                           Transform.
scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also
          accepts poly1d objects as input.

Notes
-----
The discrete convolution operation is defined as

.. math:: (a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]

It can be shown that a convolution :math:`x(t) * y(t)` in time/space
is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function `scipy.signal.fftconvolve` exploits the
FFT to calculate the convolution of large data-sets.

References
----------
.. [1] Wikipedia, "Convolution", http://en.wikipedia.org/wiki/Convolution.

Examples
--------
Note how the convolution operator flips the second array
before "sliding" the two across one another:

&gt;&gt;&gt; np.convolve([1, 2, 3], [0, 1, 0.5])
array([ 0. ,  1. ,  2.5,  4. ,  1.5])

Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:

&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'same')
array([ 1. ,  2.5,  4. ])

The two arrays are of the same length, so there
is only one position where they completely overlap:

&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'valid')
array([ 2.5])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First one-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Second one-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>'full':
  By default, mode is 'full'.  This returns the convolution
  at each point of overlap, with an output shape of (N+M-1,). At
  the end-points of the convolution, the signals do not overlap
  completely, and boundary effects may be seen.

'same':
  Mode `same` returns output of length ``max(M, N)``.  Boundary
  effects are still visible.

'valid':
  Mode `valid` returns output of length
  ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
  for points where the signals overlap completely.  Values outside
  the signal boundary have no effect.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'valid', 'same']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Discrete, linear convolution of `a` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.clip" module_name="clip" namespace="'math'">
    <docstring>Clip (limit) the values in an array.

Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of ``[0, 1]``
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.

Parameters
----------
a : array_like
    Array containing elements to clip.
a_min : scalar or array_like
    Minimum value.
a_max : scalar or array_like
    Maximum value.  If `a_min` or `a_max` are array_like, then they will
    be broadcasted to the shape of `a`.
out : ndarray, optional
    The results will be placed in this array. It may be the input
    array for in-place clipping.  `out` must be of the right shape
    to hold the output.  Its type is preserved.

Returns
-------
clipped_array : ndarray
    An array with the elements of `a`, but where values
    &lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`
    with `a_max`.

See Also
--------
numpy.doc.ufuncs : Section "Output arguments"

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing elements to clip.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a_min" name="a_minScalar" port_type="basic:Float" show_port="True">
      <docstring>Minimum value.</docstring>
      <alternateSpec arg="a_min" name="a_minSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="a_max" name="a_maxScalar" port_type="basic:Float" show_port="True">
      <docstring>Maximum value.  If `a_min` or `a_max` are array_like, then they will
be broadcasted to the shape of `a`.</docstring>
      <alternateSpec arg="a_max" name="a_maxSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>The results will be placed in this array. It may be the input
array for in-place clipping.  `out` must be of the right shape
to hold the output.  Its type is preserved.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="clipped_array" name="clipped_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array with the elements of `a`, but where values
&lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`
with `a_max`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sqrt" module_name="sqrt" namespace="'math'">
    <docstring>sqrt(x[, out])

Return the positive square-root of an array, element-wise.

Parameters
----------
x : array_like
    The values whose square-roots are required.
out : ndarray, optional
    Alternate array object in which to put the result; if provided, it
    must have the same shape as `x`

Returns
-------
y : ndarray
    An array of the same shape as `x`, containing the positive
    square-root of each element in `x`.  If any element in `x` is
    complex, a complex array is returned (and the square-roots of
    negative reals are calculated).  If all of the elements in `x`
    are real, so is `y`, with negative elements returning ``nan``.
    If `out` was provided, `y` is a reference to it.

See Also
--------
lib.scimath.sqrt
    A version which returns complex numbers when given negative reals.

Notes
-----
*sqrt* has--consistent with common convention--as its branch cut the
real "interval" [`-inf`, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.

Examples
--------
&gt;&gt;&gt; np.sqrt([1,4,9])
array([ 1.,  2.,  3.])

&gt;&gt;&gt; np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])

&gt;&gt;&gt; np.sqrt([4, -1, numpy.inf])
array([  2.,  NaN,  Inf])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The values whose square-roots are required.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate array object in which to put the result; if provided, it
must have the same shape as `x`</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of the same shape as `x`, containing the positive
square-root of each element in `x`.  If any element in `x` is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in `x`
are real, so is `y`, with negative elements returning ``nan``.
If `out` was provided, `y` is a reference to it.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.square" module_name="square" namespace="'math'">
    <docstring>square(x[, out])

Return the element-wise square of the input.

Parameters
----------
x : array_like
    Input data.

Returns
-------
out : ndarray
    Element-wise `x*x`, of the same shape and dtype as `x`.
    Returns scalar if `x` is a scalar.

See Also
--------
numpy.linalg.matrix_power
sqrt
power

Examples
--------
&gt;&gt;&gt; np.square([-1j, 1])
array([-1.-0.j,  1.+0.j])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Element-wise `x*x`, of the same shape and dtype as `x`.
Returns scalar if `x` is a scalar.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.absolute" module_name="absolute" namespace="'math'">
    <docstring>absolute(x[, out])

Calculate the absolute value element-wise.

Parameters
----------
x : array_like
    Input array.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.

Examples
--------
&gt;&gt;&gt; x = np.array([-1.2, 1.2])
&gt;&gt;&gt; np.absolute(x)
array([ 1.2,  1.2])
&gt;&gt;&gt; np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; x = np.linspace(start=-10, stop=10, num=101)
&gt;&gt;&gt; plt.plot(x, np.absolute(x))
&gt;&gt;&gt; plt.show()

Plot the function over the complex plane:

&gt;&gt;&gt; xx = x + 1j * x[:, np.newaxis]
&gt;&gt;&gt; plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="absolute" name="absolute" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An ndarray containing the absolute value of
each element in `x`.  For complex input, ``a + ib``, the
absolute value is :math:`\sqrt{ a^2 + b^2 }`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fabs" module_name="fabs" namespace="'math'">
    <docstring>fabs(x[, out])

Compute the absolute values element-wise.

This function returns the absolute values (positive magnitude) of the
data in `x`. Complex values are not handled, use `absolute` to find the
absolute values of complex data.

Parameters
----------
x : array_like
    The array of numbers for which the absolute values are required. If
    `x` is a scalar, the result `y` will also be a scalar.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and it
    must be of the right shape to hold the output. See doc.ufuncs.

Returns
-------
y : ndarray or scalar
    The absolute values of `x`, the returned values are always floats.

See Also
--------
absolute : Absolute values including `complex` types.

Examples
--------
&gt;&gt;&gt; np.fabs(-1)
1.0
&gt;&gt;&gt; np.fabs([-1.2, 1.2])
array([ 1.2,  1.2])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array of numbers for which the absolute values are required. If
`x` is a scalar, the result `y` will also be a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed. Its type is preserved and it
must be of the right shape to hold the output. See doc.ufuncs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The absolute values of `x`, the returned values are always floats.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sign" module_name="sign" namespace="'math'">
    <docstring>sign(x[, out])

Returns an element-wise indication of the sign of a number.

The `sign` function returns ``-1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0``.

Parameters
----------
x : array_like
  Input values.

Returns
-------
y : ndarray
  The sign of `x`.

Examples
--------
&gt;&gt;&gt; np.sign([-5., 4.5])
array([-1.,  1.])
&gt;&gt;&gt; np.sign(0)
0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The sign of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.maximum" module_name="maximum" namespace="'math'">
    <docstring>maximum(x1, x2[, out])

Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. They must have
    the same shape, or shapes that can be broadcast to a single shape.

Returns
-------
y : ndarray or scalar
    The maximum of `x1` and `x2`, element-wise.  Returns scalar if
    both  `x1` and `x2` are scalars.

See Also
--------
minimum :
    Element-wise minimum of two arrays, propagates NaNs.
fmax :
    Element-wise maximum of two arrays, ignores NaNs.
amax :
    The maximum value of an array along a given axis, propagates NaNs.
nanmax :
    The maximum value of an array along a given axis, ignores NaNs.

fmin, amin, nanmin

Notes
-----
The maximum is equivalent to ``np.where(x1 &gt;= x2, x1, x2)`` when
neither x1 nor x2 are nans, but it is faster and does proper
broadcasting.

Examples
--------
&gt;&gt;&gt; np.maximum([2, 3, 4], [1, 5, 2])
array([2, 5, 4])

&gt;&gt;&gt; np.maximum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

&gt;&gt;&gt; np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
array([ NaN,  NaN,  NaN])
&gt;&gt;&gt; np.maximum(np.Inf, 1)
inf</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>The arrays holding the elements to be compared. They must have
the same shape, or shapes that can be broadcast to a single shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The arrays holding the elements to be compared. They must have
the same shape, or shapes that can be broadcast to a single shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The maximum of `x1` and `x2`, element-wise.  Returns scalar if
both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fmax" module_name="fmax" namespace="'math'">
    <docstring>fmax(x1, x2[, out])

Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then the
non-nan element is returned. If both elements are NaNs then the first
is returned.  The latter distinction is important for complex NaNs,
which are defined as at least one of the real or imaginary parts being
a NaN. The net effect is that NaNs are ignored when possible.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. They must have
    the same shape.

Returns
-------
y : ndarray or scalar
    The maximum of `x1` and `x2`, element-wise.  Returns scalar if
    both  `x1` and `x2` are scalars.

See Also
--------
fmin :
    Element-wise minimum of two arrays, ignores NaNs.
maximum :
    Element-wise maximum of two arrays, propagates NaNs.
amax :
    The maximum value of an array along a given axis, propagates NaNs.
nanmax :
    The maximum value of an array along a given axis, ignores NaNs.

minimum, amin, nanmin

Notes
-----
.. versionadded:: 1.3.0

The fmax is equivalent to ``np.where(x1 &gt;= x2, x1, x2)`` when neither
x1 nor x2 are NaNs, but it is faster and does proper broadcasting.

Examples
--------
&gt;&gt;&gt; np.fmax([2, 3, 4], [1, 5, 2])
array([ 2.,  5.,  4.])

&gt;&gt;&gt; np.fmax(np.eye(2), [0.5, 2])
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

&gt;&gt;&gt; np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([  0.,   0.,  NaN])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>The arrays holding the elements to be compared. They must have
the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The arrays holding the elements to be compared. They must have
the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The maximum of `x1` and `x2`, element-wise.  Returns scalar if
both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fmin" module_name="fmin" namespace="'math'">
    <docstring>fmin(x1, x2[, out])

Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then the
non-nan element is returned. If both elements are NaNs then the first
is returned.  The latter distinction is important for complex NaNs,
which are defined as at least one of the real or imaginary parts being
a NaN. The net effect is that NaNs are ignored when possible.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. They must have
    the same shape.

Returns
-------
y : ndarray or scalar
    The minimum of `x1` and `x2`, element-wise.  Returns scalar if
    both  `x1` and `x2` are scalars.

See Also
--------
fmax :
    Element-wise maximum of two arrays, ignores NaNs.
minimum :
    Element-wise minimum of two arrays, propagates NaNs.
amin :
    The minimum value of an array along a given axis, propagates NaNs.
nanmin :
    The minimum value of an array along a given axis, ignores NaNs.

maximum, amax, nanmax

Notes
-----
.. versionadded:: 1.3.0

The fmin is equivalent to ``np.where(x1 &lt;= x2, x1, x2)`` when neither
x1 nor x2 are NaNs, but it is faster and does proper broadcasting.

Examples
--------
&gt;&gt;&gt; np.fmin([2, 3, 4], [1, 5, 2])
array([2, 5, 4])

&gt;&gt;&gt; np.fmin(np.eye(2), [0.5, 2])
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

&gt;&gt;&gt; np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([  0.,   0.,  NaN])</docstring>
    <inputPortSpec arg="x1" name="x1" port_type="basic:List" show_port="True">
      <docstring>The arrays holding the elements to be compared. They must have
the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2" port_type="basic:List" show_port="True">
      <docstring>The arrays holding the elements to be compared. They must have
the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The minimum of `x1` and `x2`, element-wise.  Returns scalar if
both  `x1` and `x2` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nan_to_num" module_name="nan_to_num" namespace="'math'">
    <docstring>Replace nan with zero and inf with finite numbers.

Returns an array or scalar replacing Not a Number (NaN) with zero,
(positive) infinity with a very large number and negative infinity
with a very small (or negative) number.

Parameters
----------
x : array_like
    Input data.

Returns
-------
out : ndarray
    New Array with the same shape as `x` and dtype of the element in
    `x`  with the greatest precision. If `x` is inexact, then NaN is
    replaced by zero, and infinity (-infinity) is replaced by the
    largest (smallest or most negative) floating point value that fits
    in the output dtype. If `x` is not inexact, then a copy of `x` is
    returned.

See Also
--------
isinf : Shows which elements are negative or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.


Examples
--------
&gt;&gt;&gt; np.set_printoptions(precision=8)
&gt;&gt;&gt; x = np.array([np.inf, -np.inf, np.nan, -128, 128])
&gt;&gt;&gt; np.nan_to_num(x)
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
        -1.28000000e+002,   1.28000000e+002])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>New Array with the same shape as `x` and dtype of the element in
`x`  with the greatest precision. If `x` is inexact, then NaN is
replaced by zero, and infinity (-infinity) is replaced by the
largest (smallest or most negative) floating point value that fits
in the output dtype. If `x` is not inexact, then a copy of `x` is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.real_if_close" module_name="real_if_close" namespace="'math'">
    <docstring>If complex input returns a real array if complex parts are close to zero.

"Close to zero" is defined as `tol` * (machine epsilon of the type for
`a`).

Parameters
----------
a : array_like
    Input array.
tol : float
    Tolerance in machine epsilons for the complex part of the elements
    in the array.

Returns
-------
out : ndarray
    If `a` is real, the type of `a` is used for the output.  If `a`
    has complex elements, the returned type is float.

See Also
--------
real, imag, angle

Notes
-----
Machine epsilon varies from machine to machine and between data types
but Python floats on most platforms have a machine epsilon equal to
2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print
out the machine epsilon for floats.

Examples
--------
&gt;&gt;&gt; np.finfo(np.float).eps
2.2204460492503131e-16

&gt;&gt;&gt; np.real_if_close([2.1 + 4e-14j], tol=1000)
array([ 2.1])
&gt;&gt;&gt; np.real_if_close([2.1 + 4e-13j], tol=1000)
array([ 2.1 +4.00000000e-13j])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance in machine epsilons for the complex part of the elements
in the array.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `a` is real, the type of `a` is used for the output.  If `a`
has complex elements, the returned type is float.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.interp" module_name="interp" namespace="'math'">
    <docstring>One-dimensional linear interpolation.

Returns the one-dimensional piecewise linear interpolant to a function
with given values at discrete data-points.

Parameters
----------
x : array_like
    The x-coordinates of the interpolated values.

xp : 1-D sequence of floats
    The x-coordinates of the data points, must be increasing if argument
    `period` is not specified. Otherwise, `xp` is internally sorted after
    normalizing the periodic boundaries with ``xp = xp % period``.

fp : 1-D sequence of floats
    The y-coordinates of the data points, same length as `xp`.

left : float, optional
    Value to return for `x &lt; xp[0]`, default is `fp[0]`.

right : float, optional
    Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.

period : None or float, optional
    A period for the x-coordinates. This parameter allows the proper
    interpolation of angular x-coordinates. Parameters `left` and `right`
    are ignored if `period` is specified.

    .. versionadded:: 1.10.0

Returns
-------
y : float or ndarray
    The interpolated values, same shape as `x`.

Raises
------
ValueError
    If `xp` and `fp` have different length
    If `xp` or `fp` are not 1-D sequences
    If `period == 0`

Notes
-----
Does not check that the x-coordinate sequence `xp` is increasing.
If `xp` is not increasing, the results are nonsense.
A simple check for increasing is::

    np.all(np.diff(xp) &gt; 0)

Examples
--------
&gt;&gt;&gt; xp = [1, 2, 3]
&gt;&gt;&gt; fp = [3, 2, 0]
&gt;&gt;&gt; np.interp(2.5, xp, fp)
1.0
&gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])
&gt;&gt;&gt; UNDEF = -99.0
&gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)
-99.0

Plot an interpolant to the sine function:

&gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)
&gt;&gt;&gt; y = np.sin(x)
&gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)
&gt;&gt;&gt; yinterp = np.interp(xvals, x, y)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x, y, 'o')
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.plot(xvals, yinterp, '-x')
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.show()

Interpolation with periodic x-coordinates:

&gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]
&gt;&gt;&gt; xp = [190, -190, 350, -350]
&gt;&gt;&gt; fp = [5, 10, 3, 4]
&gt;&gt;&gt; np.interp(x, xp, fp, period=360)
array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The x-coordinates of the interpolated values.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xp" depth="1" name="xp" port_type="basic:Float" show_port="True">
      <docstring>The x-coordinates of the data points, must be increasing if argument
`period` is not specified. Otherwise, `xp` is internally sorted after
normalizing the periodic boundaries with ``xp = xp % period``.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fp" depth="1" name="fp" port_type="basic:Float" show_port="True">
      <docstring>The y-coordinates of the data points, same length as `xp`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="left" name="left" port_type="basic:Float">
      <docstring>Value to return for `x &lt; xp[0]`, default is `fp[0]`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="right" name="right" port_type="basic:Float">
      <docstring>Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>A period for the x-coordinates. This parameter allows the proper
interpolation of angular x-coordinates. Parameters `left` and `right`
are ignored if `period` is specified.

.. versionadded:: 1.10.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The interpolated values, same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sort" module_name="sort" namespace="'sort'">
    <docstring>Return a sorted copy of an array.

Parameters
----------
a : array_like
    Array to be sorted.
axis : int or None, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort'}, optional
    Sorting algorithm. Default is 'quicksort'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.

Notes
-----
The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The three available algorithms have the following
properties:

=========== ======= ============= ============ =======
   kind      speed   worst case    work space  stable
=========== ======= ============= ============ =======
'quicksort'    1     O(n^2)            0          no
'mergesort'    2     O(n*log(n))      ~n/2        yes
'heapsort'     3     O(n*log(n))       0          no
=========== ======= ============= ============ =======

All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.

The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.

Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:

  * Real: [R, nan]
  * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]

where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.

Examples
--------
&gt;&gt;&gt; a = np.array([[1,4],[3,1]])
&gt;&gt;&gt; np.sort(a)                # sort along the last axis
array([[1, 4],
       [1, 3]])
&gt;&gt;&gt; np.sort(a, axis=None)     # sort the flattened array
array([1, 1, 3, 4])
&gt;&gt;&gt; np.sort(a, axis=0)        # sort along the first axis
array([[1, 1],
       [3, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

&gt;&gt;&gt; dtype = [('name', 'S10'), ('height', float), ('age', int)]
&gt;&gt;&gt; values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
...           ('Galahad', 1.7, 38)]
&gt;&gt;&gt; a = np.array(values, dtype=dtype)       # create a structured array
&gt;&gt;&gt; np.sort(a, order='height')                        # doctest: +SKIP
array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
       ('Lancelot', 1.8999999999999999, 38)],
      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])

Sort by age, then height if ages are equal:

&gt;&gt;&gt; np.sort(a, order=['age', 'height'])               # doctest: +SKIP
array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
       ('Arthur', 1.8, 41)],
      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to be sorted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Sorting algorithm. Default is 'quicksort'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['quicksort', 'mergesort', 'heapsort']]</values>
      <defaults>['quicksort']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="orderScalar">
      <docstring>When `a` is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</docstring>
      <alternateSpec arg="order" depth="1" name="orderSequence" />
    </inputPortSpec>
    <outputPortSpec arg="sorted_array" name="sorted_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the same type and shape as `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.lexsort" module_name="lexsort" namespace="'sort'">
    <docstring>lexsort(keys, axis=-1)

Perform an indirect sort using a sequence of keys.

Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, it's rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.

Parameters
----------
keys : (k, N) array or tuple containing k (N,)-shaped sequences
    The `k` different "columns" to be sorted.  The last column (or row if
    `keys` is a 2D array) is the primary sort key.
axis : int, optional
    Axis to be indirectly sorted.  By default, sort over the last axis.

Returns
-------
indices : (N,) ndarray of ints
    Array of indices that sort the keys along the specified axis.

See Also
--------
argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.

Examples
--------
Sort names: first by surname, then by name.

&gt;&gt;&gt; surnames =    ('Hertz',    'Galilei', 'Hertz')
&gt;&gt;&gt; first_names = ('Heinrich', 'Galileo', 'Gustav')
&gt;&gt;&gt; ind = np.lexsort((first_names, surnames))
&gt;&gt;&gt; ind
array([1, 2, 0])

&gt;&gt;&gt; [surnames[i] + ", " + first_names[i] for i in ind]
['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']

Sort two columns of numbers:

&gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column
&gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column
&gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b
&gt;&gt;&gt; print ind
[2 0 4 6 5 3 1]

&gt;&gt;&gt; [(a[i],b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]

Note that sorting is first according to the elements of ``a``.
Secondary sorting is according to the elements of ``b``.

A normal ``argsort`` would have yielded:

&gt;&gt;&gt; [(a[i],b[i]) for i in np.argsort(a)]
[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]

Structured arrays are sorted lexically by ``argsort``:

&gt;&gt;&gt; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
...              dtype=np.dtype([('x', int), ('y', int)]))

&gt;&gt;&gt; np.argsort(x) # or np.argsort(x, order=('x', 'y'))
array([2, 0, 4, 6, 5, 3, 1])</docstring>
    <inputPortSpec arg="keys" name="keys" port_type="basic:List" show_port="True">
      <docstring>The `k` different "columns" to be sorted.  The last column (or row if
`keys` is a 2D array) is the primary sort key.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis to be indirectly sorted.  By default, sort over the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="indices" depth="1" name="indices" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of indices that sort the keys along the specified axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.argsort" module_name="argsort" namespace="'sort'">
    <docstring>Returns the indices that would sort an array.

Perform an indirect sort along the given axis using the algorithm specified
by the `kind` keyword. It returns an array of indices of the same shape as
`a` that index data along the given axis in sorted order.

Parameters
----------
a : array_like
    Array to sort.
axis : int or None, optional
    Axis along which to sort.  The default is -1 (the last axis). If None,
    the flattened array is used.
kind : {'quicksort', 'mergesort', 'heapsort'}, optional
    Sorting algorithm.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
nan values. The enhanced sort order is documented in `sort`.

Examples
--------
One dimensional array:

&gt;&gt;&gt; x = np.array([3, 1, 2])
&gt;&gt;&gt; np.argsort(x)
array([1, 2, 0])

Two-dimensional array:

&gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])
&gt;&gt;&gt; x
array([[0, 3],
       [2, 2]])

&gt;&gt;&gt; np.argsort(x, axis=0)
array([[0, 1],
       [1, 0]])

&gt;&gt;&gt; np.argsort(x, axis=1)
array([[0, 1],
       [0, 1]])

Sorting with keys:

&gt;&gt;&gt; x = np.array([(1, 0), (0, 1)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])
&gt;&gt;&gt; x
array([(1, 0), (0, 1)],
      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])

&gt;&gt;&gt; np.argsort(x, order=('x','y'))
array([1, 0])

&gt;&gt;&gt; np.argsort(x, order=('y','x'))
array([0, 1])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to sort.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Sorting algorithm.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['quicksort', 'mergesort', 'heapsort']]</values>
      <defaults>['quicksort']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="orderScalar">
      <docstring>When `a` is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</docstring>
      <alternateSpec arg="order" depth="1" name="orderSequence" />
    </inputPortSpec>
    <outputPortSpec arg="index_array" depth="1" name="index_array" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of indices that sort `a` along the specified axis.
In other words, ``a[index_array]`` yields a sorted `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.msort" module_name="msort" namespace="'sort'">
    <docstring>Return a copy of an array sorted along the first axis.

Parameters
----------
a : array_like
    Array to be sorted.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
sort

Notes
-----
``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to be sorted.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sorted_array" name="sorted_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the same type and shape as `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.sort_complex" module_name="sort_complex" namespace="'sort'">
    <docstring>Sort a complex array using the real part first, then the imaginary part.

Parameters
----------
a : array_like
    Input array

Returns
-------
out : complex ndarray
    Always returns a sorted complex array.

Examples
--------
&gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])
array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])

&gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Always returns a sorted complex array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.partition" module_name="partition" namespace="'sort'">
    <docstring>Return a partitioned copy of an array.

Creates a copy of the array with its elements rearranged in such a way that
the value of the element in kth position is in the position it would be in
a sorted array. All elements smaller than the kth element are moved before
this element and all equal or greater are moved behind it. The ordering of
the elements in the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array to be sorted.
kth : int or sequence of ints
    Element index to partition by. The kth value of the element will be in
    its final sorted position and all smaller elements will be moved before
    it and all equal or greater elements behind it.
    The order all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth  of them into their sorted position at once.
axis : int or None, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string.  Not all fields need be specified, but
    unspecified fields will still be used, in the order in which they
    come up in the dtype, to break ties.

Returns
-------
partitioned_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.partition : Method to sort an array in-place.
argpartition : Indirect partition.
sort : Full sorting

Notes
-----
The various selection algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative order. The
available algorithms have the following properties:

================= ======= ============= ============ =======
   kind            speed   worst case    work space  stable
================= ======= ============= ============ =======
'introselect'        1        O(n)           0         no
================= ======= ============= ============ =======

All the partition algorithms make temporary copies of the data when
partitioning along any but the last axis.  Consequently, partitioning
along the last axis is faster and uses less space than partitioning
along any other axis.

The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.

Examples
--------
&gt;&gt;&gt; a = np.array([3, 4, 2, 1])
&gt;&gt;&gt; np.partition(a, 3)
array([2, 1, 3, 4])

&gt;&gt;&gt; np.partition(a, (1, 3))
array([1, 2, 3, 4])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to be sorted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kth" name="kthScalar" port_type="basic:Integer" show_port="True">
      <docstring>Element index to partition by. The kth value of the element will be in
its final sorted position and all smaller elements will be moved before
it and all equal or greater elements behind it.
The order all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all elements
indexed by kth  of them into their sorted position at once.</docstring>
      <alternateSpec arg="kth" depth="1" name="kthSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Selection algorithm. Default is 'introselect'.</docstring>
      <defaults>['introselect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="orderScalar">
      <docstring>When `a` is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string.  Not all fields need be specified, but
unspecified fields will still be used, in the order in which they
come up in the dtype, to break ties.</docstring>
      <alternateSpec arg="order" depth="1" name="orderSequence" />
    </inputPortSpec>
    <outputPortSpec arg="partitioned_array" name="partitioned_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the same type and shape as `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.argpartition" module_name="argpartition" namespace="'sort'">
    <docstring>Perform an indirect partition along the given axis using the algorithm
specified by the `kind` keyword. It returns an array of indices of the
same shape as `a` that index data along the given axis in partitioned
order.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array to sort.
kth : int or sequence of ints
    Element index to partition by. The kth element will be in its final
    sorted position and all smaller elements will be moved before it and
    all larger elements behind it.
    The order all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all of them into
    their sorted position at once.
axis : int or None, optional
    Axis along which to sort.  The default is -1 (the last axis). If None,
    the flattened array is used.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
index_array : ndarray, int
    Array of indices that partition `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
partition : Describes partition algorithms used.
ndarray.partition : Inplace partition.
argsort : Full indirect sort

Notes
-----
See `partition` for notes on the different selection algorithms.

Examples
--------
One dimensional array:

&gt;&gt;&gt; x = np.array([3, 4, 2, 1])
&gt;&gt;&gt; x[np.argpartition(x, 3)]
array([2, 1, 3, 4])
&gt;&gt;&gt; x[np.argpartition(x, (1, 3))]
array([1, 2, 3, 4])

&gt;&gt;&gt; x = [3, 4, 2, 1]
&gt;&gt;&gt; np.array(x)[np.argpartition(x, 3)]
array([2, 1, 3, 4])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to sort.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kth" name="kthScalar" port_type="basic:Integer" show_port="True">
      <docstring>Element index to partition by. The kth element will be in its final
sorted position and all smaller elements will be moved before it and
all larger elements behind it.
The order all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all of them into
their sorted position at once.</docstring>
      <alternateSpec arg="kth" depth="1" name="kthSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Selection algorithm. Default is 'introselect'</docstring>
      <defaults>['introselect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="orderScalar">
      <docstring>When `a` is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</docstring>
      <alternateSpec arg="order" depth="1" name="orderSequence" />
    </inputPortSpec>
    <outputPortSpec arg="index_array" depth="1" name="index_array" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of indices that partition `a` along the specified axis.
In other words, ``a[index_array]`` yields a sorted `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.argmax" module_name="argmax" namespace="'sort'">
    <docstring>Returns the indices of the maximum values along an axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    By default, the index is into the flattened array, otherwise
    along the specified axis.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.

Returns
-------
index_array : ndarray of ints
    Array of indices into the array. It has the same shape as `a.shape`
    with the dimension along `axis` removed.

See Also
--------
ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.

Notes
-----
In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.

Examples
--------
&gt;&gt;&gt; a = np.arange(6).reshape(2,3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.argmax(a)
5
&gt;&gt;&gt; np.argmax(a, axis=0)
array([1, 1, 1])
&gt;&gt;&gt; np.argmax(a, axis=1)
array([2, 2])

&gt;&gt;&gt; b = np.arange(6)
&gt;&gt;&gt; b[1] = 5
&gt;&gt;&gt; b
array([0, 5, 2, 3, 4, 5])
&gt;&gt;&gt; np.argmax(b) # Only the first occurrence is returned.
1</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>By default, the index is into the flattened array, otherwise
along the specified axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="index_array" depth="1" name="index_array" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of indices into the array. It has the same shape as `a.shape`
with the dimension along `axis` removed.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanargmax" module_name="nanargmax" namespace="'sort'">
    <docstring>Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.


Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmax, nanargmin

Examples
--------
&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])
&gt;&gt;&gt; np.argmax(a)
0
&gt;&gt;&gt; np.nanargmax(a)
1
&gt;&gt;&gt; np.nanargmax(a, axis=0)
array([1, 0])
&gt;&gt;&gt; np.nanargmax(a, axis=1)
array([1, 1])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to operate.  By default flattened input is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="index_array" name="index_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of indices or a single index value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.argmin" module_name="argmin" namespace="'sort'">
    <docstring>Returns the indices of the minimum values along an axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    By default, the index is into the flattened array, otherwise
    along the specified axis.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.

Returns
-------
index_array : ndarray of ints
    Array of indices into the array. It has the same shape as `a.shape`
    with the dimension along `axis` removed.

See Also
--------
ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.

Notes
-----
In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.

Examples
--------
&gt;&gt;&gt; a = np.arange(6).reshape(2,3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.argmin(a)
0
&gt;&gt;&gt; np.argmin(a, axis=0)
array([0, 0, 0])
&gt;&gt;&gt; np.argmin(a, axis=1)
array([0, 0])

&gt;&gt;&gt; b = np.arange(6)
&gt;&gt;&gt; b[4] = 0
&gt;&gt;&gt; b
array([0, 1, 2, 3, 0, 5])
&gt;&gt;&gt; np.argmin(b) # Only the first occurrence is returned.
0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>By default, the index is into the flattened array, otherwise
along the specified axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="index_array" depth="1" name="index_array" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of indices into the array. It has the same shape as `a.shape`
with the dimension along `axis` removed.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanargmin" module_name="nanargmin" namespace="'sort'">
    <docstring>Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmin, nanargmax

Examples
--------
&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])
&gt;&gt;&gt; np.argmin(a)
0
&gt;&gt;&gt; np.nanargmin(a)
2
&gt;&gt;&gt; np.nanargmin(a, axis=0)
array([1, 1])
&gt;&gt;&gt; np.nanargmin(a, axis=1)
array([1, 0])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to operate.  By default flattened input is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="index_array" name="index_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of indices or a single index value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.argwhere" module_name="argwhere" namespace="'sort'">
    <docstring>Find the indices of array elements that are non-zero, grouped by element.

Parameters
----------
a : array_like
    Input data.

Returns
-------
index_array : ndarray
    Indices of elements that are non-zero. Indices are grouped by element.

See Also
--------
where, nonzero

Notes
-----
``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.

The output of ``argwhere`` is not suitable for indexing arrays.
For this purpose use ``where(a)`` instead.

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2,3)
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.argwhere(x&gt;1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="index_array" name="index_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Indices of elements that are non-zero. Indices are grouped by element.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nonzero" module_name="nonzero" namespace="'sort'">
    <docstring>Return the indices of the elements that are non-zero.

Returns a tuple of arrays, one for each dimension of `a`,
containing the indices of the non-zero elements in that
dimension. The values in `a` are always tested and returned in
row-major, C-style order. The corresponding non-zero
values can be obtained with::

    a[nonzero(a)]

To group the indices by element, rather than dimension, use::

    transpose(nonzero(a))

The result of this is always a 2-D array, with a row for
each non-zero element.

Parameters
----------
a : array_like
    Input array.

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Examples
--------
&gt;&gt;&gt; x = np.eye(3)
&gt;&gt;&gt; x
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; np.nonzero(x)
(array([0, 1, 2]), array([0, 1, 2]))

&gt;&gt;&gt; x[np.nonzero(x)]
array([ 1.,  1.,  1.])
&gt;&gt;&gt; np.transpose(np.nonzero(x))
array([[0, 0],
       [1, 1],
       [2, 2]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the `a` where the condition is true.

&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; a &gt; 3
array([[False, False, False],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
&gt;&gt;&gt; np.nonzero(a &gt; 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

The ``nonzero`` method of the boolean array can also be called.

&gt;&gt;&gt; (a &gt; 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tuple_of_arrays" name="tuple_of_arrays" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Indices of elements that are non-zero.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.where" module_name="where" namespace="'sort'">
    <docstring>where(condition, [x, y])

Return elements, either from `x` or `y`, depending on `condition`.

If only `condition` is given, return ``condition.nonzero()``.

Parameters
----------
condition : array_like, bool
    When True, yield `x`, otherwise yield `y`.
x, y : array_like, optional
    Values from which to choose. `x` and `y` need to have the same
    shape as `condition`.

Returns
-------
out : ndarray or tuple of ndarrays
    If both `x` and `y` are specified, the output array contains
    elements of `x` where `condition` is True, and elements from
    `y` elsewhere.

    If only `condition` is given, return the tuple
    ``condition.nonzero()``, the indices where `condition` is True.

See Also
--------
nonzero, choose

Notes
-----
If `x` and `y` are given and input arrays are 1-D, `where` is
equivalent to::

    [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]

Examples
--------
&gt;&gt;&gt; np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])

&gt;&gt;&gt; np.where([[0, 1], [1, 0]])
(array([0, 1]), array([1, 0]))

&gt;&gt;&gt; x = np.arange(9.).reshape(3, 3)
&gt;&gt;&gt; np.where( x &gt; 5 )
(array([2, 2, 2]), array([0, 1, 2]))
&gt;&gt;&gt; x[np.where( x &gt; 3.0 )]               # Note: result is 1D.
array([ 4.,  5.,  6.,  7.,  8.])
&gt;&gt;&gt; np.where(x &lt; 5, x, -1)               # Note: broadcasting.
array([[ 0.,  1.,  2.],
       [ 3.,  4., -1.],
       [-1., -1., -1.]])

Find the indices of elements of `x` that are in `goodvalues`.

&gt;&gt;&gt; goodvalues = [3, 4, 7]
&gt;&gt;&gt; ix = np.in1d(x.ravel(), goodvalues).reshape(x.shape)
&gt;&gt;&gt; ix
array([[False, False, False],
       [ True,  True, False],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; np.where(ix)
(array([1, 1, 2]), array([0, 1, 1]))</docstring>
    <inputPortSpec arg="condition" depth="1" name="condition" port_type="basic:Boolean" show_port="True">
      <docstring>When True, yield `x`, otherwise yield `y`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>Values from which to choose. `x` and `y` need to have the same
shape as `condition`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>Values from which to choose. `x` and `y` need to have the same
shape as `condition`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If both `x` and `y` are specified, the output array contains
elements of `x` where `condition` is True, and elements from
`y` elsewhere.

If only `condition` is given, return the tuple
``condition.nonzero()``, the indices where `condition` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.searchsorted" module_name="searchsorted" namespace="'sort'">
    <docstring>Find indices where elements should be inserted to maintain order.

Find the indices into a sorted array `a` such that, if the
corresponding elements in `v` were inserted before the indices, the
order of `a` would be preserved.

Parameters
----------
a : 1-D array_like
    Input array. If `sorter` is None, then it must be sorted in
    ascending order, otherwise `sorter` must be an array of indices
    that sort it.
v : array_like
    Values to insert into `a`.
side : {'left', 'right'}, optional
    If 'left', the index of the first suitable location found is given.
    If 'right', return the last such index.  If there is no suitable
    index, return either 0 or N (where N is the length of `a`).
sorter : 1-D array_like, optional
    Optional array of integer indices that sort array a into ascending
    order. They are typically the result of argsort.

    .. versionadded:: 1.7.0

Returns
-------
indices : array of ints
    Array of insertion points with the same shape as `v`.

See Also
--------
sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.

Notes
-----
Binary search is used to find the required insertion points.

As of Numpy 1.4.0 `searchsorted` works with real/complex arrays containing
`nan` values. The enhanced sort order is documented in `sort`.

Examples
--------
&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3)
2
&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3, side='right')
3
&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
array([0, 5, 1, 2])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array. If `sorter` is None, then it must be sorted in
ascending order, otherwise `sorter` must be an array of indices
that sort it.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Values to insert into `a`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="side" name="side">
      <docstring>If 'left', the index of the first suitable location found is given.
If 'right', return the last such index.  If there is no suitable
index, return either 0 or N (where N is the length of `a`).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['left', 'right']]</values>
      <defaults>['left']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sorter" name="sorter" port_type="basic:List">
      <docstring>Optional array of integer indices that sort array a into ascending
order. They are typically the result of argsort.

.. versionadded:: 1.7.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="indices" depth="1" name="indices" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of insertion points with the same shape as `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.extract" module_name="extract" namespace="'sort'">
    <docstring>Return the elements of an array that satisfy some condition.

This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.

Note that `place` does the exact opposite of `extract`.

Parameters
----------
condition : array_like
    An array whose nonzero or True entries indicate the elements of `arr`
    to extract.
arr : array_like
    Input array of the same size as `condition`.

Returns
-------
extract : ndarray
    Rank 1 array of values from `arr` where `condition` is True.

See Also
--------
take, put, copyto, compress, place

Examples
--------
&gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))
&gt;&gt;&gt; arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
&gt;&gt;&gt; condition = np.mod(arr, 3)==0
&gt;&gt;&gt; condition
array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False]], dtype=bool)
&gt;&gt;&gt; np.extract(condition, arr)
array([0, 3, 6, 9])


If `condition` is boolean:

&gt;&gt;&gt; arr[condition]
array([0, 3, 6, 9])</docstring>
    <inputPortSpec arg="condition" name="condition" port_type="basic:List" show_port="True">
      <docstring>An array whose nonzero or True entries indicate the elements of `arr`
to extract.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array of the same size as `condition`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="extract" name="extract" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Rank 1 array of values from `arr` where `condition` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.count_nonzero" module_name="count_nonzero" namespace="'sort'">
    <docstring>count_nonzero(a)

Counts the number of non-zero values in the array ``a``.

Parameters
----------
a : array_like
    The array for which to count non-zeros.

Returns
-------
count : int or array of int
    Number of non-zero values in the array.

See Also
--------
nonzero : Return the coordinates of all the non-zero values.

Examples
--------
&gt;&gt;&gt; np.count_nonzero(np.eye(4))
4
&gt;&gt;&gt; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
5</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array for which to count non-zeros.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="count" name="count" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Number of non-zero values in the array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.amin" module_name="amin" namespace="'statistics'">
    <docstring>Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array
0
&gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
&gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])

&gt;&gt;&gt; b = np.arange(5, dtype=np.float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amin(b)
nan
&gt;&gt;&gt; np.nanmin(b)
0.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which to operate.  By default, flattened input is
used.

.. versionadded: 1.7.0

If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="amin" name="amin" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Minimum of `a`. If `axis` is None, the result is a scalar value.
If `axis` is given, the result is an array of dimension
``a.ndim - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.amax" module_name="amax" namespace="'statistics'">
    <docstring>Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array
3
&gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
&gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])

&gt;&gt;&gt; b = np.arange(5, dtype=np.float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amax(b)
nan
&gt;&gt;&gt; np.nanmax(b)
4.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which to operate.  By default, flattened input is
used.

.. versionadded: 1.7.0

If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="amax" name="amax" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Maximum of `a`. If `axis` is None, the result is a scalar value.
If `axis` is given, the result is an array of dimension
``a.ndim - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanmin" module_name="nanmin" namespace="'statistics'">
    <docstring>Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a ``RuntimeWarning`` is raised and
Nan is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose minimum is desired. If `a` is not an
    array, a conversion is attempted.
axis : int, optional
    Axis along which the minimum is computed. The default is to compute
    the minimum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    `doc.ufuncs` for details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the original `a`.

    .. versionadded:: 1.8.0

Returns
-------
nanmin : ndarray
    An array with the same shape as `a`, with the specified axis
    removed.  If `a` is a 0-d array, or if axis is None, an ndarray
    scalar is returned.  The same dtype as `a` is returned.

See Also
--------
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amax, fmax, maximum

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.min.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmin(a)
1.0
&gt;&gt;&gt; np.nanmin(a, axis=0)
array([ 1.,  2.])
&gt;&gt;&gt; np.nanmin(a, axis=1)
array([ 1.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])
1.0
&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])
-inf</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose minimum is desired. If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the minimum is computed. The default is to compute
the minimum of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  The default
is ``None``; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
`doc.ufuncs` for details.

.. versionadded:: 1.8.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original `a`.

.. versionadded:: 1.8.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nanmin" name="nanmin" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array with the same shape as `a`, with the specified axis
removed.  If `a` is a 0-d array, or if axis is None, an ndarray
scalar is returned.  The same dtype as `a` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanmax" module_name="nanmax" namespace="'statistics'">
    <docstring>Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is
raised and NaN is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose maximum is desired. If `a` is not an
    array, a conversion is attempted.
axis : int, optional
    Axis along which the maximum is computed. The default is to compute
    the maximum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    `doc.ufuncs` for details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the original `a`.

    .. versionadded:: 1.8.0

Returns
-------
nanmax : ndarray
    An array with the same shape as `a`, with the specified axis removed.
    If `a` is a 0-d array, or if axis is None, an ndarray scalar is
    returned.  The same dtype as `a` is returned.

See Also
--------
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amin, fmin, minimum

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.max.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmax(a)
3.0
&gt;&gt;&gt; np.nanmax(a, axis=0)
array([ 3.,  2.])
&gt;&gt;&gt; np.nanmax(a, axis=1)
array([ 2.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])
2.0
&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])
inf</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose maximum is desired. If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the maximum is computed. The default is to compute
the maximum of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  The default
is ``None``; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
`doc.ufuncs` for details.

.. versionadded:: 1.8.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original `a`.

.. versionadded:: 1.8.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nanmax" name="nanmax" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array with the same shape as `a`, with the specified axis removed.
If `a` is a 0-d array, or if axis is None, an ndarray scalar is
returned.  The same dtype as `a` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ptp" module_name="ptp" namespace="'statistics'">
    <docstring>Range of values (maximum - minimum) along an axis.

The name of the function comes from the acronym for 'peak to peak'.

Parameters
----------
a : array_like
    Input values.
axis : int, optional
    Axis along which to find the peaks.  By default, flatten the
    array.
out : array_like
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type of the output values will be cast if necessary.

Returns
-------
ptp : ndarray
    A new array holding the result, unless `out` was
    specified, in which case a reference to `out` is returned.

Examples
--------
&gt;&gt;&gt; x = np.arange(4).reshape((2,2))
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])

&gt;&gt;&gt; np.ptp(x, axis=0)
array([2, 2])

&gt;&gt;&gt; np.ptp(x, axis=1)
array([1, 1])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to find the peaks.  By default, flatten the
array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List" show_port="True">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type of the output values will be cast if necessary.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="ptp" name="ptp" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result, unless `out` was
specified, in which case a reference to `out` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.percentile" module_name="percentile" namespace="'statistics'">
    <docstring>Compute the qth percentile of the data along the specified axis.

Returns the qth percentile of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
q : float in range of [0,100] (or sequence of floats)
    Percentile to compute which must be between 0 and 100 inclusive.
axis : int or sequence of int, optional
    Axis along which the percentiles are computed. The default (None)
    is to compute the percentiles along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow use of memory of input array `a` for
    calculations. The input array will be modified by the call to
    percentile. This will save memory when you do not need to preserve
    the contents of the input array. In this case you should not make
    any assumptions about the content of the passed in array `a` after
    this function completes -- treat it as undefined. Default is False.
    Note that, if the `a` input is not already an array this parameter
    will have no effect, `a` will be converted to an array internally
    regardless of the value of this parameter.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to use,
    when the desired quantile lies between two data points `i` and `j`:
        * linear: `i + (j - i) * fraction`, where `fraction` is the
          fractional part of the index surrounded by `i` and `j`.
        * lower: `i`.
        * higher: `j`.
        * nearest: `i` or `j` whichever is nearest.
        * midpoint: (`i` + `j`) / 2.

    .. versionadded:: 1.9.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original array `a`.

    .. versionadded:: 1.9.0

Returns
-------
percentile : scalar or ndarray
    If a single percentile `q` is given and axis=None a scalar is
    returned.  If multiple percentiles `q` are given an array holding
    the result is returned. The results are listed in the first axis.
    (If `out` is specified, in which case that array is returned
    instead).  If the input contains integers, or floats of smaller
    precision than 64, then the output data-type is float64. Otherwise,
    the output data-type is the same as that of the input.

See Also
--------
mean, median

Notes
-----
Given a vector V of length N, the q-th percentile of V is the q-th ranked
value in a sorted copy of V.  The values and distances of the two
nearest neighbors as well as the `interpolation` parameter will
determine the percentile if the normalized ranking does not match q
exactly. This function is the same as the median if ``q=50``, the same
as the minimum if ``q=0`` and the same as the maximum if ``q=100``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; np.percentile(a, 50)
array([ 3.5])
&gt;&gt;&gt; np.percentile(a, 50, axis=0)
array([[ 6.5,  4.5,  2.5]])
&gt;&gt;&gt; np.percentile(a, 50, axis=1)
array([[ 7.],
       [ 2.]])

&gt;&gt;&gt; m = np.percentile(a, 50, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.percentile(a, 50, axis=0, out=m)
array([[ 6.5,  4.5,  2.5]])
&gt;&gt;&gt; m
array([[ 6.5,  4.5,  2.5]])

&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)
array([[ 7.],
       [ 2.]])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.percentile(b, 50, axis=None, overwrite_input=True)
array([ 3.5])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" depth="1" name="q" port_type="basic:Float" show_port="True">
      <docstring>Percentile to compute which must be between 0 and 100 inclusive.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis along which the percentiles are computed. The default (None)
is to compute the percentiles along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_input" name="overwrite_input" port_type="basic:Boolean">
      <docstring>If True, then allow use of memory of input array `a` for
calculations. The input array will be modified by the call to
percentile. This will save memory when you do not need to preserve
the contents of the input array. In this case you should not make
any assumptions about the content of the passed in array `a` after
this function completes -- treat it as undefined. Default is False.
Note that, if the `a` input is not already an array this parameter
will have no effect, `a` will be converted to an array internally
regardless of the value of this parameter.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="interpolation" name="interpolation">
      <docstring>This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points `i` and `j`:
    * linear: `i + (j - i) * fraction`, where `fraction` is the
      fractional part of the index surrounded by `i` and `j`.
    * lower: `i`.
    * higher: `j`.
    * nearest: `i` or `j` whichever is nearest.
    * midpoint: (`i` + `j`) / 2.

.. versionadded:: 1.9.0</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'lower', 'higher', 'nearest']]</values>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original array `a`.

.. versionadded:: 1.9.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="percentile" name="percentile" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>If a single percentile `q` is given and axis=None a scalar is
returned.  If multiple percentiles `q` are given an array holding
the result is returned. The results are listed in the first axis.
(If `out` is specified, in which case that array is returned
instead).  If the input contains integers, or floats of smaller
precision than 64, then the output data-type is float64. Otherwise,
the output data-type is the same as that of the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanpercentile" module_name="nanpercentile" namespace="'statistics'">
    <docstring>Compute the qth percentile of the data along the specified axis, while
ignoring nan values.

Returns the qth percentile of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
q : float in range of [0,100] (or sequence of floats)
    Percentile to compute which must be between 0 and 100 inclusive.
axis : int or sequence of int, optional
    Axis along which the percentiles are computed. The default (None)
    is to compute the percentiles along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow use of memory of input array `a` for
    calculations. The input array will be modified by the call to
    percentile. This will save memory when you do not need to preserve
    the contents of the input array. In this case you should not make
    any assumptions about the content of the passed in array `a` after
    this function completes -- treat it as undefined. Default is False.
    Note that, if the `a` input is not already an array this parameter
    will have no effect, `a` will be converted to an array internally
    regardless of the value of this parameter.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to use,
    when the desired quantile lies between two data points `i` and `j`:
        * linear: `i + (j - i) * fraction`, where `fraction` is the
          fractional part of the index surrounded by `i` and `j`.
        * lower: `i`.
        * higher: `j`.
        * nearest: `i` or `j` whichever is nearest.
        * midpoint: (`i` + `j`) / 2.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.


Returns
-------
nanpercentile : scalar or ndarray
    If a single percentile `q` is given and axis=None a scalar is
    returned.  If multiple percentiles `q` are given an array holding
    the result is returned. The results are listed in the first axis.
    (If `out` is specified, in which case that array is returned
    instead).  If the input contains integers, or floats of smaller
    precision than 64, then the output data-type is float64. Otherwise,
    the output data-type is the same as that of the input.

See Also
--------
nanmean, nanmedian, percentile, median, mean

Notes
-----
Given a vector V of length N, the q-th percentile of V is the q-th ranked
value in a sorted copy of V.  The values and distances of the two
nearest neighbors as well as the `interpolation` parameter will
determine the percentile if the normalized ranking does not match q
exactly. This function is the same as the median if ``q=50``, the same
as the minimum if ``q=0``and the same as the maximum if ``q=100``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])
&gt;&gt;&gt; a[0][1] = np.nan
&gt;&gt;&gt; a
array([[ 10.,  nan,   4.],
   [  3.,   2.,   1.]])
&gt;&gt;&gt; np.percentile(a, 50)
nan
&gt;&gt;&gt; np.nanpercentile(a, 50)
3.5
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0)
array([[ 6.5,  4.5,  2.5]])
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=1)
array([[ 7.],
       [ 2.]])
&gt;&gt;&gt; m = np.nanpercentile(a, 50, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0, out=m)
array([[ 6.5,  4.5,  2.5]])
&gt;&gt;&gt; m
array([[ 6.5,  4.5,  2.5]])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanpercentile(b, 50, axis=1, overwrite_input=True)
array([[ 7.],
       [ 2.]])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanpercentile(b, 50, axis=None, overwrite_input=True)
array([ 3.5])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" depth="1" name="q" port_type="basic:Float" show_port="True">
      <docstring>Percentile to compute which must be between 0 and 100 inclusive.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis along which the percentiles are computed. The default (None)
is to compute the percentiles along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_input" name="overwrite_input" port_type="basic:Boolean">
      <docstring>If True, then allow use of memory of input array `a` for
calculations. The input array will be modified by the call to
percentile. This will save memory when you do not need to preserve
the contents of the input array. In this case you should not make
any assumptions about the content of the passed in array `a` after
this function completes -- treat it as undefined. Default is False.
Note that, if the `a` input is not already an array this parameter
will have no effect, `a` will be converted to an array internally
regardless of the value of this parameter.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="interpolation" name="interpolation">
      <docstring>This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points `i` and `j`:
    * linear: `i + (j - i) * fraction`, where `fraction` is the
      fractional part of the index surrounded by `i` and `j`.
    * lower: `i`.
    * higher: `j`.
    * nearest: `i` or `j` whichever is nearest.
    * midpoint: (`i` + `j`) / 2.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'lower', 'higher', 'nearest']]</values>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nanpercentile" name="nanpercentile" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>If a single percentile `q` is given and axis=None a scalar is
returned.  If multiple percentiles `q` are given an array holding
the result is returned. The results are listed in the first axis.
(If `out` is specified, in which case that array is returned
instead).  If the input contains integers, or floats of smaller
precision than 64, then the output data-type is float64. Otherwise,
the output data-type is the same as that of the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.median" module_name="median" namespace="'statistics'">
    <docstring>Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int or sequence of int, optional
    Axis along which the medians are computed. The default (axis=None)
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape and buffer length as the expected output, but the
    type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array (a) for
   calculations. The input array will be modified by the call to
   median. This will save memory when you do not need to preserve the
   contents of the input array. Treat the input as undefined, but it
   will probably be fully or partially sorted. Default is False. Note
   that, if `overwrite_input` is True and the input is not already an
   ndarray, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

    .. versionadded:: 1.9.0


Returns
-------
median : ndarray
    A new array holding the result (unless `out` is specified, in which
    case that array is returned instead).  If the input contains
    integers, or floats of smaller precision than 64, then the output
    data-type is float64.  Otherwise, the output data-type is the same
    as that of the input.

See Also
--------
mean, percentile

Notes
-----
Given a vector V of length N, the median of V is the middle value of
a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is
odd.  When N is even, it is the average of the two middle values of
``V_sorted``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; np.median(a)
3.5
&gt;&gt;&gt; np.median(a, axis=0)
array([ 6.5,  4.5,  2.5])
&gt;&gt;&gt; np.median(a, axis=1)
array([ 7.,  2.])
&gt;&gt;&gt; m = np.median(a, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.median(a, axis=0, out=m)
array([ 6.5,  4.5,  2.5])
&gt;&gt;&gt; m
array([ 6.5,  4.5,  2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)
array([ 7.,  2.])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)
3.5
&gt;&gt;&gt; assert not np.all(a==b)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis along which the medians are computed. The default (axis=None)
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must have
the same shape and buffer length as the expected output, but the
type (of the output) will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_input" name="overwrite_input" port_type="basic:Boolean">
      <docstring>If True, then allow use of memory of input array (a) for
calculations. The input array will be modified by the call to
median. This will save memory when you do not need to preserve the
contents of the input array. Treat the input as undefined, but it
will probably be fully or partially sorted. Default is False. Note
that, if `overwrite_input` is True and the input is not already an
ndarray, an error will be raised.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.

.. versionadded:: 1.9.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="median" name="median" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result (unless `out` is specified, in which
case that array is returned instead).  If the input contains
integers, or floats of smaller precision than 64, then the output
data-type is float64.  Otherwise, the output data-type is the same
as that of the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.average" module_name="average" namespace="'statistics'" output_type="list">
    <docstring>Compute the weighted average along the specified axis.

Parameters
----------
a : array_like
    Array containing data to be averaged. If `a` is not an array, a
    conversion is attempted.
axis : int, optional
    Axis along which to average `a`. If `None`, averaging is done over
    the flattened array.
weights : array_like, optional
    An array of weights associated with the values in `a`. Each value in
    `a` contributes to the average according to its associated weight.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If `weights=None`, then all data in `a` are assumed to have a
    weight equal to one.
returned : bool, optional
    Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
    is returned, otherwise only the average is returned.
    If `weights=None`, `sum_of_weights` is equivalent to the number of
    elements over which the average is taken.


Returns
-------
average, [sum_of_weights] : array_type or double
    Return the average along the specified axis. When returned is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. The return type is `Float`
    if `a` is of integer type, otherwise it is of the same type as `a`.
    `sum_of_weights` is of the same type as `average`.

Raises
------
ZeroDivisionError
    When all weights along axis are zero. See `numpy.ma.average` for a
    version robust to this type of error.
TypeError
    When the length of 1D `weights` is not the same as the shape of `a`
    along axis.

See Also
--------
mean

ma.average : average for masked arrays -- useful if your data contains
             "missing" values

Examples
--------
&gt;&gt;&gt; data = range(1,5)
&gt;&gt;&gt; data
[1, 2, 3, 4]
&gt;&gt;&gt; np.average(data)
2.5
&gt;&gt;&gt; np.average(range(1,11), weights=range(10,0,-1))
4.0

&gt;&gt;&gt; data = np.arange(6).reshape((3,2))
&gt;&gt;&gt; data
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])
array([ 0.75,  2.75,  4.75])
&gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])
Traceback (most recent call last):
...
TypeError: Axis must be specified when shapes of a and weights differ.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing data to be averaged. If `a` is not an array, a
conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to average `a`. If `None`, averaging is done over
the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>An array of weights associated with the values in `a`. Each value in
`a` contributes to the average according to its associated weight.
The weights array can either be 1-D (in which case its length must be
the size of `a` along the given axis) or of the same shape as `a`.
If `weights=None`, then all data in `a` are assumed to have a
weight equal to one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="returned" name="returned" port_type="basic:Boolean">
      <docstring>Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
is returned, otherwise only the average is returned.
If `weights=None`, `sum_of_weights` is equivalent to the number of
elements over which the average is taken.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="average" name="average" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Return the average along the specified axis. When returned is `True`,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is `Float`
if `a` is of integer type, otherwise it is of the same type as `a`.
`sum_of_weights` is of the same type as `average`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[sum_of_weights]" name="[sum_of_weights]" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Return the average along the specified axis. When returned is `True`,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is `Float`
if `a` is of integer type, otherwise it is of the same type as `a`.
`sum_of_weights` is of the same type as `average`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.mean" module_name="mean" namespace="'statistics'">
    <docstring>Compute the arithmetic mean along the specified axis.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the means are computed. The default is to
    compute the mean of the flattened array.

    .. versionadded: 1.7.0

    If this is a tuple of ints, a mean is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for floating point inputs, it is the same as the
    input dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.
    See `doc.ufuncs` for details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned.

See Also
--------
average : Weighted average
std, var, nanmean, nanstd, nanvar

Notes
-----
The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.

Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for `float32` (see
example below).  Specifying a higher-precision accumulator using the
`dtype` keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.mean(a)
2.5
&gt;&gt;&gt; np.mean(a, axis=0)
array([ 2.,  3.])
&gt;&gt;&gt; np.mean(a, axis=1)
array([ 1.5,  3.5])

In single precision, `mean` can be inaccurate:

&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
&gt;&gt;&gt; a[0, :] = 1.0
&gt;&gt;&gt; a[1, :] = 0.1
&gt;&gt;&gt; np.mean(a)
0.546875

Computing the mean in float64 is more accurate:

&gt;&gt;&gt; np.mean(a, dtype=np.float64)
0.55000000074505806</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose mean is desired. If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which the means are computed. The default is to
compute the mean of the flattened array.

.. versionadded: 1.7.0

If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type to use in computing the mean.  For integer inputs, the default
is `float64`; for floating point inputs, it is the same as the
input dtype.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  The default
is ``None``; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.
See `doc.ufuncs` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="m" name="m" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `out=None`, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.std" module_name="std" namespace="'statistics'">
    <docstring>Compute the standard deviation along the specified axis.

Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Calculate the standard deviation of these values.
axis : None or int or tuple of ints, optional
    Axis or axes along which the standard deviation is computed. The
    default is to compute the standard deviation of the flattened array.

    .. versionadded: 1.7.0

    If this is a tuple of ints, a standard deviation is performed over
    multiple axes, instead of a single axis or all the axes as before.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it is
    the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the calculated
    values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of elements.
    By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard deviation,
    otherwise return a reference to the output array.

See Also
--------
var, mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section "Output arguments"

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.

The average squared deviation is normally calculated as
``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
the divisor ``N - ddof`` is used instead. In standard statistical
practice, ``ddof=1`` provides an unbiased estimator of the variance
of the infinite population. ``ddof=0`` provides a maximum likelihood
estimate of the variance for normally distributed variables. The
standard deviation computed in this function is the square root of
the estimated variance, so even with ``ddof=1``, it will not be an
unbiased estimate of the standard deviation per se.

Note that, for complex numbers, `std` takes the absolute
value before squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the `dtype` keyword can
alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.std(a)
1.1180339887498949
&gt;&gt;&gt; np.std(a, axis=0)
array([ 1.,  1.])
&gt;&gt;&gt; np.std(a, axis=1)
array([ 0.5,  0.5])

In single precision, std() can be inaccurate:

&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
&gt;&gt;&gt; a[0, :] = 1.0
&gt;&gt;&gt; a[1, :] = 0.1
&gt;&gt;&gt; np.std(a)
0.45000005

Computing the standard deviation in float64 is more accurate:

&gt;&gt;&gt; np.std(a, dtype=np.float64)
0.44999999925494177</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Calculate the standard deviation of these values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which the standard deviation is computed. The
default is to compute the standard deviation of the flattened array.

.. versionadded: 1.7.0

If this is a tuple of ints, a standard deviation is performed over
multiple axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the calculated
values) will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Means Delta Degrees of Freedom.  The divisor used in calculations
is ``N - ddof``, where ``N`` represents the number of elements.
By default `ddof` is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="standard_deviation" name="standard_deviation" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `out` is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.var" module_name="var" namespace="'statistics'">
    <docstring>Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float32`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    "Delta Degrees of Freedom": the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std , mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section "Output arguments"

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.var(a)
1.25
&gt;&gt;&gt; np.var(a, axis=0)
array([ 1.,  1.])
&gt;&gt;&gt; np.var(a, axis=1)
array([ 0.25,  0.25])

In single precision, var() can be inaccurate:

&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)
&gt;&gt;&gt; a[0, :] = 1.0
&gt;&gt;&gt; a[1, :] = 0.1
&gt;&gt;&gt; np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

&gt;&gt;&gt; np.var(a, dtype=np.float64)
0.20249999932944759
&gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose variance is desired.  If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which the variance is computed.  The default is to
compute the variance of the flattened array.

.. versionadded: 1.7.0

If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type to use in computing the variance.  For arrays of integer type
the default is `float32`; for arrays of float types it is the same as
the array type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>"Delta Degrees of Freedom": the divisor used in the calculation is
``N - ddof``, where ``N`` represents the number of elements. By
default `ddof` is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="variance" name="variance" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If ``out=None``, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanmedian" module_name="nanmedian" namespace="'statistics'">
    <docstring>Compute the median along the specified axis, while ignoring NaNs.

Returns the median of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int, optional
    Axis along which the medians are computed. The default (axis=None)
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape and buffer length as the expected output, but the
    type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array (a) for
   calculations. The input array will be modified by the call to
   median. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. Note that, if `overwrite_input` is True and the input
   is not already an ndarray, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.



Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers, or
    floats of smaller precision than 64, then the output data-type is
    float64.  Otherwise, the output data-type is the same as that of the
    input.

See Also
--------
mean, median, percentile

Notes
-----
Given a vector V of length N, the median of V is the middle value of
a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is
odd.  When N is even, it is the average of the two middle values of
``V_sorted``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10.0, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a[0, 1] = np.nan
&gt;&gt;&gt; a
array([[ 10.,  nan,   4.],
   [  3.,   2.,   1.]])
&gt;&gt;&gt; np.median(a)
nan
&gt;&gt;&gt; np.nanmedian(a)
3.0
&gt;&gt;&gt; np.nanmedian(a, axis=0)
array([ 6.5,  2.,  2.5])
&gt;&gt;&gt; np.median(a, axis=1)
array([ 7.,  2.])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanmedian(b, axis=1, overwrite_input=True)
array([ 7.,  2.])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanmedian(b, axis=None, overwrite_input=True)
3.0
&gt;&gt;&gt; assert not np.all(a==b)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the medians are computed. The default (axis=None)
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must have
the same shape and buffer length as the expected output, but the
type (of the output) will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_input" name="overwrite_input" port_type="basic:Boolean">
      <docstring>If True, then allow use of memory of input array (a) for
calculations. The input array will be modified by the call to
median. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. Note that, if `overwrite_input` is True and the input
is not already an ndarray, an error will be raised.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="median" name="median" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result. If the input contains integers, or
floats of smaller precision than 64, then the output data-type is
float64.  Otherwise, the output data-type is the same as that of the
input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanmean" module_name="nanmean" namespace="'statistics'">
    <docstring>Compute the arithmetic mean along the specified axis, ignoring NaNs.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : int, optional
    Axis along which the means are computed. The default is to compute
    the mean of the flattened array.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for inexact inputs, it is the same as the input
    dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    `doc.ufuncs` for details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the original `arr`.

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned. Nan is
    returned for slices that contain only NaNs.

See Also
--------
average : Weighted average
mean : Arithmetic mean taken while not ignoring NaNs
var, nanvar

Notes
-----
The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.

Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32`.  Specifying a
higher-precision accumulator using the `dtype` keyword can alleviate
this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanmean(a)
2.6666666666666665
&gt;&gt;&gt; np.nanmean(a, axis=0)
array([ 2.,  4.])
&gt;&gt;&gt; np.nanmean(a, axis=1)
array([ 1.,  3.5])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose mean is desired. If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the means are computed. The default is to compute
the mean of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type to use in computing the mean.  For integer inputs, the default
is `float64`; for inexact inputs, it is the same as the input
dtype.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  The default
is ``None``; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
`doc.ufuncs` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="m" name="m" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `out=None`, returns a new array containing the mean values,
otherwise a reference to the output array is returned. Nan is
returned for slices that contain only NaNs.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanstd" module_name="nanstd" namespace="'statistics'">
    <docstring>Compute the standard deviation along the specified axis, while
ignoring NaNs.

Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Calculate the standard deviation of the non-NaN values.
axis : int, optional
    Axis along which the standard deviation is computed. The default is
    to compute the standard deviation of the flattened array.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it
    is the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the
    calculated values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of non-NaN
    elements.  By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard
    deviation, otherwise return a reference to the output array. If
    ddof is &gt;= the number of non-NaN elements in a slice or the slice
    contains only NaNs, then the result for that slice is NaN.

See Also
--------
var, mean, std
nanvar, nanmean
numpy.doc.ufuncs : Section "Output arguments"

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.

The average squared deviation is normally calculated as
``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is
specified, the divisor ``N - ddof`` is used instead. In standard
statistical practice, ``ddof=1`` provides an unbiased estimator of the
variance of the infinite population. ``ddof=0`` provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with ``ddof=1``, it will not be an
unbiased estimate of the standard deviation per se.

Note that, for complex numbers, `std` takes the absolute value before
squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the `dtype`
keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanstd(a)
1.247219128924647
&gt;&gt;&gt; np.nanstd(a, axis=0)
array([ 1.,  0.])
&gt;&gt;&gt; np.nanstd(a, axis=1)
array([ 0.,  0.5])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Calculate the standard deviation of the non-NaN values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the standard deviation is computed. The default is
to compute the standard deviation of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it
is the same as the array type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the
calculated values) will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Means Delta Degrees of Freedom.  The divisor used in calculations
is ``N - ddof``, where ``N`` represents the number of non-NaN
elements.  By default `ddof` is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="standard_deviation" name="standard_deviation" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `out` is None, return a new array containing the standard
deviation, otherwise return a reference to the output array. If
ddof is &gt;= the number of non-NaN elements in a slice or the slice
contains only NaNs, then the result for that slice is NaN.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.nanvar" module_name="nanvar" namespace="'statistics'">
    <docstring>Compute the variance along the specified axis, while ignoring NaNs.

Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : int, optional
    Axis along which the variance is computed.  The default is to compute
    the variance of the flattened array.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float32`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    "Delta Degrees of Freedom": the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of non-NaN
    elements. By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
variance : ndarray, see dtype parameter above
    If `out` is None, return a new array containing the variance,
    otherwise return a reference to the output array. If ddof is &gt;= the
    number of non-NaN elements in a slice or the slice contains only
    NaNs, then the result for that slice is NaN.

See Also
--------
std : Standard deviation
mean : Average
var : Variance while not ignoring NaNs
nanstd, nanmean
numpy.doc.ufuncs : Section "Output arguments"

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite
population.  ``ddof=0`` provides a maximum likelihood estimate of the
variance for normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.var(a)
1.5555555555555554
&gt;&gt;&gt; np.nanvar(a, axis=0)
array([ 1.,  0.])
&gt;&gt;&gt; np.nanvar(a, axis=1)
array([ 0.,  0.25])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing numbers whose variance is desired.  If `a` is not an
array, a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the variance is computed.  The default is to compute
the variance of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type to use in computing the variance.  For arrays of integer type
the default is `float32`; for arrays of float types it is the same as
the array type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>"Delta Degrees of Freedom": the divisor used in the calculation is
``N - ddof``, where ``N`` represents the number of non-NaN
elements. By default `ddof` is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="variance" name="variance" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `out` is None, return a new array containing the variance,
otherwise return a reference to the output array. If ddof is &gt;= the
number of non-NaN elements in a slice or the slice contains only
NaNs, then the result for that slice is NaN.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.corrcoef" module_name="corrcoef" namespace="'statistics'">
    <docstring>Return Pearson product-moment correlation coefficients.

Please refer to the documentation for `cov` for more detail.  The
relationship between the correlation coefficient matrix, `R`, and the
covariance matrix, `C`, is

.. math:: R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }

The values of `R` are between -1 and 1, inclusive.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : int, optional
    If `rowvar` is non-zero (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no affect, do not use.

    .. deprecated:: 1.10.0
ddof : _NoValue, optional
    Has no affect, do not use.

    .. deprecated:: 1.10.0

Returns
-------
R : ndarray
    The correlation coefficient matrix of the variables.

See Also
--------
cov : Covariance matrix

Notes
-----
This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A 1-D or 2-D array containing multiple variables and observations.
Each row of `x` represents a variable, and each column a single
observation of all those variables. Also see `rowvar` below.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>An additional set of variables and observations. `y` has the same
shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rowvar" name="rowvar" port_type="basic:Integer">
      <docstring>If `rowvar` is non-zero (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Variant">
      <docstring>Has no affect, do not use.

.. deprecated:: 1.10.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Variant">
      <docstring>Has no affect, do not use.

.. deprecated:: 1.10.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="R" name="R" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The correlation coefficient matrix of the variables.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.correlate" module_name="correlate" namespace="'statistics'">
    <docstring>Cross-correlation of two 1-dimensional sequences.

This function computes the correlation as generally defined in signal
processing texts::

    c_{av}[k] = sum_n a[n+k] * conj(v[n])

with a and v sequences being zero-padded where necessary and conj being
the conjugate.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `convolve` docstring.  Note that the default
    is `valid`, unlike `convolve`, which uses `full`.
old_behavior : bool
    `old_behavior` was removed in NumPy 1.10. If you need the old
    behavior, use `multiarray.correlate`.

Returns
-------
out : ndarray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
convolve : Discrete, linear convolution of two one-dimensional sequences.
multiarray.correlate : Old, no conjugate, version of correlate.

Notes
-----
The definition of correlation above is not unique and sometimes correlation
may be defined differently. Another common definition is::

    c'_{av}[k] = sum_n a[n] conj(v[n+k])

which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.

Examples
--------
&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5])
array([ 3.5])
&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], "same")
array([ 2. ,  3.5,  3. ])
&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], "full")
array([ 0.5,  2. ,  3.5,  3. ,  0. ])

Using complex sequences:

&gt;&gt;&gt; np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])

Note that you get the time reversed, complex conjugated result
when the two input sequences change places, i.e.,
``c_{va}[k] = c^{*}_{av}[-k]``:

&gt;&gt;&gt; np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input sequences.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input sequences.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Refer to the `convolve` docstring.  Note that the default
is `valid`, unlike `convolve`, which uses `full`.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['valid', 'same', 'full']]</values>
      <defaults>['valid']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="old_behavior" name="old_behavior" port_type="basic:Boolean" show_port="True">
      <docstring>`old_behavior` was removed in NumPy 1.10. If you need the old
behavior, use `multiarray.correlate`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Discrete cross-correlation of `a` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.cov" module_name="cov" namespace="'statistics'">
    <docstring>Estimate a covariance matrix, given data and weights.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

See the notes for an outline of the algorithm.

Parameters
----------
m : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same form
    as that of `m`.
rowvar : int, optional
    If `rowvar` is non-zero (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : int, optional
    Default normalization is by ``(N - 1)``, where ``N`` corresponds to the
    number of observations given (unbiased estimate). If `bias` is 1, then
    normalization is by ``N``. These values can be overridden by using the
    keyword ``ddof`` in numpy versions &gt;= 1.5.
ddof : int, optional
    If not ``None`` the default value implied by `bias` is overridden.
    Note that ``ddof=1`` will return the unbiased estimate, even if both
    `fweights` and `aweights` are specified, and ``ddof=0`` will return
    the simple average. See the notes for the details. The default value
    is ``None``.

    .. versionadded:: 1.5
fweights : array_like, int, optional
    1-D array of integer freguency weights; the number of times each
    observation vector should be repeated.

    .. versionadded:: 1.10
aweights : array_like, optional
    1-D array of observation vector weights. These relative weights are
    typically large for observations considered "important" and smaller for
    observations considered less "important". If ``ddof=0`` the array of
    weights can be used to assign probabilities to observation vectors.

    .. versionadded:: 1.10

Returns
-------
out : ndarray
    The covariance matrix of the variables.

See Also
--------
corrcoef : Normalized covariance matrix

Notes
-----
Assume that the observations are in the columns of the observation
array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
steps to compute the weighted covariance are as follows::

    &gt;&gt;&gt; w = f * a
    &gt;&gt;&gt; v1 = np.sum(w)
    &gt;&gt;&gt; v2 = np.sum(w * a)
    &gt;&gt;&gt; m -= np.sum(m * w, axis=1, keepdims=True) / v1
    &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)

Note that when ``a == 1``, the normalization factor
``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
as it should.

Examples
--------
Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

&gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T
&gt;&gt;&gt; x
array([[0, 1, 2],
       [2, 1, 0]])

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

&gt;&gt;&gt; np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

&gt;&gt;&gt; x = [-2.1, -1,  4.3]
&gt;&gt;&gt; y = [3,  1.1,  0.12]
&gt;&gt;&gt; X = np.vstack((x,y))
&gt;&gt;&gt; print np.cov(X)
[[ 11.71        -4.286     ]
 [ -4.286        2.14413333]]
&gt;&gt;&gt; print np.cov(x, y)
[[ 11.71        -4.286     ]
 [ -4.286        2.14413333]]
&gt;&gt;&gt; print np.cov(x)
11.71</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>A 1-D or 2-D array containing multiple variables and observations.
Each row of `m` represents a variable, and each column a single
observation of all those variables. Also see `rowvar` below.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>An additional set of variables and observations. `y` has the same form
as that of `m`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rowvar" name="rowvar" port_type="basic:Integer">
      <docstring>If `rowvar` is non-zero (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Integer">
      <docstring>Default normalization is by ``(N - 1)``, where ``N`` corresponds to the
number of observations given (unbiased estimate). If `bias` is 1, then
normalization is by ``N``. These values can be overridden by using the
keyword ``ddof`` in numpy versions &gt;= 1.5.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>If not ``None`` the default value implied by `bias` is overridden.
Note that ``ddof=1`` will return the unbiased estimate, even if both
`fweights` and `aweights` are specified, and ``ddof=0`` will return
the simple average. See the notes for the details. The default value
is ``None``.

.. versionadded:: 1.5</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fweights" depth="1" name="fweights" port_type="basic:Integer">
      <docstring>1-D array of integer freguency weights; the number of times each
observation vector should be repeated.

.. versionadded:: 1.10</docstring>
    </inputPortSpec>
    <inputPortSpec arg="aweights" name="aweights" port_type="basic:List">
      <docstring>1-D array of observation vector weights. These relative weights are
typically large for observations considered "important" and smaller for
observations considered less "important". If ``ddof=0`` the array of
weights can be used to assign probabilities to observation vectors.

.. versionadded:: 1.10</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The covariance matrix of the variables.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.histogram" module_name="histogram" namespace="'statistics'" output_type="list">
    <docstring>Compute the histogram of a set of data.

Parameters
----------
a : array_like
    Input data. The histogram is computed over the flattened array.
bins : int or sequence of scalars, optional
    If `bins` is an int, it defines the number of equal-width
    bins in the given range (10, by default). If `bins` is a sequence,
    it defines the bin edges, including the rightmost edge, allowing
    for non-uniform bin widths.
range : (float, float), optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(a.min(), a.max())``.  Values outside the range are
    ignored.
normed : bool, optional
    This keyword is deprecated in Numpy 1.6 due to confusing/buggy
    behavior. It will be removed in Numpy 2.0. Use the density keyword
    instead.
    If False, the result will contain the number of samples
    in each bin.  If True, the result is the value of the
    probability *density* function at the bin, normalized such that
    the *integral* over the range is 1. Note that this latter behavior is
    known to be buggy with unequal bin widths; use `density` instead.
weights : array_like, optional
    An array of weights, of the same shape as `a`.  Each value in `a`
    only contributes its associated weight towards the bin count
    (instead of 1).  If `normed` is True, the weights are normalized,
    so that the integral of the density over the range remains 1
density : bool, optional
    If False, the result will contain the number of samples
    in each bin.  If True, the result is the value of the
    probability *density* function at the bin, normalized such that
    the *integral* over the range is 1. Note that the sum of the
    histogram values will not be equal to 1 unless bins of unity
    width are chosen; it is not a probability *mass* function.
    Overrides the `normed` keyword if given.

Returns
-------
hist : array
    The values of the histogram. See `normed` and `weights` for a
    description of the possible semantics.
bin_edges : array of dtype float
    Return the bin edges ``(length(hist)+1)``.


See Also
--------
histogramdd, bincount, searchsorted, digitize

Notes
-----
All but the last (righthand-most) bin is half-open.  In other words, if
`bins` is::

  [1, 2, 3, 4]

then the first bin is ``[1, 2)`` (including 1, but excluding 2) and the
second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which *includes*
4.

Examples
--------
&gt;&gt;&gt; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
(array([0, 2, 1]), array([0, 1, 2, 3]))
&gt;&gt;&gt; np.histogram(np.arange(4), bins=np.arange(5), density=True)
(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))
&gt;&gt;&gt; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
(array([1, 4, 1]), array([0, 1, 2, 3]))

&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; hist, bin_edges = np.histogram(a, density=True)
&gt;&gt;&gt; hist
array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])
&gt;&gt;&gt; hist.sum()
2.4999999999999996
&gt;&gt;&gt; np.sum(hist*np.diff(bin_edges))
1.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data. The histogram is computed over the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="binsScalar" port_type="basic:Integer">
      <docstring>If `bins` is an int, it defines the number of equal-width
bins in the given range (10, by default). If `bins` is a sequence,
it defines the bin edges, including the rightmost edge, allowing
for non-uniform bin widths.</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="range" name="range" port_type="basic:Float">
      <docstring>The lower and upper range of the bins.  If not provided, range
is simply ``(a.min(), a.max())``.  Values outside the range are
ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="normed" name="normed" port_type="basic:Boolean">
      <docstring>This keyword is deprecated in Numpy 1.6 due to confusing/buggy
behavior. It will be removed in Numpy 2.0. Use the density keyword
instead.
If False, the result will contain the number of samples
in each bin.  If True, the result is the value of the
probability *density* function at the bin, normalized such that
the *integral* over the range is 1. Note that this latter behavior is
known to be buggy with unequal bin widths; use `density` instead.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>An array of weights, of the same shape as `a`.  Each value in `a`
only contributes its associated weight towards the bin count
(instead of 1).  If `normed` is True, the weights are normalized,
so that the integral of the density over the range remains 1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="density" name="density" port_type="basic:Boolean">
      <docstring>If False, the result will contain the number of samples
in each bin.  If True, the result is the value of the
probability *density* function at the bin, normalized such that
the *integral* over the range is 1. Note that the sum of the
histogram values will not be equal to 1 unless bins of unity
width are chosen; it is not a probability *mass* function.
Overrides the `normed` keyword if given.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="hist" name="hist" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the histogram. See `normed` and `weights` for a
description of the possible semantics.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="bin_edges" depth="1" name="bin_edges" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Return the bin edges ``(length(hist)+1)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.histogram2d" module_name="histogram2d" namespace="'statistics'" output_type="list">
    <docstring>Compute the bi-dimensional histogram of two data samples.

Parameters
----------
x : array_like, shape (N,)
    An array containing the x coordinates of the points to be
    histogrammed.
y : array_like, shape (N,)
    An array containing the y coordinates of the points to be
    histogrammed.
bins : int or array_like or [int, int] or [array, array], optional
    The bin specification:

      * If int, the number of bins for the two dimensions (nx=ny=bins).
      * If array_like, the bin edges for the two dimensions
        (x_edges=y_edges=bins).
      * If [int, int], the number of bins in each dimension
        (nx, ny = bins).
      * If [array, array], the bin edges in each dimension
        (x_edges, y_edges = bins).
      * A combination [int, array] or [array, int], where int
        is the number of bins and array is the bin edges.

range : array_like, shape(2,2), optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
    will be considered outliers and not tallied in the histogram.
normed : bool, optional
    If False, returns the number of samples in each bin. If True,
    returns the bin density ``bin_count / sample_count / bin_area``.
weights : array_like, shape(N,), optional
    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
    Weights are normalized to 1 if `normed` is True. If `normed` is
    False, the values of the returned histogram are equal to the sum of
    the weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray, shape(nx, ny)
    The bi-dimensional histogram of samples `x` and `y`. Values in `x`
    are histogrammed along the first dimension and values in `y` are
    histogrammed along the second dimension.
xedges : ndarray, shape(nx,)
    The bin edges along the first dimension.
yedges : ndarray, shape(ny,)
    The bin edges along the second dimension.

See Also
--------
histogram : 1D histogram
histogramdd : Multidimensional histogram

Notes
-----
When `normed` is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
``bin_value * bin_area`` is 1.

Please note that the histogram does not follow the Cartesian convention
where `x` values are on the abscissa and `y` values on the ordinate
axis.  Rather, `x` is histogrammed along the first dimension of the
array (vertical), and `y` along the second dimension of the array
(horizontal).  This ensures compatibility with `histogramdd`.

Examples
--------
&gt;&gt;&gt; import matplotlib as mpl
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct a 2D-histogram with variable bin width. First define the bin
edges:

&gt;&gt;&gt; xedges = [0, 1, 1.5, 3, 5]
&gt;&gt;&gt; yedges = [0, 2, 3, 4, 6]

Next we create a histogram H with random bin content:

&gt;&gt;&gt; x = np.random.normal(3, 1, 100)
&gt;&gt;&gt; y = np.random.normal(1, 1, 100)
&gt;&gt;&gt; H, xedges, yedges = np.histogram2d(y, x, bins=(xedges, yedges))

Or we fill the histogram H with a determined bin content:

&gt;&gt;&gt; H = np.ones((4, 4)).cumsum().reshape(4, 4)
&gt;&gt;&gt; print H[::-1]  # This shows the bin content in the order as plotted
[[ 13.  14.  15.  16.]
 [  9.  10.  11.  12.]
 [  5.   6.   7.   8.]
 [  1.   2.   3.   4.]]

Imshow can only do an equidistant representation of bins:

&gt;&gt;&gt; fig = plt.figure(figsize=(7, 3))
&gt;&gt;&gt; ax = fig.add_subplot(131)
&gt;&gt;&gt; ax.set_title('imshow: equidistant')
&gt;&gt;&gt; im = plt.imshow(H, interpolation='nearest', origin='low',
                extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])

pcolormesh can display exact bin edges:

&gt;&gt;&gt; ax = fig.add_subplot(132)
&gt;&gt;&gt; ax.set_title('pcolormesh: exact bin edges')
&gt;&gt;&gt; X, Y = np.meshgrid(xedges, yedges)
&gt;&gt;&gt; ax.pcolormesh(X, Y, H)
&gt;&gt;&gt; ax.set_aspect('equal')

NonUniformImage displays exact bin edges with interpolation:

&gt;&gt;&gt; ax = fig.add_subplot(133)
&gt;&gt;&gt; ax.set_title('NonUniformImage: interpolated')
&gt;&gt;&gt; im = mpl.image.NonUniformImage(ax, interpolation='bilinear')
&gt;&gt;&gt; xcenters = xedges[:-1] + 0.5 * (xedges[1:] - xedges[:-1])
&gt;&gt;&gt; ycenters = yedges[:-1] + 0.5 * (yedges[1:] - yedges[:-1])
&gt;&gt;&gt; im.set_data(xcenters, ycenters, H)
&gt;&gt;&gt; ax.images.append(im)
&gt;&gt;&gt; ax.set_xlim(xedges[0], xedges[-1])
&gt;&gt;&gt; ax.set_ylim(yedges[0], yedges[-1])
&gt;&gt;&gt; ax.set_aspect('equal')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>An array containing the x coordinates of the points to be
histogrammed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>An array containing the y coordinates of the points to be
histogrammed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="binsScalar" port_type="basic:Integer">
      <docstring>The bin specification:

  * If int, the number of bins for the two dimensions (nx=ny=bins).
  * If array_like, the bin edges for the two dimensions
    (x_edges=y_edges=bins).
  * If [int, int], the number of bins in each dimension
    (nx, ny = bins).
  * If [array, array], the bin edges in each dimension
    (x_edges, y_edges = bins).
  * A combination [int, array] or [array, int], where int
    is the number of bins and array is the bin edges.
</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="range" name="range" port_type="basic:List">
      <docstring>The leftmost and rightmost edges of the bins along each dimension
(if not specified explicitly in the `bins` parameters):
``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
will be considered outliers and not tallied in the histogram.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="normed" name="normed" port_type="basic:Boolean">
      <docstring>If False, returns the number of samples in each bin. If True,
returns the bin density ``bin_count / sample_count / bin_area``.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
Weights are normalized to 1 if `normed` is True. If `normed` is
False, the values of the returned histogram are equal to the sum of
the weights belonging to the samples falling into each bin.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="H" name="H" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The bi-dimensional histogram of samples `x` and `y`. Values in `x`
are histogrammed along the first dimension and values in `y` are
histogrammed along the second dimension.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xedges" name="xedges" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The bin edges along the first dimension.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yedges" name="yedges" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The bin edges along the second dimension.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.histogramdd" module_name="histogramdd" namespace="'statistics'" output_type="list">
    <docstring>Compute the multidimensional histogram of some data.

Parameters
----------
sample : array_like
    The data to be histogrammed. It must be an (N,D) array or data
    that can be converted to such. The rows of the resulting array
    are the coordinates of points in a D dimensional polytope.
bins : sequence or int, optional
    The bin specification:

    * A sequence of arrays describing the bin edges along each dimension.
    * The number of bins for each dimension (nx, ny, ... =bins)
    * The number of bins for all dimensions (nx=ny=...=bins).

range : sequence, optional
    A sequence of lower and upper bin edges to be used if the edges are
    not given explicitly in `bins`. Defaults to the minimum and maximum
    values along each dimension.
normed : bool, optional
    If False, returns the number of samples in each bin. If True,
    returns the bin density ``bin_count / sample_count / bin_volume``.
weights : (N,) array_like, optional
    An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.
    Weights are normalized to 1 if normed is True. If normed is False,
    the values of the returned histogram are equal to the sum of the
    weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray
    The multidimensional histogram of sample x. See normed and weights
    for the different possible semantics.
edges : list
    A list of D arrays describing the bin edges for each dimension.

See Also
--------
histogram: 1-D histogram
histogram2d: 2-D histogram

Examples
--------
&gt;&gt;&gt; r = np.random.randn(100,3)
&gt;&gt;&gt; H, edges = np.histogramdd(r, bins = (5, 8, 4))
&gt;&gt;&gt; H.shape, edges[0].size, edges[1].size, edges[2].size
((5, 8, 4), 6, 9, 5)</docstring>
    <inputPortSpec arg="sample" name="sample" port_type="basic:List" show_port="True">
      <docstring>The data to be histogrammed. It must be an (N,D) array or data
that can be converted to such. The rows of the resulting array
are the coordinates of points in a D dimensional polytope.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="binsScalar" port_type="basic:Integer">
      <docstring>The bin specification:

* A sequence of arrays describing the bin edges along each dimension.
* The number of bins for each dimension (nx, ny, ... =bins)
* The number of bins for all dimensions (nx=ny=...=bins).
</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="range" name="range" port_type="basic:List">
      <docstring>A sequence of lower and upper bin edges to be used if the edges are
not given explicitly in `bins`. Defaults to the minimum and maximum
values along each dimension.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="normed" name="normed" port_type="basic:Boolean">
      <docstring>If False, returns the number of samples in each bin. If True,
returns the bin density ``bin_count / sample_count / bin_volume``.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.
Weights are normalized to 1 if normed is True. If normed is False,
the values of the returned histogram are equal to the sum of the
weights belonging to the samples falling into each bin.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="H" name="H" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The multidimensional histogram of sample x. See normed and weights
for the different possible semantics.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="edges" name="edges" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>A list of D arrays describing the bin edges for each dimension.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.bincount" module_name="bincount" namespace="'statistics'">
    <docstring>bincount(x, weights=None, minlength=None)

Count number of occurrences of each value in array of non-negative ints.

The number of bins (of size 1) is one larger than the largest value in
`x`. If `minlength` is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of `x`).
Each bin gives the number of occurrences of its index value in `x`.
If `weights` is specified the input array is weighted by it, i.e. if a
value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
of ``out[n] += 1``.

Parameters
----------
x : array_like, 1 dimension, nonnegative ints
    Input array.
weights : array_like, optional
    Weights, array of the same shape as `x`.
minlength : int, optional
    A minimum number of bins for the output array.

    .. versionadded:: 1.6.0

Returns
-------
out : ndarray of ints
    The result of binning the input array.
    The length of `out` is equal to ``np.amax(x)+1``.

Raises
------
ValueError
    If the input is not 1-dimensional, or contains elements with negative
    values, or if `minlength` is non-positive.
TypeError
    If the type of the input is float or complex.

See Also
--------
histogram, digitize, unique

Examples
--------
&gt;&gt;&gt; np.bincount(np.arange(5))
array([1, 1, 1, 1, 1])
&gt;&gt;&gt; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
array([1, 3, 1, 1, 0, 0, 0, 1])

&gt;&gt;&gt; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
&gt;&gt;&gt; np.bincount(x).size == np.amax(x)+1
True

The input array needs to be of integer dtype, otherwise a
TypeError is raised:

&gt;&gt;&gt; np.bincount(np.arange(5, dtype=np.float))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: array cannot be safely cast to required type

A possible use of ``bincount`` is to perform sums over
variable-size chunks of an array, using the ``weights`` keyword.

&gt;&gt;&gt; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
&gt;&gt;&gt; x = np.array([0, 1, 1, 2, 2, 2])
&gt;&gt;&gt; np.bincount(x,  weights=w)
array([ 0.3,  0.7,  1.1])</docstring>
    <inputPortSpec arg="x" depth="1" name="x" port_type="basic:Integer" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>Weights, array of the same shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="minlength" name="minlength" port_type="basic:Integer">
      <docstring>A minimum number of bins for the output array.

.. versionadded:: 1.6.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The result of binning the input array.
The length of `out` is equal to ``np.amax(x)+1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.digitize" module_name="digitize" namespace="'statistics'">
    <docstring>digitize(x, bins, right=False)

Return the indices of the bins to which each value in input array belongs.

Each index ``i`` returned is such that ``bins[i-1] &lt;= x &lt; bins[i]`` if
`bins` is monotonically increasing, or ``bins[i-1] &gt; x &gt;= bins[i]`` if
`bins` is monotonically decreasing. If values in `x` are beyond the
bounds of `bins`, 0 or ``len(bins)`` is returned as appropriate. If right
is True, then the right bin is closed so that the index ``i`` is such
that ``bins[i-1] &lt; x &lt;= bins[i]`` or bins[i-1] &gt;= x &gt; bins[i]`` if `bins`
is monotonically increasing or decreasing, respectively.

Parameters
----------
x : array_like
    Input array to be binned. Prior to Numpy 1.10.0, this array had to
    be 1-dimensional, but can now have any shape.
bins : array_like
    Array of bins. It has to be 1-dimensional and monotonic.
right : bool, optional
    Indicating whether the intervals include the right or the left bin
    edge. Default behavior is (right==False) indicating that the interval
    does not include the right edge. The left bin end is open in this
    case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
    monotonically increasing bins.

Returns
-------
out : ndarray of ints
    Output array of indices, of same shape as `x`.

Raises
------
ValueError
    If `bins` is not monotonic.
TypeError
    If the type of the input is complex.

See Also
--------
bincount, histogram, unique

Notes
-----
If values in `x` are such that they fall outside the bin range,
attempting to index `bins` with the indices that `digitize` returns
will result in an IndexError.

.. versionadded:: 1.10.0

`np.digitize` is  implemented in terms of `np.searchsorted`. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.

Examples
--------
&gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])
&gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
&gt;&gt;&gt; inds = np.digitize(x, bins)
&gt;&gt;&gt; inds
array([1, 4, 3, 2])
&gt;&gt;&gt; for n in range(x.size):
...   print bins[inds[n]-1], "&lt;=", x[n], "&lt;", bins[inds[n]]
...
0.0 &lt;= 0.2 &lt; 1.0
4.0 &lt;= 6.4 &lt; 10.0
2.5 &lt;= 3.0 &lt; 4.0
1.0 &lt;= 1.6 &lt; 2.5

&gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
&gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20])
&gt;&gt;&gt; np.digitize(x,bins,right=True)
array([1, 2, 3, 4, 4])
&gt;&gt;&gt; np.digitize(x,bins,right=False)
array([1, 3, 3, 4, 5])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array to be binned. Prior to Numpy 1.10.0, this array had to
be 1-dimensional, but can now have any shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="bins" port_type="basic:List" show_port="True">
      <docstring>Array of bins. It has to be 1-dimensional and monotonic.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="right" name="right" port_type="basic:Boolean">
      <docstring>Indicating whether the intervals include the right or the left bin
edge. Default behavior is (right==False) indicating that the interval
does not include the right edge. The left bin end is open in this
case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
monotonically increasing bins.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Output array of indices, of same shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.cholesky" module_name="cholesky" namespace="'linalg'">
    <docstring>Cholesky decomposition.

Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
where `L` is lower-triangular and .H is the conjugate transpose operator
(which is the ordinary transpose if `a` is real-valued).  `a` must be
Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is
actually returned.

Parameters
----------
a : (..., M, M) array_like
    Hermitian (symmetric if all elements are real), positive-definite
    input matrix.

Returns
-------
L : (..., M, M) array_like
    Upper or lower-triangular Cholesky factor of `a`.  Returns a
    matrix object if `a` is a matrix object.

Raises
------
LinAlgError
   If the decomposition fails, for example, if `a` is not
   positive-definite.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The Cholesky decomposition is often used as a fast way of solving

.. math:: A \mathbf{x} = \mathbf{b}

(when `A` is both Hermitian/symmetric and positive-definite).

First, we solve for :math:`\mathbf{y}` in

.. math:: L \mathbf{y} = \mathbf{b},

and then for :math:`\mathbf{x}` in

.. math:: L.H \mathbf{x} = \mathbf{y}.

Examples
--------
&gt;&gt;&gt; A = np.array([[1,-2j],[2j,5]])
&gt;&gt;&gt; A
array([[ 1.+0.j,  0.-2.j],
       [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; L = np.linalg.cholesky(A)
&gt;&gt;&gt; L
array([[ 1.+0.j,  0.+0.j],
       [ 0.+2.j,  1.+0.j]])
&gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A
array([[ 1.+0.j,  0.-2.j],
       [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
&gt;&gt;&gt; np.linalg.cholesky(A) # an ndarray object is returned
array([[ 1.+0.j,  0.+0.j],
       [ 0.+2.j,  1.+0.j]])
&gt;&gt;&gt; # But a matrix object is returned if A is a matrix object
&gt;&gt;&gt; LA.cholesky(np.matrix(A))
matrix([[ 1.+0.j,  0.+0.j],
        [ 0.+2.j,  1.+0.j]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Hermitian (symmetric if all elements are real), positive-definite
input matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="L" name="L" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Upper or lower-triangular Cholesky factor of `a`.  Returns a
matrix object if `a` is a matrix object.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.cond" module_name="cond" namespace="'linalg'">
    <docstring>Compute the condition number of a matrix.

This function is capable of returning the condition number using
one of seven different norms, depending on the value of `p` (see
Parameters below).

Parameters
----------
x : (..., M, N) array_like
    The matrix whose condition number is sought.
p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional
    Order of the norm:

    =====  ============================
    p      norm for matrices
    =====  ============================
    None   2-norm, computed directly using the ``SVD``
    'fro'  Frobenius norm
    inf    max(sum(abs(x), axis=1))
    -inf   min(sum(abs(x), axis=1))
    1      max(sum(abs(x), axis=0))
    -1     min(sum(abs(x), axis=0))
    2      2-norm (largest sing. value)
    -2     smallest singular value
    =====  ============================

    inf means the numpy.inf object, and the Frobenius norm is
    the root-of-sum-of-squares norm.

Returns
-------
c : {float, inf}
    The condition number of the matrix. May be infinite.

See Also
--------
numpy.linalg.norm

Notes
-----
The condition number of `x` is defined as the norm of `x` times the
norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
(root-of-sum-of-squares) or one of a number of other matrix norms.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
       Academic Press, Inc., 1980, pg. 285.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
&gt;&gt;&gt; a
array([[ 1,  0, -1],
       [ 0,  1,  0],
       [ 1,  0,  1]])
&gt;&gt;&gt; LA.cond(a)
1.4142135623730951
&gt;&gt;&gt; LA.cond(a, 'fro')
3.1622776601683795
&gt;&gt;&gt; LA.cond(a, np.inf)
2.0
&gt;&gt;&gt; LA.cond(a, -np.inf)
1.0
&gt;&gt;&gt; LA.cond(a, 1)
2.0
&gt;&gt;&gt; LA.cond(a, -1)
1.0
&gt;&gt;&gt; LA.cond(a, 2)
1.4142135623730951
&gt;&gt;&gt; LA.cond(a, -2)
0.70710678118654746
&gt;&gt;&gt; min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))
0.70710678118654746</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The matrix whose condition number is sought.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p">
      <docstring>Order of the norm:

=====  ============================
p      norm for matrices
=====  ============================
None   2-norm, computed directly using the ``SVD``
'fro'  Frobenius norm
inf    max(sum(abs(x), axis=1))
-inf   min(sum(abs(x), axis=1))
1      max(sum(abs(x), axis=0))
-1     min(sum(abs(x), axis=0))
2      2-norm (largest sing. value)
-2     smallest singular value
=====  ============================

inf means the numpy.inf object, and the Frobenius norm is
the root-of-sum-of-squares norm.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['inf', '-inf', 'fro']]</values>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" show_port="True" sort_key="0">
      <docstring>The condition number of the matrix. May be infinite.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.det" module_name="det" namespace="'linalg'">
    <docstring>Compute the determinant of an array.

Parameters
----------
a : (..., M, M) array_like
    Input array to compute determinants for.

Returns
-------
det : (...) array_like
    Determinant of `a`.

See Also
--------
slogdet : Another way to representing the determinant, more suitable
  for large matrices where underflow/overflow may occur.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The determinant is computed via LU factorization using the LAPACK
routine z/dgetrf.

Examples
--------
The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.linalg.det(a)
-2.0

Computing determinants for a stack of matrices:

&gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
&gt;&gt;&gt; a.shape
(3, 2, 2)
&gt;&gt;&gt; np.linalg.det(a)
array([-2., -3., -8.])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array to compute determinants for.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="det" name="det" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Determinant of `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.eig" module_name="eig" namespace="'linalg'" output_type="list">
    <docstring>Compute the eigenvalues and right eigenvectors of a square array.

Parameters
----------
a : (..., M, M) array
    Matrices for which the eigenvalues and right eigenvectors will
    be computed

Returns
-------
w : (..., M) array
    The eigenvalues, each repeated according to its multiplicity.
    The eigenvalues are not necessarily ordered. The resulting
    array will be of complex type, unless the imaginary part is
    zero in which case it will be cast to a real type. When `a`
    is real the resulting eigenvalues will be real (0 imaginary
    part) or occur in conjugate pairs

v : (..., M, M) array
    The normalized (unit "length") eigenvectors, such that the
    column ``v[:,i]`` is the eigenvector corresponding to the
    eigenvalue ``w[i]``.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvals : eigenvalues of a non-symmetric array.

eigh : eigenvalues and eigenvectors of a symmetric or Hermitian
       (conjugate symmetric) array.

eigvalsh : eigenvalues of a symmetric or Hermitian (conjugate symmetric)
           array.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the _geev LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

The number `w` is an eigenvalue of `a` if there exists a vector
`v` such that ``dot(a,v) = w * v``. Thus, the arrays `a`, `w`, and
`v` satisfy the equations ``dot(a[:,:], v[:,i]) = w[i] * v[:,i]``
for :math:`i \in \{0,...,M-1\}`.

The array `v` of eigenvectors may not be of maximum rank, that is, some
of the columns may be linearly dependent, although round-off error may
obscure that fact. If the eigenvalues are all different, then theoretically
the eigenvectors are linearly independent. Likewise, the (complex-valued)
matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,
if ``dot(a, a.H) = dot(a.H, a)``, where `a.H` denotes the conjugate
transpose of `a`.

Finally, it is emphasized that `v` consists of the *right* (as in
right-hand side) eigenvectors of `a`.  A vector `y` satisfying
``dot(y.T, a) = z * y.T`` for some number `z` is called a *left*
eigenvector of `a`, and, in general, the left and right eigenvectors
of a matrix are not necessarily the (perhaps conjugate) transposes
of each other.

References
----------
G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
Academic Press, Inc., 1980, Various pp.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA

(Almost) trivial example with real e-values and e-vectors.

&gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))
&gt;&gt;&gt; w; v
array([ 1.,  2.,  3.])
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])

Real matrix possessing complex e-values and e-vectors; note that the
e-values are complex conjugates of each other.

&gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))
&gt;&gt;&gt; w; v
array([ 1. + 1.j,  1. - 1.j])
array([[ 0.70710678+0.j        ,  0.70710678+0.j        ],
       [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]])

Complex-valued matrix with real e-values (but complex-valued e-vectors);
note that a.conj().T = a, i.e., a is Hermitian.

&gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])
&gt;&gt;&gt; w, v = LA.eig(a)
&gt;&gt;&gt; w; v
array([  2.00000000e+00+0.j,   5.98651912e-36+0.j]) # i.e., {2, 0}
array([[ 0.00000000+0.70710678j,  0.70710678+0.j        ],
       [ 0.70710678+0.j        ,  0.00000000+0.70710678j]])

Be careful about round-off error!

&gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
&gt;&gt;&gt; # Theor. e-values are 1 +/- 1e-9
&gt;&gt;&gt; w, v = LA.eig(a)
&gt;&gt;&gt; w; v
array([ 1.,  1.])
array([[ 1.,  0.],
       [ 0.,  1.]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrices for which the eigenvalues and right eigenvectors will
be computed</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The eigenvalues, each repeated according to its multiplicity.
The eigenvalues are not necessarily ordered. The resulting
array will be of complex type, unless the imaginary part is
zero in which case it will be cast to a real type. When `a`
is real the resulting eigenvalues will be real (0 imaginary
part) or occur in conjugate pairs
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The normalized (unit "length") eigenvectors, such that the
column ``v[:,i]`` is the eigenvector corresponding to the
eigenvalue ``w[i]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.eigh" module_name="eigh" namespace="'linalg'" output_type="list">
    <docstring>Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.

Returns two objects, a 1-D array containing the eigenvalues of `a`, and
a 2-D square array or matrix (depending on the input type) of the
corresponding eigenvectors (in columns).

Parameters
----------
a : (..., M, M) array
    Hermitian/Symmetric matrices whose eigenvalues and
    eigenvectors are to be computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').

Returns
-------
w : (..., M) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.
v : {(..., M, M) ndarray, (..., M, M) matrix}
    The column ``v[:, i]`` is the normalized eigenvector corresponding
    to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
    a matrix object.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvalsh : eigenvalues of symmetric or Hermitian arrays.
eig : eigenvalues and right eigenvectors for non-symmetric arrays.
eigvals : eigenvalues of non-symmetric arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,
_heevd

The eigenvalues of real symmetric or complex Hermitian matrices are
always real. [1]_ The array `v` of (column) eigenvectors is unitary
and `a`, `w`, and `v` satisfy the equations
``dot(a, v[:, i]) = w[i] * v[:, i]``.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 222.

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])
&gt;&gt;&gt; a
array([[ 1.+0.j,  0.-2.j],
       [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; w, v = LA.eigh(a)
&gt;&gt;&gt; w; v
array([ 0.17157288,  5.82842712])
array([[-0.92387953+0.j        , -0.38268343+0.j        ],
       [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])

&gt;&gt;&gt; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
array([2.77555756e-17 + 0.j, 0. + 1.38777878e-16j])
&gt;&gt;&gt; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
array([ 0.+0.j,  0.+0.j])

&gt;&gt;&gt; A = np.matrix(a) # what happens if input is a matrix object
&gt;&gt;&gt; A
matrix([[ 1.+0.j,  0.-2.j],
        [ 0.+2.j,  5.+0.j]])
&gt;&gt;&gt; w, v = LA.eigh(A)
&gt;&gt;&gt; w; v
array([ 0.17157288,  5.82842712])
matrix([[-0.92387953+0.j        , -0.38268343+0.j        ],
        [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Hermitian/Symmetric matrices whose eigenvalues and
eigenvectors are to be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="UPLO" name="UPLO">
      <docstring>Specifies whether the calculation is done with the lower triangular
part of `a` ('L', default) or the upper triangular part ('U').</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['L', 'U']]</values>
      <defaults>['L']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The eigenvalues in ascending order, each repeated according to
its multiplicity.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The column ``v[:, i]`` is the normalized eigenvector corresponding
to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
a matrix object.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.eigvals" module_name="eigvals" namespace="'linalg'">
    <docstring>Compute the eigenvalues of a general matrix.

Main difference between `eigvals` and `eig`: the eigenvectors aren't
returned.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues will be computed.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues, each repeated according to its multiplicity.
    They are not necessarily ordered, nor are they necessarily
    real for real matrices.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eig : eigenvalues and right eigenvectors of general arrays
eigvalsh : eigenvalues of symmetric or Hermitian arrays.
eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the _geev LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

Examples
--------
Illustration, using the fact that the eigenvalues of a diagonal matrix
are its diagonal elements, that multiplying a matrix on the left
by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
of `Q`), preserves the eigenvalues of the "middle" matrix.  In other words,
if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
``A``:

&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; x = np.random.random()
&gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
&gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
(1.0, 1.0, 0.0)

Now multiply a diagonal matrix by Q on one side and by Q.T on the other:

&gt;&gt;&gt; D = np.diag((-1,1))
&gt;&gt;&gt; LA.eigvals(D)
array([-1.,  1.])
&gt;&gt;&gt; A = np.dot(Q, D)
&gt;&gt;&gt; A = np.dot(A, Q.T)
&gt;&gt;&gt; LA.eigvals(A)
array([ 1., -1.])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A complex- or real-valued matrix whose eigenvalues will be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The eigenvalues, each repeated according to its multiplicity.
They are not necessarily ordered, nor are they necessarily
real for real matrices.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.eigvalsh" module_name="eigvalsh" namespace="'linalg'">
    <docstring>Compute the eigenvalues of a Hermitian or real symmetric matrix.

Main difference from eigh: the eigenvectors are not computed.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues are to be
    computed.
UPLO : {'L', 'U'}, optional
    Same as `lower`, with 'L' for lower and 'U' for upper triangular.
    Deprecated.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.
eigvals : eigenvalues of general real or complex arrays.
eig : eigenvalues and right eigenvectors of general real or complex
      arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues are computed using LAPACK routines _syevd, _heevd

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])
&gt;&gt;&gt; LA.eigvalsh(a)
array([ 0.17157288,  5.82842712])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A complex- or real-valued matrix whose eigenvalues are to be
computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="UPLO" name="UPLO">
      <docstring>Same as `lower`, with 'L' for lower and 'U' for upper triangular.
Deprecated.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['L', 'U']]</values>
      <defaults>['L']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The eigenvalues in ascending order, each repeated according to
its multiplicity.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.inv" module_name="inv" namespace="'linalg'">
    <docstring>Compute the (multiplicative) inverse of a matrix.

Given a square matrix `a`, return the matrix `ainv` satisfying
``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be inverted.

Returns
-------
ainv : (..., M, M) ndarray or matrix
    (Multiplicative) inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is not square or inversion fails.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

Examples
--------
&gt;&gt;&gt; from numpy.linalg import inv
&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
&gt;&gt;&gt; ainv = inv(a)
&gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))
True
&gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))
True

If a is a matrix object, then the return value is a matrix as well:

&gt;&gt;&gt; ainv = inv(np.matrix(a))
&gt;&gt;&gt; ainv
matrix([[-2. ,  1. ],
        [ 1.5, -0.5]])

Inverses of several matrices can be computed at once:

&gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
&gt;&gt;&gt; inv(a)
array([[[-2. ,  1. ],
        [ 1.5, -0.5]],
       [[-5. ,  2. ],
        [ 3. , -1. ]]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be inverted.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="ainv" name="ainv" show_port="True" sort_key="0">
      <docstring>(Multiplicative) inverse of the matrix `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.lstsq" module_name="lstsq" namespace="'linalg'" output_type="list">
    <docstring>Return the least-squares solution to a linear matrix equation.

Solves the equation `a x = b` by computing a vector `x` that
minimizes the Euclidean 2-norm `|| b - a x ||^2`.  The equation may
be under-, well-, or over- determined (i.e., the number of
linearly independent rows of `a` can be less than, equal to, or
greater than its number of linearly independent columns).  If `a`
is square and of full rank, then `x` (but for round-off error) is
the "exact" solution of the equation.

Parameters
----------
a : (M, N) array_like
    "Coefficient" matrix.
b : {(M,), (M, K)} array_like
    Ordinate or "dependent variable" values. If `b` is two-dimensional,
    the least-squares solution is calculated for each of the `K` columns
    of `b`.
rcond : float, optional
    Cut-off ratio for small singular values of `a`.
    Singular values are set to zero if they are smaller than `rcond`
    times the largest singular value of `a`.

Returns
-------
x : {(N,), (N, K)} ndarray
    Least-squares solution. If `b` is two-dimensional,
    the solutions are in the `K` columns of `x`.
residuals : {(), (1,), (K,)} ndarray
    Sums of residuals; squared Euclidean 2-norm for each column in
    ``b - a*x``.
    If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.
    If `b` is 1-dimensional, this is a (1,) shape array.
    Otherwise the shape is (K,).
rank : int
    Rank of matrix `a`.
s : (min(M, N),) ndarray
    Singular values of `a`.

Raises
------
LinAlgError
    If computation does not converge.

Notes
-----
If `b` is a matrix, then all array results are returned as matrices.

Examples
--------
Fit a line, ``y = mx + c``, through some noisy data-points:

&gt;&gt;&gt; x = np.array([0, 1, 2, 3])
&gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])

By examining the coefficients, we see that the line should have a
gradient of roughly 1 and cut the y-axis at, more or less, -1.

We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:

&gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T
&gt;&gt;&gt; A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])

&gt;&gt;&gt; m, c = np.linalg.lstsq(A, y)[0]
&gt;&gt;&gt; print m, c
1.0 -0.95

Plot the data along with the fitted line:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x, y, 'o', label='Original data', markersize=10)
&gt;&gt;&gt; plt.plot(x, m*x + c, 'r', label='Fitted line')
&gt;&gt;&gt; plt.legend()
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>"Coefficient" matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Ordinate or "dependent variable" values. If `b` is two-dimensional,
the least-squares solution is calculated for each of the `K` columns
of `b`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Cut-off ratio for small singular values of `a`.
Singular values are set to zero if they are smaller than `rcond`
times the largest singular value of `a`.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Least-squares solution. If `b` is two-dimensional,
the solutions are in the `K` columns of `x`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="residuals" name="residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Sums of residuals; squared Euclidean 2-norm for each column in
``b - a*x``.
If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.
If `b` is 1-dimensional, this is a (1,) shape array.
Otherwise the shape is (K,).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Rank of matrix `a`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Singular values of `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.matrix_power" module_name="matrix_power" namespace="'linalg'">
    <docstring>Raise a square matrix to the (integer) power `n`.

For positive integers `n`, the power is computed by repeated matrix
squarings and matrix multiplications. If ``n == 0``, the identity matrix
of the same shape as M is returned. If ``n &lt; 0``, the inverse
is computed and then raised to the ``abs(n)``.

Parameters
----------
M : ndarray or matrix object
    Matrix to be "powered."  Must be square, i.e. ``M.shape == (m, m)``,
    with `m` a positive integer.
n : int
    The exponent can be any integer or long integer, positive,
    negative, or zero.

Returns
-------
M**n : ndarray or matrix object
    The return value is the same shape and type as `M`;
    if the exponent is positive or zero then the type of the
    elements is the same as those of `M`. If the exponent is
    negative the elements are floating-point.

Raises
------
LinAlgError
    If the matrix is not numerically invertible.

See Also
--------
matrix
    Provides an equivalent function as the exponentiation operator
    (``**``, not ``^``).

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
&gt;&gt;&gt; LA.matrix_power(i, 3) # should = -i
array([[ 0, -1],
       [ 1,  0]])
&gt;&gt;&gt; LA.matrix_power(np.matrix(i), 3) # matrix arg returns matrix
matrix([[ 0, -1],
        [ 1,  0]])
&gt;&gt;&gt; LA.matrix_power(i, 0)
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; LA.matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
array([[ 0.,  1.],
       [-1.,  0.]])

Somewhat more sophisticated example

&gt;&gt;&gt; q = np.zeros((4, 4))
&gt;&gt;&gt; q[0:2, 0:2] = -i
&gt;&gt;&gt; q[2:4, 2:4] = i
&gt;&gt;&gt; q # one of the three quarternion units not equal to 1
array([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])
&gt;&gt;&gt; LA.matrix_power(q, 2) # = -np.eye(4)
array([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:List" show_port="True">
      <docstring>Matrix to be "powered."  Must be square, i.e. ``M.shape == (m, m)``,
with `m` a positive integer.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The exponent can be any integer or long integer, positive,
negative, or zero.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="M**n" name="M**n" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The return value is the same shape and type as `M`;
if the exponent is positive or zero then the type of the
elements is the same as those of `M`. If the exponent is
negative the elements are floating-point.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.matrix_rank" module_name="matrix_rank" namespace="'linalg'">
    <docstring>Return matrix rank of array using SVD method

Rank of the array is the number of SVD singular values of the array that are
greater than `tol`.

Parameters
----------
M : {(M,), (M, N)} array_like
    array of &lt;=2 dimensions
tol : {None, float}, optional
   threshold below which SVD values are considered zero. If `tol` is
   None, and ``S`` is an array with singular values for `M`, and
   ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
   set to ``S.max() * max(M.shape) * eps``.

Notes
-----
The default threshold to detect rank deficiency is a test on the magnitude
of the singular values of `M`.  By default, we identify singular values less
than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with
the symbols defined above). This is the algorithm MATLAB uses [1].  It also
appears in *Numerical recipes* in the discussion of SVD solutions for linear
least squares [2].

This default threshold is designed to detect rank deficiency accounting for
the numerical errors of the SVD computation.  Imagine that there is a column
in `M` that is an exact (in floating point) linear combination of other
columns in `M`. Computing the SVD on `M` will not produce a singular value
exactly equal to 0 in general: any difference of the smallest SVD value from
0 will be caused by numerical imprecision in the calculation of the SVD.
Our threshold for small SVD values takes this numerical imprecision into
account, and the default threshold will detect such numerical rank
deficiency.  The threshold may declare a matrix `M` rank deficient even if
the linear combination of some columns of `M` is not exactly equal to
another column of `M` but only numerically very close to another column of
`M`.

We chose our default threshold because it is in wide use.  Other thresholds
are possible.  For example, elsewhere in the 2007 edition of *Numerical
recipes* there is an alternative threshold of ``S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
this threshold as being based on "expected roundoff error" (p 71).

The thresholds above deal with floating point roundoff error in the
calculation of the SVD.  However, you may have more information about the
sources of error in `M` that would make you consider other tolerance values
to detect *effective* rank deficiency.  The most useful measure of the
tolerance depends on the operations you intend to use on your matrix.  For
example, if your data come from uncertain measurements with uncertainties
greater than floating point epsilon, choosing a tolerance near that
uncertainty may be preferable.  The tolerance may be absolute if the
uncertainties are absolute rather than relative.

References
----------
.. [1] MATLAB reference documention, "Rank"
       http://www.mathworks.com/help/techdoc/ref/rank.html
.. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
       "Numerical Recipes (3rd edition)", Cambridge University Press, 2007,
       page 795.

Examples
--------
&gt;&gt;&gt; from numpy.linalg import matrix_rank
&gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix
4
&gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
&gt;&gt;&gt; matrix_rank(I)
3
&gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
1
&gt;&gt;&gt; matrix_rank(np.zeros((4,)))
0</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:List" show_port="True">
      <docstring>array of &lt;=2 dimensions</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>threshold below which SVD values are considered zero. If `tol` is
None, and ``S`` is an array with singular values for `M`, and
``eps`` is the epsilon value for datatype of ``S``, then `tol` is
set to ``S.max() * max(M.shape) * eps``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.multi_dot" module_name="multi_dot" namespace="'linalg'">
    <docstring>Compute the dot product of two or more arrays in a single function call,
while automatically selecting the fastest evaluation order.

`multi_dot` chains `numpy.dot` and uses optimal parenthesization
of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
this can speed up the multiplication a lot.

If the first argument is 1-D it is treated as a row vector.
If the last argument is 1-D it is treated as a column vector.
The other arguments must be 2-D.

Think of `multi_dot` as::

    def multi_dot(arrays): return functools.reduce(np.dot, arrays)


Parameters
----------
arrays : sequence of array_like
    If the first argument is 1-D it is treated as row vector.
    If the last argument is 1-D it is treated as column vector.
    The other arguments must be 2-D.

Returns
-------
output : ndarray
    Returns the dot product of the supplied arrays.

See Also
--------
dot : dot multiplication with two arguments.

References
----------

.. [1] Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378
.. [2] http://en.wikipedia.org/wiki/Matrix_chain_multiplication

Examples
--------
`multi_dot` allows you to write::

&gt;&gt;&gt; from numpy.linalg import multi_dot
&gt;&gt;&gt; # Prepare some data
&gt;&gt;&gt; A = np.random.random(10000, 100)
&gt;&gt;&gt; B = np.random.random(100, 1000)
&gt;&gt;&gt; C = np.random.random(1000, 5)
&gt;&gt;&gt; D = np.random.random(5, 333)
&gt;&gt;&gt; # the actual dot multiplication
&gt;&gt;&gt; multi_dot([A, B, C, D])

instead of::

&gt;&gt;&gt; np.dot(np.dot(np.dot(A, B), C), D)
&gt;&gt;&gt; # or
&gt;&gt;&gt; A.dot(B).dot(C).dot(D)


Example: multiplication costs of different parenthesizations
------------------------------------------------------------

The cost for a matrix multiplication can be calculated with the
following function::

    def cost(A, B): return A.shape[0] * A.shape[1] * B.shape[1]

Let's assume we have three matrices
:math:`A_{10x100}, B_{100x5}, C_{5x50}$`.

The costs for the two different parenthesizations are as follows::

    cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
    cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000</docstring>
    <inputPortSpec arg="arrays" name="arrays" port_type="basic:List" show_port="True">
      <docstring>If the first argument is 1-D it is treated as row vector.
If the last argument is 1-D it is treated as column vector.
The other arguments must be 2-D.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns the dot product of the supplied arrays.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.norm" module_name="norm" namespace="'linalg'">
    <docstring>Matrix or vector norm.

This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
x : array_like
    Input array.  If `axis` is None, `x` must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object.
axis : {int, 2-tuple of ints, None}, optional
    If `axis` is an integer, it specifies the axis of `x` along which to
    compute the vector norms.  If `axis` is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If `axis` is None then either a vector norm (when `x`
    is 1-D) or a matrix norm (when `x` is 2-D) is returned.
keepdims : bool, optional
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original `x`.

    .. versionadded:: 1.10.0

Returns
-------
n : float or ndarray
    Norm of the matrix or vector(s).

Notes
-----
For values of ``ord &lt;= 0``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
'nuc'  nuclear norm                  --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

The nuclear norm is the sum of the singular values.

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
&gt;&gt;&gt; from numpy import linalg as LA
&gt;&gt;&gt; a = np.arange(9) - 4
&gt;&gt;&gt; a
array([-4, -3, -2, -1,  0,  1,  2,  3,  4])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])

&gt;&gt;&gt; LA.norm(a)
7.745966692414834
&gt;&gt;&gt; LA.norm(b)
7.745966692414834
&gt;&gt;&gt; LA.norm(b, 'fro')
7.745966692414834
&gt;&gt;&gt; LA.norm(a, np.inf)
4
&gt;&gt;&gt; LA.norm(b, np.inf)
9
&gt;&gt;&gt; LA.norm(a, -np.inf)
0
&gt;&gt;&gt; LA.norm(b, -np.inf)
2

&gt;&gt;&gt; LA.norm(a, 1)
20
&gt;&gt;&gt; LA.norm(b, 1)
7
&gt;&gt;&gt; LA.norm(a, -1)
-4.6566128774142013e-010
&gt;&gt;&gt; LA.norm(b, -1)
6
&gt;&gt;&gt; LA.norm(a, 2)
7.745966692414834
&gt;&gt;&gt; LA.norm(b, 2)
7.3484692283495345

&gt;&gt;&gt; LA.norm(a, -2)
nan
&gt;&gt;&gt; LA.norm(b, -2)
1.8570331885190563e-016
&gt;&gt;&gt; LA.norm(a, 3)
5.8480354764257312
&gt;&gt;&gt; LA.norm(a, -3)
nan

Using the `axis` argument to compute vector norms:

&gt;&gt;&gt; c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
&gt;&gt;&gt; LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
&gt;&gt;&gt; LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
&gt;&gt;&gt; LA.norm(c, ord=1, axis=1)
array([6, 6])

Using the `axis` argument to compute matrix norms:

&gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)
&gt;&gt;&gt; LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
&gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.  If `axis` is None, `x` must be 1-D or 2-D.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ord" name="ord">
      <docstring>Order of the norm (see table under ``Notes``). inf means numpy's
`inf` object.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['inf', '-inf', 'fro', 'nuc']]</values>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>If `axis` is an integer, it specifies the axis of `x` along which to
compute the vector norms.  If `axis` is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If `axis` is None then either a vector norm (when `x`
is 1-D) or a matrix norm (when `x` is 2-D) is returned.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original `x`.

.. versionadded:: 1.10.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="n" name="n" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Norm of the matrix or vector(s).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.pinv" module_name="pinv" namespace="'linalg'">
    <docstring>Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
*large* singular values.

Parameters
----------
a : (M, N) array_like
  Matrix to be pseudo-inverted.
rcond : float
  Cutoff for small singular values.
  Singular values smaller (in modulus) than
  `rcond` * largest_singular_value (again, in modulus)
  are set to zero.

Returns
-------
B : (N, M) ndarray
  The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
  is `B`.

Raises
------
LinAlgError
  If the SVD computation does not converge.

Notes
-----
The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
defined as: "the matrix that 'solves' [the least-squares problem]
:math:`Ax = b`," i.e., if :math:`\bar{x}` is said solution, then
:math:`A^+` is that matrix such that :math:`\bar{x} = A^+b`.

It can be shown that if :math:`Q_1 \Sigma Q_2^T = A` is the singular
value decomposition of A, then
:math:`A^+ = Q_2 \Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
orthogonal matrices, :math:`\Sigma` is a diagonal matrix consisting
of A's so-called singular values, (followed, typically, by
zeros), and then :math:`\Sigma^+` is simply the diagonal matrix
consisting of the reciprocals of A's singular values
(again, followed by zeros). [1]_

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pp. 139-142.

Examples
--------
The following example checks that ``a * a+ * a == a`` and
``a+ * a * a+ == a+``:

&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; B = np.linalg.pinv(a)
&gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))
True
&gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be pseudo-inverted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Cutoff for small singular values.
Singular values smaller (in modulus) than
`rcond` * largest_singular_value (again, in modulus)
are set to zero.</docstring>
      <defaults>[1e-15]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
is `B`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.qr" module_name="qr" namespace="'linalg'" output_type="list">
    <docstring>Compute the qr factorization of a matrix.

Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
upper-triangular.

Parameters
----------
a : array_like, shape (M, N)
    Matrix to be factored.
mode : {'reduced', 'complete', 'r', 'raw', 'full', 'economic'}, optional
    If K = min(M, N), then

    'reduced'  : returns q, r with dimensions (M, K), (K, N) (default)
    'complete' : returns q, r with dimensions (M, M), (M, N)
    'r'        : returns r only with dimensions (K, N)
    'raw'      : returns h, tau with dimensions (N, M), (K,)
    'full'     : alias of 'reduced', deprecated
    'economic' : returns h from 'raw', deprecated.

    The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
    see the notes for more information. The default is 'reduced' and to
    maintain backward compatibility with earlier versions of numpy both
    it and the old default 'full' can be omitted. Note that array h
    returned in 'raw' mode is transposed for calling Fortran. The
    'economic' mode is deprecated.  The modes 'full' and 'economic' may
    be passed using only the first letter for backwards compatibility,
    but all others must be spelled out. See the Notes for more
    explanation.


Returns
-------
q : ndarray of float or complex, optional
    A matrix with orthonormal columns. When mode = 'complete' the
    result is an orthogonal/unitary matrix depending on whether or not
    a is real/complex. The determinant may be either +/- 1 in that
    case.
r : ndarray of float or complex, optional
    The upper-triangular matrix.
(h, tau) : ndarrays of np.double or np.cdouble, optional
    The array h contains the Householder reflectors that generate q
    along with r. The tau array contains scaling factors for the
    reflectors. In the deprecated  'economic' mode only h is returned.

Raises
------
LinAlgError
    If factoring fails.

Notes
-----
This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, and zungqr.

For more information on the qr factorization, see for example:
http://en.wikipedia.org/wiki/QR_factorization

Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
`a` is of type `matrix`, all the return values will be matrices too.

New 'reduced', 'complete', and 'raw' options for mode were added in
Numpy 1.8 and the old option 'full' was made an alias of 'reduced'.  In
addition the options 'full' and 'economic' were deprecated.  Because
'full' was the previous default and 'reduced' is the new default,
backward compatibility can be maintained by letting `mode` default.
The 'raw' option was added so that LAPACK routines that can multiply
arrays by q using the Householder reflectors can be used. Note that in
this case the returned arrays are of type np.double or np.cdouble and
the h array is transposed to be FORTRAN compatible.  No routines using
the 'raw' return are currently exposed by numpy, but some are available
in lapack_lite and just await the necessary work.

Examples
--------
&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; q, r = np.linalg.qr(a)
&gt;&gt;&gt; np.allclose(a, np.dot(q, r))  # a does equal qr
True
&gt;&gt;&gt; r2 = np.linalg.qr(a, mode='r')
&gt;&gt;&gt; r3 = np.linalg.qr(a, mode='economic')
&gt;&gt;&gt; np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
True
&gt;&gt;&gt; # But only triu parts are guaranteed equal when mode='economic'
&gt;&gt;&gt; np.allclose(r, np.triu(r3[:6,:6], k=0))
True

Example illustrating a common use of `qr`: solving of least squares
problems

What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
by solving the over-determined matrix equation ``Ax = b``, where::

  A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
  x = array([[y0], [m]])
  b = array([[1], [0], [2], [1]])

If A = qr such that q is orthonormal (which is always possible via
Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
however, we simply use `lstsq`.)

&gt;&gt;&gt; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
&gt;&gt;&gt; A
array([[0, 1],
       [1, 1],
       [1, 1],
       [2, 1]])
&gt;&gt;&gt; b = np.array([1, 0, 2, 1])
&gt;&gt;&gt; q, r = LA.qr(A)
&gt;&gt;&gt; p = np.dot(q.T, b)
&gt;&gt;&gt; np.dot(LA.inv(r), p)
array([  1.1e-16,   1.0e+00])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be factored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>If K = min(M, N), then

'reduced'  : returns q, r with dimensions (M, K), (K, N) (default)
'complete' : returns q, r with dimensions (M, M), (M, N)
'r'        : returns r only with dimensions (K, N)
'raw'      : returns h, tau with dimensions (N, M), (K,)
'full'     : alias of 'reduced', deprecated
'economic' : returns h from 'raw', deprecated.

The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
see the notes for more information. The default is 'reduced' and to
maintain backward compatibility with earlier versions of numpy both
it and the old default 'full' can be omitted. Note that array h
returned in 'raw' mode is transposed for calling Fortran. The
'economic' mode is deprecated.  The modes 'full' and 'economic' may
be passed using only the first letter for backwards compatibility,
but all others must be spelled out. See the Notes for more
explanation.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reduced', 'complete', 'r', 'raw', 'full', 'economic']]</values>
      <defaults>['reduced']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="q" name="q" show_port="True" sort_key="0">
      <docstring>A matrix with orthonormal columns. When mode = 'complete' the
result is an orthogonal/unitary matrix depending on whether or not
a is real/complex. The determinant may be either +/- 1 in that
case.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r" name="r" show_port="True" sort_key="1">
      <docstring>The upper-triangular matrix.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="(h" name="(h" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>The array h contains the Householder reflectors that generate q
along with r. The tau array contains scaling factors for the
reflectors. In the deprecated  'economic' mode only h is returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="tau)" name="tau)" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>The array h contains the Householder reflectors that generate q
along with r. The tau array contains scaling factors for the
reflectors. In the deprecated  'economic' mode only h is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.slogdet" module_name="slogdet" namespace="'linalg'" output_type="list">
    <docstring>Compute the sign and (natural) logarithm of the determinant of an array.

If an array has a very small or very large determinant, then a call to
`det` may overflow or underflow. This routine is more robust against such
issues, because it computes the logarithm of the determinant rather than
the determinant itself.

Parameters
----------
a : (..., M, M) array_like
    Input array, has to be a square 2-D array.

Returns
-------
sign : (...) array_like
    A number representing the sign of the determinant. For a real matrix,
    this is 1, 0, or -1. For a complex matrix, this is a complex number
    with absolute value 1 (i.e., it is on the unit circle), or else 0.
logdet : (...) array_like
    The natural log of the absolute value of the determinant.

If the determinant is zero, then `sign` will be 0 and `logdet` will be
-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.

See Also
--------
det

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

.. versionadded:: 1.6.0.

The determinant is computed via LU factorization using the LAPACK
routine z/dgetrf.


Examples
--------
The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:

&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; (sign, logdet) = np.linalg.slogdet(a)
&gt;&gt;&gt; (sign, logdet)
(-1, 0.69314718055994529)
&gt;&gt;&gt; sign * np.exp(logdet)
-2.0

Computing log-determinants for a stack of matrices:

&gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
&gt;&gt;&gt; a.shape
(3, 2, 2)
&gt;&gt;&gt; sign, logdet = np.linalg.slogdet(a)
&gt;&gt;&gt; (sign, logdet)
(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
&gt;&gt;&gt; sign * np.exp(logdet)
array([-2., -3., -8.])

This routine succeeds where ordinary `det` does not:

&gt;&gt;&gt; np.linalg.det(np.eye(500) * 0.1)
0.0
&gt;&gt;&gt; np.linalg.slogdet(np.eye(500) * 0.1)
(1, -1151.2925464970228)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, has to be a square 2-D array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sign" name="sign" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A number representing the sign of the determinant. For a real matrix,
this is 1, 0, or -1. For a complex matrix, this is a complex number
with absolute value 1 (i.e., it is on the unit circle), or else 0.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="logdet" name="logdet" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The natural log of the absolute value of the determinant.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="2" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="4" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="5" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.solve" module_name="solve" namespace="'linalg'">
    <docstring>Solve a linear matrix equation, or system of linear scalar equations.

Computes the "exact" solution, `x`, of the well-determined, i.e., full
rank, linear matrix equation `ax = b`.

Parameters
----------
a : (..., M, M) array_like
    Coefficient matrix.
b : {(..., M,), (..., M, K)}, array_like
    Ordinate or "dependent variable" values.

Returns
-------
x : {(..., M,), (..., M, K)} ndarray
    Solution to the system a x = b.  Returned shape is identical to `b`.

Raises
------
LinAlgError
    If `a` is singular or not square.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The solutions are computed using LAPACK routine _gesv

`a` must be square and of full-rank, i.e., all rows (or, equivalently,
columns) must be linearly independent; if either is not true, use
`lstsq` for the least-squares best "solution" of the
system/equation.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 22.

Examples
--------
Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:

&gt;&gt;&gt; a = np.array([[3,1], [1,2]])
&gt;&gt;&gt; b = np.array([9,8])
&gt;&gt;&gt; x = np.linalg.solve(a, b)
&gt;&gt;&gt; x
array([ 2.,  3.])

Check that the solution is correct:

&gt;&gt;&gt; np.allclose(np.dot(a, x), b)
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Coefficient matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Ordinate or "dependent variable" values.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the system a x = b.  Returned shape is identical to `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.svd" module_name="svd" namespace="'linalg'" output_type="list">
    <docstring>Singular Value Decomposition.

Factors the matrix `a` as ``u * np.diag(s) * v``, where `u` and `v`
are unitary and `s` is a 1-d array of `a`'s singular values.

Parameters
----------
a : (..., M, N) array_like
    A real or complex matrix of shape (`M`, `N`) .
full_matrices : bool, optional
    If True (default), `u` and `v` have the shapes (`M`, `M`) and
    (`N`, `N`), respectively.  Otherwise, the shapes are (`M`, `K`)
    and (`K`, `N`), respectively, where `K` = min(`M`, `N`).
compute_uv : bool, optional
    Whether or not to compute `u` and `v` in addition to `s`.  True
    by default.

Returns
-------
u : { (..., M, M), (..., M, K) } array
    Unitary matrices. The actual shape depends on the value of
    ``full_matrices``. Only returned when ``compute_uv`` is True.
s : (..., K) array
    The singular values for every matrix, sorted in descending order.
v : { (..., N, N), (..., K, N) } array
    Unitary matrices. The actual shape depends on the value of
    ``full_matrices``. Only returned when ``compute_uv`` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The decomposition is performed using LAPACK routine _gesdd

The SVD is commonly written as ``a = U S V.H``.  The `v` returned
by this function is ``V.H`` and ``u = U``.

If ``U`` is a unitary matrix, it means that it
satisfies ``U.H = inv(U)``.

The rows of `v` are the eigenvectors of ``a.H a``. The columns
of `u` are the eigenvectors of ``a a.H``.  For row ``i`` in
`v` and column ``i`` in `u`, the corresponding eigenvalue is
``s[i]**2``.

If `a` is a `matrix` object (as opposed to an `ndarray`), then so
are all the return values.

Examples
--------
&gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)

Reconstruction based on full SVD:

&gt;&gt;&gt; U, s, V = np.linalg.svd(a, full_matrices=True)
&gt;&gt;&gt; U.shape, V.shape, s.shape
((9, 9), (6, 6), (6,))
&gt;&gt;&gt; S = np.zeros((9, 6), dtype=complex)
&gt;&gt;&gt; S[:6, :6] = np.diag(s)
&gt;&gt;&gt; np.allclose(a, np.dot(U, np.dot(S, V)))
True

Reconstruction based on reduced SVD:

&gt;&gt;&gt; U, s, V = np.linalg.svd(a, full_matrices=False)
&gt;&gt;&gt; U.shape, V.shape, s.shape
((9, 6), (6, 6), (6,))
&gt;&gt;&gt; S = np.diag(s)
&gt;&gt;&gt; np.allclose(a, np.dot(U, np.dot(S, V)))
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A real or complex matrix of shape (`M`, `N`) .</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_matrices" name="full_matricesScalar" port_type="basic:Integer">
      <docstring>If True (default), `u` and `v` have the shapes (`M`, `M`) and
(`N`, `N`), respectively.  Otherwise, the shapes are (`M`, `K`)
and (`K`, `N`), respectively, where `K` = min(`M`, `N`).</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="full_matrices" name="full_matricesBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="compute_uv" name="compute_uvScalar" port_type="basic:Integer">
      <docstring>Whether or not to compute `u` and `v` in addition to `s`.  True
by default.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="compute_uv" name="compute_uvBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="u" name="u" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Unitary matrices. The actual shape depends on the value of
``full_matrices``. Only returned when ``compute_uv`` is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The singular values for every matrix, sorted in descending order.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Unitary matrices. The actual shape depends on the value of
``full_matrices``. Only returned when ``compute_uv`` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.tensorinv" module_name="tensorinv" namespace="'linalg'">
    <docstring>Compute the 'inverse' of an N-dimensional array.

The result is an inverse for `a` relative to the tensordot operation
``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
``tensordot(tensorinv(a), a, ind)`` is the "identity" tensor for the
tensordot operation.

Parameters
----------
a : array_like
    Tensor to 'invert'. Its shape must be 'square', i. e.,
    ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
ind : int, optional
    Number of first indices that are involved in the inverse sum.
    Must be a positive integer, default is 2.

Returns
-------
b : ndarray
    `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
tensordot, tensorsolve

Examples
--------
&gt;&gt;&gt; a = np.eye(4*6)
&gt;&gt;&gt; a.shape = (4, 6, 8, 3)
&gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)
&gt;&gt;&gt; ainv.shape
(8, 3, 4, 6)
&gt;&gt;&gt; b = np.random.randn(4, 6)
&gt;&gt;&gt; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
True

&gt;&gt;&gt; a = np.eye(4*6)
&gt;&gt;&gt; a.shape = (24, 8, 3)
&gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)
&gt;&gt;&gt; ainv.shape
(8, 3, 24)
&gt;&gt;&gt; b = np.random.randn(24)
&gt;&gt;&gt; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Tensor to 'invert'. Its shape must be 'square', i. e.,
``prod(a.shape[:ind]) == prod(a.shape[ind:])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ind" name="ind" port_type="basic:Integer">
      <docstring>Number of first indices that are involved in the inverse sum.
Must be a positive integer, default is 2.</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.linalg.tensorsolve" module_name="tensorsolve" namespace="'linalg'">
    <docstring>Solve the tensor equation ``a x = b`` for x.

It is assumed that all indices of `x` are summed over in the product,
together with the rightmost indices of `a`, as is done in, for example,
``tensordot(a, x, axes=len(b.shape))``.

Parameters
----------
a : array_like
    Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
    the shape of that sub-tensor of `a` consisting of the appropriate
    number of its rightmost indices, and must be such that
    ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
    'square').
b : array_like
    Right-hand tensor, which can be of any shape.
axes : tuple of ints, optional
    Axes in `a` to reorder to the right, before inversion.
    If None (default), no reordering is done.

Returns
-------
x : ndarray, shape Q

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
tensordot, tensorinv, einsum

Examples
--------
&gt;&gt;&gt; a = np.eye(2*3*4)
&gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)
&gt;&gt;&gt; b = np.random.randn(2*3, 4)
&gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)
&gt;&gt;&gt; x.shape
(2, 3, 4)
&gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
the shape of that sub-tensor of `a` consisting of the appropriate
number of its rightmost indices, and must be such that
``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
'square').</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand tensor, which can be of any shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>Axes in `a` to reorder to the right, before inversion.
If None (default), no reordering is done.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.fft" module_name="fft" namespace="'fft'">
    <docstring>Compute the one-dimensional discrete Fourier Transform.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [CT].

Parameters
----------
a : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT.  If not given, the last axis is
    used.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    if `axes` is larger than the last axis of `a`.

See Also
--------
numpy.fft : for definition of the DFT and conventions used.
ifft : The inverse of `fft`.
fft2 : The two-dimensional FFT.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.

Notes
-----
FFT (Fast Fourier Transform) refers to a way the discrete Fourier
Transform (DFT) can be calculated efficiently, by using symmetries in the
calculated terms.  The symmetry is highest when `n` is a power of 2, and
the transform is therefore most efficient for these sizes.

The DFT is defined, with the conventions used in this implementation, in
the documentation for the `numpy.fft` module.

References
----------
.. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
        machine calculation of complex Fourier series," *Math. Comput.*
        19: 297-301.

Examples
--------
&gt;&gt;&gt; np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([ -3.44505240e-16 +1.14383329e-17j,
         8.00000000e+00 -5.71092652e-15j,
         2.33482938e-16 +1.22460635e-16j,
         1.64863782e-15 +1.77635684e-15j,
         9.95839695e-17 +2.33482938e-16j,
         0.00000000e+00 +1.66837030e-15j,
         1.14383329e-17 +1.22460635e-16j,
         -1.64863782e-15 +1.77635684e-15j])

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.arange(256)
&gt;&gt;&gt; sp = np.fft.fft(np.sin(t))
&gt;&gt;&gt; freq = np.fft.fftfreq(t.shape[-1])
&gt;&gt;&gt; plt.plot(freq, sp.real, freq, sp.imag)
[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.show()

In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part, as described in
the `numpy.fft` documentation.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, can be complex.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transformed axis of the output.
If `n` is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If `n` is not given,
the length of the input along the axis specified by `axis` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to compute the FFT.  If not given, the last axis is
used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axis
indicated by `axis`, or the last one if `axis` is not specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.fft2" module_name="fft2" namespace="'fft'">
    <docstring>Compute the 2-dimensional discrete Fourier Transform

This function computes the *n*-dimensional discrete Fourier Transform
over any axes in an *M*-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.

Parameters
----------
a : array_like
    Input array, can be complex
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (`s[0]` refers to axis 0, `s[1]` to axis 1, etc.).
    This corresponds to `n` for `fft(x, n)`.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.  A repeated index in `axes` means the transform over
    that axis is performed multiple times.  A one-element sequence means
    that a one-dimensional FFT is performed.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The *n*-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
    For two-dimensional input, swaps first and third quadrants, and second
    and fourth quadrants.

Notes
-----
`fft2` is just `fftn` with a different default for `axes`.

The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.

See `fftn` for details and a plotting example, and `numpy.fft` for
definitions and conventions used.


Examples
--------
&gt;&gt;&gt; a = np.mgrid[:5, :5][0]
&gt;&gt;&gt; np.fft.fft2(a)
array([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,
          0.0 +0.j        ,   0.0 +0.j        ],
       [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,
          0.0 +0.j        ,   0.0 +0.j        ],
       [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,
          0.0 +0.j        ,   0.0 +0.j        ],
       [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,
            0.0 +0.j        ,   0.0 +0.j        ],
       [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,
          0.0 +0.j        ,   0.0 +0.j        ]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, can be complex</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape (length of each transformed axis) of the output
(`s[0]` refers to axis 0, `s[1]` to axis 1, etc.).
This corresponds to `n` for `fft(x, n)`.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if `s` is not given, the shape of the input along the axes specified
by `axes` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <docstring>Axes over which to compute the FFT.  If not given, the last two
axes are used.  A repeated index in `axes` means the transform over
that axis is performed multiple times.  A one-element sequence means
that a one-dimensional FFT is performed.</docstring>
      <defaults>[(-2, -1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axes
indicated by `axes`, or the last two axes if `axes` is not given.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.fftfreq" module_name="fftfreq" namespace="'fft'">
    <docstring>Return the Discrete Fourier Transform sample frequencies.

The returned float array `f` contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.

Given a window length `n` and a sample spacing `d`::

  f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even
  f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing (inverse of the sampling rate). Defaults to 1.

Returns
-------
f : ndarray
    Array of length `n` containing the sample frequencies.

Examples
--------
&gt;&gt;&gt; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
&gt;&gt;&gt; fourier = np.fft.fft(signal)
&gt;&gt;&gt; n = signal.size
&gt;&gt;&gt; timestep = 0.1
&gt;&gt;&gt; freq = np.fft.fftfreq(n, d=timestep)
&gt;&gt;&gt; freq
array([ 0.  ,  1.25,  2.5 ,  3.75, -5.  , -3.75, -2.5 , -1.25])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Window length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d" name="d" port_type="basic:Float">
      <docstring>Sample spacing (inverse of the sampling rate). Defaults to 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of length `n` containing the sample frequencies.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.fftn" module_name="fftn" namespace="'fft'">
    <docstring>Compute the N-dimensional discrete Fourier Transform.

This function computes the *N*-dimensional discrete Fourier Transform over
any number of axes in an *M*-dimensional array by means of the Fast Fourier
Transform (FFT).

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (`s[0]` refers to axis 0, `s[1]` to axis 1, etc.).
    This corresponds to `n` for `fft(x, n)`.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the transform over that axis is
    performed multiple times.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `a`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
    and conventions used.
ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The *n*-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array

Notes
-----
The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

See `numpy.fft` for details, definitions and conventions used.

Examples
--------
&gt;&gt;&gt; a = np.mgrid[:3, :3, :3][0]
&gt;&gt;&gt; np.fft.fftn(a, axes=(1, 2))
array([[[  0.+0.j,   0.+0.j,   0.+0.j],
        [  0.+0.j,   0.+0.j,   0.+0.j],
        [  0.+0.j,   0.+0.j,   0.+0.j]],
       [[  9.+0.j,   0.+0.j,   0.+0.j],
        [  0.+0.j,   0.+0.j,   0.+0.j],
        [  0.+0.j,   0.+0.j,   0.+0.j]],
       [[ 18.+0.j,   0.+0.j,   0.+0.j],
        [  0.+0.j,   0.+0.j,   0.+0.j],
        [  0.+0.j,   0.+0.j,   0.+0.j]]])
&gt;&gt;&gt; np.fft.fftn(a, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j],
        [ 0.+0.j,  0.+0.j,  0.+0.j]],
       [[-2.+0.j, -2.+0.j, -2.+0.j],
        [ 0.+0.j,  0.+0.j,  0.+0.j]]])

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
&gt;&gt;&gt; S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
&gt;&gt;&gt; FS = np.fft.fftn(S)
&gt;&gt;&gt; plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
&lt;matplotlib.image.AxesImage object at 0x...&gt;
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, can be complex.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape (length of each transformed axis) of the output
(`s[0]` refers to axis 0, `s[1]` to axis 1, etc.).
This corresponds to `n` for `fft(x, n)`.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if `s` is not given, the shape of the input along the axes specified
by `axes` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>Axes over which to compute the FFT.  If not given, the last ``len(s)``
axes are used, or all axes if `s` is also not specified.
Repeated indices in `axes` means that the transform over that axis is
performed multiple times.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axes
indicated by `axes`, or by a combination of `s` and `a`,
as explained in the parameters section above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.fftshift" module_name="fftshift" namespace="'fft'">
    <docstring>Shift the zero-frequency component to the center of the spectrum.

This function swaps half-spaces for all axes listed (defaults to all).
Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even.

Parameters
----------
x : array_like
    Input array.
axes : int or shape tuple, optional
    Axes over which to shift.  Default is None, which shifts all axes.

Returns
-------
y : ndarray
    The shifted array.

See Also
--------
ifftshift : The inverse of `fftshift`.

Examples
--------
&gt;&gt;&gt; freqs = np.fft.fftfreq(10, 0.1)
&gt;&gt;&gt; freqs
array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])
&gt;&gt;&gt; np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])

Shift the zero-frequency component only along the second axis:

&gt;&gt;&gt; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
&gt;&gt;&gt; freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
&gt;&gt;&gt; np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
       [-4.,  3.,  4.],
       [-1., -3., -2.]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axesScalar" port_type="basic:Integer">
      <docstring>Axes over which to shift.  Default is None, which shifts all axes.</docstring>
      <alternateSpec arg="axes" name="axesSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shifted array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.hfft" module_name="hfft" namespace="'fft'">
    <docstring>Compute the FFT of a signal which has Hermitian symmetry (real spectrum).

Parameters
----------
a : array_like
    The input array.
n : int, optional
    Length of the transformed axis of the output.
    For `n` output points, ``n//2+1`` input points are necessary.  If the
    input is longer than this, it is cropped.  If it is shorter than this,
    it is padded with zeros.  If `n` is not given, it is determined from
    the length of the input along the axis specified by `axis`.
axis : int, optional
    Axis over which to compute the FFT. If not given, the last
    axis is used.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is `n`, or, if `n` is not given,
    ``2*(m-1)`` where ``m`` is the length of the transformed axis of the
    input. To get an odd number of output points, `n` must be specified.

Raises
------
IndexError
    If `axis` is larger than the last axis of `a`.

See also
--------
rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of `hfft`.

Notes
-----
`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
opposite case: here the signal has Hermitian symmetry in the time domain
and is real in the frequency domain. So here it's `hfft` for which
you must supply the length of the result if it is to be odd:
``ihfft(hfft(a), len(a)) == a``, within numerical accuracy.

Examples
--------
&gt;&gt;&gt; signal = np.array([1, 2, 3, 4, 3, 2])
&gt;&gt;&gt; np.fft.fft(signal)
array([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])
&gt;&gt;&gt; np.fft.hfft(signal[:4]) # Input first half of signal
array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])
&gt;&gt;&gt; np.fft.hfft(signal, 6)  # Input entire signal and truncate
array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])


&gt;&gt;&gt; signal = np.array([[1, 1.j], [-1.j, 2]])
&gt;&gt;&gt; np.conj(signal.T) - signal   # check Hermitian symmetry
array([[ 0.-0.j,  0.+0.j],
       [ 0.+0.j,  0.-0.j]])
&gt;&gt;&gt; freq_spectrum = np.fft.hfft(signal)
&gt;&gt;&gt; freq_spectrum
array([[ 1.,  1.],
       [ 2., -2.]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transformed axis of the output.
For `n` output points, ``n//2+1`` input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If `n` is not given, it is determined from
the length of the input along the axis specified by `axis`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to compute the FFT. If not given, the last
axis is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axis
indicated by `axis`, or the last one if `axis` is not specified.
The length of the transformed axis is `n`, or, if `n` is not given,
``2*(m-1)`` where ``m`` is the length of the transformed axis of the
input. To get an odd number of output points, `n` must be specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.ifft" module_name="ifft" namespace="'fft'">
    <docstring>Compute the one-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier transform computed by `fft`.  In other words,
``ifft(fft(a)) == a`` to within numerical accuracy.
For a general description of the algorithm and definitions,
see `numpy.fft`.

The input should be ordered in the same way as is returned by `fft`,
i.e., ``a[0]`` should contain the zero frequency term,
``a[1:n/2+1]`` should contain the positive-frequency terms, and
``a[n/2+1:]`` should contain the negative-frequency terms, in order of
decreasingly negative frequency.  See `numpy.fft` for details.

Parameters
----------
a : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
    See notes about padding issues.
axis : int, optional
    Axis over which to compute the inverse DFT.  If not given, the last
    axis is used.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    If `axes` is larger than the last axis of `a`.

See Also
--------
numpy.fft : An introduction, with definitions and general explanations.
fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.

Notes
-----
If the input parameter `n` is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling `ifft`.

Examples
--------
&gt;&gt;&gt; np.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])

Create and plot a band-limited signal with random phases:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.arange(400)
&gt;&gt;&gt; n = np.zeros((400,), dtype=complex)
&gt;&gt;&gt; n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
&gt;&gt;&gt; s = np.fft.ifft(n)
&gt;&gt;&gt; plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.legend(('real', 'imaginary'))
&lt;matplotlib.legend.Legend object at 0x...&gt;
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, can be complex.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transformed axis of the output.
If `n` is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If `n` is not given,
the length of the input along the axis specified by `axis` is used.
See notes about padding issues.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to compute the inverse DFT.  If not given, the last
axis is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axis
indicated by `axis`, or the last one if `axis` is not specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.ifft2" module_name="ifft2" namespace="'fft'">
    <docstring>Compute the 2-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fft2`, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
    ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.  A repeated index in `axes` means the transform over
    that axis is performed multiple times.  A one-element sequence means
    that a one-dimensional FFT is performed.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.
ifftn : The inverse of the *n*-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.

Notes
-----
`ifft2` is just `ifftn` with a different default for `axes`.

See `ifftn` for details and a plotting example, and `numpy.fft` for
definition and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifft2` is called.

Examples
--------
&gt;&gt;&gt; a = 4 * np.eye(4)
&gt;&gt;&gt; np.fft.ifft2(a)
array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, can be complex.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if `s` is not given, the shape of the input along the axes specified
by `axes` is used.  See notes for issue on `ifft` zero padding.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <docstring>Axes over which to compute the FFT.  If not given, the last two
axes are used.  A repeated index in `axes` means the transform over
that axis is performed multiple times.  A one-element sequence means
that a one-dimensional FFT is performed.</docstring>
      <defaults>[(-2, -1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axes
indicated by `axes`, or the last two axes if `axes` is not given.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.ifftn" module_name="ifftn" namespace="'fft'">
    <docstring>Compute the N-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
``ifftn(fftn(a)) == a`` to within numerical accuracy.
For a description of the definitions and conventions used, see `numpy.fft`.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fftn`, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``ifft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.
axes : sequence of ints, optional
    Axes over which to compute the IFFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the inverse transform over that
    axis is performed multiple times.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `a`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
    of array.

Notes
-----
See `numpy.fft` for definitions and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifftn` is called.

Examples
--------
&gt;&gt;&gt; a = np.eye(4)
&gt;&gt;&gt; np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
       [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])


Create and plot an image with band-limited frequency content:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; n = np.zeros((200,200), dtype=complex)
&gt;&gt;&gt; n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
&gt;&gt;&gt; im = np.fft.ifftn(n).real
&gt;&gt;&gt; plt.imshow(im)
&lt;matplotlib.image.AxesImage object at 0x...&gt;
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, can be complex.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape (length of each transformed axis) of the output
(``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
This corresponds to ``n`` for ``ifft(x, n)``.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if `s` is not given, the shape of the input along the axes specified
by `axes` is used.  See notes for issue on `ifft` zero padding.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>Axes over which to compute the IFFT.  If not given, the last ``len(s)``
axes are used, or all axes if `s` is also not specified.
Repeated indices in `axes` means that the inverse transform over that
axis is performed multiple times.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axes
indicated by `axes`, or by a combination of `s` or `a`,
as explained in the parameters section above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.ifftshift" module_name="ifftshift" namespace="'fft'">
    <docstring>The inverse of `fftshift`. Although identical for even-length `x`, the
functions differ by one sample for odd-length `x`.

Parameters
----------
x : array_like
    Input array.
axes : int or shape tuple, optional
    Axes over which to calculate.  Defaults to None, which shifts all axes.

Returns
-------
y : ndarray
    The shifted array.

See Also
--------
fftshift : Shift zero-frequency component to the center of the spectrum.

Examples
--------
&gt;&gt;&gt; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
&gt;&gt;&gt; freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
&gt;&gt;&gt; np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axesScalar" port_type="basic:Integer">
      <docstring>Axes over which to calculate.  Defaults to None, which shifts all axes.</docstring>
      <alternateSpec arg="axes" name="axesSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shifted array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.ihfft" module_name="ihfft" namespace="'fft'">
    <docstring>Compute the inverse FFT of a signal which has Hermitian symmetry.

Parameters
----------
a : array_like
    Input array.
n : int, optional
    Length of the inverse FFT.
    Number of points along transformation axis in the input to use.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros. If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the inverse FFT. If not given, the last
    axis is used.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    If `n` is even, the length of the transformed axis is ``(n/2)+1``.
    If `n` is odd, the length is ``(n+1)/2``.

See also
--------
hfft, irfft

Notes
-----
`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
opposite case: here the signal has Hermitian symmetry in the time domain
and is real in the frequency domain. So here it's `hfft` for which
you must supply the length of the result if it is to be odd:
``ihfft(hfft(a), len(a)) == a``, within numerical accuracy.

Examples
--------
&gt;&gt;&gt; spectrum = np.array([ 15, -4, 0, -1, 0, -4])
&gt;&gt;&gt; np.fft.ifft(spectrum)
array([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])
&gt;&gt;&gt; np.fft.ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the inverse FFT.
Number of points along transformation axis in the input to use.
If `n` is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If `n` is not given,
the length of the input along the axis specified by `axis` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to compute the inverse FFT. If not given, the last
axis is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axis
indicated by `axis`, or the last one if `axis` is not specified.
If `n` is even, the length of the transformed axis is ``(n/2)+1``.
If `n` is odd, the length is ``(n+1)/2``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.irfft" module_name="irfft" namespace="'fft'">
    <docstring>Compute the inverse of the n-point DFT for real input.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier Transform of real input computed by `rfft`.
In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical
accuracy. (See Notes below for why ``len(a)`` is necessary here.)

The input is expected to be in the form returned by `rfft`, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.

Parameters
----------
a : array_like
    The input array.
n : int, optional
    Length of the transformed axis of the output.
    For `n` output points, ``n//2+1`` input points are necessary.  If the
    input is longer than this, it is cropped.  If it is shorter than this,
    it is padded with zeros.  If `n` is not given, it is determined from
    the length of the input along the axis specified by `axis`.
axis : int, optional
    Axis over which to compute the inverse FFT. If not given, the last
    axis is used.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is `n`, or, if `n` is not given,
    ``2*(m-1)`` where ``m`` is the length of the transformed axis of the
    input. To get an odd number of output points, `n` must be specified.

Raises
------
IndexError
    If `axis` is larger than the last axis of `a`.

See Also
--------
numpy.fft : For definition of the DFT and conventions used.
rfft : The one-dimensional FFT of real input, of which `irfft` is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the *n*-dimensional FFT of real input.

Notes
-----
Returns the real valued `n`-point inverse discrete Fourier transform
of `a`, where `a` contains the non-negative frequency terms of a
Hermitian-symmetric sequence. `n` is the length of the result, not the
input.

If you specify an `n` such that `a` must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to `m` points via Fourier interpolation by:
``a_resamp = irfft(rfft(a), m)``.

Examples
--------
&gt;&gt;&gt; np.fft.ifft([1, -1j, -1, 1j])
array([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])
&gt;&gt;&gt; np.fft.irfft([1, -1j, -1])
array([ 0.,  1.,  0.,  0.])

Notice how the last term in the input to the ordinary `ifft` is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling `irfft`, the negative frequencies are not
specified, and the output array is purely real.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transformed axis of the output.
For `n` output points, ``n//2+1`` input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If `n` is not given, it is determined from
the length of the input along the axis specified by `axis`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to compute the inverse FFT. If not given, the last
axis is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axis
indicated by `axis`, or the last one if `axis` is not specified.
The length of the transformed axis is `n`, or, if `n` is not given,
``2*(m-1)`` where ``m`` is the length of the transformed axis of the
input. To get an odd number of output points, `n` must be specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.irfft2" module_name="irfft2" namespace="'fft'">
    <docstring>Compute the 2-dimensional inverse FFT of a real array.

Parameters
----------
a : array_like
    The input array
s : sequence of ints, optional
    Shape of the inverse FFT.
axes : sequence of ints, optional
    The axes over which to compute the inverse fft.
    Default is the last two axes.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The result of the inverse real 2-D FFT.

See Also
--------
irfftn : Compute the inverse of the N-dimensional FFT of real input.

Notes
-----
This is really `irfftn` with different defaults.
For more details see `irfftn`.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape of the inverse FFT.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <docstring>The axes over which to compute the inverse fft.
Default is the last two axes.</docstring>
      <defaults>[(-2, -1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of the inverse real 2-D FFT.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.irfftn" module_name="irfftn" namespace="'fft'">
    <docstring>Compute the inverse of the N-dimensional FFT of real input.

This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical
accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,
and for the same reason.)

The input should be ordered in the same way as is returned by `rfftn`,
i.e. as for `irfft` for the final transformation axis, and as for `ifftn`
along all the other axes.

Parameters
----------
a : array_like
    Input array.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the
    number of input points used along this axis, except for the last axis,
    where ``s[-1]//2+1`` points of the input are used.
    Along any axis, if the shape indicated by `s` is smaller than that of
    the input, the input is cropped.  If it is larger, the input is padded
    with zeros. If `s` is not given, the shape of the input along the
    axes specified by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the inverse FFT. If not given, the last
    `len(s)` axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the inverse transform over that
    axis is performed multiple times.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `a`,
    as explained in the parameters section above.
    The length of each transformed axis is as given by the corresponding
    element of `s`, or the length of the input in every axis except for the
    last one if `s` is not given.  In the final transformed axis the length
    of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the
    length of the final transformed axis of the input.  To get an odd
    number of output points in the final axis, `s` must be specified.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
rfftn : The forward n-dimensional FFT of real input,
        of which `ifftn` is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.

Notes
-----
See `fft` for definitions and conventions used.

See `rfft` for definitions and conventions used for real input.

Examples
--------
&gt;&gt;&gt; a = np.zeros((3, 2, 2))
&gt;&gt;&gt; a[0, 0, 0] = 3 * 2 * 2
&gt;&gt;&gt; np.fft.irfftn(a)
array([[[ 1.,  1.],
        [ 1.,  1.]],
       [[ 1.,  1.],
        [ 1.,  1.]],
       [[ 1.,  1.],
        [ 1.,  1.]]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape (length of each transformed axis) of the output
(``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the
number of input points used along this axis, except for the last axis,
where ``s[-1]//2+1`` points of the input are used.
Along any axis, if the shape indicated by `s` is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If `s` is not given, the shape of the input along the
axes specified by `axes` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>Axes over which to compute the inverse FFT. If not given, the last
`len(s)` axes are used, or all axes if `s` is also not specified.
Repeated indices in `axes` means that the inverse transform over that
axis is performed multiple times.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axes
indicated by `axes`, or by a combination of `s` or `a`,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of `s`, or the length of the input in every axis except for the
last one if `s` is not given.  In the final transformed axis the length
of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, `s` must be specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.rfft" module_name="rfft" namespace="'fft'">
    <docstring>Compute the one-dimensional discrete Fourier Transform for real input.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).

Parameters
----------
a : array_like
    Input array
n : int, optional
    Number of points along transformation axis in the input to use.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros. If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT. If not given, the last axis is
    used.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    If `n` is even, the length of the transformed axis is ``(n/2)+1``.
    If `n` is odd, the length is ``(n+1)/2``.

Raises
------
IndexError
    If `axis` is larger than the last axis of `a`.

See Also
--------
numpy.fft : For definition of the DFT and conventions used.
irfft : The inverse of `rfft`.
fft : The one-dimensional FFT of general (complex) input.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.

Notes
-----
When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore ``n//2 + 1``.

When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.

If `n` is even, ``A[-1]`` contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.

If the input `a` contains an imaginary part, it is silently discarded.

Examples
--------
&gt;&gt;&gt; np.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])
&gt;&gt;&gt; np.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j])

Notice how the final element of the `fft` output is the complex conjugate
of the second element, for real input. For `rfft`, this symmetry is
exploited to compute only the non-negative frequency terms.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Number of points along transformation axis in the input to use.
If `n` is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If `n` is not given,
the length of the input along the axis specified by `axis` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to compute the FFT. If not given, the last axis is
used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axis
indicated by `axis`, or the last one if `axis` is not specified.
If `n` is even, the length of the transformed axis is ``(n/2)+1``.
If `n` is odd, the length is ``(n+1)/2``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.rfft2" module_name="rfft2" namespace="'fft'">
    <docstring>Compute the 2-dimensional FFT of a real array.

Parameters
----------
a : array
    Input array, taken to be real.
s : sequence of ints, optional
    Shape of the FFT.
axes : sequence of ints, optional
    Axes over which to compute the FFT.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The result of the real 2-D FFT.

See Also
--------
rfftn : Compute the N-dimensional discrete Fourier Transform for real
        input.

Notes
-----
This is really just `rfftn` with different default behavior.
For more details see `rfftn`.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, taken to be real.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape of the FFT.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <docstring>Axes over which to compute the FFT.</docstring>
      <defaults>[(-2, -1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of the real 2-D FFT.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.rfftfreq" module_name="rfftfreq" namespace="'fft'">
    <docstring>Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).

The returned float array `f` contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.

Given a window length `n` and a sample spacing `d`::

  f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even
  f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd

Unlike `fftfreq` (but like `scipy.fftpack.rfftfreq`)
the Nyquist frequency component is considered to be positive.

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing (inverse of the sampling rate). Defaults to 1.

Returns
-------
f : ndarray
    Array of length ``n//2 + 1`` containing the sample frequencies.

Examples
--------
&gt;&gt;&gt; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
&gt;&gt;&gt; fourier = np.fft.rfft(signal)
&gt;&gt;&gt; n = signal.size
&gt;&gt;&gt; sample_rate = 100
&gt;&gt;&gt; freq = np.fft.fftfreq(n, d=1./sample_rate)
&gt;&gt;&gt; freq
array([  0.,  10.,  20.,  30.,  40., -50., -40., -30., -20., -10.])
&gt;&gt;&gt; freq = np.fft.rfftfreq(n, d=1./sample_rate)
&gt;&gt;&gt; freq
array([  0.,  10.,  20.,  30.,  40.,  50.])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Window length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d" name="d" port_type="basic:Float">
      <docstring>Sample spacing (inverse of the sampling rate). Defaults to 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of length ``n//2 + 1`` containing the sample frequencies.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.fft.rfftn" module_name="rfftn" namespace="'fft'">
    <docstring>Compute the N-dimensional discrete Fourier Transform for real input.

This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.

Parameters
----------
a : array_like
    Input array, taken to be real.
s : sequence of ints, optional
    Shape (length along each transformed axis) to use from the input.
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    The final element of `s` corresponds to `n` for ``rfft(x, n)``, while
    for the remaining axes, it corresponds to `n` for ``fft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
norm : {None, "ortho"}, optional
    .. versionadded:: 1.10.0
    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `a`,
    as explained in the parameters section above.
    The length of the last axis transformed will be ``s[-1]//2+1``,
    while the remaining transformed axes will have lengths according to
    `s`, or unchanged from the input.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
irfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT
     of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.

Notes
-----
The transform for real input is performed over the last transformation
axis, as by `rfft`, then the transform over the remaining axes is
performed as by `fftn`.  The order of the output is as for `rfft` for the
final transformation axis, and as for `fftn` for the remaining
transformation axes.

See `fft` for details, definitions and conventions used.

Examples
--------
&gt;&gt;&gt; a = np.ones((2, 2, 2))
&gt;&gt;&gt; np.fft.rfftn(a)
array([[[ 8.+0.j,  0.+0.j],
        [ 0.+0.j,  0.+0.j]],
       [[ 0.+0.j,  0.+0.j],
        [ 0.+0.j,  0.+0.j]]])

&gt;&gt;&gt; np.fft.rfftn(a, axes=(2, 0))
array([[[ 4.+0.j,  0.+0.j],
        [ 4.+0.j,  0.+0.j]],
       [[ 0.+0.j,  0.+0.j],
        [ 0.+0.j,  0.+0.j]]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, taken to be real.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" depth="1" name="s" port_type="basic:Integer">
      <docstring>Shape (length along each transformed axis) to use from the input.
(``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
The final element of `s` corresponds to `n` for ``rfft(x, n)``, while
for the remaining axes, it corresponds to `n` for ``fft(x, n)``.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if `s` is not given, the shape of the input along the axes specified
by `axes` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>Axes over which to compute the FFT.  If not given, the last ``len(s)``
axes are used, or all axes if `s` is also not specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>.. versionadded:: 1.10.0
Normalization mode (see `numpy.fft`). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The truncated or zero-padded input, transformed along the axes
indicated by `axes`, or by a combination of `s` and `a`,
as explained in the parameters section above.
The length of the last axis transformed will be ``s[-1]//2+1``,
while the remaining transformed axes will have lengths according to
`s`, or unchanged from the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.beta" module_name="beta" namespace="'random'">
    <docstring>beta(a, b, size=None)

Draw samples from a Beta distribution.

The Beta distribution is a special case of the Dirichlet distribution,
and is related to the Gamma distribution.  It has the probability
distribution function

.. math:: f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
                                                 (1 - x)^{\beta - 1},

where the normalisation, B, is the beta function,

.. math:: B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
                             (1 - t)^{\beta - 1} dt.

It is often seen in Bayesian inference and order statistics.

Parameters
----------
a : float
    Alpha, non-negative.
b : float
    Beta, non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    Array of the given shape, containing values drawn from a
    Beta distribution.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Alpha, non-negative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Beta, non-negative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the given shape, containing values drawn from a
Beta distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.binomial" module_name="binomial" namespace="'random'">
    <docstring>binomial(n, p, size=None)

Draw samples from a binomial distribution.

Samples are drawn from a binomial distribution with specified
parameters, n trials and p probability of success where
n an integer &gt;= 0 and p is in the interval [0,1]. (n may be
input as a float, but it is truncated to an integer in use)

Parameters
----------
n : float (but truncated to an integer)
        parameter, &gt;= 0.
p : float
        parameter, &gt;= 0 and &lt;=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
          where the values are all integers in  [0, n].

See Also
--------
scipy.stats.distributions.binom : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the binomial distribution is

.. math:: P(N) = \binom{n}{N}p^N(1-p)^{n-N},

where :math:`n` is the number of trials, :math:`p` is the probability
of success, and :math:`N` is the number of successes.

When estimating the standard error of a proportion in a population by
using a random sample, the normal distribution works well unless the
product p*n &lt;=5, where p = population proportion estimate, and n =
number of samples, in which case the binomial distribution is used
instead. For example, a sample of 15 people shows 4 who are left
handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
so the binomial distribution should be used in this case.

References
----------
.. [1] Dalgaard, Peter, "Introductory Statistics with R",
       Springer-Verlag, 2002.
.. [2] Glantz, Stanton A. "Primer of Biostatistics.", McGraw-Hill,
       Fifth Edition, 2002.
.. [3] Lentner, Marvin, "Elementary Applied Statistics", Bogden
       and Quigley, 1972.
.. [4] Weisstein, Eric W. "Binomial Distribution." From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/BinomialDistribution.html
.. [5] Wikipedia, "Binomial-distribution",
       http://en.wikipedia.org/wiki/Binomial_distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; n, p = 10, .5  # number of trials, probability of each trial
&gt;&gt;&gt; s = np.random.binomial(n, p, 1000)
# result of flipping a coin 10 times, tested 1000 times.

A real world example. A company drills 9 wild-cat oil exploration
wells, each with an estimated probability of success of 0.1. All nine
wells fail. What is the probability of that happening?

Let's do 20,000 trials of the model, and count the number that
generate zero positive results.

&gt;&gt;&gt; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
# answer = 0.38885, or 38%.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Float" show_port="True">
      <docstring>parameter, &gt;= 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True">
      <docstring>parameter, &gt;= 0 and &lt;=1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>where the values are all integers in  [0, n].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.bytes" module_name="bytes" namespace="'random'">
    <docstring>bytes(length)

Return random bytes.

Parameters
----------
length : int
    Number of random bytes.

Returns
-------
out : str
    String of length `length`.

Examples
--------
&gt;&gt;&gt; np.random.bytes(10)
' eh\x85\x022SZ\xbf\xa4' #random</docstring>
    <inputPortSpec arg="length" name="length" port_type="basic:Integer" show_port="True">
      <docstring>Number of random bytes.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" show_port="True" sort_key="0">
      <docstring>String of length `length`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.chisquare" module_name="chisquare" namespace="'random'">
    <docstring>chisquare(df, size=None)

Draw samples from a chi-square distribution.

When `df` independent random variables, each with standard normal
distributions (mean 0, variance 1), are squared and summed, the
resulting distribution is chi-square (see Notes).  This distribution
is often used in hypothesis testing.

Parameters
----------
df : int
     Number of degrees of freedom.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
output : ndarray
    Samples drawn from the distribution, packed in a `size`-shaped
    array.

Raises
------
ValueError
    When `df` &lt;= 0 or when an inappropriate `size` (e.g. ``size=-1``)
    is given.

Notes
-----
The variable obtained by summing the squares of `df` independent,
standard normally distributed random variables:

.. math:: Q = \sum_{i=0}^{\mathtt{df}} X^2_i

is chi-square distributed, denoted

.. math:: Q \sim \chi^2_k.

The probability density function of the chi-squared distribution is

.. math:: p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
                 x^{k/2 - 1} e^{-x/2},

where :math:`\Gamma` is the gamma function,

.. math:: \Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.

References
----------
.. [1] NIST "Engineering Statistics Handbook"
       http://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm

Examples
--------
&gt;&gt;&gt; np.random.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])</docstring>
    <inputPortSpec arg="df" name="df" port_type="basic:Integer" show_port="True">
      <docstring>Number of degrees of freedom.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Samples drawn from the distribution, packed in a `size`-shaped
array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.exponential" module_name="exponential" namespace="'random'">
    <docstring>exponential(scale=1.0, size=None)

Draw samples from an exponential distribution.

Its probability density function is

.. math:: f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),

for ``x &gt; 0`` and 0 elsewhere. :math:`\beta` is the scale parameter,
which is the inverse of the rate parameter :math:`\lambda = 1/\beta`.
The rate parameter is an alternative, widely used parameterization
of the exponential distribution [3]_.

The exponential distribution is a continuous analogue of the
geometric distribution.  It describes many common situations, such as
the size of raindrops measured over many rainstorms [1]_, or the time
between page requests to Wikipedia [2]_.

Parameters
----------
scale : float
    The scale parameter, :math:`\beta = 1/\lambda`.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

References
----------
.. [1] Peyton Z. Peebles Jr., "Probability, Random Variables and
       Random Signal Principles", 4th ed, 2001, p. 57.
.. [2] "Poisson Process", Wikipedia,
       http://en.wikipedia.org/wiki/Poisson_process
.. [3] "Exponential Distribution, Wikipedia,
       http://en.wikipedia.org/wiki/Exponential_distribution</docstring>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <docstring>The scale parameter, :math:`\beta = 1/\lambda`.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.f" module_name="f" namespace="'random'">
    <docstring>f(dfnum, dfden, size=None)

Draw samples from an F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters should be greater than
zero.

The random variate of the F distribution (also known as the
Fisher distribution) is a continuous probability distribution
that arises in ANOVA tests, and is the ratio of two chi-square
variates.

Parameters
----------
dfnum : float
    Degrees of freedom in numerator. Should be greater than zero.
dfden : float
    Degrees of freedom in denominator. Should be greater than zero.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    Samples from the Fisher distribution.

See Also
--------
scipy.stats.distributions.f : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The F statistic is used to compare in-group variances to between-group
variances. Calculating the distribution depends on the sampling, and
so it is a function of the respective degrees of freedom in the
problem.  The variable `dfnum` is the number of samples minus one, the
between-groups degrees of freedom, while `dfden` is the within-groups
degrees of freedom, the sum of the number of samples in each group
minus the number of groups.

References
----------
.. [1] Glantz, Stanton A. "Primer of Biostatistics.", McGraw-Hill,
       Fifth Edition, 2002.
.. [2] Wikipedia, "F-distribution",
       http://en.wikipedia.org/wiki/F-distribution

Examples
--------
An example from Glantz[1], pp 47-40:

Two groups, children of diabetics (25 people) and children from people
without diabetes (25 controls). Fasting blood glucose was measured,
case group had a mean value of 86.1, controls had a mean value of
82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
data consistent with the null hypothesis that the parents diabetic
status does not affect their children's blood glucose levels?
Calculating the F statistic from the data gives a value of 36.01.

Draw samples from the distribution:

&gt;&gt;&gt; dfnum = 1. # between group degrees of freedom
&gt;&gt;&gt; dfden = 48. # within groups degrees of freedom
&gt;&gt;&gt; s = np.random.f(dfnum, dfden, 1000)

The lower bound for the top 1% of the samples is :

&gt;&gt;&gt; sort(s)[-10]
7.61988120985

So there is about a 1% chance that the F statistic will exceed 7.62,
the measured value is 36, so the null hypothesis is rejected at the 1%
level.</docstring>
    <inputPortSpec arg="dfnum" name="dfnum" port_type="basic:Float" show_port="True">
      <docstring>Degrees of freedom in numerator. Should be greater than zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dfden" name="dfden" port_type="basic:Float" show_port="True">
      <docstring>Degrees of freedom in denominator. Should be greater than zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Samples from the Fisher distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.gamma" module_name="gamma" namespace="'random'">
    <docstring>gamma(shape, scale=1.0, size=None)

Draw samples from a Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
`shape` (sometimes designated "k") and `scale` (sometimes designated
"theta"), where both parameters are &gt; 0.

Parameters
----------
shape : scalar &gt; 0
    The shape of the gamma distribution.
scale : scalar &gt; 0, optional
    The scale of the gamma distribution.  Default is equal to 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray, float
    Returns one sample unless `size` parameter is specified.

See Also
--------
scipy.stats.distributions.gamma : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. "Gamma Distribution." From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, "Gamma-distribution",
       http://en.wikipedia.org/wiki/Gamma-distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; shape, scale = 2., 2. # mean and dispersion
&gt;&gt;&gt; s = np.random.gamma(shape, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import scipy.special as sps
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, normed=True)
&gt;&gt;&gt; y = bins**(shape-1)*(np.exp(-bins/scale) /
...                      (sps.gamma(shape)*scale**shape))
&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="shape" name="shape" port_type="basic:Float" show_port="True">
      <docstring>The shape of the gamma distribution.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <docstring>The scale of the gamma distribution.  Default is equal to 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Returns one sample unless `size` parameter is specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.geometric" module_name="geometric" namespace="'random'">
    <docstring>geometric(p, size=None)

Draw samples from the geometric distribution.

Bernoulli trials are experiments with one of two outcomes:
success or failure (an example of such an experiment is flipping
a coin).  The geometric distribution models the number of trials
that must be run in order to achieve success.  It is therefore
supported on the positive integers, ``k = 1, 2, ...``.

The probability mass function of the geometric distribution is

.. math:: f(k) = (1 - p)^{k - 1} p

where `p` is the probability of success of an individual trial.

Parameters
----------
p : float
    The probability of success of an individual trial.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    Samples from the geometric distribution, shaped according to
    `size`.

Examples
--------
Draw ten thousand values from the geometric distribution,
with the probability of an individual success equal to 0.35:

&gt;&gt;&gt; z = np.random.geometric(p=0.35, size=10000)

How many trials succeeded after a single run?

&gt;&gt;&gt; (z == 1).sum() / 10000.
0.34889999999999999 #random</docstring>
    <inputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True">
      <docstring>The probability of success of an individual trial.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Samples from the geometric distribution, shaped according to
`size`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.get_state" module_name="get_state" namespace="'random'">
    <docstring>get_state()

Return a tuple representing the internal state of the generator.

For more details, see `set_state`.

Returns
-------
out : tuple(str, ndarray of 624 uints, int, int, float)
    The returned tuple has the following items:

    1. the string 'MT19937'.
    2. a 1-D array of 624 unsigned integer keys.
    3. an integer ``pos``.
    4. an integer ``has_gauss``.
    5. a float ``cached_gaussian``.

See Also
--------
set_state

Notes
-----
`set_state` and `get_state` are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.</docstring>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The returned tuple has the following items:

1. the string 'MT19937'.
2. a 1-D array of 624 unsigned integer keys.
3. an integer ``pos``.
4. an integer ``has_gauss``.
5. a float ``cached_gaussian``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.gumbel" module_name="gumbel" namespace="'random'">
    <docstring>gumbel(loc=0.0, scale=1.0, size=None)

Draw samples from a Gumbel distribution.

Draw samples from a Gumbel distribution with specified location and
scale.  For more information on the Gumbel distribution, see
Notes and References below.

Parameters
----------
loc : float
    The location of the mode of the distribution.
scale : float
    The scale parameter of the distribution.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar

See Also
--------
scipy.stats.gumbel_l
scipy.stats.gumbel_r
scipy.stats.genextreme
weibull

Notes
-----
The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
Value Type I) distribution is one of a class of Generalized Extreme
Value (GEV) distributions used in modeling extreme value problems.
The Gumbel is a special case of the Extreme Value Type I distribution
for maximums from distributions with "exponential-like" tails.

The probability density for the Gumbel distribution is

.. math:: p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
          \beta}},

where :math:`\mu` is the mode, a location parameter, and
:math:`\beta` is the scale parameter.

The Gumbel (named for German mathematician Emil Julius Gumbel) was used
very early in the hydrology literature, for modeling the occurrence of
flood events. It is also used for modeling maximum wind speed and
rainfall rates.  It is a "fat-tailed" distribution - the probability of
an event in the tail of the distribution is larger than if one used a
Gaussian, hence the surprisingly frequent occurrence of 100-year
floods. Floods were initially modeled as a Gaussian process, which
underestimated the frequency of extreme events.

It is one of a class of extreme value distributions, the Generalized
Extreme Value (GEV) distributions, which also includes the Weibull and
Frechet.

The function has a mean of :math:`\mu + 0.57721\beta` and a variance
of :math:`\frac{\pi^2}{6}\beta^2`.

References
----------
.. [1] Gumbel, E. J., "Statistics of Extremes,"
       New York: Columbia University Press, 1958.
.. [2] Reiss, R.-D. and Thomas, M., "Statistical Analysis of Extreme
       Values from Insurance, Finance, Hydrology and Other Fields,"
       Basel: Birkhauser Verlag, 2001.

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; mu, beta = 0, 0.1 # location and scale
&gt;&gt;&gt; s = np.random.gumbel(mu, beta, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, normed=True)
&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
&gt;&gt;&gt; plt.show()

Show how an extreme value distribution can arise from a Gaussian process
and compare to a Gaussian:

&gt;&gt;&gt; means = []
&gt;&gt;&gt; maxima = []
&gt;&gt;&gt; for i in range(0,1000) :
...    a = np.random.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
&gt;&gt;&gt; count, bins, ignored = plt.hist(maxima, 30, normed=True)
&gt;&gt;&gt; beta = np.std(maxima)*np.pi/np.sqrt(6)
&gt;&gt;&gt; mu = np.mean(maxima) - 0.57721*beta
&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
&gt;&gt;&gt; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="loc" name="loc" port_type="basic:Float">
      <docstring>The location of the mode of the distribution.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <docstring>The scale parameter of the distribution.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.hypergeometric" module_name="hypergeometric" namespace="'random'">
    <docstring>hypergeometric(ngood, nbad, nsample, size=None)

Draw samples from a Hypergeometric distribution.

Samples are drawn from a hypergeometric distribution with specified
parameters, ngood (ways to make a good selection), nbad (ways to make
a bad selection), and nsample = number of items sampled, which is less
than or equal to the sum ngood + nbad.

Parameters
----------
ngood : int or array_like
    Number of ways to make a good selection.  Must be nonnegative.
nbad : int or array_like
    Number of ways to make a bad selection.  Must be nonnegative.
nsample : int or array_like
    Number of items sampled.  Must be at least 1 and at most
    ``ngood + nbad``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The values are all integers in  [0, n].

See Also
--------
scipy.stats.distributions.hypergeom : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Hypergeometric distribution is

.. math:: P(x) = \frac{\binom{m}{n}\binom{N-m}{n-x}}{\binom{N}{n}},

where :math:`0 \le x \le m` and :math:`n+m-N \le x \le n`

for P(x) the probability of x successes, n = ngood, m = nbad, and
N = number of samples.

Consider an urn with black and white marbles in it, ngood of them
black and nbad are white. If you draw nsample balls without
replacement, then the hypergeometric distribution describes the
distribution of black balls in the drawn sample.

Note that this distribution is very similar to the binomial
distribution, except that in this case, samples are drawn without
replacement, whereas in the Binomial case samples are drawn with
replacement (or the sample space is infinite). As the sample space
becomes large, this distribution approaches the binomial.

References
----------
.. [1] Lentner, Marvin, "Elementary Applied Statistics", Bogden
       and Quigley, 1972.
.. [2] Weisstein, Eric W. "Hypergeometric Distribution." From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/HypergeometricDistribution.html
.. [3] Wikipedia, "Hypergeometric-distribution",
       http://en.wikipedia.org/wiki/Hypergeometric_distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
&gt;&gt;&gt; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
&gt;&gt;&gt; hist(s)
#   note that it is very unlikely to grab both bad items

Suppose you have an urn with 15 white and 15 black marbles.
If you pull 15 marbles at random, how likely is it that
12 or more of them are one color?

&gt;&gt;&gt; s = np.random.hypergeometric(15, 15, 15, 100000)
&gt;&gt;&gt; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.
#   answer = 0.003 ... pretty unlikely!</docstring>
    <inputPortSpec arg="ngood" name="ngoodScalar" port_type="basic:Integer" show_port="True">
      <docstring>Number of ways to make a good selection.  Must be nonnegative.</docstring>
      <alternateSpec arg="ngood" name="ngoodSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nbad" name="nbadScalar" port_type="basic:Integer" show_port="True">
      <docstring>Number of ways to make a bad selection.  Must be nonnegative.</docstring>
      <alternateSpec arg="nbad" name="nbadSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nsample" name="nsampleScalar" port_type="basic:Integer" show_port="True">
      <docstring>Number of items sampled.  Must be at least 1 and at most
``ngood + nbad``.</docstring>
      <alternateSpec arg="nsample" name="nsampleSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The values are all integers in  [0, n].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.laplace" module_name="laplace" namespace="'random'">
    <docstring>laplace(loc=0.0, scale=1.0, size=None)

Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).

The Laplace distribution is similar to the Gaussian/normal distribution,
but is sharper at the peak and has fatter tails. It represents the
difference between two independent, identically distributed exponential
random variables.

Parameters
----------
loc : float, optional
    The position, :math:`\mu`, of the distribution peak.
scale : float, optional
    :math:`\lambda`, the exponential decay.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or float

Notes
-----
It has the probability density function

.. math:: f(x; \mu, \lambda) = \frac{1}{2\lambda}
                               \exp\left(-\frac{|x - \mu|}{\lambda}\right).

The first law of Laplace, from 1774, states that the frequency
of an error can be expressed as an exponential function of the
absolute magnitude of the error, which leads to the Laplace
distribution. For many problems in economics and health
sciences, this distribution seems to model the data better
than the standard Gaussian distribution.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). "Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing," New York: Dover, 1972.
.. [2] Kotz, Samuel, et. al. "The Laplace Distribution and
       Generalizations, " Birkhauser, 2001.
.. [3] Weisstein, Eric W. "Laplace Distribution."
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LaplaceDistribution.html
.. [4] Wikipedia, "Laplace Distribution",
       http://en.wikipedia.org/wiki/Laplace_distribution

Examples
--------
Draw samples from the distribution

&gt;&gt;&gt; loc, scale = 0., 1.
&gt;&gt;&gt; s = np.random.laplace(loc, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, normed=True)
&gt;&gt;&gt; x = np.arange(-8., 8., .01)
&gt;&gt;&gt; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
&gt;&gt;&gt; plt.plot(x, pdf)

Plot Gaussian for comparison:

&gt;&gt;&gt; g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
&gt;&gt;&gt; plt.plot(x,g)</docstring>
    <inputPortSpec arg="loc" name="loc" port_type="basic:Float">
      <docstring>The position, :math:`\mu`, of the distribution peak.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <docstring>:math:`\lambda`, the exponential decay.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.logistic" module_name="logistic" namespace="'random'">
    <docstring>logistic(loc=0.0, scale=1.0, size=None)

Draw samples from a logistic distribution.

Samples are drawn from a logistic distribution with specified
parameters, loc (location or mean, also median), and scale (&gt;0).

Parameters
----------
loc : float

scale : float &gt; 0.

size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
          where the values are all integers in  [0, n].

See Also
--------
scipy.stats.distributions.logistic : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Logistic distribution is

.. math:: P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},

where :math:`\mu` = location and :math:`s` = scale.

The Logistic distribution is used in Extreme Value problems where it
can act as a mixture of Gumbel distributions, in Epidemiology, and by
the World Chess Federation (FIDE) where it is used in the Elo ranking
system, assuming the performance of each player is a logistically
distributed random variable.

References
----------
.. [1] Reiss, R.-D. and Thomas M. (2001), "Statistical Analysis of
       Extreme Values, from Insurance, Finance, Hydrology and Other
       Fields," Birkhauser Verlag, Basel, pp 132-133.
.. [2] Weisstein, Eric W. "Logistic Distribution." From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LogisticDistribution.html
.. [3] Wikipedia, "Logistic-distribution",
       http://en.wikipedia.org/wiki/Logistic_distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; loc, scale = 10, 1
&gt;&gt;&gt; s = np.random.logistic(loc, scale, 10000)
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=50)

#   plot against distribution

&gt;&gt;&gt; def logist(x, loc, scale):
...     return exp((loc-x)/scale)/(scale*(1+exp((loc-x)/scale))**2)
&gt;&gt;&gt; plt.plot(bins, logist(bins, loc, scale)*count.max()/\
... logist(bins, loc, scale).max())
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="loc" name="loc" port_type="basic:Float">
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>where the values are all integers in  [0, n].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.lognormal" module_name="lognormal" namespace="'random'">
    <docstring>lognormal(mean=0.0, sigma=1.0, size=None)

Draw samples from a log-normal distribution.

Draw samples from a log-normal distribution with specified mean,
standard deviation, and array shape.  Note that the mean and standard
deviation are not the values for the distribution itself, but of the
underlying normal distribution it is derived from.

Parameters
----------
mean : float
    Mean value of the underlying normal distribution
sigma : float, &gt; 0.
    Standard deviation of the underlying normal distribution
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or float
    The desired samples. An array of the same shape as `size` if given,
    if `size` is None a float is returned.

See Also
--------
scipy.stats.lognorm : probability density function, distribution,
    cumulative density function, etc.

Notes
-----
A variable `x` has a log-normal distribution if `log(x)` is normally
distributed.  The probability density function for the log-normal
distribution is:

.. math:: p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
                 e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}

where :math:`\mu` is the mean and :math:`\sigma` is the standard
deviation of the normally distributed logarithm of the variable.
A log-normal distribution results if a random variable is the *product*
of a large number of independent, identically-distributed variables in
the same way that a normal distribution results if the variable is the
*sum* of a large number of independent, identically-distributed
variables.

References
----------
.. [1] Limpert, E., Stahel, W. A., and Abbt, M., "Log-normal
       Distributions across the Sciences: Keys and Clues,"
       BioScience, Vol. 51, No. 5, May, 2001.
       http://stat.ethz.ch/~stahel/lognormal/bioscience.pdf
.. [2] Reiss, R.D. and Thomas, M., "Statistical Analysis of Extreme
       Values," Basel: Birkhauser Verlag, 2001, pp. 31-32.

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; mu, sigma = 3., 1. # mean and standard deviation
&gt;&gt;&gt; s = np.random.lognormal(mu, sigma, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 100, normed=True, align='mid')

&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)
&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

&gt;&gt;&gt; plt.plot(x, pdf, linewidth=2, color='r')
&gt;&gt;&gt; plt.axis('tight')
&gt;&gt;&gt; plt.show()

Demonstrate that taking the products of random samples from a uniform
distribution can be fit well by a log-normal probability density
function.

&gt;&gt;&gt; # Generate a thousand samples: each is the product of 100 random
&gt;&gt;&gt; # values, drawn from a normal distribution.
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for i in range(1000):
...    a = 10. + np.random.random(100)
...    b.append(np.product(a))

&gt;&gt;&gt; b = np.array(b) / np.min(b) # scale values to be positive
&gt;&gt;&gt; count, bins, ignored = plt.hist(b, 100, normed=True, align='mid')
&gt;&gt;&gt; sigma = np.std(np.log(b))
&gt;&gt;&gt; mu = np.mean(np.log(b))

&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)
&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

&gt;&gt;&gt; plt.plot(x, pdf, color='r', linewidth=2)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="mean" name="mean" port_type="basic:Float">
      <docstring>Mean value of the underlying normal distribution</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigma" port_type="basic:Float">
      <docstring>Standard deviation of the underlying normal distribution</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The desired samples. An array of the same shape as `size` if given,
if `size` is None a float is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.logseries" module_name="logseries" namespace="'random'">
    <docstring>logseries(p, size=None)

Draw samples from a logarithmic series distribution.

Samples are drawn from a log series distribution with specified
shape parameter, 0 &lt; ``p`` &lt; 1.

Parameters
----------
loc : float

scale : float &gt; 0.

size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
          where the values are all integers in  [0, n].

See Also
--------
scipy.stats.distributions.logser : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Log Series distribution is

.. math:: P(k) = \frac{-p^k}{k \ln(1-p)},

where p = probability.

The log series distribution is frequently used to represent species
richness and occurrence, first proposed by Fisher, Corbet, and
Williams in 1943 [2].  It may also be used to model the numbers of
occupants seen in cars [3].

References
----------
.. [1] Buzas, Martin A.; Culver, Stephen J.,  Understanding regional
       species diversity through the log series distribution of
       occurrences: BIODIVERSITY RESEARCH Diversity &amp; Distributions,
       Volume 5, Number 5, September 1999 , pp. 187-195(9).
.. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The
       relation between the number of species and the number of
       individuals in a random sample of an animal population.
       Journal of Animal Ecology, 12:42-58.
.. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small
       Data Sets, CRC Press, 1994.
.. [4] Wikipedia, "Logarithmic-distribution",
       http://en.wikipedia.org/wiki/Logarithmic-distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; a = .6
&gt;&gt;&gt; s = np.random.logseries(a, 10000)
&gt;&gt;&gt; count, bins, ignored = plt.hist(s)

#   plot against distribution

&gt;&gt;&gt; def logseries(k, p):
...     return -p**k/(k*log(1-p))
&gt;&gt;&gt; plt.plot(bins, logseries(bins, a)*count.max()/
             logseries(bins, a).max(), 'r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="loc" name="loc" port_type="basic:Float" show_port="True" />
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float" show_port="True" />
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>where the values are all integers in  [0, n].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.multinomial" module_name="multinomial" namespace="'random'">
    <docstring>multinomial(n, pvals, size=None)

Draw samples from a multinomial distribution.

The multinomial distribution is a multivariate generalisation of the
binomial distribution.  Take an experiment with one of ``p``
possible outcomes.  An example of such an experiment is throwing a dice,
where the outcome can be 1 through 6.  Each sample drawn from the
distribution represents `n` such experiments.  Its values,
``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the
outcome was ``i``.

Parameters
----------
n : int
    Number of experiments.
pvals : sequence of floats, length p
    Probabilities of each of the ``p`` different outcomes.  These
    should sum to 1 (however, the last element is always assumed to
    account for the remaining probability, as long as
    ``sum(pvals[:-1]) &lt;= 1)``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

Examples
--------
Throw a dice 20 times:

&gt;&gt;&gt; np.random.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]])

It landed 4 times on 1, once on 2, etc.

Now, throw the dice 20 times, and 20 times again:

&gt;&gt;&gt; np.random.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3],
       [2, 4, 3, 4, 0, 7]])

For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
we threw 2 times 1, 4 times 2, etc.

A loaded dice is more likely to land on number 6:

&gt;&gt;&gt; np.random.multinomial(100, [1/7.]*5)
array([13, 16, 13, 16, 42])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Number of experiments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pvals" depth="1" name="pvals" port_type="basic:Float" show_port="True">
      <docstring>Probabilities of each of the ``p`` different outcomes.  These
should sum to 1 (however, the last element is always assumed to
account for the remaining probability, as long as
``sum(pvals[:-1]) &lt;= 1)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The drawn samples, of shape *size*, if that was provided.  If not,
the shape is ``(N,)``.

In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
value drawn from the distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.multivariate_normal" module_name="multivariate_normal" namespace="'random'">
    <docstring>multivariate_normal(mean, cov[, size])

Draw random samples from a multivariate normal distribution.

The multivariate normal, multinormal or Gaussian distribution is a
generalization of the one-dimensional normal distribution to higher
dimensions.  Such a distribution is specified by its mean and
covariance matrix.  These parameters are analogous to the mean
(average or "center") and variance (standard deviation, or "width,"
squared) of the one-dimensional normal distribution.

Parameters
----------
mean : 1-D array_like, of length N
    Mean of the N-dimensional distribution.
cov : 2-D array_like, of shape (N, N)
    Covariance matrix of the distribution. It must be symmetric and
    positive-semidefinite for proper sampling.
size : int or tuple of ints, optional
    Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are
    generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because
    each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.
    If no shape is specified, a single (`N`-D) sample is returned.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

Notes
-----
The mean is a coordinate in N-dimensional space, which represents the
location where samples are most likely to be generated.  This is
analogous to the peak of the bell curve for the one-dimensional or
univariate normal distribution.

Covariance indicates the level to which two variables vary together.
From the multivariate normal distribution, we draw N-dimensional
samples, :math:`X = [x_1, x_2, ... x_N]`.  The covariance matrix
element :math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.
The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its
"spread").

Instead of specifying the full covariance matrix, popular
approximations include:

  - Spherical covariance (*cov* is a multiple of the identity matrix)
  - Diagonal covariance (*cov* has non-negative elements, and only on
    the diagonal)

This geometrical property can be seen in two dimensions by plotting
generated data-points:

&gt;&gt;&gt; mean = [0, 0]
&gt;&gt;&gt; cov = [[1, 0], [0, 100]]  # diagonal covariance

Diagonal covariance means that points are oriented along x or y-axis:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x, y = np.random.multivariate_normal(mean, cov, 5000).T
&gt;&gt;&gt; plt.plot(x, y, 'x')
&gt;&gt;&gt; plt.axis('equal')
&gt;&gt;&gt; plt.show()

Note that the covariance matrix must be positive semidefinite (a.k.a.
nonnegative-definite). Otherwise, the behavior of this method is
undefined and backwards compatibility is not guaranteed.

References
----------
.. [1] Papoulis, A., "Probability, Random Variables, and Stochastic
       Processes," 3rd ed., New York: McGraw-Hill, 1991.
.. [2] Duda, R. O., Hart, P. E., and Stork, D. G., "Pattern
       Classification," 2nd ed., New York: Wiley, 2001.

Examples
--------
&gt;&gt;&gt; mean = (1, 2)
&gt;&gt;&gt; cov = [[1, 0], [0, 1]]
&gt;&gt;&gt; x = np.random.multivariate_normal(mean, cov, (3, 3))
&gt;&gt;&gt; x.shape
(3, 3, 2)

The following is probably true, given that 0.6 is roughly twice the
standard deviation:

&gt;&gt;&gt; list((x[0,0,:] - mean) &lt; 0.6)
[True, True]</docstring>
    <inputPortSpec arg="mean" name="mean" port_type="basic:List" show_port="True">
      <docstring>Mean of the N-dimensional distribution.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cov" name="cov" port_type="basic:List" show_port="True">
      <docstring>Covariance matrix of the distribution. It must be symmetric and
positive-semidefinite for proper sampling.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are
generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because
each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.
If no shape is specified, a single (`N`-D) sample is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The drawn samples, of shape *size*, if that was provided.  If not,
the shape is ``(N,)``.

In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
value drawn from the distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.negative_binomial" module_name="negative_binomial" namespace="'random'">
    <docstring>negative_binomial(n, p, size=None)

Draw samples from a negative binomial distribution.

Samples are drawn from a negative binomial distribution with specified
parameters, `n` trials and `p` probability of success where `n` is an
integer &gt; 0 and `p` is in the interval [0, 1].

Parameters
----------
n : int
    Parameter, &gt; 0.
p : float
    Parameter, &gt;= 0 and &lt;=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : int or ndarray of ints
    Drawn samples.

Notes
-----
The probability density for the negative binomial distribution is

.. math:: P(N;n,p) = \binom{N+n-1}{n-1}p^{n}(1-p)^{N},

where :math:`n-1` is the number of successes, :math:`p` is the
probability of success, and :math:`N+n-1` is the number of trials.
The negative binomial distribution gives the probability of n-1
successes and N failures in N+n-1 trials, and success on the (N+n)th
trial.

If one throws a die repeatedly until the third time a "1" appears,
then the probability distribution of the number of non-"1"s that
appear before the third "1" is a negative binomial distribution.

References
----------
.. [1] Weisstein, Eric W. "Negative Binomial Distribution." From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NegativeBinomialDistribution.html
.. [2] Wikipedia, "Negative binomial distribution",
       http://en.wikipedia.org/wiki/Negative_binomial_distribution

Examples
--------
Draw samples from the distribution:

A real world example. A company drills wild-cat oil
exploration wells, each with an estimated probability of
success of 0.1.  What is the probability of having one success
for each successive well, that is what is the probability of a
single success after drilling 5 wells, after 6 wells, etc.?

&gt;&gt;&gt; s = np.random.negative_binomial(1, 0.1, 100000)
&gt;&gt;&gt; for i in range(1, 11):
...    probability = sum(s&lt;i) / 100000.
...    print i, "wells drilled, probability of one success =", probability</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Parameter, &gt; 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True">
      <docstring>Parameter, &gt;= 0 and &lt;=1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.noncentral_chisquare" module_name="noncentral_chisquare" namespace="'random'">
    <docstring>noncentral_chisquare(df, nonc, size=None)

Draw samples from a noncentral chi-square distribution.

The noncentral :math:`\chi^2` distribution is a generalisation of
the :math:`\chi^2` distribution.

Parameters
----------
df : int
    Degrees of freedom, should be &gt; 0 as of Numpy 1.10,
    should be &gt; 1 for earlier versions.
nonc : float
    Non-centrality, should be &gt; 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Notes
-----
The probability density function for the noncentral Chi-square
distribution is

.. math:: P(x;df,nonc) = \sum^{\infty}_{i=0}
                       \frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
                       \P_{Y_{df+2i}}(x),

where :math:`Y_{q}` is the Chi-square with q degrees of freedom.

In Delhi (2007), it is noted that the noncentral chi-square is
useful in bombing and coverage problems, the probability of
killing the point target given by the noncentral chi-squared
distribution.

References
----------
.. [1] Delhi, M.S. Holla, "On a noncentral chi-square distribution in
       the analysis of weapon systems effectiveness", Metrika,
       Volume 15, Number 1 / December, 1970.
.. [2] Wikipedia, "Noncentral chi-square distribution"
       http://en.wikipedia.org/wiki/Noncentral_chi-square_distribution

Examples
--------
Draw values from the distribution and plot the histogram

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, normed=True)
&gt;&gt;&gt; plt.show()

Draw values from a noncentral chisquare with very small noncentrality,
and compare to a chisquare.

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), normed=True)
&gt;&gt;&gt; values2 = plt.hist(np.random.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), normed=True)
&gt;&gt;&gt; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
&gt;&gt;&gt; plt.show()

Demonstrate how large values of non-centrality lead to a more symmetric
distribution.

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, normed=True)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="df" name="df" port_type="basic:Integer" show_port="True">
      <docstring>Degrees of freedom, should be &gt; 0 as of Numpy 1.10,
should be &gt; 1 for earlier versions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nonc" name="nonc" port_type="basic:Float" show_port="True">
      <docstring>Non-centrality, should be &gt; 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.noncentral_f" module_name="noncentral_f" namespace="'random'">
    <docstring>noncentral_f(dfnum, dfden, nonc, size=None)

Draw samples from the noncentral F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters &gt; 1.
`nonc` is the non-centrality parameter.

Parameters
----------
dfnum : int
    Parameter, should be &gt; 1.
dfden : int
    Parameter, should be &gt; 1.
nonc : float
    Parameter, should be &gt;= 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : scalar or ndarray
    Drawn samples.

Notes
-----
When calculating the power of an experiment (power = probability of
rejecting the null hypothesis when a specific alternative is true) the
non-central F statistic becomes important.  When the null hypothesis is
true, the F statistic follows a central F distribution. When the null
hypothesis is not true, then it follows a non-central F statistic.

References
----------
.. [1] Weisstein, Eric W. "Noncentral F-Distribution."
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NoncentralF-Distribution.html
.. [2] Wikipedia, "Noncentral F distribution",
       http://en.wikipedia.org/wiki/Noncentral_F-distribution

Examples
--------
In a study, testing for a specific alternative to the null hypothesis
requires use of the Noncentral F distribution. We need to calculate the
area in the tail of the distribution that exceeds the value of the F
distribution for the null hypothesis.  We'll plot the two probability
distributions for comparison.

&gt;&gt;&gt; dfnum = 3 # between group deg of freedom
&gt;&gt;&gt; dfden = 20 # within groups degrees of freedom
&gt;&gt;&gt; nonc = 3.0
&gt;&gt;&gt; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
&gt;&gt;&gt; NF = np.histogram(nc_vals, bins=50, normed=True)
&gt;&gt;&gt; c_vals = np.random.f(dfnum, dfden, 1000000)
&gt;&gt;&gt; F = np.histogram(c_vals, bins=50, normed=True)
&gt;&gt;&gt; plt.plot(F[1][1:], F[0])
&gt;&gt;&gt; plt.plot(NF[1][1:], NF[0])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="dfnum" name="dfnum" port_type="basic:Integer" show_port="True">
      <docstring>Parameter, should be &gt; 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dfden" name="dfden" port_type="basic:Integer" show_port="True">
      <docstring>Parameter, should be &gt; 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nonc" name="nonc" port_type="basic:Float" show_port="True">
      <docstring>Parameter, should be &gt;= 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.normal" module_name="normal" namespace="'random'">
    <docstring>normal(loc=0.0, scale=1.0, size=None)

Draw random samples from a normal (Gaussian) distribution.

The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently [2]_, is often called the bell curve because of
its characteristic shape (see the example below).

The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution [2]_.

Parameters
----------
loc : float
    Mean ("centre") of the distribution.
scale : float
    Standard deviation (spread or "width") of the distribution.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

See Also
--------
scipy.stats.distributions.norm : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Gaussian distribution is

.. math:: p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
                 e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },

where :math:`\mu` is the mean and :math:`\sigma` the standard
deviation. The square of the standard deviation, :math:`\sigma^2`,
is called the variance.

The function has its peak at the mean, and its "spread" increases with
the standard deviation (the function reaches 0.607 times its maximum at
:math:`x + \sigma` and :math:`x - \sigma` [2]_).  This implies that
`numpy.random.normal` is more likely to return samples lying close to
the mean, rather than those far away.

References
----------
.. [1] Wikipedia, "Normal distribution",
       http://en.wikipedia.org/wiki/Normal_distribution
.. [2] P. R. Peebles Jr., "Central Limit Theorem" in "Probability,
       Random Variables and Random Signal Principles", 4th ed., 2001,
       pp. 51, 51, 125.

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation
&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)

Verify the mean and the variance:

&gt;&gt;&gt; abs(mu - np.mean(s)) &lt; 0.01
True

&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1)) &lt; 0.01
True

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, normed=True)
&gt;&gt;&gt; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="loc" name="loc" port_type="basic:Float">
      <docstring>Mean ("centre") of the distribution.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <docstring>Standard deviation (spread or "width") of the distribution.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.pareto" module_name="pareto" namespace="'random'">
    <docstring>pareto(a, size=None)

Draw samples from a Pareto II or Lomax distribution with
specified shape.

The Lomax or Pareto II distribution is a shifted Pareto
distribution. The classical Pareto distribution can be
obtained from the Lomax distribution by adding 1 and
multiplying by the scale parameter ``m`` (see Notes).  The
smallest value of the Lomax distribution is zero while for the
classical Pareto distribution it is ``mu``, where the standard
Pareto distribution has location ``mu = 1``.  Lomax can also
be considered as a simplified version of the Generalized
Pareto distribution (available in SciPy), with the scale set
to one and the location set to zero.

The Pareto distribution must be greater than zero, and is
unbounded above.  It is also known as the "80-20 rule".  In
this distribution, 80 percent of the weights are in the lowest
20 percent of the range, while the other 20 percent fill the
remaining 80 percent of the range.

Parameters
----------
shape : float, &gt; 0.
    Shape of the distribution.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

See Also
--------
scipy.stats.distributions.lomax.pdf : probability density function,
    distribution or cumulative density function, etc.
scipy.stats.distributions.genpareto.pdf : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Pareto distribution is

.. math:: p(x) = \frac{am^a}{x^{a+1}}

where :math:`a` is the shape and :math:`m` the scale.

The Pareto distribution, named after the Italian economist
Vilfredo Pareto, is a power law probability distribution
useful in many real world problems.  Outside the field of
economics it is generally referred to as the Bradford
distribution. Pareto developed the distribution to describe
the distribution of wealth in an economy.  It has also found
use in insurance, web page access statistics, oil field sizes,
and many other problems, including the download frequency for
projects in Sourceforge [1]_.  It is one of the so-called
"fat-tailed" distributions.


References
----------
.. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of
       Sourceforge projects.
.. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.
.. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme
       Values, Birkhauser Verlag, Basel, pp 23-30.
.. [4] Wikipedia, "Pareto distribution",
       http://en.wikipedia.org/wiki/Pareto_distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; a, m = 3., 2.  # shape and mode
&gt;&gt;&gt; s = (np.random.pareto(a, 1000) + 1) * m

Display the histogram of the samples, along with the probability
density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, _ = plt.hist(s, 100, normed=True)
&gt;&gt;&gt; fit = a*m**a / bins**(a+1)
&gt;&gt;&gt; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="shape" name="shape" port_type="basic:Float" show_port="True">
      <docstring>Shape of the distribution.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.permutation" module_name="permutation" namespace="'random'">
    <docstring>permutation(x)

Randomly permute a sequence, or return a permuted range.

If `x` is a multi-dimensional array, it is only shuffled along its
first index.

Parameters
----------
x : int or array_like
    If `x` is an integer, randomly permute ``np.arange(x)``.
    If `x` is an array, make a copy and shuffle the elements
    randomly.

Returns
-------
out : ndarray
    Permuted sequence or array range.

Examples
--------
&gt;&gt;&gt; np.random.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])

&gt;&gt;&gt; np.random.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12])

&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; np.random.permutation(arr)
array([[6, 7, 8],
       [0, 1, 2],
       [3, 4, 5]])</docstring>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Integer" show_port="True">
      <docstring>If `x` is an integer, randomly permute ``np.arange(x)``.
If `x` is an array, make a copy and shuffle the elements
randomly.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Permuted sequence or array range.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.poisson" module_name="poisson" namespace="'random'">
    <docstring>poisson(lam=1.0, size=None)

Draw samples from a Poisson distribution.

The Poisson distribution is the limit of the binomial distribution
for large N.

Parameters
----------
lam : float or sequence of float
    Expectation of interval, should be &gt;= 0. A sequence of expectation
    intervals must be broadcastable over the requested size.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The drawn samples, of shape *size*, if it was provided.

Notes
-----
The Poisson distribution

.. math:: f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}

For events with an expected separation :math:`\lambda` the Poisson
distribution :math:`f(k; \lambda)` describes the probability of
:math:`k` events occurring within the observed
interval :math:`\lambda`.

Because the output is limited to the range of the C long type, a
ValueError is raised when `lam` is within 10 sigma of the maximum
representable value.

References
----------
.. [1] Weisstein, Eric W. "Poisson Distribution."
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/PoissonDistribution.html
.. [2] Wikipedia, "Poisson distribution",
       http://en.wikipedia.org/wiki/Poisson_distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; s = np.random.poisson(5, 10000)

Display histogram of the sample:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 14, normed=True)
&gt;&gt;&gt; plt.show()

Draw each 100 values for lambda 100 and 500:

&gt;&gt;&gt; s = np.random.poisson(lam=(100., 500.), size=(100, 2))</docstring>
    <inputPortSpec arg="lam" name="lamScalar" port_type="basic:Float">
      <docstring>Expectation of interval, should be &gt;= 0. A sequence of expectation
intervals must be broadcastable over the requested size.</docstring>
      <defaults>[1.0]</defaults>
      <alternateSpec arg="lam" depth="1" name="lamSequence" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The drawn samples, of shape *size*, if it was provided.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.power" module_name="power" namespace="'random'">
    <docstring>power(a, size=None)

Draws samples in [0, 1] from a power distribution with positive
exponent a - 1.

Also known as the power function distribution.

Parameters
----------
a : float
    parameter, &gt; 0
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The returned samples lie in [0, 1].

Raises
------
ValueError
    If a &lt; 1.

Notes
-----
The probability density function is

.. math:: P(x; a) = ax^{a-1}, 0 \le x \le 1, a&gt;0.

The power function distribution is just the inverse of the Pareto
distribution. It may also be seen as a special case of the Beta
distribution.

It is used, for example, in modeling the over-reporting of insurance
claims.

References
----------
.. [1] Christian Kleiber, Samuel Kotz, "Statistical size distributions
       in economics and actuarial sciences", Wiley, 2003.
.. [2] Heckert, N. A. and Filliben, James J. "NIST Handbook 148:
       Dataplot Reference Manual, Volume 2: Let Subcommands and Library
       Functions", National Institute of Standards and Technology
       Handbook Series, June 2003.
       http://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; a = 5. # shape
&gt;&gt;&gt; samples = 1000
&gt;&gt;&gt; s = np.random.power(a, samples)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=30)
&gt;&gt;&gt; x = np.linspace(0, 1, 100)
&gt;&gt;&gt; y = a*x**(a-1.)
&gt;&gt;&gt; normed_y = samples*np.diff(bins)[0]*y
&gt;&gt;&gt; plt.plot(x, normed_y)
&gt;&gt;&gt; plt.show()

Compare the power function distribution to the inverse of the Pareto.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rvs = np.random.power(5, 1000000)
&gt;&gt;&gt; rvsp = np.random.pareto(5, 1000000)
&gt;&gt;&gt; xx = np.linspace(0,1,100)
&gt;&gt;&gt; powpdf = stats.powerlaw.pdf(xx,5)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.hist(rvs, bins=50, normed=True)
&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')
&gt;&gt;&gt; plt.title('np.random.power(5)')

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, normed=True)
&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')
&gt;&gt;&gt; plt.title('inverse of 1 + np.random.pareto(5)')

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, normed=True)
&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')
&gt;&gt;&gt; plt.title('inverse of stats.pareto(5)')</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>parameter, &gt; 0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The returned samples lie in [0, 1].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.rand" module_name="rand" namespace="'random'">
    <docstring>rand(d0, d1, ..., dn)

Random values in a given shape.

Create an array of the given shape and propagate it with
random samples from a uniform distribution
over ``[0, 1)``.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, should all be positive.
    If no argument is given a single Python float is returned.

Returns
-------
out : ndarray, shape ``(d0, d1, ..., dn)``
    Random values.

See Also
--------
random

Notes
-----
This is a convenience function. If you want an interface that
takes a shape-tuple as the first argument, refer to
np.random.random_sample .

Examples
--------
&gt;&gt;&gt; np.random.rand(3,2)
array([[ 0.14022471,  0.96360618],  #random
       [ 0.37601032,  0.25528411],  #random
       [ 0.49313049,  0.94909878]]) #random</docstring>
    <inputPortSpec arg="d0" name="d0" port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d1" name="d1" port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dn" name="dn" port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Random values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.randint" module_name="randint" namespace="'random'">
    <docstring>randint(low, high=None, size=None)

Return random integers from `low` (inclusive) to `high` (exclusive).

Return random integers from the "discrete uniform" distribution in the
"half-open" interval [`low`, `high`). If `high` is None (the default),
then results are from [0, `low`).

Parameters
----------
low : int
    Lowest (signed) integer to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is the *highest* such
    integer).
high : int, optional
    If provided, one above the largest (signed) integer to be drawn
    from the distribution (see above for behavior if ``high=None``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
random.random_integers : similar to `randint`, only for the closed
    interval [`low`, `high`], and 1 is the lowest value if `high` is
    omitted. In particular, this other one is the one to use to generate
    uniformly distributed discrete non-integers.

Examples
--------
&gt;&gt;&gt; np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])
&gt;&gt;&gt; np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

Generate a 2 x 4 array of ints between 0 and 4, inclusive:

&gt;&gt;&gt; np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1],
       [3, 2, 2, 0]])</docstring>
    <inputPortSpec arg="low" name="low" port_type="basic:Integer" show_port="True">
      <docstring>Lowest (signed) integer to be drawn from the distribution (unless
``high=None``, in which case this parameter is the *highest* such
integer).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Integer">
      <docstring>If provided, one above the largest (signed) integer to be drawn
from the distribution (see above for behavior if ``high=None``).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>`size`-shaped array of random integers from the appropriate
distribution, or a single such random int if `size` not provided.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.randn" module_name="randn" namespace="'random'">
    <docstring>randn(d0, d1, ..., dn)

Return a sample (or samples) from the "standard normal" distribution.

If positive, int_like or int-convertible arguments are provided,
`randn` generates an array of shape ``(d0, d1, ..., dn)``, filled
with random floats sampled from a univariate "normal" (Gaussian)
distribution of mean 0 and variance 1 (if any of the :math:`d_i` are
floats, they are first converted to integers by truncation). A single
float randomly sampled from the distribution is returned if no
argument is provided.

This is a convenience function.  If you want an interface that takes a
tuple as the first argument, use `numpy.random.standard_normal` instead.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, should be all positive.
    If no argument is given a single Python float is returned.

Returns
-------
Z : ndarray or float
    A ``(d0, d1, ..., dn)``-shaped array of floating-point samples from
    the standard normal distribution, or a single such float if
    no parameters were supplied.

See Also
--------
random.standard_normal : Similar, but takes a tuple as its argument.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use:

``sigma * np.random.randn(...) + mu``

Examples
--------
&gt;&gt;&gt; np.random.randn()
2.1923875335537315 #random

Two-by-four array of samples from N(3, 6.25):

&gt;&gt;&gt; 2.5 * np.random.randn(2, 4) + 3
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random</docstring>
    <inputPortSpec arg="d0" name="d0" port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d1" name="d1" port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dn" name="dn" port_type="basic:Integer">
      <docstring>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>A ``(d0, d1, ..., dn)``-shaped array of floating-point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.random_integers" module_name="random_integers" namespace="'random'">
    <docstring>random_integers(low, high=None, size=None)

Return random integers between `low` and `high`, inclusive.

Return random integers from the "discrete uniform" distribution in the
closed interval [`low`, `high`].  If `high` is None (the default),
then results are from [1, `low`].

Parameters
----------
low : int
    Lowest (signed) integer to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is the *highest* such
    integer).
high : int, optional
    If provided, the largest (signed) integer to be drawn from the
    distribution (see above for behavior if ``high=None``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
random.randint : Similar to `random_integers`, only for the half-open
    interval [`low`, `high`), and 0 is the lowest value if `high` is
    omitted.

Notes
-----
To sample from N evenly spaced floating-point numbers between a and b,
use::

  a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)

Examples
--------
&gt;&gt;&gt; np.random.random_integers(5)
4
&gt;&gt;&gt; type(np.random.random_integers(5))
&lt;type 'int'&gt;
&gt;&gt;&gt; np.random.random_integers(5, size=(3.,2.))
array([[5, 4],
       [3, 3],
       [4, 5]])

Choose five random numbers from the set of five evenly-spaced
numbers between 0 and 2.5, inclusive (*i.e.*, from the set
:math:`{0, 5/8, 10/8, 15/8, 20/8}`):

&gt;&gt;&gt; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ])

Roll two six sided dice 1000 times and sum the results:

&gt;&gt;&gt; d1 = np.random.random_integers(1, 6, 1000)
&gt;&gt;&gt; d2 = np.random.random_integers(1, 6, 1000)
&gt;&gt;&gt; dsums = d1 + d2

Display results as a histogram:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(dsums, 11, normed=True)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="low" name="low" port_type="basic:Integer" show_port="True">
      <docstring>Lowest (signed) integer to be drawn from the distribution (unless
``high=None``, in which case this parameter is the *highest* such
integer).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Integer">
      <docstring>If provided, the largest (signed) integer to be drawn from the
distribution (see above for behavior if ``high=None``).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>`size`-shaped array of random integers from the appropriate
distribution, or a single such random int if `size` not provided.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.random_sample" module_name="random_sample" namespace="'random'">
    <docstring>random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the "continuous uniform" distribution over the
stated interval.  To sample :math:`Unif[a, b), b &gt; a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

Examples
--------
&gt;&gt;&gt; np.random.random_sample()
0.47108547995356098
&gt;&gt;&gt; type(np.random.random_sample())
&lt;type 'float'&gt;
&gt;&gt;&gt; np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])

Three-by-two array of random numbers from [-5, 0):

&gt;&gt;&gt; 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984],
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Array of random floats of shape `size` (unless ``size=None``, in which
case a single float is returned).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.rayleigh" module_name="rayleigh" namespace="'random'">
    <docstring>rayleigh(scale=1.0, size=None)

Draw samples from a Rayleigh distribution.

The :math:`\chi` and Weibull distributions are generalizations of the
Rayleigh.

Parameters
----------
scale : scalar
    Scale, also equals the mode. Should be &gt;= 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Notes
-----
The probability density function for the Rayleigh distribution is

.. math:: P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}

The Rayleigh distribution would arise, for example, if the East
and North components of the wind velocity had identical zero-mean
Gaussian distributions.  Then the wind speed would have a Rayleigh
distribution.

References
----------
.. [1] Brighton Webs Ltd., "Rayleigh Distribution,"
       http://www.brighton-webs.co.uk/distributions/rayleigh.asp
.. [2] Wikipedia, "Rayleigh distribution"
       http://en.wikipedia.org/wiki/Rayleigh_distribution

Examples
--------
Draw values from the distribution and plot the histogram

&gt;&gt;&gt; values = hist(np.random.rayleigh(3, 100000), bins=200, normed=True)

Wave heights tend to follow a Rayleigh distribution. If the mean wave
height is 1 meter, what fraction of waves are likely to be larger than 3
meters?

&gt;&gt;&gt; meanvalue = 1
&gt;&gt;&gt; modevalue = np.sqrt(2 / np.pi) * meanvalue
&gt;&gt;&gt; s = np.random.rayleigh(modevalue, 1000000)

The percentage of waves larger than 3 meters is:

&gt;&gt;&gt; 100.*sum(s&gt;3)/1000000.
0.087300000000000003</docstring>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float">
      <docstring>Scale, also equals the mode. Should be &gt;= 0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.seed" module_name="seed" namespace="'random'">
    <docstring>seed(seed=None)

Seed the generator.

This method is called when `RandomState` is initialized. It can be
called again to re-seed the generator. For details, see `RandomState`.

Parameters
----------
seed : int or array_like, optional
    Seed for `RandomState`.
    Must be convertible to 32 bit unsigned integers.

See Also
--------
RandomState</docstring>
    <inputPortSpec arg="seed" name="seedScalar" port_type="basic:Integer">
      <docstring>Seed for `RandomState`.
Must be convertible to 32 bit unsigned integers.</docstring>
      <alternateSpec arg="seed" name="seedSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.set_state" module_name="set_state" namespace="'random'">
    <docstring>set_state(state)

Set the internal state of the generator from a tuple.

For use if one has reason to manually (re-)set the internal state of the
"Mersenne Twister"[1]_ pseudo-random number generating algorithm.

Parameters
----------
state : tuple(str, ndarray of 624 uints, int, int, float)
    The `state` tuple has the following items:

    1. the string 'MT19937', specifying the Mersenne Twister algorithm.
    2. a 1-D array of 624 unsigned integers ``keys``.
    3. an integer ``pos``.
    4. an integer ``has_gauss``.
    5. a float ``cached_gaussian``.

Returns
-------
out : None
    Returns 'None' on success.

See Also
--------
get_state

Notes
-----
`set_state` and `get_state` are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.

For backwards compatibility, the form (str, array of 624 uints, int) is
also accepted although it is missing some information about the cached
Gaussian value: ``state = ('MT19937', keys, pos)``.

References
----------
.. [1] M. Matsumoto and T. Nishimura, "Mersenne Twister: A
   623-dimensionally equidistributed uniform pseudorandom number
   generator," *ACM Trans. on Modeling and Computer Simulation*,
   Vol. 8, No. 1, pp. 3-30, Jan. 1998.</docstring>
    <inputPortSpec arg="state" depth="1" name="state" port_type="basic:Integer" show_port="True">
      <docstring>The `state` tuple has the following items:

1. the string 'MT19937', specifying the Mersenne Twister algorithm.
2. a 1-D array of 624 unsigned integers ``keys``.
3. an integer ``pos``.
4. an integer ``has_gauss``.
5. a float ``cached_gaussian``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Returns 'None' on success.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.shuffle" module_name="shuffle" namespace="'random'">
    <docstring>shuffle(x)

Modify a sequence in-place by shuffling its contents.

Parameters
----------
x : array_like
    The array or list to be shuffled.

Returns
-------
None

Examples
--------
&gt;&gt;&gt; arr = np.arange(10)
&gt;&gt;&gt; np.random.shuffle(arr)
&gt;&gt;&gt; arr
[1 7 5 2 9 4 3 6 0 8]

This function only shuffles the array along the first index of a
multi-dimensional array:

&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; np.random.shuffle(arr)
&gt;&gt;&gt; arr
array([[3, 4, 5],
       [6, 7, 8],
       [0, 1, 2]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array or list to be shuffled.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.standard_cauchy" module_name="standard_cauchy" namespace="'random'">
    <docstring>standard_cauchy(size=None)

Draw samples from a standard Cauchy distribution with mode = 0.

Also known as the Lorentz distribution.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The drawn samples.

Notes
-----
The probability density function for the full Cauchy distribution is

.. math:: P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
          (\frac{x-x_0}{\gamma})^2 \bigr] }

and the Standard Cauchy distribution just sets :math:`x_0=0` and
:math:`\gamma=1`

The Cauchy distribution arises in the solution to the driven harmonic
oscillator problem, and also describes spectral line broadening. It
also describes the distribution of values at which a line tilted at
a random angle will cut the x axis.

When studying hypothesis tests that assume normality, seeing how the
tests perform on data from a Cauchy distribution is a good indicator of
their sensitivity to a heavy-tailed distribution, since the Cauchy looks
very much like a Gaussian distribution, but with heavier tails.

References
----------
.. [1] NIST/SEMATECH e-Handbook of Statistical Methods, "Cauchy
      Distribution",
      http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm
.. [2] Weisstein, Eric W. "Cauchy Distribution." From MathWorld--A
      Wolfram Web Resource.
      http://mathworld.wolfram.com/CauchyDistribution.html
.. [3] Wikipedia, "Cauchy distribution"
      http://en.wikipedia.org/wiki/Cauchy_distribution

Examples
--------
Draw samples and plot the distribution:

&gt;&gt;&gt; s = np.random.standard_cauchy(1000000)
&gt;&gt;&gt; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well
&gt;&gt;&gt; plt.hist(s, bins=100)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.standard_exponential" module_name="standard_exponential" namespace="'random'">
    <docstring>standard_exponential(size=None)

Draw samples from the standard exponential distribution.

`standard_exponential` is identical to the exponential distribution
with a scale parameter of 1.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    Drawn samples.

Examples
--------
Output a 3x8000 array:

&gt;&gt;&gt; n = np.random.standard_exponential((3, 8000))</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.standard_gamma" module_name="standard_gamma" namespace="'random'">
    <docstring>standard_gamma(shape, size=None)

Draw samples from a standard Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
shape (sometimes designated "k") and scale=1.

Parameters
----------
shape : float
    Parameter, should be &gt; 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The drawn samples.

See Also
--------
scipy.stats.distributions.gamma : probability density function,
    distribution or cumulative density function, etc.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. "Gamma Distribution." From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, "Gamma-distribution",
       http://en.wikipedia.org/wiki/Gamma-distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; shape, scale = 2., 1. # mean and width
&gt;&gt;&gt; s = np.random.standard_gamma(shape, 1000000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import scipy.special as sps
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, normed=True)
&gt;&gt;&gt; y = bins**(shape-1) * ((np.exp(-bins/scale))/ \
...                       (sps.gamma(shape) * scale**shape))
&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="shape" name="shape" port_type="basic:Float" show_port="True">
      <docstring>Parameter, should be &gt; 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.standard_normal" module_name="standard_normal" namespace="'random'">
    <docstring>standard_normal(size=None)

Draw samples from a standard Normal distribution (mean=0, stdev=1).

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    Drawn samples.

Examples
--------
&gt;&gt;&gt; s = np.random.standard_normal(8000)
&gt;&gt;&gt; s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random
       -0.38672696, -0.4685006 ])                               #random
&gt;&gt;&gt; s.shape
(8000,)
&gt;&gt;&gt; s = np.random.standard_normal(size=(3, 4, 2))
&gt;&gt;&gt; s.shape
(3, 4, 2)</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.standard_t" module_name="standard_t" namespace="'random'">
    <docstring>standard_t(df, size=None)

Draw samples from a standard Student's t distribution with `df` degrees
of freedom.

A special case of the hyperbolic distribution.  As `df` gets
large, the result resembles that of the standard normal
distribution (`standard_normal`).

Parameters
----------
df : int
    Degrees of freedom, should be &gt; 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    Drawn samples.

Notes
-----
The probability density function for the t distribution is

.. math:: P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
          \Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}

The t test is based on an assumption that the data come from a
Normal distribution. The t test provides a way to test whether
the sample mean (that is the mean calculated from the data) is
a good estimate of the true mean.

The derivation of the t-distribution was first published in
1908 by William Gisset while working for the Guinness Brewery
in Dublin. Due to proprietary issues, he had to publish under
a pseudonym, and so he used the name Student.

References
----------
.. [1] Dalgaard, Peter, "Introductory Statistics With R",
       Springer, 2002.
.. [2] Wikipedia, "Student's t-distribution"
       http://en.wikipedia.org/wiki/Student's_t-distribution

Examples
--------
From Dalgaard page 83 [1]_, suppose the daily energy intake for 11
women in Kj is:

&gt;&gt;&gt; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])

Does their energy intake deviate systematically from the recommended
value of 7725 kJ?

We have 10 degrees of freedom, so is the sample mean within 95% of the
recommended value?

&gt;&gt;&gt; s = np.random.standard_t(10, size=100000)
&gt;&gt;&gt; np.mean(intake)
6753.636363636364
&gt;&gt;&gt; intake.std(ddof=1)
1142.1232221373727

Calculate the t statistic, setting the ddof parameter to the unbiased
value so the divisor in the standard deviation will be degrees of
freedom, N-1.

&gt;&gt;&gt; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; h = plt.hist(s, bins=100, normed=True)

For a one-sided t-test, how far out in the distribution does the t
statistic appear?

&gt;&gt;&gt; np.sum(s&lt;t) / float(len(s))
0.0090699999999999999  #random

So the p-value is about 0.009, which says the null hypothesis has a
probability of about 99% of being true.</docstring>
    <inputPortSpec arg="df" name="df" port_type="basic:Integer" show_port="True">
      <docstring>Degrees of freedom, should be &gt; 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Drawn samples.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.triangular" module_name="triangular" namespace="'random'">
    <docstring>triangular(left, mode, right, size=None)

Draw samples from the triangular distribution.

The triangular distribution is a continuous probability
distribution with lower limit left, peak at mode, and upper
limit right. Unlike the other distributions, these parameters
directly define the shape of the pdf.

Parameters
----------
left : scalar
    Lower limit.
mode : scalar
    The value where the peak of the distribution occurs.
    The value should fulfill the condition ``left &lt;= mode &lt;= right``.
right : scalar
    Upper limit, should be larger than `left`.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The returned samples all lie in the interval [left, right].

Notes
-----
The probability density function for the triangular distribution is

.. math:: P(x;l, m, r) = \begin{cases}
          \frac{2(x-l)}{(r-l)(m-l)}&amp; \text{for $l \leq x \leq m$},\\
          \frac{2(m-x)}{(r-l)(r-m)}&amp; \text{for $m \leq x \leq r$},\\
          0&amp; \text{otherwise}.
          \end{cases}

The triangular distribution is often used in ill-defined
problems where the underlying distribution is not known, but
some knowledge of the limits and mode exists. Often it is used
in simulations.

References
----------
.. [1] Wikipedia, "Triangular distribution"
       http://en.wikipedia.org/wiki/Triangular_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
...              normed=True)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="left" name="left" port_type="basic:Float" show_port="True">
      <docstring>Lower limit.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode" port_type="basic:Float" show_port="True">
      <docstring>The value where the peak of the distribution occurs.
The value should fulfill the condition ``left &lt;= mode &lt;= right``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="right" name="right" port_type="basic:Float" show_port="True">
      <docstring>Upper limit, should be larger than `left`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The returned samples all lie in the interval [left, right].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.uniform" module_name="uniform" namespace="'random'">
    <docstring>uniform(low=0.0, high=1.0, size=None)

Draw samples from a uniform distribution.

Samples are uniformly distributed over the half-open interval
``[low, high)`` (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by `uniform`.

Parameters
----------
low : float, optional
    Lower boundary of the output interval.  All values generated will be
    greater than or equal to low.  The default value is 0.
high : float
    Upper boundary of the output interval.  All values generated will be
    less than high.  The default value is 1.0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    Drawn samples, with shape `size`.

See Also
--------
randint : Discrete uniform distribution, yielding integers.
random_integers : Discrete uniform distribution over the closed
                  interval ``[low, high]``.
random_sample : Floats uniformly distributed over ``[0, 1)``.
random : Alias for `random_sample`.
rand : Convenience function that accepts dimensions as input, e.g.,
       ``rand(2,2)`` would generate a 2-by-2 array of floats,
       uniformly distributed over ``[0, 1)``.

Notes
-----
The probability density function of the uniform distribution is

.. math:: p(x) = \frac{1}{b - a}

anywhere within the interval ``[a, b)``, and zero elsewhere.

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; s = np.random.uniform(-1,0,1000)

All values are within the given interval:

&gt;&gt;&gt; np.all(s &gt;= -1)
True
&gt;&gt;&gt; np.all(s &lt; 0)
True

Display the histogram of the samples, along with the
probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 15, normed=True)
&gt;&gt;&gt; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="low" name="low" port_type="basic:Float">
      <docstring>Lower boundary of the output interval.  All values generated will be
greater than or equal to low.  The default value is 0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Float">
      <docstring>Upper boundary of the output interval.  All values generated will be
less than high.  The default value is 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Drawn samples, with shape `size`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.vonmises" module_name="vonmises" namespace="'random'">
    <docstring>vonmises(mu, kappa, size=None)

Draw samples from a von Mises distribution.

Samples are drawn from a von Mises distribution with specified mode
(mu) and dispersion (kappa), on the interval [-pi, pi].

The von Mises distribution (also known as the circular normal
distribution) is a continuous probability distribution on the unit
circle.  It may be thought of as the circular analogue of the normal
distribution.

Parameters
----------
mu : float
    Mode ("center") of the distribution.
kappa : float
    Dispersion of the distribution, has to be &gt;=0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : scalar or ndarray
    The returned samples, which are in the interval [-pi, pi].

See Also
--------
scipy.stats.distributions.vonmises : probability density function,
    distribution, or cumulative density function, etc.

Notes
-----
The probability density for the von Mises distribution is

.. math:: p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},

where :math:`\mu` is the mode and :math:`\kappa` the dispersion,
and :math:`I_0(\kappa)` is the modified Bessel function of order 0.

The von Mises is named for Richard Edler von Mises, who was born in
Austria-Hungary, in what is now the Ukraine.  He fled to the United
States in 1939 and became a professor at Harvard.  He worked in
probability theory, aerodynamics, fluid mechanics, and philosophy of
science.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). "Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing," New York: Dover, 1972.
.. [2] von Mises, R., "Mathematical Theory of Probability
       and Statistics", New York: Academic Press, 1964.

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; mu, kappa = 0.0, 4.0 # mean and dispersion
&gt;&gt;&gt; s = np.random.vonmises(mu, kappa, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy.special import i0
&gt;&gt;&gt; plt.hist(s, 50, normed=True)
&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, num=51)
&gt;&gt;&gt; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))
&gt;&gt;&gt; plt.plot(x, y, linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True">
      <docstring>Mode ("center") of the distribution.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kappa" name="kappa" port_type="basic:Float" show_port="True">
      <docstring>Dispersion of the distribution, has to be &gt;=0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The returned samples, which are in the interval [-pi, pi].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.wald" module_name="wald" namespace="'random'">
    <docstring>wald(mean, scale, size=None)

Draw samples from a Wald, or inverse Gaussian, distribution.

As the scale approaches infinity, the distribution becomes more like a
Gaussian. Some references claim that the Wald is an inverse Gaussian
with mean equal to 1, but this is by no means universal.

The inverse Gaussian distribution was first studied in relationship to
Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
because there is an inverse relationship between the time to cover a
unit distance and distance covered in unit time.

Parameters
----------
mean : scalar
    Distribution mean, should be &gt; 0.
scale : scalar
    Scale parameter, should be &gt;= 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    Drawn sample, all greater than zero.

Notes
-----
The probability density function for the Wald distribution is

.. math:: P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
                            \frac{-scale(x-mean)^2}{2\cdotp mean^2x}

As noted above the inverse Gaussian distribution first arise
from attempts to model Brownian motion. It is also a
competitor to the Weibull for use in reliability modeling and
modeling stock returns and interest rate processes.

References
----------
.. [1] Brighton Webs Ltd., Wald Distribution,
       http://www.brighton-webs.co.uk/distributions/wald.asp
.. [2] Chhikara, Raj S., and Folks, J. Leroy, "The Inverse Gaussian
       Distribution: Theory : Methodology, and Applications", CRC Press,
       1988.
.. [3] Wikipedia, "Wald distribution"
       http://en.wikipedia.org/wiki/Wald_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, normed=True)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="mean" name="mean" port_type="basic:Float" show_port="True">
      <docstring>Distribution mean, should be &gt; 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float" show_port="True">
      <docstring>Scale parameter, should be &gt;= 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Drawn sample, all greater than zero.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.weibull" module_name="weibull" namespace="'random'">
    <docstring>weibull(a, size=None)

Draw samples from a Weibull distribution.

Draw samples from a 1-parameter Weibull distribution with the given
shape parameter `a`.

.. math:: X = (-ln(U))^{1/a}

Here, U is drawn from the uniform distribution over (0,1].

The more common 2-parameter Weibull, including a scale parameter
:math:`\lambda` is just :math:`X = \lambda(-ln(U))^{1/a}`.

Parameters
----------
a : float
    Shape of the distribution.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray

See Also
--------
scipy.stats.distributions.weibull_max
scipy.stats.distributions.weibull_min
scipy.stats.distributions.genextreme
gumbel

Notes
-----
The Weibull (or Type III asymptotic extreme value distribution
for smallest values, SEV Type III, or Rosin-Rammler
distribution) is one of a class of Generalized Extreme Value
(GEV) distributions used in modeling extreme value problems.
This class includes the Gumbel and Frechet distributions.

The probability density for the Weibull distribution is

.. math:: p(x) = \frac{a}
                 {\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},

where :math:`a` is the shape and :math:`\lambda` the scale.

The function has its peak (the mode) at
:math:`\lambda(\frac{a-1}{a})^{1/a}`.

When ``a = 1``, the Weibull distribution reduces to the exponential
distribution.

References
----------
.. [1] Waloddi Weibull, Royal Technical University, Stockholm,
       1939 "A Statistical Theory Of The Strength Of Materials",
       Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,
       Generalstabens Litografiska Anstalts Forlag, Stockholm.
.. [2] Waloddi Weibull, "A Statistical Distribution Function of
       Wide Applicability", Journal Of Applied Mechanics ASME Paper
       1951.
.. [3] Wikipedia, "Weibull distribution",
       http://en.wikipedia.org/wiki/Weibull_distribution

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; a = 5. # shape
&gt;&gt;&gt; s = np.random.weibull(a, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.arange(1,100.)/50.
&gt;&gt;&gt; def weib(x,n,a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)

&gt;&gt;&gt; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
&gt;&gt;&gt; x = np.arange(1,100.)/50.
&gt;&gt;&gt; scale = count.max()/weib(x, 1., 5.).max()
&gt;&gt;&gt; plt.plot(x, weib(x, 1., 5.)*scale)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Shape of the distribution.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:List" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.zipf" module_name="zipf" namespace="'random'">
    <docstring>zipf(a, size=None)

Draw samples from a Zipf distribution.

Samples are drawn from a Zipf distribution with specified parameter
`a` &gt; 1.

The Zipf distribution (also known as the zeta distribution) is a
continuous probability distribution that satisfies Zipf's law: the
frequency of an item is inversely proportional to its rank in a
frequency table.

Parameters
----------
a : float &gt; 1
    Distribution parameter.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : scalar or ndarray
    The returned samples are greater than or equal to one.

See Also
--------
scipy.stats.distributions.zipf : probability density function,
    distribution, or cumulative density function, etc.

Notes
-----
The probability density for the Zipf distribution is

.. math:: p(x) = \frac{x^{-a}}{\zeta(a)},

where :math:`\zeta` is the Riemann Zeta function.

It is named for the American linguist George Kingsley Zipf, who noted
that the frequency of any word in a sample of a language is inversely
proportional to its rank in the frequency table.

References
----------
.. [1] Zipf, G. K., "Selected Studies of the Principle of Relative
       Frequency in Language," Cambridge, MA: Harvard Univ. Press,
       1932.

Examples
--------
Draw samples from the distribution:

&gt;&gt;&gt; a = 2. # parameter
&gt;&gt;&gt; s = np.random.zipf(a, 1000)

Display the histogram of the samples, along with
the probability density function:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import scipy.special as sps
Truncate s values at 50 so plot is interesting
&gt;&gt;&gt; count, bins, ignored = plt.hist(s[s&lt;50], 50, normed=True)
&gt;&gt;&gt; x = np.arange(1., 50.)
&gt;&gt;&gt; y = x**(-a)/sps.zetac(a)
&gt;&gt;&gt; plt.plot(x, y/max(y), linewidth=2, color='r')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Distribution parameter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="samples" name="samples" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The returned samples are greater than or equal to one.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.ranf" module_name="ranf" namespace="'random'">
    <docstring>random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the "continuous uniform" distribution over the
stated interval.  To sample :math:`Unif[a, b), b &gt; a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

Examples
--------
&gt;&gt;&gt; np.random.random_sample()
0.47108547995356098
&gt;&gt;&gt; type(np.random.random_sample())
&lt;type 'float'&gt;
&gt;&gt;&gt; np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])

Three-by-two array of random numbers from [-5, 0):

&gt;&gt;&gt; 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984],
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Array of random floats of shape `size` (unless ``size=None``, in which
case a single float is returned).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.random" module_name="random" namespace="'random'">
    <docstring>random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the "continuous uniform" distribution over the
stated interval.  To sample :math:`Unif[a, b), b &gt; a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

Examples
--------
&gt;&gt;&gt; np.random.random_sample()
0.47108547995356098
&gt;&gt;&gt; type(np.random.random_sample())
&lt;type 'float'&gt;
&gt;&gt;&gt; np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])

Three-by-two array of random numbers from [-5, 0):

&gt;&gt;&gt; 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984],
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Array of random floats of shape `size` (unless ``size=None``, in which
case a single float is returned).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.random.sample" module_name="sample" namespace="'random'">
    <docstring>random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the "continuous uniform" distribution over the
stated interval.  To sample :math:`Unif[a, b), b &gt; a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

Examples
--------
&gt;&gt;&gt; np.random.random_sample()
0.47108547995356098
&gt;&gt;&gt; type(np.random.random_sample())
&lt;type 'float'&gt;
&gt;&gt;&gt; np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])

Three-by-two array of random numbers from [-5, 0):

&gt;&gt;&gt; 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984],
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])</docstring>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
``m * n * k`` samples are drawn.  Default is None, in which case a
single value is returned.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Array of random floats of shape `size` (unless ``size=None``, in which
case a single float is returned).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyline" module_name="polyline" namespace="'polynomial|polynomial'">
    <docstring>Returns an array representing a linear polynomial.

Parameters
----------
off, scl : scalars
    The "y-intercept" and "slope" of the line, respectively.

Returns
-------
y : ndarray
    This module's representation of the linear polynomial ``off +
    scl*x``.

See Also
--------
chebline

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; P.polyline(1,-1)
array([ 1, -1])
&gt;&gt;&gt; P.polyval(1, P.polyline(1,-1)) # should be 0
0.0</docstring>
    <inputPortSpec arg="off" name="off" port_type="basic:Float" show_port="True">
      <docstring>The "y-intercept" and "slope" of the line, respectively.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float" show_port="True">
      <docstring>The "y-intercept" and "slope" of the line, respectively.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This module's representation of the linear polynomial ``off +
scl*x``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyadd" module_name="polyadd" namespace="'polynomial|polynomial'">
    <docstring>Add one polynomial to another.

Returns the sum of two polynomials `c1` + `c2`.  The arguments are
sequences of coefficients from lowest order term to highest, i.e.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to high.

Returns
-------
out : ndarray
    The coefficient array representing their sum.

See Also
--------
polysub, polymul, polydiv, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; sum = P.polyadd(c1,c2); sum
array([ 4.,  4.,  4.])
&gt;&gt;&gt; P.polyval(2, sum) # 4 + 4(2) + 4(2**2)
28.0</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of polynomial coefficients ordered from low to high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of polynomial coefficients ordered from low to high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The coefficient array representing their sum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polysub" module_name="polysub" namespace="'polynomial|polynomial'">
    <docstring>Subtract one polynomial from another.

Returns the difference of two polynomials `c1` - `c2`.  The arguments
are sequences of coefficients from lowest order term to highest, i.e.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of coefficients representing their difference.

See Also
--------
polyadd, polymul, polydiv, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; P.polysub(c1,c2)
array([-2.,  0.,  2.])
&gt;&gt;&gt; P.polysub(c2,c1) # -P.polysub(c1,c2)
array([ 2.,  0., -2.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of polynomial coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of polynomial coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of coefficients representing their difference.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polymulx" module_name="polymulx" namespace="'polynomial|polynomial'">
    <docstring>Multiply a polynomial by x.

Multiply the polynomial `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of polynomial coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----

.. versionadded:: 1.5.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of polynomial coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the result of the multiplication.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polymul" module_name="polymul" namespace="'polynomial|polynomial'">
    <docstring>Multiply one polynomial by another.

Returns the product of two polynomials `c1` * `c2`.  The arguments are
sequences of coefficients, from lowest order term to highest, e.g.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``

Parameters
----------
c1, c2 : array_like
    1-D arrays of coefficients representing a polynomial, relative to the
    "standard" basis, and ordered from lowest order term to highest.

Returns
-------
out : ndarray
    Of the coefficients of their product.

See Also
--------
polyadd, polysub, polydiv, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; P.polymul(c1,c2)
array([  3.,   8.,  14.,   8.,   3.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of coefficients representing a polynomial, relative to the
"standard" basis, and ordered from lowest order term to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of coefficients representing a polynomial, relative to the
"standard" basis, and ordered from lowest order term to highest.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of the coefficients of their product.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polydiv" module_name="polydiv" namespace="'polynomial|polynomial'" output_type="list">
    <docstring>Divide one polynomial by another.

Returns the quotient-with-remainder of two polynomials `c1` / `c2`.
The arguments are sequences of coefficients, from lowest order term
to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to high.

Returns
-------
[quo, rem] : ndarrays
    Of coefficient series representing the quotient and remainder.

See Also
--------
polyadd, polysub, polymul, polypow

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; P.polydiv(c1,c2)
(array([ 3.]), array([-8., -4.]))
&gt;&gt;&gt; P.polydiv(c2,c1)
(array([ 0.33333333]), array([ 2.66666667,  1.33333333]))</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of polynomial coefficients ordered from low to high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of polynomial coefficients ordered from low to high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="[quo" name="[quo" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of coefficient series representing the quotient and remainder.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rem]" name="rem]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Of coefficient series representing the quotient and remainder.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polypow" module_name="polypow" namespace="'polynomial|polynomial'">
    <docstring>Raise a polynomial to a power.

Returns the polynomial `c` raised to the power `pow`. The argument
`c` is a sequence of coefficients ordered from low to high. i.e.,
[1,2,3] is the series  ``1 + 2*x + 3*x**2.``

Parameters
----------
c : array_like
    1-D array of array of series coefficients ordered from low to
    high degree.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Power series of power.

See Also
--------
polyadd, polysub, polymul, polydiv

Examples
--------</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of array of series coefficients ordered from low to
high degree.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pow" name="pow" port_type="basic:Integer" show_port="True">
      <docstring>Power to which the series will be raised</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxpower" name="maxpower" port_type="basic:Integer">
      <docstring>Maximum power allowed. This is mainly to limit growth of the series
to unmanageable size. Default is 16</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Power series of power.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyval" module_name="polyval" namespace="'polynomial|polynomial'">
    <docstring>Evaluate a polynomial at points x.

If `c` is of length `n + 1`, this function returns the value

.. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, compatible object
    The shape of the returned array is described above.

See Also
--------
polyval2d, polygrid2d, polyval3d, polygrid3d

Notes
-----
The evaluation uses Horner's method.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.polynomial import polyval
&gt;&gt;&gt; polyval(1, [1,2,3])
6.0
&gt;&gt;&gt; a = np.arange(4).reshape(2,2)
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; polyval(a, [1,2,3])
array([[  1.,   6.],
       [ 17.,  34.]])
&gt;&gt;&gt; coef = np.arange(4).reshape(2,2) # multidimensional coefficients
&gt;&gt;&gt; coef
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; polyval([1,2], coef, tensor=True)
array([[ 2.,  4.],
       [ 4.,  7.]])
&gt;&gt;&gt; polyval([1,2], coef, tensor=False)
array([ 2.,  7.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>If `x` is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, `x`
or its elements must support addition and multiplication with
with themselves and with the elements of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If `c` is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tensor" name="tensor" port_type="basic:Boolean">
      <docstring>If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of `x`. Scalars have dimension 0
for this action. The result is that every column of coefficients in
`c` is evaluated for every element of `x`. If False, `x` is broadcast
over the columns of `c` for the evaluation.  This keyword is useful
when `c` is multidimensional. The default value is True.

.. versionadded:: 1.7.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned array is described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyder" module_name="polyder" namespace="'polynomial|polynomial'">
    <docstring>Differentiate a polynomial.

Returns the polynomial coefficients `c` differentiated `m` times along
`axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable).  The
argument `c` is an array of coefficients from low to high degree along
each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``
while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is
``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of polynomial coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree
    in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change
    of variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Polynomial coefficients of the derivative.

See Also
--------
polyint

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3
&gt;&gt;&gt; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2
array([  2.,   6.,  12.])
&gt;&gt;&gt; P.polyder(c,3) # (d**3/dx**3)(c) = 24
array([ 24.])
&gt;&gt;&gt; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2
array([ -2.,  -6., -12.])
&gt;&gt;&gt; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x
array([  6.,  24.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of polynomial coefficients. If c is multidimensional the
different axis correspond to different variables with the degree
in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of derivatives taken, must be non-negative. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Each differentiation is multiplied by `scl`.  The end result is
multiplication by ``scl**m``.  This is for use in a linear change
of variable. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the derivative is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="der" name="der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Polynomial coefficients of the derivative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyint" module_name="polyint" namespace="'polynomial|polynomial'">
    <docstring>Integrate a polynomial.

Returns the polynomial coefficients `c` integrated `m` times from
`lbnd` along `axis`.  At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.) The argument `c` is an array of
coefficients, from low to high degree along each axis, e.g., [1,2,3]
represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]
represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    1-D array of polynomial coefficients, ordered from low to high.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Coefficient array of the integral.

Raises
------
ValueError
    If ``m &lt; 1``, ``len(k) &gt; m``.

See Also
--------
polyder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.  Why
is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`. Then
.. math::`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; c = (1,2,3)
&gt;&gt;&gt; P.polyint(c) # should return array([0, 1, 1, 1])
array([ 0.,  1.,  1.,  1.])
&gt;&gt;&gt; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])
array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333,
        0.05      ])
&gt;&gt;&gt; P.polyint(c,k=3) # should return array([3, 1, 1, 1])
array([ 3.,  1.,  1.,  1.])
&gt;&gt;&gt; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])
array([ 6.,  1.,  1.,  1.])
&gt;&gt;&gt; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])
array([ 0., -2., -2., -2.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of polynomial coefficients, ordered from low to high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Order of integration, must be positive. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Float">
      <docstring>Integration constant(s).  The value of the first integral at zero
is the first value in the list, the value of the second integral
at zero is the second value, etc.  If ``k == []`` (the default),
all constants are set to zero.  If ``m == 1``, a single scalar can
be given instead of a list.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List">
        <entry_types>['enum']</entry_types>
        <values>[[[]]]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="lbnd" name="lbnd" port_type="basic:Float">
      <docstring>The lower bound of the integral. (Default: 0)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Following each integration the result is *multiplied* by `scl`
before the integration constant is added. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the integral is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Coefficient array of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyfromroots" module_name="polyfromroots" namespace="'polynomial|polynomial'">
    <docstring>Generate a monic polynomial with given roots.

Return the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

where the `r_n` are the roots specified in `roots`.  If a zero has
multiplicity n, then it must appear in `roots` n times. For instance,
if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,
then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear
in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * x + ... +  x^n

The coefficient of the last term is 1 for monic polynomials in this
form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of the polynomial's coefficients If all the roots are
    real, then `out` is also real, otherwise it is complex.  (see
    Examples below).

See Also
--------
chebfromroots, legfromroots, lagfromroots, hermfromroots
hermefromroots

Notes
-----
The coefficients are determined by multiplying together linear factors
of the form `(x - r_i)`, i.e.

.. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)

where ``n == len(roots) - 1``; note that this implies that `1` is always
returned for :math:`a_n`.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x
array([ 0., -1.,  0.,  1.])
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; P.polyfromroots((-j,j)) # complex returned, though values are real
array([ 1.+0.j,  0.+0.j,  1.+0.j])</docstring>
    <inputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True">
      <docstring>Sequence containing the roots.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of the polynomial's coefficients If all the roots are
real, then `out` is also real, otherwise it is complex.  (see
Examples below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyvander" module_name="polyvander" namespace="'polynomial|polynomial'">
    <docstring>Vandermonde matrix of given degree.

Returns the Vandermonde matrix of degree `deg` and sample points
`x`. The Vandermonde matrix is defined by

.. math:: V[..., i] = x^i,

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the power of `x`.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and
``polyval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of polynomials of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray.
    The Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where the last index is the power of `x`.
    The dtype will be the same as the converted `x`.

See Also
--------
polyvander2d, polyvander3d</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of points. The dtype is converted to float64 or complex128
depending on whether any of the elements are complex. If `x` is
scalar it is converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the resulting matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander" name="vander" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Vandermonde matrix. The shape of the returned matrix is
``x.shape + (deg + 1,)``, where the last index is the power of `x`.
The dtype will be the same as the converted `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyfit" module_name="polyfit" namespace="'polynomial|polynomial'" output_type="list">
    <docstring>Least-squares fit of a polynomial to data.

Return the coefficients of a polynomial of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,

where `n` is `deg`.

Parameters
----------
x : array_like, shape (`M`,)
    x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.
y : array_like, shape (`M`,) or (`M`, `K`)
    y-coordinates of the sample points.  Several sets of sample points
    sharing the same x-coordinates can be (independently) fit with one
    call to `polyfit` by passing in for `y` a 2-D array that contains
    one data set per column.
deg : int
    Degree of the polynomial(s) to be fit.
rcond : float, optional
    Relative condition number of the fit.  Singular values smaller
    than `rcond`, relative to the largest singular value, will be
    ignored.  The default value is ``len(x)*eps``, where `eps` is the
    relative precision of the platform's float type, about 2e-16 in
    most cases.
full : bool, optional
    Switch determining the nature of the return value.  When ``False``
    (the default) just the coefficients are returned; when ``True``,
    diagnostic information from the singular value decomposition (used
    to solve the fit's matrix equation) is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)
    Polynomial coefficients ordered from low to high.  If `y` was 2-D,
    the coefficients in column `k` of `coef` represent the polynomial
    fit to the data in `y`'s `k`-th column.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Raises
------
RankWarning
    Raised if the matrix in the least-squares fit is rank deficient.
    The warning is only raised if `full` == False.  The warnings can
    be turned off by:

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebfit, legfit, lagfit, hermfit, hermefit
polyval : Evaluates a polynomial.
polyvander : Vandermonde matrix for powers.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the polynomial `p` that minimizes
the sum of the weighted squared errors

.. math :: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) over-determined matrix equation:

.. math :: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected (and `full` == ``False``), a `RankWarning` will be raised.
This means that the coefficient values may be poorly determined.
Fitting to a lower order polynomial will usually get rid of the warning
(but may not be what you want, of course; if you have independent
reason(s) for choosing the degree which isn't working, you may have to:
a) reconsider those reasons, and/or b) reconsider the quality of your
data).  The `rcond` parameter can also be set to a value smaller than
its default, but the resulting fit may be spurious and have large
contributions from roundoff error.

Polynomial fits using double precision tend to "fail" at about
(polynomial) degree 20. Fits using Chebyshev or Legendre series are
generally better conditioned, but much can still depend on the
distribution of the sample points and the smoothness of the data.  If
the quality of the fit is inadequate, splines may be a good
alternative.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import polynomial as P
&gt;&gt;&gt; x = np.linspace(-1,1,51) # x "data": [-1, -0.96, ..., 0.96, 1]
&gt;&gt;&gt; y = x**3 - x + np.random.randn(len(x)) # x^3 - x + N(0,1) "noise"
&gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)
&gt;&gt;&gt; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1
array([ 0.01909725, -1.30598256, -0.00577963,  1.02644286])
&gt;&gt;&gt; stats # note the large SSR, explaining the rather poor results
[array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316,
0.28853036]), 1.1324274851176597e-014]

Same thing without the added noise

&gt;&gt;&gt; y = x**3 - x
&gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)
&gt;&gt;&gt; c # c[0], c[2] should be "very close to 0", c[1] ~= -1, c[3] ~= 1
array([ -1.73362882e-17,  -1.00000000e+00,  -2.67471909e-16,
         1.00000000e+00])
&gt;&gt;&gt; stats # note the minuscule SSR
[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158,
0.50443316,  0.28853036]), 1.1324274851176597e-014]</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>y-coordinates of the sample points.  Several sets of sample points
sharing the same x-coordinates can be (independently) fit with one
call to `polyfit` by passing in for `y` a 2-D array that contains
one data set per column.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the polynomial(s) to be fit.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit.  Singular values smaller
than `rcond`, relative to the largest singular value, will be
ignored.  The default value is ``len(x)*eps``, where `eps` is the
relative precision of the platform's float type, about 2e-16 in
most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining the nature of the return value.  When ``False``
(the default) just the coefficients are returned; when ``True``,
diagnostic information from the singular value decomposition (used
to solve the fit's matrix equation) is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Weights. If not None, the contribution of each point
``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
weights are chosen so that the errors of the products ``w[i]*y[i]``
all have the same variance.  The default value is None.

.. versionadded:: 1.5.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Polynomial coefficients ordered from low to high.  If `y` was 2-D,
the coefficients in column `k` of `coef` represent the polynomial
fit to the data in `y`'s `k`-th column.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[residuals" name="[residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="singular_values" name="singular_values" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rcond]" name="rcond]" port_type="basic:List" show_port="True" sort_key="4">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polytrim" module_name="polytrim" namespace="'polynomial|polynomial'">
    <docstring>Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` &lt; 0

See Also
--------
trimseq

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
&gt;&gt;&gt; P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
&gt;&gt;&gt; i = complex(0,1) # works for complex
&gt;&gt;&gt; P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-d array of coefficients, ordered from lowest order to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Integer">
      <docstring>Trailing (i.e., highest order) elements with absolute value less
than or equal to `tol` (default value is zero) are removed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-d array with trailing zeros removed.  If the resulting series
would be empty, a series containing a single zero is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyroots" module_name="polyroots" namespace="'polynomial|polynomial'">
    <docstring>Compute the roots of a polynomial.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \sum_i c[i] * x^i.

Parameters
----------
c : 1-D array_like
    1-D array of polynomial coefficients.

Returns
-------
out : ndarray
    Array of the roots of the polynomial. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
chebroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the power series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.polynomial as poly
&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1)))
array([-1.,  0.,  1.])
&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype
dtype('float64')
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-j,0,j)))
array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of polynomial coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the roots of the polynomial. If all the roots are real,
then `out` is also real, otherwise it is complex.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyval2d" module_name="polyval2d" namespace="'polynomial|polynomial'">
    <docstring>Evaluate a 2-D polynomial at points (x, y).

This function returns the value

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * x^i * y^j

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in `c[i,j]`. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
polyval, polygrid2d, polyval3d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term
of multi-degree i,j is contained in `c[i,j]`. If `c` has
dimension greater than two the remaining indices enumerate multiple
sets of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points formed with
pairs of corresponding values from `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyval3d" module_name="polyval3d" namespace="'polynomial|polynomial'">
    <docstring>Evaluate a 3-D polynomial at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
polyval, polyval2d, polygrid2d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
greater than 3 the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the multidimensional polynomial on points formed with
triples of corresponding values from `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polygrid2d" module_name="polygrid2d" namespace="'polynomial|polynomial'">
    <docstring>Evaluate a 2-D polynomial on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * a^i * b^j

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
polyval, polyval2d, polyval3d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polygrid3d" module_name="polygrid3d" namespace="'polynomial|polynomial'">
    <docstring>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
polyval, polyval2d, polygrid2d, polyval3d

Notes
-----

.. versionadded:: 1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyvander2d" module_name="polyvander2d" namespace="'polynomial|polynomial'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., deg[1]*i + j] = x^i * y^j,

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the powers of
`x` and `y`.

If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D polynomials
of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
polyvander, polyvander3d. polyval2d, polyval3d</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander2d" name="vander2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
as the converted `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.polyvander3d" module_name="polyvander3d" namespace="'polynomial|polynomial'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the powers of `x`, `y`, and `z`.

If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D polynomials
of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
polyvander, polyvander3d. polyval2d, polyval3d

Notes
-----

.. versionadded:: 1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg, z_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander3d" name="vander3d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
be the same as the converted `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebline" module_name="chebline" namespace="'polynomial|chebyshev'">
    <docstring>Chebyshev series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Chebyshev series for
    ``off + scl*x``.

See Also
--------
polyline

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.chebyshev as C
&gt;&gt;&gt; C.chebline(3,2)
array([3, 2])
&gt;&gt;&gt; C.chebval(-3, C.chebline(3,2)) # should be -3
-3.0</docstring>
    <inputPortSpec arg="off" name="off" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This module's representation of the Chebyshev series for
``off + scl*x``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebadd" module_name="chebadd" namespace="'polynomial|chebyshev'">
    <docstring>Add one Chebyshev series to another.

Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Chebyshev series of their sum.

See Also
--------
chebsub, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Chebyshev series
is a Chebyshev series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebadd(c1,c2)
array([ 4.,  4.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the Chebyshev series of their sum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebsub" module_name="chebsub" namespace="'polynomial|chebyshev'">
    <docstring>Subtract one Chebyshev series from another.

Returns the difference of two Chebyshev series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their difference.

See Also
--------
chebadd, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Chebyshev
series is a Chebyshev series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebsub(c1,c2)
array([-2.,  0.,  2.])
&gt;&gt;&gt; C.chebsub(c2,c1) # -C.chebsub(c1,c2)
array([ 2.,  0., -2.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Chebyshev series coefficients representing their difference.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebmulx" module_name="chebmulx" namespace="'polynomial|chebyshev'">
    <docstring>Multiply a Chebyshev series by x.

Multiply the polynomial `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----

.. versionadded:: 1.5.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the result of the multiplication.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebmul" module_name="chebmul" namespace="'polynomial|chebyshev'">
    <docstring>Multiply one Chebyshev series by another.

Returns the product of two Chebyshev series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their product.

See Also
--------
chebadd, chebsub, chebdiv, chebpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Chebyshev polynomial basis set.  Thus, to express
the product as a C-series, it is typically necessary to "reproject"
the product onto said basis set, which typically produces
"unintuitive live" (but correct) results; see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebmul(c1,c2) # multiplication requires "reprojection"
array([  6.5,  12. ,  12. ,   4. ,   1.5])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Chebyshev series coefficients representing their product.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebdiv" module_name="chebdiv" namespace="'polynomial|chebyshev'" output_type="list">
    <docstring>Divide one Chebyshev series by another.

Returns the quotient-with-remainder of two Chebyshev series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Chebyshev series coefficients representing the quotient and
    remainder.

See Also
--------
chebadd, chebsub, chebmul, chebpow

Notes
-----
In general, the (polynomial) division of one C-series by another
results in quotient and remainder terms that are not in the Chebyshev
polynomial basis set.  Thus, to express these results as C-series, it
is typically necessary to "reproject" the results onto said basis
set, which typically produces "unintuitive" (but correct) results;
see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; C.chebdiv(c1,c2) # quotient "intuitive," remainder not
(array([ 3.]), array([-8., -4.]))
&gt;&gt;&gt; c2 = (0,1,2,3)
&gt;&gt;&gt; C.chebdiv(c2,c1) # neither "intuitive"
(array([ 0.,  2.]), array([-2., -4.]))</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="[quo" name="[quo" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Chebyshev series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rem]" name="rem]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Of Chebyshev series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebpow" module_name="chebpow" namespace="'polynomial|chebyshev'">
    <docstring>Raise a Chebyshev series to a power.

Returns the Chebyshev series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``

Parameters
----------
c : array_like
    1-D array of Chebyshev series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Chebyshev series of power.

See Also
--------
chebadd, chebsub, chebmul, chebdiv

Examples
--------</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Chebyshev series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pow" name="pow" port_type="basic:Integer" show_port="True">
      <docstring>Power to which the series will be raised</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxpower" name="maxpower" port_type="basic:Integer">
      <docstring>Maximum power allowed. This is mainly to limit growth of the series
to unmanageable size. Default is 16</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Chebyshev series of power.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebval" module_name="chebval" namespace="'polynomial|chebyshev'">
    <docstring>Evaluate a Chebyshev series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
chebval2d, chebgrid2d, chebval3d, chebgrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>If `x` is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, `x`
or its elements must support addition and multiplication with
with themselves and with the elements of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If `c` is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tensor" name="tensor" port_type="basic:Boolean">
      <docstring>If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of `x`. Scalars have dimension 0
for this action. The result is that every column of coefficients in
`c` is evaluated for every element of `x`. If False, `x` is broadcast
over the columns of `c` for the evaluation.  This keyword is useful
when `c` is multidimensional. The default value is True.

.. versionadded:: 1.7.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the return value is described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebder" module_name="chebder" namespace="'polynomial|chebyshev'">
    <docstring>Differentiate a Chebyshev series.

Returns the Chebyshev series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*T_0 + 2*T_1 + 3*T_2``
while [[1,2],[1,2]] represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) +
2*T_0(x)*T_1(y) + 2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Chebyshev series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Chebyshev series of the derivative.

See Also
--------
chebint

Notes
-----
In general, the result of differentiating a C-series needs to be
"reprojected" onto the C-series basis set. Thus, typically, the
result of this function is "unintuitive," albeit correct; see Examples
section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c = (1,2,3,4)
&gt;&gt;&gt; C.chebder(c)
array([ 14.,  12.,  24.])
&gt;&gt;&gt; C.chebder(c,3)
array([ 96.])
&gt;&gt;&gt; C.chebder(c,scl=-1)
array([-14., -12., -24.])
&gt;&gt;&gt; C.chebder(c,2,-1)
array([ 12.,  96.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Chebyshev series coefficients. If c is multidimensional
the different axis correspond to different variables with the
degree in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of derivatives taken, must be non-negative. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Each differentiation is multiplied by `scl`.  The end result is
multiplication by ``scl**m``.  This is for use in a linear change of
variable. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the derivative is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="der" name="der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Chebyshev series of the derivative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebint" module_name="chebint" namespace="'polynomial|chebyshev'">
    <docstring>Integrate a Chebyshev series.

Returns the Chebyshev series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``T_0 + 2*T_1 + 3*T_2`` while [[1,2],[1,2]]
represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) + 2*T_0(x)*T_1(y) +
2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Chebyshev series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    C-series coefficients of the integral.

Raises
------
ValueError
    If ``m &lt; 1``, ``len(k) &gt; m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
chebder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
.. math::`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a`- perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "reprojected" onto the C-series basis set.  Thus, typically,
the result of this function is "unintuitive," albeit correct; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import chebyshev as C
&gt;&gt;&gt; c = (1,2,3)
&gt;&gt;&gt; C.chebint(c)
array([ 0.5, -0.5,  0.5,  0.5])
&gt;&gt;&gt; C.chebint(c,3)
array([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667,
        0.00625   ])
&gt;&gt;&gt; C.chebint(c, k=3)
array([ 3.5, -0.5,  0.5,  0.5])
&gt;&gt;&gt; C.chebint(c,lbnd=-2)
array([ 8.5, -0.5,  0.5,  0.5])
&gt;&gt;&gt; C.chebint(c,scl=-2)
array([-1.,  1., -1., -1.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Chebyshev series coefficients. If c is multidimensional
the different axis correspond to different variables with the
degree in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Order of integration, must be positive. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Float">
      <docstring>Integration constant(s).  The value of the first integral at zero
is the first value in the list, the value of the second integral
at zero is the second value, etc.  If ``k == []`` (the default),
all constants are set to zero.  If ``m == 1``, a single scalar can
be given instead of a list.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List">
        <entry_types>['enum']</entry_types>
        <values>[[[]]]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="lbnd" name="lbnd" port_type="basic:Float">
      <docstring>The lower bound of the integral. (Default: 0)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Following each integration the result is *multiplied* by `scl`
before the integration constant is added. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the integral is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>C-series coefficients of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.cheb2poly" module_name="cheb2poly" namespace="'polynomial|chebyshev'">
    <docstring>Convert a Chebyshev series to a polynomial.

Convert an array representing the coefficients of a Chebyshev series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Chebyshev series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2cheb

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; c = P.Chebyshev(range(4))
&gt;&gt;&gt; c
Chebyshev([ 0.,  1.,  2.,  3.], [-1.,  1.])
&gt;&gt;&gt; p = c.convert(kind=P.Polynomial)
&gt;&gt;&gt; p
Polynomial([ -2.,  -8.,   4.,  12.], [-1.,  1.])
&gt;&gt;&gt; P.cheb2poly(range(4))
array([ -2.,  -8.,   4.,  12.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the Chebyshev series coefficients, ordered
from lowest order term to highest.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent polynomial
(relative to the "standard" basis) ordered from lowest order term
to highest.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.poly2cheb" module_name="poly2cheb" namespace="'polynomial|chebyshev'">
    <docstring>Convert a polynomial to a Chebyshev series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Chebyshev series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Chebyshev
    series.

See Also
--------
cheb2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; p = P.Polynomial(range(4))
&gt;&gt;&gt; p
Polynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])
&gt;&gt;&gt; c = p.convert(kind=P.Chebyshev)
&gt;&gt;&gt; c
Chebyshev([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])
&gt;&gt;&gt; P.poly2cheb(range(4))
array([ 1.  ,  3.25,  1.  ,  0.75])</docstring>
    <inputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the polynomial coefficients</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent Chebyshev
series.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebfromroots" module_name="chebfromroots" namespace="'polynomial|chebyshev'">
    <docstring>Generate a Chebyshev series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Chebyshev form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * T_1(x) + ... +  c_n * T_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Chebyshev form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, hermfromroots,
hermefromroots.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.chebyshev as C
&gt;&gt;&gt; C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis
array([ 0.  , -0.25,  0.  ,  0.25])
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis
array([ 1.5+0.j,  0.0+0.j,  0.5+0.j])</docstring>
    <inputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True">
      <docstring>Sequence containing the roots.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of coefficients.  If all roots are real then `out` is a
real array, if some of the roots are complex, then `out` is complex
even if all the coefficients in the result are real (see Examples
below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebvander" module_name="chebvander" namespace="'polynomial|chebyshev'">
    <docstring>Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = T_i(x),

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Chebyshev polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
matrix ``V = chebvander(x, n)``, then ``np.dot(V, c)`` and
``chebval(x, c)`` are the same up to roundoff.  This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Chebyshev series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Chebyshev polynomial.  The dtype will be the same as
    the converted `x`.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of points. The dtype is converted to float64 or complex128
depending on whether any of the elements are complex. If `x` is
scalar it is converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the resulting matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander" name="vander" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo Vandermonde matrix. The shape of the returned matrix is
``x.shape + (deg + 1,)``, where The last index is the degree of the
corresponding Chebyshev polynomial.  The dtype will be the same as
the converted `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebfit" module_name="chebfit" namespace="'polynomial|chebyshev'" output_type="list">
    <docstring>Least squares fit of Chebyshev series to data.

Return the coefficients of a Legendre series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting series
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Chebyshev coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
polyfit, legfit, lagfit, hermfit, hermefit
chebval : Evaluates a Chebyshev series.
chebvander : Vandermonde matrix of Chebyshev series.
chebweight : Chebyshev weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Chebyshev series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where :math:`w_j` are the weights. This problem is solved by setting up
as the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Chebyshev series are usually better conditioned than fits
using power series, but much can depend on the distribution of the
sample points and the smoothness of the data. If the quality of the fit
is inadequate splines may be a good alternative.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the M sample points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="yScalar" show_port="True">
      <docstring>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</docstring>
      <alternateSpec arg="y" name="ySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the fitting series</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Weights. If not None, the contribution of each point
``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
weights are chosen so that the errors of the products ``w[i]*y[i]``
all have the same variance.  The default value is None.

.. versionadded:: 1.5.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" show_port="True" sort_key="0">
      <docstring>Chebyshev coefficients ordered from low to high. If `y` was 2-D,
the coefficients for the data in column k  of `y` are in column
`k`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[residuals" name="[residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="singular_values" name="singular_values" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rcond]" name="rcond]" port_type="basic:List" show_port="True" sort_key="4">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebtrim" module_name="chebtrim" namespace="'polynomial|chebyshev'">
    <docstring>Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` &lt; 0

See Also
--------
trimseq

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
&gt;&gt;&gt; P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
&gt;&gt;&gt; i = complex(0,1) # works for complex
&gt;&gt;&gt; P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-d array of coefficients, ordered from lowest order to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Integer">
      <docstring>Trailing (i.e., highest order) elements with absolute value less
than or equal to `tol` (default value is zero) are removed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-d array with trailing zeros removed.  If the resulting series
would be empty, a series containing a single zero is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebroots" module_name="chebroots" namespace="'polynomial|chebyshev'">
    <docstring>Compute the roots of a Chebyshev series.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \sum_i c[i] * T_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, hermroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The Chebyshev series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.chebyshev as cheb
&gt;&gt;&gt; cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots
array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the roots of the series. If all the roots are real,
then `out` is also real, otherwise it is complex.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebpts1" module_name="chebpts1" namespace="'polynomial|chebyshev'">
    <docstring>Chebyshev points of the first kind.

The Chebyshev points of the first kind are the points ``cos(x)``,
where ``x = [pi*(k + .5)/npts for k in range(npts)]``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the first kind.

See Also
--------
chebpts2

Notes
-----

.. versionadded:: 1.5.0</docstring>
    <inputPortSpec arg="npts" name="npts" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points desired.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pts" name="pts" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Chebyshev points of the first kind.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebpts2" module_name="chebpts2" namespace="'polynomial|chebyshev'">
    <docstring>Chebyshev points of the second kind.

The Chebyshev points of the second kind are the points ``cos(x)``,
where ``x = [pi*k/(npts - 1) for k in range(npts)]``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the second kind.

Notes
-----

.. versionadded:: 1.5.0</docstring>
    <inputPortSpec arg="npts" name="npts" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points desired.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pts" name="pts" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Chebyshev points of the second kind.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebval2d" module_name="chebval2d" namespace="'polynomial|chebyshev'">
    <docstring>Evaluate a 2-D Chebyshev series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * T_i(x) * T_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than 2 the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points formed
    from pairs of corresponding values from `x` and `y`.

See Also
--------
chebval, chebgrid2d, chebval3d, chebgrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term
of multi-degree i,j is contained in ``c[i,j]``. If `c` has
dimension greater than 2 the remaining indices enumerate multiple
sets of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional Chebyshev series at points formed
from pairs of corresponding values from `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebval3d" module_name="chebval3d" namespace="'polynomial|chebyshev'">
    <docstring>Evaluate a 3-D Chebyshev series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * T_i(x) * T_j(y) * T_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
chebval, chebval2d, chebgrid2d, chebgrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
greater than 3 the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the multidimensional polynomial on points formed with
triples of corresponding values from `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebgrid2d" module_name="chebgrid2d" namespace="'polynomial|chebyshev'">
    <docstring>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * T_i(a) * T_j(b),

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points in the
    Cartesian product of `x` and `y`.

See Also
--------
chebval, chebval2d, chebval3d, chebgrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional Chebyshev series at points in the
Cartesian product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebgrid3d" module_name="chebgrid3d" namespace="'polynomial|chebyshev'">
    <docstring>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
chebval, chebval2d, chebgrid2d, chebval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebvander2d" module_name="chebvander2d" namespace="'polynomial|chebyshev'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., deg[1]*i + j] = T_i(x) * T_j(y),

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Chebyshev polynomials.

If ``V = chebvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``chebval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Chebyshev
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
chebvander, chebvander3d. chebval2d, chebval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander2d" name="vander2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
as the converted `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebvander3d" module_name="chebvander3d" namespace="'polynomial|chebyshev'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Chebyshev polynomials.

If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Chebyshev
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
chebvander, chebvander3d. chebval2d, chebval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg, z_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander3d" name="vander3d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
be the same as the converted `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebcompanion" module_name="chebcompanion" namespace="'polynomial|chebyshev'">
    <docstring>Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is a Chebyshev basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of Chebyshev series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Chebyshev series coefficients ordered from low to high
degree.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mat" name="mat" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Scaled companion matrix of dimensions (deg, deg).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebgauss" module_name="chebgauss" namespace="'polynomial|chebyshev'" output_type="list">
    <docstring>Gauss-Chebyshev quadrature.

Computes the sample points and weights for Gauss-Chebyshev quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
the weight function :math:`f(x) = 1/\sqrt{1 - x^2}`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be &gt;= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. For Gauss-Chebyshev there are closed form solutions for
the sample points and weights. If n = `deg`, then

.. math:: x_i = \cos(\pi (2 i - 1) / (2 n))

.. math:: w_i = \pi / n</docstring>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points and weights. It must be &gt;= 1.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D ndarray containing the sample points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>1-D ndarray containing the weights.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.chebweight" module_name="chebweight" namespace="'polynomial|chebyshev'">
    <docstring>The weight function of the Chebyshev polynomials.

The weight function is :math:`1/\sqrt{1 - x^2}` and the interval of
integration is :math:`[-1, 1]`. The Chebyshev polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Values at which the weight function will be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The weight function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legline" module_name="legline" namespace="'polynomial|legendre'">
    <docstring>Legendre series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Legendre series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.legendre as L
&gt;&gt;&gt; L.legline(3,2)
array([3, 2])
&gt;&gt;&gt; L.legval(-3, L.legline(3,2)) # should be -3
-3.0</docstring>
    <inputPortSpec arg="off" name="off" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This module's representation of the Legendre series for
``off + scl*x``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legadd" module_name="legadd" namespace="'polynomial|legendre'">
    <docstring>Add one Legendre series to another.

Returns the sum of two Legendre series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Legendre series of their sum.

See Also
--------
legsub, legmul, legdiv, legpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Legendre series
is a Legendre series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import legendre as L
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; L.legadd(c1,c2)
array([ 4.,  4.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the Legendre series of their sum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legsub" module_name="legsub" namespace="'polynomial|legendre'">
    <docstring>Subtract one Legendre series from another.

Returns the difference of two Legendre series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Legendre series coefficients representing their difference.

See Also
--------
legadd, legmul, legdiv, legpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Legendre
series is a Legendre series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import legendre as L
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; L.legsub(c1,c2)
array([-2.,  0.,  2.])
&gt;&gt;&gt; L.legsub(c2,c1) # -C.legsub(c1,c2)
array([ 2.,  0., -2.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Legendre series coefficients representing their difference.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legmulx" module_name="legmulx" namespace="'polynomial|legendre'">
    <docstring>Multiply a Legendre series by x.

Multiply the Legendre series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
The multiplication uses the recursion relationship for Legendre
polynomials in the form

.. math::

  xP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the result of the multiplication.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legmul" module_name="legmul" namespace="'polynomial|legendre'">
    <docstring>Multiply one Legendre series by another.

Returns the product of two Legendre series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Legendre series coefficients representing their product.

See Also
--------
legadd, legsub, legdiv, legpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Legendre polynomial basis set.  Thus, to express
the product as a Legendre series, it is necessary to "reproject" the
product onto said basis set, which may produce "unintuitive" (but
correct) results; see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import legendre as L
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2)
&gt;&gt;&gt; P.legmul(c1,c2) # multiplication requires "reprojection"
array([  4.33333333,  10.4       ,  11.66666667,   3.6       ])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Legendre series coefficients representing their product.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legdiv" module_name="legdiv" namespace="'polynomial|legendre'" output_type="list">
    <docstring>Divide one Legendre series by another.

Returns the quotient-with-remainder of two Legendre series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
quo, rem : ndarrays
    Of Legendre series coefficients representing the quotient and
    remainder.

See Also
--------
legadd, legsub, legmul, legpow

Notes
-----
In general, the (polynomial) division of one Legendre series by another
results in quotient and remainder terms that are not in the Legendre
polynomial basis set.  Thus, to express these results as a Legendre
series, it is necessary to "reproject" the results onto the Legendre
basis set, which may produce "unintuitive" (but correct) results; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import legendre as L
&gt;&gt;&gt; c1 = (1,2,3)
&gt;&gt;&gt; c2 = (3,2,1)
&gt;&gt;&gt; L.legdiv(c1,c2) # quotient "intuitive," remainder not
(array([ 3.]), array([-8., -4.]))
&gt;&gt;&gt; c2 = (0,1,2,3)
&gt;&gt;&gt; L.legdiv(c2,c1) # neither "intuitive"
(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852]))</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="quo" name="quo" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Legendre series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rem" name="rem" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Of Legendre series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legpow" module_name="legpow" namespace="'polynomial|legendre'">
    <docstring>Raise a Legendre series to a power.

Returns the Legendre series `c` raised to the power `pow`. The
arguement `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Legendre series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Legendre series of power.

See Also
--------
legadd, legsub, legmul, legdiv

Examples
--------</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Legendre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pow" name="pow" port_type="basic:Integer" show_port="True">
      <docstring>Power to which the series will be raised</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxpower" name="maxpower" port_type="basic:Integer">
      <docstring>Maximum power allowed. This is mainly to limit growth of the series
to unmanageable size. Default is 16</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Legendre series of power.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legval" module_name="legval" namespace="'polynomial|legendre'">
    <docstring>Evaluate a Legendre series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
legval2d, leggrid2d, legval3d, leggrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>If `x` is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, `x`
or its elements must support addition and multiplication with
with themselves and with the elements of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If `c` is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tensor" name="tensor" port_type="basic:Boolean">
      <docstring>If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of `x`. Scalars have dimension 0
for this action. The result is that every column of coefficients in
`c` is evaluated for every element of `x`. If False, `x` is broadcast
over the columns of `c` for the evaluation.  This keyword is useful
when `c` is multidimensional. The default value is True.

.. versionadded:: 1.7.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the return value is described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legder" module_name="legder" namespace="'polynomial|legendre'">
    <docstring>Differentiate a Legendre series.

Returns the Legendre series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``
while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Legendre series coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Legendre series of the derivative.

See Also
--------
legint

Notes
-----
In general, the result of differentiating a Legendre series does not
resemble the same operation on a power series. Thus the result of this
function may be "unintuitive," albeit correct; see Examples section
below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import legendre as L
&gt;&gt;&gt; c = (1,2,3,4)
&gt;&gt;&gt; L.legder(c)
array([  6.,   9.,  20.])
&gt;&gt;&gt; L.legder(c, 3)
array([ 60.])
&gt;&gt;&gt; L.legder(c, scl=-1)
array([ -6.,  -9., -20.])
&gt;&gt;&gt; L.legder(c, 2,-1)
array([  9.,  60.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Legendre series coefficients. If c is multidimensional the
different axis correspond to different variables with the degree in
each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of derivatives taken, must be non-negative. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Each differentiation is multiplied by `scl`.  The end result is
multiplication by ``scl**m``.  This is for use in a linear change of
variable. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the derivative is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="der" name="der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Legendre series of the derivative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legint" module_name="legint" namespace="'polynomial|legendre'">
    <docstring>Integrate a Legendre series.

Returns the Legendre series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]
represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Legendre series coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Legendre series coefficient array of the integral.

Raises
------
ValueError
    If ``m &lt; 0``, ``len(k) &gt; m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
legder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
.. math::`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "reprojected" onto the C-series basis set.  Thus, typically,
the result of this function is "unintuitive," albeit correct; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial import legendre as L
&gt;&gt;&gt; c = (1,2,3)
&gt;&gt;&gt; L.legint(c)
array([ 0.33333333,  0.4       ,  0.66666667,  0.6       ])
&gt;&gt;&gt; L.legint(c, 3)
array([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02,
        -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])
&gt;&gt;&gt; L.legint(c, k=3)
array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ])
&gt;&gt;&gt; L.legint(c, lbnd=-2)
array([ 7.33333333,  0.4       ,  0.66666667,  0.6       ])
&gt;&gt;&gt; L.legint(c, scl=2)
array([ 0.66666667,  0.8       ,  1.33333333,  1.2       ])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Legendre series coefficients. If c is multidimensional the
different axis correspond to different variables with the degree in
each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Order of integration, must be positive. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Float">
      <docstring>Integration constant(s).  The value of the first integral at
``lbnd`` is the first value in the list, the value of the second
integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
default), all constants are set to zero.  If ``m == 1``, a single
scalar can be given instead of a list.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List">
        <entry_types>['enum']</entry_types>
        <values>[[[]]]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="lbnd" name="lbnd" port_type="basic:Float">
      <docstring>The lower bound of the integral. (Default: 0)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Following each integration the result is *multiplied* by `scl`
before the integration constant is added. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the integral is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Legendre series coefficient array of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.leg2poly" module_name="leg2poly" namespace="'polynomial|legendre'">
    <docstring>Convert a Legendre series to a polynomial.

Convert an array representing the coefficients of a Legendre series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Legendre series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2leg

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; c = P.Legendre(range(4))
&gt;&gt;&gt; c
Legendre([ 0.,  1.,  2.,  3.], [-1.,  1.])
&gt;&gt;&gt; p = c.convert(kind=P.Polynomial)
&gt;&gt;&gt; p
Polynomial([-1. , -3.5,  3. ,  7.5], [-1.,  1.])
&gt;&gt;&gt; P.leg2poly(range(4))
array([-1. , -3.5,  3. ,  7.5])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the Legendre series coefficients, ordered
from lowest order term to highest.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent polynomial
(relative to the "standard" basis) ordered from lowest order term
to highest.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.poly2leg" module_name="poly2leg" namespace="'polynomial|legendre'">
    <docstring>Convert a polynomial to a Legendre series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Legendre series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Legendre
    series.

See Also
--------
leg2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; p = P.Polynomial(np.arange(4))
&gt;&gt;&gt; p
Polynomial([ 0.,  1.,  2.,  3.], [-1.,  1.])
&gt;&gt;&gt; c = P.Legendre(P.poly2leg(p.coef))
&gt;&gt;&gt; c
Legendre([ 1.  ,  3.25,  1.  ,  0.75], [-1.,  1.])</docstring>
    <inputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the polynomial coefficients</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent Legendre
series.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legfromroots" module_name="legfromroots" namespace="'polynomial|legendre'">
    <docstring>Generate a Legendre series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Legendre form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Legendre form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, chebfromroots, lagfromroots, hermfromroots,
hermefromroots.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.legendre as L
&gt;&gt;&gt; L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis
array([ 0. , -0.4,  0. ,  0.4])
&gt;&gt;&gt; j = complex(0,1)
&gt;&gt;&gt; L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis
array([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j])</docstring>
    <inputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True">
      <docstring>Sequence containing the roots.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of coefficients.  If all roots are real then `out` is a
real array, if some of the roots are complex, then `out` is complex
even if all the coefficients in the result are real (see Examples
below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legvander" module_name="legvander" namespace="'polynomial|legendre'">
    <docstring>Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = L_i(x)

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Legendre polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = legvander(x, n)``, then ``np.dot(V, c)`` and
``legval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Legendre series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Legendre polynomial.  The dtype will be the same as
    the converted `x`.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of points. The dtype is converted to float64 or complex128
depending on whether any of the elements are complex. If `x` is
scalar it is converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the resulting matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander" name="vander" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-Vandermonde matrix. The shape of the returned matrix is
``x.shape + (deg + 1,)``, where The last index is the degree of the
corresponding Legendre polynomial.  The dtype will be the same as
the converted `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legfit" module_name="legfit" namespace="'polynomial|legendre'" output_type="list">
    <docstring>Least squares fit of Legendre series to data.

Return the coefficients of a Legendre series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Legendre coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebfit, polyfit, lagfit, hermfit, hermefit
legval : Evaluates a Legendre series.
legvander : Vandermonde matrix of Legendre series.
legweight : Legendre weight function (= 1).
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Legendre series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where :math:`w_j` are the weights. This problem is solved by setting up
as the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Legendre series are usually better conditioned than fits
using power series, but much can depend on the distribution of the
sample points and the smoothness of the data. If the quality of the fit
is inadequate splines may be a good alternative.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the M sample points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="yScalar" show_port="True">
      <docstring>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</docstring>
      <alternateSpec arg="y" name="ySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the fitting polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Weights. If not None, the contribution of each point
``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
weights are chosen so that the errors of the products ``w[i]*y[i]``
all have the same variance.  The default value is None.

.. versionadded:: 1.5.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" show_port="True" sort_key="0">
      <docstring>Legendre coefficients ordered from low to high. If `y` was 2-D,
the coefficients for the data in column k  of `y` are in column
`k`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[residuals" name="[residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="singular_values" name="singular_values" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rcond]" name="rcond]" port_type="basic:List" show_port="True" sort_key="4">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legtrim" module_name="legtrim" namespace="'polynomial|legendre'">
    <docstring>Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` &lt; 0

See Also
--------
trimseq

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
&gt;&gt;&gt; P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
&gt;&gt;&gt; i = complex(0,1) # works for complex
&gt;&gt;&gt; P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-d array of coefficients, ordered from lowest order to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Integer">
      <docstring>Trailing (i.e., highest order) elements with absolute value less
than or equal to `tol` (default value is zero) are removed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-d array with trailing zeros removed.  If the resulting series
would be empty, a series containing a single zero is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legroots" module_name="legroots" namespace="'polynomial|legendre'">
    <docstring>Compute the roots of a Legendre series.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \sum_i c[i] * L_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, chebroots, lagroots, hermroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such values.
Roots with multiplicity greater than 1 will also show larger errors as
the value of the series near such points is relatively insensitive to
errors in the roots. Isolated roots near the origin can be improved by
a few iterations of Newton's method.

The Legendre series basis polynomials aren't powers of ``x`` so the
results of this function may seem unintuitive.

Examples
--------
&gt;&gt;&gt; import numpy.polynomial.legendre as leg
&gt;&gt;&gt; leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots
array([-0.85099543, -0.11407192,  0.51506735])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the roots of the series. If all the roots are real,
then `out` is also real, otherwise it is complex.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legval2d" module_name="legval2d" namespace="'polynomial|legendre'">
    <docstring>Evaluate a 2-D Legendre series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * L_i(x) * L_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Legendre series at points formed
    from pairs of corresponding values from `x` and `y`.

See Also
--------
legval, leggrid2d, legval3d, leggrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term
of multi-degree i,j is contained in ``c[i,j]``. If `c` has
dimension greater than two the remaining indices enumerate multiple
sets of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional Legendre series at points formed
from pairs of corresponding values from `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legval3d" module_name="legval3d" namespace="'polynomial|legendre'">
    <docstring>Evaluate a 3-D Legendre series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
legval, legval2d, leggrid2d, leggrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
greater than 3 the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the multidimensional polynomial on points formed with
triples of corresponding values from `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.leggrid2d" module_name="leggrid2d" namespace="'polynomial|legendre'">
    <docstring>Evaluate a 2-D Legendre series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * L_i(a) * L_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points in the
    Cartesian product of `x` and `y`.

See Also
--------
legval, legval2d, legval3d, leggrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional Chebyshev series at points in the
Cartesian product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.leggrid3d" module_name="leggrid3d" namespace="'polynomial|legendre'">
    <docstring>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
legval, legval2d, leggrid2d, legval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legvander2d" module_name="legvander2d" namespace="'polynomial|legendre'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., deg[1]*i + j] = L_i(x) * L_j(y),

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Legendre polynomials.

If ``V = legvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``legval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Legendre
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
legvander, legvander3d. legval2d, legval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander2d" name="vander2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
as the converted `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legvander3d" module_name="legvander3d" namespace="'polynomial|legendre'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Legendre polynomials.

If ``V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and ``np.dot(V, c.flat)`` and ``legval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Legendre
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
legvander, legvander3d. legval2d, legval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg, z_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander3d" name="vander3d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
be the same as the converted `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legcompanion" module_name="legcompanion" namespace="'polynomial|legendre'">
    <docstring>Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an Legendre basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of Legendre series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Legendre series coefficients ordered from low to high
degree.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mat" name="mat" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Scaled companion matrix of dimensions (deg, deg).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.leggauss" module_name="leggauss" namespace="'polynomial|legendre'" output_type="list">
    <docstring>Gauss-Legendre quadrature.

Computes the sample points and weights for Gauss-Legendre quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
the weight function :math:`f(x) = 1`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be &gt;= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded::1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`L_n`, and then scaling the results to get
the right value when integrating 1.</docstring>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points and weights. It must be &gt;= 1.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D ndarray containing the sample points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>1-D ndarray containing the weights.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.legweight" module_name="legweight" namespace="'polynomial|legendre'">
    <docstring>Weight function of the Legendre polynomials.

The weight function is :math:`1` and the interval of integration is
:math:`[-1, 1]`. The Legendre polynomials are orthogonal, but not
normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Values at which the weight function will be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The weight function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagline" module_name="lagline" namespace="'polynomial|laguerre'">
    <docstring>Laguerre series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Laguerre series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagline, lagval
&gt;&gt;&gt; lagval(0,lagline(3, 2))
3.0
&gt;&gt;&gt; lagval(1,lagline(3, 2))
5.0</docstring>
    <inputPortSpec arg="off" name="off" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This module's representation of the Laguerre series for
``off + scl*x``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagadd" module_name="lagadd" namespace="'polynomial|laguerre'">
    <docstring>Add one Laguerre series to another.

Returns the sum of two Laguerre series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Laguerre series of their sum.

See Also
--------
lagsub, lagmul, lagdiv, lagpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Laguerre series
is a Laguerre series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagadd
&gt;&gt;&gt; lagadd([1, 2, 3], [1, 2, 3, 4])
array([ 2.,  4.,  6.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the Laguerre series of their sum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagsub" module_name="lagsub" namespace="'polynomial|laguerre'">
    <docstring>Subtract one Laguerre series from another.

Returns the difference of two Laguerre series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Laguerre series coefficients representing their difference.

See Also
--------
lagadd, lagmul, lagdiv, lagpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Laguerre
series is a Laguerre series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagsub
&gt;&gt;&gt; lagsub([1, 2, 3, 4], [1, 2, 3])
array([ 0.,  0.,  0.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Laguerre series coefficients representing their difference.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagmulx" module_name="lagmulx" namespace="'polynomial|laguerre'">
    <docstring>Multiply a Laguerre series by x.

Multiply the Laguerre series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
The multiplication uses the recursion relationship for Laguerre
polynomials in the form

.. math::

xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagmulx
&gt;&gt;&gt; lagmulx([1, 2, 3])
array([ -1.,  -1.,  11.,  -9.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the result of the multiplication.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagmul" module_name="lagmul" namespace="'polynomial|laguerre'">
    <docstring>Multiply one Laguerre series by another.

Returns the product of two Laguerre series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Laguerre series coefficients representing their product.

See Also
--------
lagadd, lagsub, lagdiv, lagpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Laguerre polynomial basis set.  Thus, to express
the product as a Laguerre series, it is necessary to "reproject" the
product onto said basis set, which may produce "unintuitive" (but
correct) results; see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagmul
&gt;&gt;&gt; lagmul([1, 2, 3], [0, 1, 2])
array([  8., -13.,  38., -51.,  36.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Laguerre series coefficients representing their product.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagdiv" module_name="lagdiv" namespace="'polynomial|laguerre'" output_type="list">
    <docstring>Divide one Laguerre series by another.

Returns the quotient-with-remainder of two Laguerre series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Laguerre series coefficients representing the quotient and
    remainder.

See Also
--------
lagadd, lagsub, lagmul, lagpow

Notes
-----
In general, the (polynomial) division of one Laguerre series by another
results in quotient and remainder terms that are not in the Laguerre
polynomial basis set.  Thus, to express these results as a Laguerre
series, it is necessary to "reproject" the results onto the Laguerre
basis set, which may produce "unintuitive" (but correct) results; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagdiv
&gt;&gt;&gt; lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 0.]))
&gt;&gt;&gt; lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 1.,  1.]))</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="[quo" name="[quo" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Laguerre series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rem]" name="rem]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Of Laguerre series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagpow" module_name="lagpow" namespace="'polynomial|laguerre'">
    <docstring>Raise a Laguerre series to a power.

Returns the Laguerre series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Laguerre series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Laguerre series of power.

See Also
--------
lagadd, lagsub, lagmul, lagdiv

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagpow
&gt;&gt;&gt; lagpow([1, 2, 3], 2)
array([ 14., -16.,  56., -72.,  54.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Laguerre series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pow" name="pow" port_type="basic:Integer" show_port="True">
      <docstring>Power to which the series will be raised</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxpower" name="maxpower" port_type="basic:Integer">
      <docstring>Maximum power allowed. This is mainly to limit growth of the series
to unmanageable size. Default is 16</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Laguerre series of power.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagval" module_name="lagval" namespace="'polynomial|laguerre'">
    <docstring>Evaluate a Laguerre series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
lagval2d, laggrid2d, lagval3d, laggrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagval
&gt;&gt;&gt; coef = [1,2,3]
&gt;&gt;&gt; lagval(1, coef)
-0.5
&gt;&gt;&gt; lagval([[1,2],[3,4]], coef)
array([[-0.5, -4. ],
       [-4.5, -2. ]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>If `x` is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, `x`
or its elements must support addition and multiplication with
with themselves and with the elements of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If `c` is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tensor" name="tensor" port_type="basic:Boolean">
      <docstring>If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of `x`. Scalars have dimension 0
for this action. The result is that every column of coefficients in
`c` is evaluated for every element of `x`. If False, `x` is broadcast
over the columns of `c` for the evaluation.  This keyword is useful
when `c` is multidimensional. The default value is True.

.. versionadded:: 1.7.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the return value is described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagder" module_name="lagder" namespace="'polynomial|laguerre'">
    <docstring>Differentiate a Laguerre series.

Returns the Laguerre series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``
while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Laguerre series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Laguerre series of the derivative.

See Also
--------
lagint

Notes
-----
In general, the result of differentiating a Laguerre series does not
resemble the same operation on a power series. Thus the result of this
function may be "unintuitive," albeit correct; see Examples section
below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagder
&gt;&gt;&gt; lagder([ 1.,  1.,  1., -3.])
array([ 1.,  2.,  3.])
&gt;&gt;&gt; lagder([ 1.,  0.,  0., -4.,  3.], m=2)
array([ 1.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Laguerre series coefficients. If `c` is multidimensional
the different axis correspond to different variables with the
degree in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of derivatives taken, must be non-negative. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Each differentiation is multiplied by `scl`.  The end result is
multiplication by ``scl**m``.  This is for use in a linear change of
variable. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the derivative is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="der" name="der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Laguerre series of the derivative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagint" module_name="lagint" namespace="'polynomial|laguerre'">
    <docstring>Integrate a Laguerre series.

Returns the Laguerre series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]
represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.


Parameters
----------
c : array_like
    Array of Laguerre series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Laguerre series coefficients of the integral.

Raises
------
ValueError
    If ``m &lt; 0``, ``len(k) &gt; m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
lagder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
.. math::`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "reprojected" onto the C-series basis set.  Thus, typically,
the result of this function is "unintuitive," albeit correct; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagint
&gt;&gt;&gt; lagint([1,2,3])
array([ 1.,  1.,  1., -3.])
&gt;&gt;&gt; lagint([1,2,3], m=2)
array([ 1.,  0.,  0., -4.,  3.])
&gt;&gt;&gt; lagint([1,2,3], k=1)
array([ 2.,  1.,  1., -3.])
&gt;&gt;&gt; lagint([1,2,3], lbnd=-1)
array([ 11.5,   1. ,   1. ,  -3. ])
&gt;&gt;&gt; lagint([1,2], m=2, k=[1,2], lbnd=-1)
array([ 11.16666667,  -5.        ,  -3.        ,   2.        ])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Laguerre series coefficients. If `c` is multidimensional
the different axis correspond to different variables with the
degree in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Order of integration, must be positive. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Float">
      <docstring>Integration constant(s).  The value of the first integral at
``lbnd`` is the first value in the list, the value of the second
integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
default), all constants are set to zero.  If ``m == 1``, a single
scalar can be given instead of a list.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List">
        <entry_types>['enum']</entry_types>
        <values>[[[]]]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="lbnd" name="lbnd" port_type="basic:Float">
      <docstring>The lower bound of the integral. (Default: 0)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Following each integration the result is *multiplied* by `scl`
before the integration constant is added. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the integral is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Laguerre series coefficients of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lag2poly" module_name="lag2poly" namespace="'polynomial|laguerre'">
    <docstring>Convert a Laguerre series to a polynomial.

Convert an array representing the coefficients of a Laguerre series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Laguerre series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2lag

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lag2poly
&gt;&gt;&gt; lag2poly([ 23., -63.,  58., -18.])
array([ 0.,  1.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the Laguerre series coefficients, ordered
from lowest order term to highest.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent polynomial
(relative to the "standard" basis) ordered from lowest order term
to highest.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.poly2lag" module_name="poly2lag" namespace="'polynomial|laguerre'">
    <docstring>poly2lag(pol)

Convert a polynomial to a Laguerre series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Laguerre series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Laguerre
    series.

See Also
--------
lag2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import poly2lag
&gt;&gt;&gt; poly2lag(np.arange(4))
array([ 23., -63.,  58., -18.])</docstring>
    <inputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the polynomial coefficients</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent Laguerre
series.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagfromroots" module_name="lagfromroots" namespace="'polynomial|laguerre'">
    <docstring>Generate a Laguerre series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Laguerre form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Laguerre form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, chebfromroots, hermfromroots,
hermefromroots.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagfromroots, lagval
&gt;&gt;&gt; coef = lagfromroots((-1, 0, 1))
&gt;&gt;&gt; lagval((-1, 0, 1), coef)
array([ 0.,  0.,  0.])
&gt;&gt;&gt; coef = lagfromroots((-1j, 1j))
&gt;&gt;&gt; lagval((-1j, 1j), coef)
array([ 0.+0.j,  0.+0.j])</docstring>
    <inputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True">
      <docstring>Sequence containing the roots.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of coefficients.  If all roots are real then `out` is a
real array, if some of the roots are complex, then `out` is complex
even if all the coefficients in the result are real (see Examples
below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagvander" module_name="lagvander" namespace="'polynomial|laguerre'">
    <docstring>Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = L_i(x)

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Laguerre polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = lagvander(x, n)``, then ``np.dot(V, c)`` and
``lagval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Laguerre series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Laguerre polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagvander
&gt;&gt;&gt; x = np.array([0, 1, 2])
&gt;&gt;&gt; lagvander(x, 3)
array([[ 1.        ,  1.        ,  1.        ,  1.        ],
       [ 1.        ,  0.        , -0.5       , -0.66666667],
       [ 1.        , -1.        , -1.        , -0.33333333]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of points. The dtype is converted to float64 or complex128
depending on whether any of the elements are complex. If `x` is
scalar it is converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the resulting matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander" name="vander" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-Vandermonde matrix. The shape of the returned matrix is
``x.shape + (deg + 1,)``, where The last index is the degree of the
corresponding Laguerre polynomial.  The dtype will be the same as
the converted `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagfit" module_name="lagfit" namespace="'polynomial|laguerre'" output_type="list">
    <docstring>Least squares fit of Laguerre series to data.

Return the coefficients of a Laguerre series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Laguerre coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebfit, legfit, polyfit, hermfit, hermefit
lagval : Evaluates a Laguerre series.
lagvander : pseudo Vandermonde matrix of Laguerre series.
lagweight : Laguerre weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Laguerre series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up as the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Laguerre series are probably most useful when the data can
be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the Laguerre
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `lagweight`.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagfit, lagval
&gt;&gt;&gt; x = np.linspace(0, 10)
&gt;&gt;&gt; err = np.random.randn(len(x))/10
&gt;&gt;&gt; y = lagval(x, [1, 2, 3]) + err
&gt;&gt;&gt; lagfit(x, y, 2)
array([ 0.96971004,  2.00193749,  3.00288744])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the M sample points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="yScalar" show_port="True">
      <docstring>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</docstring>
      <alternateSpec arg="y" name="ySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the fitting polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Weights. If not None, the contribution of each point
``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
weights are chosen so that the errors of the products ``w[i]*y[i]``
all have the same variance.  The default value is None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" show_port="True" sort_key="0">
      <docstring>Laguerre coefficients ordered from low to high. If `y` was 2-D,
the coefficients for the data in column k  of `y` are in column
`k`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[residuals" name="[residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="singular_values" name="singular_values" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rcond]" name="rcond]" port_type="basic:List" show_port="True" sort_key="4">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagtrim" module_name="lagtrim" namespace="'polynomial|laguerre'">
    <docstring>Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` &lt; 0

See Also
--------
trimseq

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
&gt;&gt;&gt; P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
&gt;&gt;&gt; i = complex(0,1) # works for complex
&gt;&gt;&gt; P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-d array of coefficients, ordered from lowest order to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Integer">
      <docstring>Trailing (i.e., highest order) elements with absolute value less
than or equal to `tol` (default value is zero) are removed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-d array with trailing zeros removed.  If the resulting series
would be empty, a series containing a single zero is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagroots" module_name="lagroots" namespace="'polynomial|laguerre'">
    <docstring>Compute the roots of a Laguerre series.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \sum_i c[i] * L_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, chebroots, hermroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The Laguerre series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.laguerre import lagroots, lagfromroots
&gt;&gt;&gt; coef = lagfromroots([0, 1, 2])
&gt;&gt;&gt; coef
array([  2.,  -8.,  12.,  -6.])
&gt;&gt;&gt; lagroots(coef)
array([ -4.44089210e-16,   1.00000000e+00,   2.00000000e+00])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the roots of the series. If all the roots are real,
then `out` is also real, otherwise it is complex.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagval2d" module_name="lagval2d" namespace="'polynomial|laguerre'">
    <docstring>Evaluate a 2-D Laguerre series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * L_i(x) * L_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
lagval, laggrid2d, lagval3d, laggrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term
of multi-degree i,j is contained in ``c[i,j]``. If `c` has
dimension greater than two the remaining indices enumerate multiple
sets of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points formed with
pairs of corresponding values from `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagval3d" module_name="lagval3d" namespace="'polynomial|laguerre'">
    <docstring>Evaluate a 3-D Laguerre series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimension polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
lagval, lagval2d, laggrid2d, laggrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
greater than 3 the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the multidimension polynomial on points formed with
triples of corresponding values from `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.laggrid2d" module_name="laggrid2d" namespace="'polynomial|laguerre'">
    <docstring>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * L_i(a) * L_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points in the
    Cartesian product of `x` and `y`.

See Also
--------
lagval, lagval2d, lagval3d, laggrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional Chebyshev series at points in the
Cartesian product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.laggrid3d" module_name="laggrid3d" namespace="'polynomial|laguerre'">
    <docstring>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
lagval, lagval2d, laggrid2d, lagval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagvander2d" module_name="lagvander2d" namespace="'polynomial|laguerre'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., deg[1]*i + j] = L_i(x) * L_j(y),

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Laguerre polynomials.

If ``V = lagvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``lagval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Laguerre
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
lagvander, lagvander3d. lagval2d, lagval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander2d" name="vander2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
as the converted `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagvander3d" module_name="lagvander3d" namespace="'polynomial|laguerre'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Laguerre polynomials.

If ``V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``lagval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Laguerre
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
lagvander, lagvander3d. lagval2d, lagval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg, z_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander3d" name="vander3d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
be the same as the converted `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagcompanion" module_name="lagcompanion" namespace="'polynomial|laguerre'">
    <docstring>Return the companion matrix of c.

The usual companion matrix of the Laguerre polynomials is already
symmetric when `c` is a basis Laguerre polynomial, so no scaling is
applied.

Parameters
----------
c : array_like
    1-D array of Laguerre series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Laguerre series coefficients ordered from low to high
degree.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mat" name="mat" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Companion matrix of dimensions (deg, deg).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.laggauss" module_name="laggauss" namespace="'polynomial|laguerre'" output_type="list">
    <docstring>Gauss-Laguerre quadrature.

Computes the sample points and weights for Gauss-Laguerre quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[0, \inf]`
with the weight function :math:`f(x) = \exp(-x)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be &gt;= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded::1.7.0

The results have only been tested up to degree 100 higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`L_n`, and then scaling the results to get
the right value when integrating 1.</docstring>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points and weights. It must be &gt;= 1.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D ndarray containing the sample points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>1-D ndarray containing the weights.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.lagweight" module_name="lagweight" namespace="'polynomial|laguerre'">
    <docstring>Weight function of the Laguerre polynomials.

The weight function is :math:`exp(-x)` and the interval of integration
is :math:`[0, \inf]`. The Laguerre polynomials are orthogonal, but not
normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Values at which the weight function will be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The weight function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermline" module_name="hermline" namespace="'polynomial|hermite'">
    <docstring>Hermite series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Hermite series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermline, hermval
&gt;&gt;&gt; hermval(0,hermline(3, 2))
3.0
&gt;&gt;&gt; hermval(1,hermline(3, 2))
5.0</docstring>
    <inputPortSpec arg="off" name="off" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This module's representation of the Hermite series for
``off + scl*x``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermadd" module_name="hermadd" namespace="'polynomial|hermite'">
    <docstring>Add one Hermite series to another.

Returns the sum of two Hermite series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Hermite series of their sum.

See Also
--------
hermsub, hermmul, hermdiv, hermpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Hermite series
is a Hermite series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermadd
&gt;&gt;&gt; hermadd([1, 2, 3], [1, 2, 3, 4])
array([ 2.,  4.,  6.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the Hermite series of their sum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermsub" module_name="hermsub" namespace="'polynomial|hermite'">
    <docstring>Subtract one Hermite series from another.

Returns the difference of two Hermite series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their difference.

See Also
--------
hermadd, hermmul, hermdiv, hermpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Hermite
series is a Hermite series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermsub
&gt;&gt;&gt; hermsub([1, 2, 3, 4], [1, 2, 3])
array([ 0.,  0.,  0.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Hermite series coefficients representing their difference.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermmulx" module_name="hermmulx" namespace="'polynomial|hermite'">
    <docstring>Multiply a Hermite series by x.

Multiply the Hermite series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
The multiplication uses the recursion relationship for Hermite
polynomials in the form

.. math::

xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermmulx
&gt;&gt;&gt; hermmulx([1, 2, 3])
array([ 2. ,  6.5,  1. ,  1.5])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the result of the multiplication.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermmul" module_name="hermmul" namespace="'polynomial|hermite'">
    <docstring>Multiply one Hermite series by another.

Returns the product of two Hermite series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their product.

See Also
--------
hermadd, hermsub, hermdiv, hermpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Hermite polynomial basis set.  Thus, to express
the product as a Hermite series, it is necessary to "reproject" the
product onto said basis set, which may produce "unintuitive" (but
correct) results; see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermmul
&gt;&gt;&gt; hermmul([1, 2, 3], [0, 1, 2])
array([ 52.,  29.,  52.,   7.,   6.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Hermite series coefficients representing their product.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermdiv" module_name="hermdiv" namespace="'polynomial|hermite'" output_type="list">
    <docstring>Divide one Hermite series by another.

Returns the quotient-with-remainder of two Hermite series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Hermite series coefficients representing the quotient and
    remainder.

See Also
--------
hermadd, hermsub, hermmul, hermpow

Notes
-----
In general, the (polynomial) division of one Hermite series by another
results in quotient and remainder terms that are not in the Hermite
polynomial basis set.  Thus, to express these results as a Hermite
series, it is necessary to "reproject" the results onto the Hermite
basis set, which may produce "unintuitive" (but correct) results; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermdiv
&gt;&gt;&gt; hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 0.]))
&gt;&gt;&gt; hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 2.,  2.]))
&gt;&gt;&gt; hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 1.,  1.]))</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="[quo" name="[quo" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Hermite series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rem]" name="rem]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Of Hermite series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermpow" module_name="hermpow" namespace="'polynomial|hermite'">
    <docstring>Raise a Hermite series to a power.

Returns the Hermite series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Hermite series of power.

See Also
--------
hermadd, hermsub, hermmul, hermdiv

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermpow
&gt;&gt;&gt; hermpow([1, 2, 3], 2)
array([ 81.,  52.,  82.,  12.,   9.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pow" name="pow" port_type="basic:Integer" show_port="True">
      <docstring>Power to which the series will be raised</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxpower" name="maxpower" port_type="basic:Integer">
      <docstring>Maximum power allowed. This is mainly to limit growth of the series
to unmanageable size. Default is 16</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hermite series of power.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermval" module_name="hermval" namespace="'polynomial|hermite'">
    <docstring>Evaluate an Hermite series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
hermval2d, hermgrid2d, hermval3d, hermgrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermval
&gt;&gt;&gt; coef = [1,2,3]
&gt;&gt;&gt; hermval(1, coef)
11.0
&gt;&gt;&gt; hermval([[1,2],[3,4]], coef)
array([[  11.,   51.],
       [ 115.,  203.]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>If `x` is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, `x`
or its elements must support addition and multiplication with
with themselves and with the elements of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If `c` is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tensor" name="tensor" port_type="basic:Boolean">
      <docstring>If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of `x`. Scalars have dimension 0
for this action. The result is that every column of coefficients in
`c` is evaluated for every element of `x`. If False, `x` is broadcast
over the columns of `c` for the evaluation.  This keyword is useful
when `c` is multidimensional. The default value is True.

.. versionadded:: 1.7.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the return value is described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermder" module_name="hermder" namespace="'polynomial|hermite'">
    <docstring>Differentiate a Hermite series.

Returns the Hermite series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*H_0 + 2*H_1 + 3*H_2``
while [[1,2],[1,2]] represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) +
2*H_0(x)*H_1(y) + 2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Hermite series coefficients. If `c` is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Hermite series of the derivative.

See Also
--------
hermint

Notes
-----
In general, the result of differentiating a Hermite series does not
resemble the same operation on a power series. Thus the result of this
function may be "unintuitive," albeit correct; see Examples section
below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermder
&gt;&gt;&gt; hermder([ 1. ,  0.5,  0.5,  0.5])
array([ 1.,  2.,  3.])
&gt;&gt;&gt; hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)
array([ 1.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Hermite series coefficients. If `c` is multidimensional the
different axis correspond to different variables with the degree in
each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of derivatives taken, must be non-negative. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Each differentiation is multiplied by `scl`.  The end result is
multiplication by ``scl**m``.  This is for use in a linear change of
variable. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the derivative is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="der" name="der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hermite series of the derivative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermint" module_name="hermint" namespace="'polynomial|hermite'">
    <docstring>Integrate a Hermite series.

Returns the Hermite series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Hermite series coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Hermite series coefficients of the integral.

Raises
------
ValueError
    If ``m &lt; 0``, ``len(k) &gt; m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
hermder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
.. math::`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "reprojected" onto the C-series basis set.  Thus, typically,
the result of this function is "unintuitive," albeit correct; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermint
&gt;&gt;&gt; hermint([1,2,3]) # integrate once, value 0 at 0.
array([ 1. ,  0.5,  0.5,  0.5])
&gt;&gt;&gt; hermint([1,2,3], m=2) # integrate twice, value &amp; deriv 0 at 0
array([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ])
&gt;&gt;&gt; hermint([1,2,3], k=1) # integrate once, value 1 at 0.
array([ 2. ,  0.5,  0.5,  0.5])
&gt;&gt;&gt; hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1
array([-2. ,  0.5,  0.5,  0.5])
&gt;&gt;&gt; hermint([1,2,3], m=2, k=[1,2], lbnd=-1)
array([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Hermite series coefficients. If c is multidimensional the
different axis correspond to different variables with the degree in
each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Order of integration, must be positive. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Float">
      <docstring>Integration constant(s).  The value of the first integral at
``lbnd`` is the first value in the list, the value of the second
integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
default), all constants are set to zero.  If ``m == 1``, a single
scalar can be given instead of a list.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List">
        <entry_types>['enum']</entry_types>
        <values>[[[]]]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="lbnd" name="lbnd" port_type="basic:Float">
      <docstring>The lower bound of the integral. (Default: 0)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Following each integration the result is *multiplied* by `scl`
before the integration constant is added. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the integral is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hermite series coefficients of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.herm2poly" module_name="herm2poly" namespace="'polynomial|hermite'">
    <docstring>Convert a Hermite series to a polynomial.

Convert an array representing the coefficients of a Hermite series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Hermite series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2herm

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import herm2poly
&gt;&gt;&gt; herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])
array([ 0.,  1.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the Hermite series coefficients, ordered
from lowest order term to highest.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent polynomial
(relative to the "standard" basis) ordered from lowest order term
to highest.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.poly2herm" module_name="poly2herm" namespace="'polynomial|hermite'">
    <docstring>poly2herm(pol)

Convert a polynomial to a Hermite series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Hermite series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Hermite
    series.

See Also
--------
herm2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import poly2herm
&gt;&gt;&gt; poly2herm(np.arange(4))
array([ 1.   ,  2.75 ,  0.5  ,  0.375])</docstring>
    <inputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the polynomial coefficients</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent Hermite
series.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermfromroots" module_name="hermfromroots" namespace="'polynomial|hermite'">
    <docstring>Generate a Hermite series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Hermite form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * H_1(x) + ... +  c_n * H_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Hermite form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, chebfromroots,
hermefromroots.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermfromroots, hermval
&gt;&gt;&gt; coef = hermfromroots((-1, 0, 1))
&gt;&gt;&gt; hermval((-1, 0, 1), coef)
array([ 0.,  0.,  0.])
&gt;&gt;&gt; coef = hermfromroots((-1j, 1j))
&gt;&gt;&gt; hermval((-1j, 1j), coef)
array([ 0.+0.j,  0.+0.j])</docstring>
    <inputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True">
      <docstring>Sequence containing the roots.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of coefficients.  If all roots are real then `out` is a
real array, if some of the roots are complex, then `out` is complex
even if all the coefficients in the result are real (see Examples
below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermvander" module_name="hermvander" namespace="'polynomial|hermite'">
    <docstring>Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = H_i(x),

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Hermite polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = hermvander(x, n)``, then ``np.dot(V, c)`` and
``hermval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Hermite series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Hermite polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermvander
&gt;&gt;&gt; x = np.array([-1, 0, 1])
&gt;&gt;&gt; hermvander(x, 3)
array([[ 1., -2.,  2.,  4.],
       [ 1.,  0., -2., -0.],
       [ 1.,  2.,  2., -4.]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of points. The dtype is converted to float64 or complex128
depending on whether any of the elements are complex. If `x` is
scalar it is converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the resulting matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander" name="vander" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-Vandermonde matrix. The shape of the returned matrix is
``x.shape + (deg + 1,)``, where The last index is the degree of the
corresponding Hermite polynomial.  The dtype will be the same as
the converted `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermfit" module_name="hermfit" namespace="'polynomial|hermite'" output_type="list">
    <docstring>Least squares fit of Hermite series to data.

Return the coefficients of a Hermite series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * H_1(x) + ... + c_n * H_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Hermite coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebfit, legfit, lagfit, polyfit, hermefit
hermval : Evaluates a Hermite series.
hermvander : Vandermonde matrix of Hermite series.
hermweight : Hermite weight function
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Hermite series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Hermite series are probably most useful when the data can be
approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the Hermite
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `hermweight`.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermfit, hermval
&gt;&gt;&gt; x = np.linspace(-10, 10)
&gt;&gt;&gt; err = np.random.randn(len(x))/10
&gt;&gt;&gt; y = hermval(x, [1, 2, 3]) + err
&gt;&gt;&gt; hermfit(x, y, 2)
array([ 0.97902637,  1.99849131,  3.00006   ])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the M sample points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="yScalar" show_port="True">
      <docstring>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</docstring>
      <alternateSpec arg="y" name="ySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the fitting polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Weights. If not None, the contribution of each point
``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
weights are chosen so that the errors of the products ``w[i]*y[i]``
all have the same variance.  The default value is None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" show_port="True" sort_key="0">
      <docstring>Hermite coefficients ordered from low to high. If `y` was 2-D,
the coefficients for the data in column k  of `y` are in column
`k`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[residuals" name="[residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="singular_values" name="singular_values" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rcond]" name="rcond]" port_type="basic:List" show_port="True" sort_key="4">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermtrim" module_name="hermtrim" namespace="'polynomial|hermite'">
    <docstring>Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` &lt; 0

See Also
--------
trimseq

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
&gt;&gt;&gt; P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
&gt;&gt;&gt; i = complex(0,1) # works for complex
&gt;&gt;&gt; P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-d array of coefficients, ordered from lowest order to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Integer">
      <docstring>Trailing (i.e., highest order) elements with absolute value less
than or equal to `tol` (default value is zero) are removed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-d array with trailing zeros removed.  If the resulting series
would be empty, a series containing a single zero is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermroots" module_name="hermroots" namespace="'polynomial|hermite'">
    <docstring>Compute the roots of a Hermite series.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \sum_i c[i] * H_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, chebroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The Hermite series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite import hermroots, hermfromroots
&gt;&gt;&gt; coef = hermfromroots([-1, 0, 1])
&gt;&gt;&gt; coef
array([ 0.   ,  0.25 ,  0.   ,  0.125])
&gt;&gt;&gt; hermroots(coef)
array([ -1.00000000e+00,  -1.38777878e-17,   1.00000000e+00])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the roots of the series. If all the roots are real,
then `out` is also real, otherwise it is complex.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermval2d" module_name="hermval2d" namespace="'polynomial|hermite'">
    <docstring>Evaluate a 2-D Hermite series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * H_i(x) * H_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
hermval, hermgrid2d, hermval3d, hermgrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term
of multi-degree i,j is contained in ``c[i,j]``. If `c` has
dimension greater than two the remaining indices enumerate multiple
sets of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points formed with
pairs of corresponding values from `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermval3d" module_name="hermval3d" namespace="'polynomial|hermite'">
    <docstring>Evaluate a 3-D Hermite series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * H_i(x) * H_j(y) * H_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
hermval, hermval2d, hermgrid2d, hermgrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
greater than 3 the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the multidimensional polynomial on points formed with
triples of corresponding values from `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermgrid2d" module_name="hermgrid2d" namespace="'polynomial|hermite'">
    <docstring>Evaluate a 2-D Hermite series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * H_i(a) * H_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermval, hermval2d, hermval3d, hermgrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermgrid3d" module_name="hermgrid3d" namespace="'polynomial|hermite'">
    <docstring>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermval, hermval2d, hermgrid2d, hermval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermvander2d" module_name="hermvander2d" namespace="'polynomial|hermite'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., deg[1]*i + j] = H_i(x) * H_j(y),

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Hermite polynomials.

If ``V = hermvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``hermval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Hermite
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
hermvander, hermvander3d. hermval2d, hermval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander2d" name="vander2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
as the converted `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermvander3d" module_name="hermvander3d" namespace="'polynomial|hermite'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = H_i(x)*H_j(y)*H_k(z),

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Hermite polynomials.

If ``V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``hermval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Hermite
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
hermvander, hermvander3d. hermval2d, hermval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg, z_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander3d" name="vander3d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
be the same as the converted `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermcompanion" module_name="hermcompanion" namespace="'polynomial|hermite'">
    <docstring>Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an Hermite basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Hermite series coefficients ordered from low to high
degree.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mat" name="mat" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Scaled companion matrix of dimensions (deg, deg).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermgauss" module_name="hermgauss" namespace="'polynomial|hermite'" output_type="list">
    <docstring>Gauss-Hermite quadrature.

Computes the sample points and weights for Gauss-Hermite quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-\inf, \inf]`
with the weight function :math:`f(x) = \exp(-x^2)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be &gt;= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded::1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (H'_n(x_k) * H_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`H_n`, and then scaling the results to get
the right value when integrating 1.</docstring>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points and weights. It must be &gt;= 1.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D ndarray containing the sample points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>1-D ndarray containing the weights.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.hermweight" module_name="hermweight" namespace="'polynomial|hermite'">
    <docstring>Weight function of the Hermite polynomials.

The weight function is :math:`\exp(-x^2)` and the interval of
integration is :math:`[-\inf, \inf]`. the Hermite polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Values at which the weight function will be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The weight function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeline" module_name="hermeline" namespace="'polynomial|hermite_e'">
    <docstring>Hermite series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Hermite series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeline
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeline, hermeval
&gt;&gt;&gt; hermeval(0,hermeline(3, 2))
3.0
&gt;&gt;&gt; hermeval(1,hermeline(3, 2))
5.0</docstring>
    <inputPortSpec arg="off" name="off" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float" show_port="True">
      <docstring>The specified line is given by ``off + scl*x``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>This module's representation of the Hermite series for
``off + scl*x``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeadd" module_name="hermeadd" namespace="'polynomial|hermite_e'">
    <docstring>Add one Hermite series to another.

Returns the sum of two Hermite series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Hermite series of their sum.

See Also
--------
hermesub, hermemul, hermediv, hermepow

Notes
-----
Unlike multiplication, division, etc., the sum of two Hermite series
is a Hermite series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeadd
&gt;&gt;&gt; hermeadd([1, 2, 3], [1, 2, 3, 4])
array([ 2.,  4.,  6.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the Hermite series of their sum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermesub" module_name="hermesub" namespace="'polynomial|hermite_e'">
    <docstring>Subtract one Hermite series from another.

Returns the difference of two Hermite series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their difference.

See Also
--------
hermeadd, hermemul, hermediv, hermepow

Notes
-----
Unlike multiplication, division, etc., the difference of two Hermite
series is a Hermite series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermesub
&gt;&gt;&gt; hermesub([1, 2, 3, 4], [1, 2, 3])
array([ 0.,  0.,  0.,  4.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Hermite series coefficients representing their difference.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermemulx" module_name="hermemulx" namespace="'polynomial|hermite_e'">
    <docstring>Multiply a Hermite series by x.

Multiply the Hermite series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
The multiplication uses the recursion relationship for Hermite
polynomials in the form

.. math::

xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermemulx
&gt;&gt;&gt; hermemulx([1, 2, 3])
array([ 2.,  7.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array representing the result of the multiplication.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermemul" module_name="hermemul" namespace="'polynomial|hermite_e'">
    <docstring>Multiply one Hermite series by another.

Returns the product of two Hermite series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their product.

See Also
--------
hermeadd, hermesub, hermediv, hermepow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Hermite polynomial basis set.  Thus, to express
the product as a Hermite series, it is necessary to "reproject" the
product onto said basis set, which may produce "unintuitive" (but
correct) results; see Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermemul
&gt;&gt;&gt; hermemul([1, 2, 3], [0, 1, 2])
array([ 14.,  15.,  28.,   7.,   6.])</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Hermite series coefficients representing their product.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermediv" module_name="hermediv" namespace="'polynomial|hermite_e'" output_type="list">
    <docstring>Divide one Hermite series by another.

Returns the quotient-with-remainder of two Hermite series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Hermite series coefficients representing the quotient and
    remainder.

See Also
--------
hermeadd, hermesub, hermemul, hermepow

Notes
-----
In general, the (polynomial) division of one Hermite series by another
results in quotient and remainder terms that are not in the Hermite
polynomial basis set.  Thus, to express these results as a Hermite
series, it is necessary to "reproject" the results onto the Hermite
basis set, which may produce "unintuitive" (but correct) results; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermediv
&gt;&gt;&gt; hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 0.]))
&gt;&gt;&gt; hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 1.,  2.]))</docstring>
    <inputPortSpec arg="c1" name="c1" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="[quo" name="[quo" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Of Hermite series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rem]" name="rem]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Of Hermite series coefficients representing the quotient and
remainder.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermepow" module_name="hermepow" namespace="'polynomial|hermite_e'">
    <docstring>Raise a Hermite series to a power.

Returns the Hermite series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Hermite series of power.

See Also
--------
hermeadd, hermesub, hermemul, hermediv

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermepow
&gt;&gt;&gt; hermepow([1, 2, 3], 2)
array([ 23.,  28.,  46.,  12.,   9.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of Hermite series coefficients ordered from low to
high.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pow" name="pow" port_type="basic:Integer" show_port="True">
      <docstring>Power to which the series will be raised</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxpower" name="maxpower" port_type="basic:Integer">
      <docstring>Maximum power allowed. This is mainly to limit growth of the series
to unmanageable size. Default is 16</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hermite series of power.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeval" module_name="hermeval" namespace="'polynomial|hermite_e'">
    <docstring>Evaluate an HermiteE series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
hermeval2d, hermegrid2d, hermeval3d, hermegrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeval
&gt;&gt;&gt; coef = [1,2,3]
&gt;&gt;&gt; hermeval(1, coef)
3.0
&gt;&gt;&gt; hermeval([[1,2],[3,4]], coef)
array([[  3.,  14.],
       [ 31.,  54.]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>If `x` is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, `x`
or its elements must support addition and multiplication with
with themselves and with the elements of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If `c` is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tensor" name="tensor" port_type="basic:Boolean">
      <docstring>If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of `x`. Scalars have dimension 0
for this action. The result is that every column of coefficients in
`c` is evaluated for every element of `x`. If False, `x` is broadcast
over the columns of `c` for the evaluation.  This keyword is useful
when `c` is multidimensional. The default value is True.

.. versionadded:: 1.7.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the return value is described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeder" module_name="hermeder" namespace="'polynomial|hermite_e'">
    <docstring>Differentiate a Hermite_e series.

Returns the series coefficients `c` differentiated `m` times along
`axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*He_0 + 2*He_1 + 3*He_2``
while [[1,2],[1,2]] represents ``1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)
+ 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)`` if axis=0 is ``x`` and axis=1
is ``y``.

Parameters
----------
c : array_like
    Array of Hermite_e series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Hermite series of the derivative.

See Also
--------
hermeint

Notes
-----
In general, the result of differentiating a Hermite series does not
resemble the same operation on a power series. Thus the result of this
function may be "unintuitive," albeit correct; see Examples section
below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeder
&gt;&gt;&gt; hermeder([ 1.,  1.,  1.,  1.])
array([ 1.,  2.,  3.])
&gt;&gt;&gt; hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)
array([ 1.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Hermite_e series coefficients. If `c` is multidimensional
the different axis correspond to different variables with the
degree in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of derivatives taken, must be non-negative. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Each differentiation is multiplied by `scl`.  The end result is
multiplication by ``scl**m``.  This is for use in a linear change of
variable. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the derivative is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="der" name="der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hermite series of the derivative.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeint" module_name="hermeint" namespace="'polynomial|hermite_e'">
    <docstring>Integrate a Hermite_e series.

Returns the Hermite_e series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Hermite_e series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Hermite_e series coefficients of the integral.

Raises
------
ValueError
    If ``m &lt; 0``, ``len(k) &gt; m``, ``np.isscalar(lbnd) == False``, or
    ``np.isscalar(scl) == False``.

See Also
--------
hermeder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
.. math::`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "reprojected" onto the C-series basis set.  Thus, typically,
the result of this function is "unintuitive," albeit correct; see
Examples section below.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeint
&gt;&gt;&gt; hermeint([1, 2, 3]) # integrate once, value 0 at 0.
array([ 1.,  1.,  1.,  1.])
&gt;&gt;&gt; hermeint([1, 2, 3], m=2) # integrate twice, value &amp; deriv 0 at 0
array([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ])
&gt;&gt;&gt; hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.
array([ 2.,  1.,  1.,  1.])
&gt;&gt;&gt; hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1
array([-1.,  1.,  1.,  1.])
&gt;&gt;&gt; hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)
array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of Hermite_e series coefficients. If c is multidimensional
the different axis correspond to different variables with the
degree in each axis given by the corresponding index.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Order of integration, must be positive. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Float">
      <docstring>Integration constant(s).  The value of the first integral at
``lbnd`` is the first value in the list, the value of the second
integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
default), all constants are set to zero.  If ``m == 1``, a single
scalar can be given instead of a list.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List">
        <entry_types>['enum']</entry_types>
        <values>[[[]]]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="lbnd" name="lbnd" port_type="basic:Float">
      <docstring>The lower bound of the integral. (Default: 0)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scl" name="scl" port_type="basic:Float">
      <docstring>Following each integration the result is *multiplied* by `scl`
before the integration constant is added. (Default: 1)</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which the integral is taken. (Default: 0).

.. versionadded:: 1.7.0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hermite_e series coefficients of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.herme2poly" module_name="herme2poly" namespace="'polynomial|hermite_e'">
    <docstring>Convert a Hermite series to a polynomial.

Convert an array representing the coefficients of a Hermite series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Hermite series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2herme

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import herme2poly
&gt;&gt;&gt; herme2poly([  2.,  10.,   2.,   3.])
array([ 0.,  1.,  2.,  3.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the Hermite series coefficients, ordered
from lowest order term to highest.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent polynomial
(relative to the "standard" basis) ordered from lowest order term
to highest.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.poly2herme" module_name="poly2herme" namespace="'polynomial|hermite_e'">
    <docstring>poly2herme(pol)

Convert a polynomial to a Hermite series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Hermite series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Hermite
    series.

See Also
--------
herme2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import poly2herme
&gt;&gt;&gt; poly2herme(np.arange(4))
array([  2.,  10.,   2.,   3.])</docstring>
    <inputPortSpec arg="pol" name="pol" port_type="basic:List" show_port="True">
      <docstring>1-D array containing the polynomial coefficients</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array containing the coefficients of the equivalent Hermite
series.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermefromroots" module_name="hermefromroots" namespace="'polynomial|hermite_e'">
    <docstring>Generate a HermiteE series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in HermiteE form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in HermiteE form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, hermfromroots,
chebfromroots.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermefromroots, hermeval
&gt;&gt;&gt; coef = hermefromroots((-1, 0, 1))
&gt;&gt;&gt; hermeval((-1, 0, 1), coef)
array([ 0.,  0.,  0.])
&gt;&gt;&gt; coef = hermefromroots((-1j, 1j))
&gt;&gt;&gt; hermeval((-1j, 1j), coef)
array([ 0.+0.j,  0.+0.j])</docstring>
    <inputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True">
      <docstring>Sequence containing the roots.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of coefficients.  If all roots are real then `out` is a
real array, if some of the roots are complex, then `out` is complex
even if all the coefficients in the result are real (see Examples
below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermevander" module_name="hermevander" namespace="'polynomial|hermite_e'">
    <docstring>Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = He_i(x),

where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the HermiteE polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and
``hermeval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of HermiteE series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding HermiteE polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermevander
&gt;&gt;&gt; x = np.array([-1, 0, 1])
&gt;&gt;&gt; hermevander(x, 3)
array([[ 1., -1.,  0.,  2.],
       [ 1.,  0., -1., -0.],
       [ 1.,  1.,  0., -2.]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of points. The dtype is converted to float64 or complex128
depending on whether any of the elements are complex. If `x` is
scalar it is converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the resulting matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander" name="vander" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-Vandermonde matrix. The shape of the returned matrix is
``x.shape + (deg + 1,)``, where The last index is the degree of the
corresponding HermiteE polynomial.  The dtype will be the same as
the converted `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermefit" module_name="hermefit" namespace="'polynomial|hermite_e'" output_type="list">
    <docstring>Least squares fit of Hermite series to data.

Return the coefficients of a HermiteE series of degree `deg` that is
the least squares fit to the data values `y` given at points `x`. If
`y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D
multiple fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Hermite coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebfit, legfit, polyfit, hermfit, polyfit
hermeval : Evaluates a Hermite series.
hermevander : pseudo Vandermonde matrix of Hermite series.
hermeweight : HermiteE weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the HermiteE series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c`
are the coefficients to be solved for, and the elements of `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using HermiteE series are probably most useful when the data can
be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the HermiteE
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `hermeweight`.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermefik, hermeval
&gt;&gt;&gt; x = np.linspace(-10, 10)
&gt;&gt;&gt; err = np.random.randn(len(x))/10
&gt;&gt;&gt; y = hermeval(x, [1, 2, 3]) + err
&gt;&gt;&gt; hermefit(x, y, 2)
array([ 1.01690445,  1.99951418,  2.99948696])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the M sample points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="yScalar" show_port="True">
      <docstring>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</docstring>
      <alternateSpec arg="y" name="ySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the fitting polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Weights. If not None, the contribution of each point
``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
weights are chosen so that the errors of the products ``w[i]*y[i]``
all have the same variance.  The default value is None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coef" name="coef" show_port="True" sort_key="0">
      <docstring>Hermite coefficients ordered from low to high. If `y` was 2-D,
the coefficients for the data in column k  of `y` are in column
`k`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[residuals" name="[residuals" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="singular_values" name="singular_values" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rcond]" name="rcond]" port_type="basic:List" show_port="True" sort_key="4">
      <docstring>These values are only returned if `full` = True

resid -- sum of squared residuals of the least squares fit
rank -- the numerical rank of the scaled Vandermonde matrix
sv -- singular values of the scaled Vandermonde matrix
rcond -- value of `rcond`.

For more details, see `linalg.lstsq`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermetrim" module_name="hermetrim" namespace="'polynomial|hermite_e'">
    <docstring>Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` &lt; 0

See Also
--------
trimseq

Examples
--------
&gt;&gt;&gt; from numpy import polynomial as P
&gt;&gt;&gt; P.trimcoef((0,0,3,0,5,0,0))
array([ 0.,  0.,  3.,  0.,  5.])
&gt;&gt;&gt; P.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([ 0.])
&gt;&gt;&gt; i = complex(0,1) # works for complex
&gt;&gt;&gt; P.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([ 0.0003+0.j   ,  0.0010-0.001j])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-d array of coefficients, ordered from lowest order to highest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Integer">
      <docstring>Trailing (i.e., highest order) elements with absolute value less
than or equal to `tol` (default value is zero) are removed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trimmed" name="trimmed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-d array with trailing zeros removed.  If the resulting series
would be empty, a series containing a single zero is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeroots" module_name="hermeroots" namespace="'polynomial|hermite_e'">
    <docstring>Compute the roots of a HermiteE series.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \sum_i c[i] * He_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, hermroots, chebroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The HermiteE series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeroots, hermefromroots
&gt;&gt;&gt; coef = hermefromroots([-1, 0, 1])
&gt;&gt;&gt; coef
array([ 0.,  2.,  0.,  1.])
&gt;&gt;&gt; hermeroots(coef)
array([-1.,  0.,  1.])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the roots of the series. If all the roots are real,
then `out` is also real, otherwise it is complex.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeval2d" module_name="hermeval2d" namespace="'polynomial|hermite_e'">
    <docstring>Evaluate a 2-D HermiteE series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * He_i(x) * He_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
hermeval, hermegrid2d, hermeval3d, hermegrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points `(x, y)`,
where `x` and `y` must have the same shape. If `x` or `y` is a list
or tuple, it is first converted to an ndarray, otherwise it is left
unchanged and if it isn't an ndarray it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term
of multi-degree i,j is contained in ``c[i,j]``. If `c` has
dimension greater than two the remaining indices enumerate multiple
sets of coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points formed with
pairs of corresponding values from `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeval3d" module_name="hermeval3d" namespace="'polynomial|hermite_e'">
    <docstring>Evaluate a 3-D Hermite_e series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
hermeval, hermeval2d, hermegrid2d, hermegrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points
`(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
any of `x`, `y`, or `z` is a list or tuple, it is first converted
to an ndarray, otherwise it is left unchanged and if it isn't an
ndarray it is  treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficient of the term of
multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
greater than 3 the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the multidimensional polynomial on points formed with
triples of corresponding values from `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermegrid2d" module_name="hermegrid2d" namespace="'polynomial|hermite_e'">
    <docstring>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * H_i(a) * H_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermeval, hermeval2d, hermeval3d, hermegrid3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The two dimensional series is evaluated at the points in the
Cartesian product of `x` and `y`.  If `x` or `y` is a list or
tuple, it is first converted to an ndarray, otherwise it is left
unchanged and, if it isn't an ndarray, it is treated as a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermegrid3d" module_name="hermegrid3d" namespace="'polynomial|hermite_e'">
    <docstring>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermeval, hermeval2d, hermegrid2d, hermeval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>The three dimensional series is evaluated at the points in the
Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
list or tuple, it is first converted to an ndarray, otherwise it is
left unchanged and, if it isn't an ndarray, it is treated as a
scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Array of coefficients ordered so that the coefficients for terms of
degree i,j are contained in ``c[i,j]``. If `c` has dimension
greater than two the remaining indices enumerate multiple sets of
coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values" name="values" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the two dimensional polynomial at points in the Cartesian
product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermevander2d" module_name="hermevander2d" namespace="'polynomial|hermite_e'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., deg[1]*i + j] = He_i(x) * He_j(y),

where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the HermiteE polynomials.

If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D HermiteE
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
hermevander, hermevander3d. hermeval2d, hermeval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes
will be converted to either float64 or complex128 depending on
whether any of the elements are complex. Scalars are converted to
1-D arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander2d" name="vander2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
as the converted `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermevander3d" module_name="hermevander3d" namespace="'polynomial|hermite_e'">
    <docstring>Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then Hehe pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),

where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the HermiteE polynomials.

If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D HermiteE
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
hermevander, hermevander3d. hermeval2d, hermeval3d

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Arrays of point coordinates, all of the same shape. The dtypes will
be converted to either float64 or complex128 depending on whether
any of the elements are complex. Scalars are converted to 1-D
arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deg" depth="1" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>List of maximum degrees of the form [x_deg, y_deg, z_deg].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vander3d" name="vander3d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape of the returned matrix is ``x.shape + (order,)``, where
:math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
be the same as the converted `x`, `y`, and `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermecompanion" module_name="hermecompanion" namespace="'polynomial|hermite_e'">
    <docstring>Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an HermiteE basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of HermiteE series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array of HermiteE series coefficients ordered from low to high
degree.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mat" name="mat" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Scaled companion matrix of dimensions (deg, deg).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermegauss" module_name="hermegauss" namespace="'polynomial|hermite_e'" output_type="list">
    <docstring>Gauss-HermiteE quadrature.

Computes the sample points and weights for Gauss-HermiteE quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-\inf, \inf]`
with the weight function :math:`f(x) = \exp(-x^2/2)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be &gt;= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded::1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`He_n`, and then scaling the results to get
the right value when integrating 1.</docstring>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Number of sample points and weights. It must be &gt;= 1.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D ndarray containing the sample points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>1-D ndarray containing the weights.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.hermeweight" module_name="hermeweight" namespace="'polynomial|hermite_e'">
    <docstring>Weight function of the Hermite_e polynomials.

The weight function is :math:`\exp(-x^2/2)` and the interval of
integration is :math:`[-\inf, \inf]`. the HermiteE polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded::1.7.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Values at which the weight function will be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The weight function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.allclose" module_name="allclose" namespace="'ma'">
    <docstring>Returns True if two arrays are element-wise equal within a tolerance.

This function is equivalent to `allclose` except that masked values
are treated as equal (default) or unequal, depending on the `masked_equal`
argument.

Parameters
----------
a, b : array_like
    Input arrays to compare.
masked_equal : bool, optional
    Whether masked values in `a` and `b` are considered equal (True) or not
    (False). They are considered equal by default.
rtol : float, optional
    Relative tolerance. The relative difference is equal to ``rtol * b``.
    Default is 1e-5.
atol : float, optional
    Absolute tolerance. The absolute difference is equal to `atol`.
    Default is 1e-8.

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN, then
    False is returned.

See Also
--------
all, any
numpy.allclose : the non-masked `allclose`.

Notes
-----
If the following equation is element-wise True, then `allclose` returns
True::

  absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))

Return True if all elements of `a` and `b` are equal subject to
given tolerances.

Examples
--------
&gt;&gt;&gt; a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
&gt;&gt;&gt; a
masked_array(data = [10000000000.0 1e-07 --],
             mask = [False False  True],
       fill_value = 1e+20)
&gt;&gt;&gt; b = ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
&gt;&gt;&gt; ma.allclose(a, b)
False

&gt;&gt;&gt; a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
&gt;&gt;&gt; b = ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
&gt;&gt;&gt; ma.allclose(a, b)
True
&gt;&gt;&gt; ma.allclose(a, b, masked_equal=False)
False

Masked values are not compared directly.

&gt;&gt;&gt; a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
&gt;&gt;&gt; b = ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
&gt;&gt;&gt; ma.allclose(a, b)
True
&gt;&gt;&gt; ma.allclose(a, b, masked_equal=False)
False</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="masked_equal" name="masked_equal" port_type="basic:Boolean">
      <docstring>Whether masked values in `a` and `b` are considered equal (True) or not
(False). They are considered equal by default.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>Relative tolerance. The relative difference is equal to ``rtol * b``.
Default is 1e-5.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>Absolute tolerance. The absolute difference is equal to `atol`.
Default is 1e-8.</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Returns True if the two arrays are equal within the given
tolerance, False otherwise. If either array contains NaN, then
False is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.allequal" module_name="allequal" namespace="'ma'">
    <docstring>Return True if all entries of a and b are equal, using
fill_value as a truth value where either or both are masked.

Parameters
----------
a, b : array_like
    Input arrays to compare.
fill_value : bool, optional
    Whether masked values in a or b are considered equal (True) or not
    (False).

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN,
    then False is returned.

See Also
--------
all, any
numpy.ma.allclose

Examples
--------
&gt;&gt;&gt; a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
&gt;&gt;&gt; a
masked_array(data = [10000000000.0 1e-07 --],
      mask = [False False  True],
      fill_value=1e+20)

&gt;&gt;&gt; b = array([1e10, 1e-7, -42.0])
&gt;&gt;&gt; b
array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
&gt;&gt;&gt; ma.allequal(a, b, fill_value=False)
False
&gt;&gt;&gt; ma.allequal(a, b)
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input arrays to compare.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Boolean">
      <docstring>Whether masked values in a or b are considered equal (True) or not
(False).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Returns True if the two arrays are equal within the given
tolerance, False otherwise. If either array contains NaN,
then False is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.amax" module_name="amax" namespace="'ma'">
    <docstring>Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array
3
&gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
&gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])

&gt;&gt;&gt; b = np.arange(5, dtype=np.float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amax(b)
nan
&gt;&gt;&gt; np.nanmax(b)
4.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which to operate.  By default, flattened input is
used.

.. versionadded: 1.7.0

If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="amax" name="amax" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Maximum of `a`. If `axis` is None, the result is a scalar value.
If `axis` is given, the result is an array of dimension
``a.ndim - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.amin" module_name="amin" namespace="'ma'">
    <docstring>Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array
0
&gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
&gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])

&gt;&gt;&gt; b = np.arange(5, dtype=np.float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amin(b)
nan
&gt;&gt;&gt; np.nanmin(b)
0.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which to operate.  By default, flattened input is
used.

.. versionadded: 1.7.0

If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="amin" name="amin" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Minimum of `a`. If `axis` is None, the result is a scalar value.
If `axis` is given, the result is an array of dimension
``a.ndim - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.append" module_name="append" namespace="'ma'">
    <docstring>Append values to the end of an array.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Values are appended to a copy of this array.
b : array_like
    These values are appended to a copy of `a`.  It must be of the
    correct shape (the same shape as `a`, excluding `axis`).  If `axis`
    is not specified, `b` can be any shape and will be flattened
    before use.
axis : int, optional
    The axis along which `v` are appended.  If `axis` is not given,
    both `a` and `b` are flattened before use.

Returns
-------
append : MaskedArray
    A copy of `a` with `b` appended to `axis`.  Note that `append`
    does not occur in-place: a new array is allocated and filled.  If
    `axis` is None, the result is a flattened array.

See Also
--------
numpy.append : Equivalent function in the top-level NumPy module.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.masked_values([1, 2, 3], 2)
&gt;&gt;&gt; b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
&gt;&gt;&gt; print(ma.append(a, b))
[1 -- 3 4 5 6 -- 8 9]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Values are appended to a copy of this array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>These values are appended to a copy of `a`.  It must be of the
correct shape (the same shape as `a`, excluding `axis`).  If `axis`
is not specified, `b` can be any shape and will be flattened
before use.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which `v` are appended.  If `axis` is not given,
both `a` and `b` are flattened before use.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="append" name="append" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A copy of `a` with `b` appended to `axis`.  Note that `append`
does not occur in-place: a new array is allocated and filled.  If
`axis` is None, the result is a flattened array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.argmax" module_name="argmax" namespace="'ma'">
    <docstring>Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    maximum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
index_array : {integer_array}

Examples
--------
&gt;&gt;&gt; a = np.arange(6).reshape(2,3)
&gt;&gt;&gt; a.argmax()
5
&gt;&gt;&gt; a.argmax(0)
array([1, 1, 1])
&gt;&gt;&gt; a.argmax(1)
array([2, 2])</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True">
      <docstring>If None, the index is into the flattened array, otherwise along
the specified axis</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value">
      <docstring>Value used to fill in the masked values.  If None, the output of
maximum_fill_value(self._data) is used instead.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['var']]</values>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the result can be placed. Its type is preserved
and it must be of the right shape to hold the output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="index_array" depth="1" name="index_array" port_type="basic:Integer" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.argmin" module_name="argmin" namespace="'ma'">
    <docstring>Return array of indices to the minimum values along the given axis.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    minimum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
ndarray or scalar
    If multi-dimension input, returns a new ndarray of indices to the
    minimum values along the given axis.  Otherwise, returns a scalar
    of index to the minimum values along the given axis.

Examples
--------
&gt;&gt;&gt; x = np.ma.array(arange(4), mask=[1,1,0,0])
&gt;&gt;&gt; x.shape = (2,2)
&gt;&gt;&gt; print x
[[-- --]
 [2 3]]
&gt;&gt;&gt; print x.argmin(axis=0, fill_value=-1)
[0 0]
&gt;&gt;&gt; print x.argmin(axis=0, fill_value=9)
[1 1]</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True">
      <docstring>If None, the index is into the flattened array, otherwise along
the specified axis</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value">
      <docstring>Value used to fill in the masked values.  If None, the output of
minimum_fill_value(self._data) is used instead.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['var']]</values>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the result can be placed. Its type is preserved
and it must be of the right shape to hold the output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>If multi-dimension input, returns a new ndarray of indices to the
minimum values along the given axis.  Otherwise, returns a scalar
of index to the minimum values along the given axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.argsort" module_name="argsort" namespace="'ma'">
    <docstring>Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
`fill_value`.

Parameters
----------
axis : int, optional
    Axis along which to sort.  The default is -1 (last axis).
    If None, the flattened array is used.
fill_value : var, optional
    Value used to fill the array before sorting.
    The default is the `fill_value` attribute of the input array.
kind : {'quicksort', 'mergesort', 'heapsort'}, optional
    Sorting algorithm.
order : list, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

Examples
--------
&gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])
&gt;&gt;&gt; a
masked_array(data = [3 2 --],
             mask = [False False  True],
       fill_value = 999999)
&gt;&gt;&gt; a.argsort()
array([1, 0, 2])</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to sort.  The default is -1 (last axis).
If None, the flattened array is used.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Variant">
      <docstring>Value used to fill the array before sorting.
The default is the `fill_value` attribute of the input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Sorting algorithm.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['quicksort', 'mergesort', 'heapsort']]</values>
      <defaults>['quicksort']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:List">
      <docstring>When `a` is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  Not all fields need be
specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="index_array" depth="1" name="index_array" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Array of indices that sort `a` along the specified axis.
In other words, ``a[index_array]`` yields a sorted `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.array" module_name="array" namespace="'ma'">
    <docstring>An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None,
                  copy=False, subok=True, ndmin=0, fill_value=None,
                  keep_mask=True, hard_mask=None, shrink=True)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mask" name="mask">
      <docstring>Mask. Must be convertible to an array of booleans with the same
shape as `data`. True indicates a masked (i.e. invalid) data.</docstring>
      <defaults>[False]</defaults>
      <alternateSpec arg="mask" name="maskSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the output.
If `dtype` is None, the type of the data argument (``data.dtype``)
is used. If `dtype` is not None and different from ``data.dtype``,
a copy is performed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>Whether to copy the input data (True), or to use a reference instead.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="subok" name="subok" port_type="basic:Boolean">
      <docstring>Whether to return a subclass of `MaskedArray` if possible (True) or a
plain `MaskedArray`. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndmin" name="ndmin" port_type="basic:Integer">
      <docstring>Minimum number of dimensions. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Float">
      <docstring>Value used to fill in the masked values when necessary.
If None, a default based on the data-type is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keep_mask" name="keep_mask" port_type="basic:Boolean">
      <docstring>Whether to combine `mask` with the mask of the input data, if any
(True), or to use only `mask` for the output (False). Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hard_mask" name="hard_mask" port_type="basic:Boolean">
      <docstring>Whether to use a hard mask or not. With a hard mask, masked values
cannot be unmasked. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to force compression of an empty mask. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.asanyarray" module_name="asanyarray" namespace="'ma'">
    <docstring>Convert the input to a masked array, conserving subclasses.

If `a` is a subclass of `MaskedArray`, its class is conserved.
No copy is performed if the input is already an `ndarray`.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    MaskedArray interpretation of `a`.

See Also
--------
asarray : Similar to `asanyarray`, but does not conserve subclass.

Examples
--------
&gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)
&gt;&gt;&gt; x
array([[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]])
&gt;&gt;&gt; np.ma.asanyarray(x)
masked_array(data =
 [[ 0.  1.  2.  3.  4.]
 [ 5.  6.  7.  8.  9.]],
             mask =
 False,
       fill_value = 1e+20)
&gt;&gt;&gt; type(np.ma.asanyarray(x))
&lt;class 'numpy.ma.core.MaskedArray'&gt;</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data, in any form that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>By default, the data-type is inferred from the input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to use row-major ('C') or column-major ('FORTRAN') memory
representation.  Default is 'C'.</docstring>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>MaskedArray interpretation of `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.asarray" module_name="asarray" namespace="'ma'">
    <docstring>Convert the input to a masked array of the given data-type.

No copy is performed if the input is already an `ndarray`. If `a` is
a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to a masked array. This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists, ndarrays and masked arrays.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    Masked array interpretation of `a`.

See Also
--------
asanyarray : Similar to `asarray`, but conserves subclasses.

Examples
--------
&gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)
&gt;&gt;&gt; x
array([[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]])
&gt;&gt;&gt; np.ma.asarray(x)
masked_array(data =
 [[ 0.  1.  2.  3.  4.]
 [ 5.  6.  7.  8.  9.]],
             mask =
 False,
       fill_value = 1e+20)
&gt;&gt;&gt; type(np.ma.asarray(x))
&lt;class 'numpy.ma.core.MaskedArray'&gt;</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data, in any form that can be converted to a masked array. This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists, ndarrays and masked arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>By default, the data-type is inferred from the input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to use row-major ('C') or column-major ('FORTRAN') memory
representation.  Default is 'C'.</docstring>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Masked array interpretation of `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.choose" module_name="choose" namespace="'ma'">
    <docstring>Use an index array to construct a new array from a set of choices.

Given an array of integers and a set of n choice arrays, this method
will create a new array that merges each of the choice arrays.  Where a
value in `a` is i, the new array will have the value that choices[i]
contains in the same place.

Parameters
----------
a : ndarray of ints
    This array must contain integers in ``[0, n-1]``, where n is the
    number of choices.
choices : sequence of arrays
    Choice arrays. The index array and all of the choices should be
    broadcastable to the same shape.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and `dtype`.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' : raise an error
    * 'wrap' : wrap around
    * 'clip' : clip to the range

Returns
-------
merged_array : array

See Also
--------
choose : equivalent function

Examples
--------
&gt;&gt;&gt; choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
&gt;&gt;&gt; a = np.array([2, 1, 0])
&gt;&gt;&gt; np.ma.choose(a, choice)
masked_array(data = [3 2 1],
      mask = False,
      fill_value=999999)</docstring>
    <inputPortSpec arg="a" depth="1" name="a" port_type="basic:Integer" show_port="True">
      <docstring>This array must contain integers in ``[0, n-1]``, where n is the
number of choices.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="choices" name="choices" port_type="basic:List" show_port="True">
      <docstring>Choice arrays. The index array and all of the choices should be
broadcastable to the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>If provided, the result will be inserted into this array. It should
be of the appropriate shape and `dtype`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Specifies how out-of-bounds indices will behave.

* 'raise' : raise an error
* 'wrap' : wrap around
* 'clip' : clip to the range</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['raise', 'wrap', 'clip']]</values>
      <defaults>['raise']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="indices" name="indices" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="merged_array" name="merged_array" port_type="basic:List" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.clip" module_name="clip" namespace="'ma'">
    <docstring>Clip (limit) the values in an array.

Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of ``[0, 1]``
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.

Parameters
----------
a : array_like
    Array containing elements to clip.
a_min : scalar or array_like
    Minimum value.
a_max : scalar or array_like
    Maximum value.  If `a_min` or `a_max` are array_like, then they will
    be broadcasted to the shape of `a`.
out : ndarray, optional
    The results will be placed in this array. It may be the input
    array for in-place clipping.  `out` must be of the right shape
    to hold the output.  Its type is preserved.

Returns
-------
clipped_array : ndarray
    An array with the elements of `a`, but where values
    &lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`
    with `a_max`.

See Also
--------
numpy.doc.ufuncs : Section "Output arguments"

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array containing elements to clip.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a_min" name="a_minScalar" port_type="basic:Float" show_port="True">
      <docstring>Minimum value.</docstring>
      <alternateSpec arg="a_min" name="a_minSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="a_max" name="a_maxScalar" port_type="basic:Float" show_port="True">
      <docstring>Maximum value.  If `a_min` or `a_max` are array_like, then they will
be broadcasted to the shape of `a`.</docstring>
      <alternateSpec arg="a_max" name="a_maxSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>The results will be placed in this array. It may be the input
array for in-place clipping.  `out` must be of the right shape
to hold the output.  Its type is preserved.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="clipped_array" name="clipped_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array with the elements of `a`, but where values
&lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`
with `a_max`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.common_fill_value" module_name="common_fill_value" namespace="'ma'">
    <docstring>Return the common filling value of two masked arrays, if any.

If ``a.fill_value == b.fill_value``, return the fill value,
otherwise return None.

Parameters
----------
a, b : MaskedArray
    The masked arrays for which to compare fill values.

Returns
-------
fill_value : scalar or None
    The common fill value, or None.

Examples
--------
&gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=3)
&gt;&gt;&gt; y = np.ma.array([0, 1.], fill_value=3)
&gt;&gt;&gt; np.ma.common_fill_value(x, y)
3.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>The masked arrays for which to compare fill values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True">
      <docstring>The masked arrays for which to compare fill values.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fill_value" name="fill_value" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The common fill value, or None.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.compressed" module_name="compressed" namespace="'ma'">
    <docstring>Return all the non-masked data as a 1-D array.

This function is equivalent to calling the "compressed" method of a
`MaskedArray`, see `MaskedArray.compressed` for details.

See Also
--------
MaskedArray.compressed
    Equivalent method.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.concatenate" module_name="concatenate" namespace="'ma'">
    <docstring>Concatenate a sequence of arrays along the given axis.

Parameters
----------
arrays : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined. Default is 0.

Returns
-------
result : MaskedArray
    The concatenated array with any masked entries preserved.

See Also
--------
numpy.concatenate : Equivalent function in the top-level NumPy module.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.arange(3)
&gt;&gt;&gt; a[1] = ma.masked
&gt;&gt;&gt; b = ma.arange(2, 5)
&gt;&gt;&gt; a
masked_array(data = [0 -- 2],
             mask = [False  True False],
       fill_value = 999999)
&gt;&gt;&gt; b
masked_array(data = [2 3 4],
             mask = False,
       fill_value = 999999)
&gt;&gt;&gt; ma.concatenate([a, b])
masked_array(data = [0 -- 2 2 3 4],
             mask = [False  True False False False False],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="arrays" name="arrays" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the arrays will be joined. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The concatenated array with any masked entries preserved.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.count" module_name="count" namespace="'ma'">
    <docstring>Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : int, optional
    Axis along which to count the non-masked elements. If `axis` is
    `None`, all non-masked elements are counted.

Returns
-------
result : int or ndarray
    If `axis` is `None`, an integer count is returned. When `axis` is
    not `None`, an array with shape determined by the lengths of the
    remaining axes, is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.arange(6).reshape((2, 3))
&gt;&gt;&gt; a[1, :] = ma.masked
&gt;&gt;&gt; a
masked_array(data =
 [[0 1 2]
 [-- -- --]],
             mask =
 [[False False False]
 [ True  True  True]],
       fill_value = 999999)
&gt;&gt;&gt; a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

&gt;&gt;&gt; a.count(axis=0)
array([1, 1, 1])
&gt;&gt;&gt; a.count(axis=1)
array([3, 0])</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to count the non-masked elements. If `axis` is
`None`, all non-masked elements are counted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="result" name="result" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>If `axis` is `None`, an integer count is returned. When `axis` is
not `None`, an array with shape determined by the lengths of the
remaining axes, is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.default_fill_value" module_name="default_fill_value" namespace="'ma'">
    <docstring>Return the default fill value for the argument object.

The default filling value depends on the datatype of the input
array or the type of the input scalar:

   ========  ========
   datatype  default
   ========  ========
   bool      True
   int       999999
   float     1.e20
   complex   1.e20+0j
   object    '?'
   string    'N/A'
   ========  ========


Parameters
----------
obj : ndarray, dtype or scalar
    The array data-type or scalar for which the default fill value
    is returned.

Returns
-------
fill_value : scalar
    The default fill value.

Examples
--------
&gt;&gt;&gt; np.ma.default_fill_value(1)
999999
&gt;&gt;&gt; np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
1e+20
&gt;&gt;&gt; np.ma.default_fill_value(np.dtype(complex))
(1e+20+0j)</docstring>
    <inputPortSpec arg="obj" name="objScalar" port_type="basic:Float" show_port="True">
      <docstring>The array data-type or scalar for which the default fill value
is returned.</docstring>
      <alternateSpec arg="obj" name="objSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="fill_value" name="fill_value" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The default fill value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.diag" module_name="diag" namespace="'ma'">
    <docstring>Extract a diagonal or construct a diagonal array.

This function is the equivalent of `numpy.diag` that takes masked
values into account, see `numpy.diag` for details.

See Also
--------
numpy.diag : Equivalent function for ndarrays.</docstring>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.diff" module_name="diff" namespace="'ma'">
    <docstring>Calculate the n-th order discrete difference along given axis.

The first order difference is given by ``out[n] = a[n+1] - a[n]`` along
the given axis, higher order differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced.
axis : int, optional
    The axis along which the difference is taken, default is the last axis.

Returns
-------
diff : ndarray
    The `n` order differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`.

See Also
--------
gradient, ediff1d, cumsum

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])
&gt;&gt;&gt; np.diff(x)
array([ 1,  2,  3, -7])
&gt;&gt;&gt; np.diff(x, n=2)
array([  1,   1, -10])

&gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
&gt;&gt;&gt; np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
&gt;&gt;&gt; np.diff(x, axis=0)
array([[-1,  2,  0, -2]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>The number of times values are differenced.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the difference is taken, default is the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="diff" name="diff" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The `n` order differences. The shape of the output is the same as `a`
except along `axis` where the dimension is smaller by `n`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.dump" module_name="dump" namespace="'ma'">
    <docstring>Pickle a masked array to a file.

This is a wrapper around ``cPickle.dump``.

Parameters
----------
a : MaskedArray
    The array to be pickled.
F : str or file-like object
    The file to pickle `a` to. If a string, the full path to the file.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>The array to be pickled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="F" name="FScalar" show_port="True">
      <docstring>The file to pickle `a` to. If a string, the full path to the file.</docstring>
      <alternateSpec arg="F" name="FSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.dumps" module_name="dumps" namespace="'ma'">
    <docstring>Return a string corresponding to the pickling of a masked array.

This is a wrapper around ``cPickle.dumps``.

Parameters
----------
a : MaskedArray
    The array for which the string representation of the pickle is
    returned.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>The array for which the string representation of the pickle is
returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.expand_dims" module_name="expand_dims" namespace="'ma'">
    <docstring>Expand the shape of an array.

Expands the shape of the array by including a new axis before the one
specified by the `axis` parameter. This function behaves the same as
`numpy.expand_dims` but preserves masked elements.

See Also
--------
numpy.expand_dims : Equivalent function in top-level NumPy module.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = ma.array([1, 2, 4])
&gt;&gt;&gt; x[1] = ma.masked
&gt;&gt;&gt; x
masked_array(data = [1 -- 4],
             mask = [False  True False],
       fill_value = 999999)
&gt;&gt;&gt; np.expand_dims(x, axis=0)
array([[1, 2, 4]])
&gt;&gt;&gt; ma.expand_dims(x, axis=0)
masked_array(data =
 [[1 -- 4]],
             mask =
 [[False  True False]],
       fill_value = 999999)

The same result can be achieved using slicing syntax with `np.newaxis`.

&gt;&gt;&gt; x[np.newaxis, :]
masked_array(data =
 [[1 -- 4]],
             mask =
 [[False  True False]],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.filled" module_name="filled" namespace="'ma'">
    <docstring>Return input as an array with masked data replaced by a fill value.

If `a` is not a `MaskedArray`, `a` itself is returned.
If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
``a.fill_value``.

Parameters
----------
a : MaskedArray or array_like
    An input object.
fill_value : scalar, optional
    Filling value. Default is None.

Returns
-------
a : ndarray
    The filled array.

See Also
--------
compressed

Examples
--------
&gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
&gt;&gt;&gt; x.filled()
array([[999999,      1,      2],
       [999999,      4,      5],
       [     6,      7,      8]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>An input object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Float">
      <docstring>Filling value. Default is None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filled array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.fix_invalid" module_name="fix_invalid" namespace="'ma'">
    <docstring>Return input with invalid data masked and replaced by a fill value.

Invalid data means values of `nan`, `inf`, etc.

Parameters
----------
a : array_like
    Input array, a (subclass of) ndarray.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
copy : bool, optional
    Whether to use a copy of `a` (True) or to fix `a` in place (False).
    Default is True.
fill_value : scalar, optional
    Value used for fixing invalid data. Default is None, in which case
    the ``a.fill_value`` is used.

Returns
-------
b : MaskedArray
    The input array with invalid entries fixed.

Notes
-----
A copy is performed by default.

Examples
--------
&gt;&gt;&gt; x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
&gt;&gt;&gt; x
masked_array(data = [-- -1.0 nan inf],
             mask = [ True False False False],
       fill_value = 1e+20)
&gt;&gt;&gt; np.ma.fix_invalid(x)
masked_array(data = [-- -1.0 -- --],
             mask = [ True False  True  True],
       fill_value = 1e+20)

&gt;&gt;&gt; fixed = np.ma.fix_invalid(x)
&gt;&gt;&gt; fixed.data
array([  1.00000000e+00,  -1.00000000e+00,   1.00000000e+20,
         1.00000000e+20])
&gt;&gt;&gt; x.data
array([  1.,  -1.,  NaN,  Inf])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, a (subclass of) ndarray.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mask" name="mask">
      <docstring>Mask. Must be convertible to an array of booleans with the same
shape as `data`. True indicates a masked (i.e. invalid) data.</docstring>
      <defaults>[False]</defaults>
      <alternateSpec arg="mask" name="maskSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>Whether to use a copy of `a` (True) or to fix `a` in place (False).
Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Float">
      <docstring>Value used for fixing invalid data. Default is None, in which case
the ``a.fill_value`` is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The input array with invalid entries fixed.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.flatten_mask" module_name="flatten_mask" namespace="'ma'">
    <docstring>Returns a completely flattened version of the mask, where nested fields
are collapsed.

Parameters
----------
mask : array_like
    Input array, which will be interpreted as booleans.

Returns
-------
flattened_mask : ndarray of bools
    The flattened input.

Examples
--------
&gt;&gt;&gt; mask = np.array([0, 0, 1], dtype=np.bool)
&gt;&gt;&gt; flatten_mask(mask)
array([False, False,  True], dtype=bool)

&gt;&gt;&gt; mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
&gt;&gt;&gt; flatten_mask(mask)
array([False, False, False,  True], dtype=bool)

&gt;&gt;&gt; mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
&gt;&gt;&gt; mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
&gt;&gt;&gt; flatten_mask(mask)
array([False, False, False, False, False,  True], dtype=bool)</docstring>
    <inputPortSpec arg="mask" name="mask" port_type="basic:List" show_port="True">
      <docstring>Input array, which will be interpreted as booleans.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="flattened_mask" depth="1" name="flattened_mask" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>The flattened input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.flatten_structured_array" module_name="flatten_structured_array" namespace="'ma'">
    <docstring>Flatten a structured array.

The data type of the output is chosen such that it can represent all of the
(nested) fields.

Parameters
----------
a : structured array

Returns
-------
output : masked array or ndarray
    A flattened masked array if the input is a masked array, otherwise a
    standard ndarray.

Examples
--------
&gt;&gt;&gt; ndtype = [('a', int), ('b', float)]
&gt;&gt;&gt; a = np.array([(1, 1), (2, 2)], dtype=ndtype)
&gt;&gt;&gt; flatten_structured_array(a)
array([[1., 1.],
       [2., 2.]])</docstring>
    <inputPortSpec arg="a" depth="1" name="a" show_port="True" />
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A flattened masked array if the input is a masked array, otherwise a
standard ndarray.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.fromflex" module_name="fromflex" namespace="'ma'">
    <docstring>Build a masked array from a suitable flexible-type array.

The input array has to have a data-type with ``_data`` and ``_mask``
fields. This type of array is output by `MaskedArray.toflex`.

Parameters
----------
fxarray : ndarray
    The structured input array, containing ``_data`` and ``_mask``
    fields. If present, other fields are discarded.

Returns
-------
result : MaskedArray
    The constructed masked array.

See Also
--------
MaskedArray.toflex : Build a flexible-type array from a masked array.

Examples
--------
&gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
&gt;&gt;&gt; rec = x.toflex()
&gt;&gt;&gt; rec
array([[(0, False), (1, True), (2, False)],
       [(3, True), (4, False), (5, True)],
       [(6, False), (7, True), (8, False)]],
      dtype=[('_data', '&lt;i4'), ('_mask', '|b1')])
&gt;&gt;&gt; x2 = np.ma.fromflex(rec)
&gt;&gt;&gt; x2
masked_array(data =
 [[0 -- 2]
 [-- 4 --]
 [6 -- 8]],
             mask =
 [[False  True False]
 [ True False  True]
 [False  True False]],
       fill_value = 999999)

Extra fields can be present in the structured array but are discarded:

&gt;&gt;&gt; dt = [('_data', '&lt;i4'), ('_mask', '|b1'), ('field3', '&lt;f4')]
&gt;&gt;&gt; rec2 = np.zeros((2, 2), dtype=dt)
&gt;&gt;&gt; rec2
array([[(0, False, 0.0), (0, False, 0.0)],
       [(0, False, 0.0), (0, False, 0.0)]],
      dtype=[('_data', '&lt;i4'), ('_mask', '|b1'), ('field3', '&lt;f4')])
&gt;&gt;&gt; y = np.ma.fromflex(rec2)
&gt;&gt;&gt; y
masked_array(data =
 [[0 0]
 [0 0]],
             mask =
 [[False False]
 [False False]],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="fxarray" name="fxarray" port_type="basic:List" show_port="True">
      <docstring>The structured input array, containing ``_data`` and ``_mask``
fields. If present, other fields are discarded.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The constructed masked array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.getdata" module_name="getdata" namespace="'ma'">
    <docstring>Return the data of a masked array as an ndarray.

Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
else return `a` as a ndarray or subclass (depending on `subok`) if not.

Parameters
----------
a : array_like
    Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
subok : bool
    Whether to force the output to be a `pure` ndarray (False) or to
    return a subclass of ndarray if appropriate (True, default).

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)
&gt;&gt;&gt; a
masked_array(data =
 [[1 --]
 [3 4]],
      mask =
 [[False  True]
 [False False]],
      fill_value=999999)
&gt;&gt;&gt; ma.getdata(a)
array([[1, 2],
       [3, 4]])

Equivalently use the ``MaskedArray`` `data` attribute.

&gt;&gt;&gt; a.data
array([[1, 2],
       [3, 4]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="subok" name="subok" port_type="basic:Boolean">
      <docstring>Whether to force the output to be a `pure` ndarray (False) or to
return a subclass of ndarray if appropriate (True, default).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.getmask" module_name="getmask" namespace="'ma'">
    <docstring>Return the mask of a masked array, or nomask.

Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
mask is not `nomask`, else return `nomask`. To guarantee a full array
of booleans of the same shape as a, use `getmaskarray`.

Parameters
----------
a : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getdata : Return the data of a masked array as an ndarray.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)
&gt;&gt;&gt; a
masked_array(data =
 [[1 --]
 [3 4]],
      mask =
 [[False  True]
 [False False]],
      fill_value=999999)
&gt;&gt;&gt; ma.getmask(a)
array([[False,  True],
       [False, False]], dtype=bool)

Equivalently use the `MaskedArray` `mask` attribute.

&gt;&gt;&gt; a.mask
array([[False,  True],
       [False, False]], dtype=bool)

Result when mask == `nomask`

&gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])
&gt;&gt;&gt; b
masked_array(data =
 [[1 2]
 [3 4]],
      mask =
 False,
      fill_value=999999)
&gt;&gt;&gt; ma.nomask
False
&gt;&gt;&gt; ma.getmask(b) == ma.nomask
True
&gt;&gt;&gt; b.mask == ma.nomask
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input `MaskedArray` for which the mask is required.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.getmaskarray" module_name="getmaskarray" namespace="'ma'">
    <docstring>Return the mask of a masked array, or full boolean array of False.

Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
the mask is not `nomask`, else return a full boolean array of False of
the same shape as `arr`.

Parameters
----------
arr : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getdata : Return the data of a masked array as an ndarray.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)
&gt;&gt;&gt; a
masked_array(data =
 [[1 --]
 [3 4]],
      mask =
 [[False  True]
 [False False]],
      fill_value=999999)
&gt;&gt;&gt; ma.getmaskarray(a)
array([[False,  True],
       [False, False]], dtype=bool)

Result when mask == ``nomask``

&gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])
&gt;&gt;&gt; b
masked_array(data =
 [[1 2]
 [3 4]],
      mask =
 False,
      fill_value=999999)
&gt;&gt;&gt; &gt;ma.getmaskarray(b)
array([[False, False],
       [False, False]], dtype=bool)</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input `MaskedArray` for which the mask is required.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.indices" module_name="indices" namespace="'ma'">
    <docstring>Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0,1,...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.

Returns
-------
grid : ndarray
    The array of grid indices,
    ``grid.shape = (len(dimensions),) + tuple(dimensions)``.

See Also
--------
mgrid, meshgrid

Notes
-----
The output shape is obtained by prepending the number of dimensions
in front of the tuple of dimensions, i.e. if `dimensions` is a tuple
``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N,r0,...,rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k,i0,i1,...,iN-1] = ik

Examples
--------
&gt;&gt;&gt; grid = np.indices((2, 3))
&gt;&gt;&gt; grid.shape
(2, 2, 3)
&gt;&gt;&gt; grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
&gt;&gt;&gt; grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

&gt;&gt;&gt; x = np.arange(20).reshape(5, 4)
&gt;&gt;&gt; row, col = np.indices((2, 3))
&gt;&gt;&gt; x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.</docstring>
    <inputPortSpec arg="dimensions" depth="1" name="dimensions" port_type="basic:Integer" show_port="True">
      <docstring>The shape of the grid.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the result.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="grid" name="grid" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array of grid indices,
``grid.shape = (len(dimensions),) + tuple(dimensions)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.inner" module_name="inner" namespace="'ma'">
    <docstring>inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions of must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r &gt; 0` and `ndim(b) = s &gt; 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2

A multidimensional example:

&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[ 7.,  0.],
       [ 0.,  7.]])

Notes
-----
Masked values are replaced by 0.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>If `a` and `b` are nonscalar, their last dimensions of must match.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>If `a` and `b` are nonscalar, their last dimensions of must match.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`out.shape = a.shape[:-1] + b.shape[:-1]`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.innerproduct" module_name="innerproduct" namespace="'ma'">
    <docstring>inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions of must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r &gt; 0` and `ndim(b) = s &gt; 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2

A multidimensional example:

&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[ 7.,  0.],
       [ 0.,  7.]])

Notes
-----
Masked values are replaced by 0.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>If `a` and `b` are nonscalar, their last dimensions of must match.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>If `a` and `b` are nonscalar, their last dimensions of must match.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`out.shape = a.shape[:-1] + b.shape[:-1]`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.isMA" module_name="isMA" namespace="'ma'">
    <docstring>Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.eye(3, 3)
&gt;&gt;&gt; a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; m = ma.masked_values(a, 0)
&gt;&gt;&gt; m
masked_array(data =
 [[1.0 -- --]
 [-- 1.0 --]
 [-- -- 1.0]],
      mask =
 [[False  True  True]
 [ True False  True]
 [ True  True False]],
      fill_value=0.0)
&gt;&gt;&gt; ma.isMaskedArray(a)
False
&gt;&gt;&gt; ma.isMaskedArray(m)
True
&gt;&gt;&gt; ma.isMaskedArray([0, 1, 2])
False</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Object to test.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if `x` is a MaskedArray.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.isMaskedArray" module_name="isMaskedArray" namespace="'ma'">
    <docstring>Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.eye(3, 3)
&gt;&gt;&gt; a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; m = ma.masked_values(a, 0)
&gt;&gt;&gt; m
masked_array(data =
 [[1.0 -- --]
 [-- 1.0 --]
 [-- -- 1.0]],
      mask =
 [[False  True  True]
 [ True False  True]
 [ True  True False]],
      fill_value=0.0)
&gt;&gt;&gt; ma.isMaskedArray(a)
False
&gt;&gt;&gt; ma.isMaskedArray(m)
True
&gt;&gt;&gt; ma.isMaskedArray([0, 1, 2])
False</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Object to test.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if `x` is a MaskedArray.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.is_mask" module_name="is_mask" namespace="'ma'">
    <docstring>Return True if m is a valid, standard mask.

This function does not check the contents of the input, only that the
type is MaskType. In particular, this function returns False if the
mask has a flexible dtype.

Parameters
----------
m : array_like
    Array to test.

Returns
-------
result : bool
    True if `m.dtype.type` is MaskType, False otherwise.

See Also
--------
isMaskedArray : Test whether input is an instance of MaskedArray.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; m = ma.masked_equal([0, 1, 0, 2, 3], 0)
&gt;&gt;&gt; m
masked_array(data = [-- 1 -- 2 3],
      mask = [ True False  True False False],
      fill_value=999999)
&gt;&gt;&gt; ma.is_mask(m)
False
&gt;&gt;&gt; ma.is_mask(m.mask)
True

Input must be an ndarray (or have similar attributes)
for it to be considered a valid mask.

&gt;&gt;&gt; m = [False, True, False]
&gt;&gt;&gt; ma.is_mask(m)
False
&gt;&gt;&gt; m = np.array([False, True, False])
&gt;&gt;&gt; m
array([False,  True, False], dtype=bool)
&gt;&gt;&gt; ma.is_mask(m)
True

Arrays with complex dtypes don't return True.

&gt;&gt;&gt; dtype = np.dtype({'names':['monty', 'pithon'],
                      'formats':[np.bool, np.bool]})
&gt;&gt;&gt; dtype
dtype([('monty', '|b1'), ('pithon', '|b1')])
&gt;&gt;&gt; m = np.array([(True, False), (False, True), (True, False)],
                 dtype=dtype)
&gt;&gt;&gt; m
array([(True, False), (False, True), (True, False)],
      dtype=[('monty', '|b1'), ('pithon', '|b1')])
&gt;&gt;&gt; ma.is_mask(m)
False</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Array to test.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if `m.dtype.type` is MaskType, False otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.is_masked" module_name="is_masked" namespace="'ma'">
    <docstring>Determine whether input has masked values.

Accepts any object as input, but always returns False unless the
input is a MaskedArray containing masked values.

Parameters
----------
x : array_like
    Array to check for masked values.

Returns
-------
result : bool
    True if `x` is a MaskedArray with masked values, False otherwise.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 0)
&gt;&gt;&gt; x
masked_array(data = [-- 1 -- 2 3],
      mask = [ True False  True False False],
      fill_value=999999)
&gt;&gt;&gt; ma.is_masked(x)
True
&gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 42)
&gt;&gt;&gt; x
masked_array(data = [0 1 0 2 3],
      mask = False,
      fill_value=999999)
&gt;&gt;&gt; ma.is_masked(x)
False

Always returns False if `x` isn't a MaskedArray.

&gt;&gt;&gt; x = [False, True, False]
&gt;&gt;&gt; ma.is_masked(x)
False
&gt;&gt;&gt; x = 'a string'
&gt;&gt;&gt; ma.is_masked(x)
False</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array to check for masked values.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if `x` is a MaskedArray with masked values, False otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.isarray" module_name="isarray" namespace="'ma'">
    <docstring>Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.eye(3, 3)
&gt;&gt;&gt; a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; m = ma.masked_values(a, 0)
&gt;&gt;&gt; m
masked_array(data =
 [[1.0 -- --]
 [-- 1.0 --]
 [-- -- 1.0]],
      mask =
 [[False  True  True]
 [ True False  True]
 [ True  True False]],
      fill_value=0.0)
&gt;&gt;&gt; ma.isMaskedArray(a)
False
&gt;&gt;&gt; ma.isMaskedArray(m)
True
&gt;&gt;&gt; ma.isMaskedArray([0, 1, 2])
False</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Object to test.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if `x` is a MaskedArray.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.left_shift" module_name="left_shift" namespace="'ma'">
    <docstring>Shift the bits of an integer to the left.

This is the masked array version of `numpy.left_shift`, for details
see that function.

See Also
--------
numpy.left_shift</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.load" module_name="load" namespace="'ma'">
    <docstring>Wrapper around ``cPickle.load`` which accepts either a file-like object
or a filename.

Parameters
----------
F : str or file
    The file or file name to load.

See Also
--------
dump : Pickle an array

Notes
-----
This is different from `numpy.load`, which does not use cPickle but loads
the NumPy binary .npy format.</docstring>
    <inputPortSpec arg="F" name="F" show_port="True">
      <docstring>The file or file name to load.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.loads" module_name="loads" namespace="'ma'">
    <docstring>Load a pickle from the current string.

The result of ``cPickle.loads(strg)`` is returned.

Parameters
----------
strg : str
    The string to load.

See Also
--------
dumps : Return a string corresponding to the pickling of a masked array.</docstring>
    <inputPortSpec arg="strg" name="strg" show_port="True">
      <docstring>The string to load.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.make_mask" module_name="make_mask" namespace="'ma'">
    <docstring>Create a boolean mask from an array.

Return `m` as a boolean mask, creating a copy if necessary or requested.
The function can accept any sequence that is convertible to integers,
or ``nomask``.  Does not require that contents must be 0s and 1s, values
of 0 are interepreted as False, everything else as True.

Parameters
----------
m : array_like
    Potential mask.
copy : bool, optional
    Whether to return a copy of `m` (True) or `m` itself (False).
shrink : bool, optional
    Whether to shrink `m` to ``nomask`` if all its values are False.
dtype : dtype, optional
    Data-type of the output mask. By default, the output mask has
    a dtype of MaskType (bool). If the dtype is flexible, each field
    has a boolean dtype.

Returns
-------
result : ndarray
    A boolean mask derived from `m`.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; m = [True, False, True, True]
&gt;&gt;&gt; ma.make_mask(m)
array([ True, False,  True,  True], dtype=bool)
&gt;&gt;&gt; m = [1, 0, 1, 1]
&gt;&gt;&gt; ma.make_mask(m)
array([ True, False,  True,  True], dtype=bool)
&gt;&gt;&gt; m = [1, 0, 2, -3]
&gt;&gt;&gt; ma.make_mask(m)
array([ True, False,  True,  True], dtype=bool)

Effect of the `shrink` parameter.

&gt;&gt;&gt; m = np.zeros(4)
&gt;&gt;&gt; m
array([ 0.,  0.,  0.,  0.])
&gt;&gt;&gt; ma.make_mask(m)
False
&gt;&gt;&gt; ma.make_mask(m, shrink=False)
array([False, False, False, False], dtype=bool)

Using a flexible `dtype`.

&gt;&gt;&gt; m = [1, 0, 1, 1]
&gt;&gt;&gt; n = [0, 1, 0, 0]
&gt;&gt;&gt; arr = []
&gt;&gt;&gt; for man, mouse in zip(m, n):
...     arr.append((man, mouse))
&gt;&gt;&gt; arr
[(1, 0), (0, 1), (1, 0), (1, 0)]
&gt;&gt;&gt; dtype = np.dtype({'names':['man', 'mouse'],
                      'formats':[np.int, np.int]})
&gt;&gt;&gt; arr = np.array(arr, dtype=dtype)
&gt;&gt;&gt; arr
array([(1, 0), (0, 1), (1, 0), (1, 0)],
      dtype=[('man', '&lt;i4'), ('mouse', '&lt;i4')])
&gt;&gt;&gt; ma.make_mask(arr, dtype=dtype)
array([(True, False), (False, True), (True, False), (True, False)],
      dtype=[('man', '|b1'), ('mouse', '|b1')])</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Potential mask.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>Whether to return a copy of `m` (True) or `m` itself (False).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to shrink `m` to ``nomask`` if all its values are False.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data-type of the output mask. By default, the output mask has
a dtype of MaskType (bool). If the dtype is flexible, each field
has a boolean dtype.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A boolean mask derived from `m`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.make_mask_descr" module_name="make_mask_descr" namespace="'ma'">
    <docstring>Construct a dtype description list from a given dtype.

Returns a new dtype object, with the type of all fields in `ndtype` to a
boolean type. Field names are not altered.

Parameters
----------
ndtype : dtype
    The dtype to convert.

Returns
-------
result : dtype
    A dtype that looks like `ndtype`, the type of all fields is boolean.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; dtype = np.dtype({'names':['foo', 'bar'],
                      'formats':[np.float32, np.int]})
&gt;&gt;&gt; dtype
dtype([('foo', '&lt;f4'), ('bar', '&lt;i4')])
&gt;&gt;&gt; ma.make_mask_descr(dtype)
dtype([('foo', '|b1'), ('bar', '|b1')])
&gt;&gt;&gt; ma.make_mask_descr(np.float32)
&lt;type 'numpy.bool_'&gt;</docstring>
    <inputPortSpec arg="ndtype" name="ndtype" port_type="basic:Variant" show_port="True">
      <docstring>The dtype to convert.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A dtype that looks like `ndtype`, the type of all fields is boolean.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.make_mask_none" module_name="make_mask_none" namespace="'ma'">
    <docstring>Return a boolean mask of the given shape, filled with False.

This function returns a boolean ndarray with all entries False, that can
be used in common mask manipulations. If a complex dtype is specified, the
type of each field is converted to a boolean type.

Parameters
----------
newshape : tuple
    A tuple indicating the shape of the mask.
dtype : {None, dtype}, optional
    If None, use a MaskType instance. Otherwise, use a new datatype with
    the same fields as `dtype`, converted to boolean types.

Returns
-------
result : ndarray
    An ndarray of appropriate shape and dtype, filled with False.

See Also
--------
make_mask : Create a boolean mask from an array.
make_mask_descr : Construct a dtype description list from a given dtype.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; ma.make_mask_none((3,))
array([False, False, False], dtype=bool)

Defining a more complex dtype.

&gt;&gt;&gt; dtype = np.dtype({'names':['foo', 'bar'],
                      'formats':[np.float32, np.int]})
&gt;&gt;&gt; dtype
dtype([('foo', '&lt;f4'), ('bar', '&lt;i4')])
&gt;&gt;&gt; ma.make_mask_none((3,), dtype=dtype)
array([(False, False), (False, False), (False, False)],
      dtype=[('foo', '|b1'), ('bar', '|b1')])</docstring>
    <inputPortSpec arg="newshape" name="newshape" port_type="basic:List" show_port="True">
      <docstring>A tuple indicating the shape of the mask.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype">
      <docstring>If None, use a MaskType instance. Otherwise, use a new datatype with
the same fields as `dtype`, converted to boolean types.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dtype']]</values>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An ndarray of appropriate shape and dtype, filled with False.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.mask_or" module_name="mask_or" namespace="'ma'">
    <docstring>Combine two masks with the ``logical_or`` operator.

The result may be a view on `m1` or `m2` if the other is `nomask`
(i.e. False).

Parameters
----------
m1, m2 : array_like
    Input masks.
copy : bool, optional
    If copy is False and one of the inputs is `nomask`, return a view
    of the other input mask. Defaults to False.
shrink : bool, optional
    Whether to shrink the output to `nomask` if all its values are
    False. Defaults to True.

Returns
-------
mask : output mask
    The result masks values that are masked in either `m1` or `m2`.

Raises
------
ValueError
    If `m1` and `m2` have different flexible dtypes.

Examples
--------
&gt;&gt;&gt; m1 = np.ma.make_mask([0, 1, 1, 0])
&gt;&gt;&gt; m2 = np.ma.make_mask([1, 0, 0, 0])
&gt;&gt;&gt; np.ma.mask_or(m1, m2)
array([ True,  True,  True, False], dtype=bool)</docstring>
    <inputPortSpec arg="m1" name="m1" port_type="basic:List" show_port="True">
      <docstring>Input masks.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m2" name="m2" port_type="basic:List" show_port="True">
      <docstring>Input masks.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>If copy is False and one of the inputs is `nomask`, return a view
of the other input mask. Defaults to False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to shrink the output to `nomask` if all its values are
False. Defaults to True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="mask" name="mask" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The result masks values that are masked in either `m1` or `m2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_equal" module_name="masked_equal" namespace="'ma'">
    <docstring>Mask an array where equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x == value).  For floating point arrays,
consider using ``masked_values(x, value)``.

See Also
--------
masked_where : Mask where a condition is met.
masked_values : Mask using floating point equality.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_equal(a, 2)
masked_array(data = [0 1 -- 3],
      mask = [False False  True False],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_greater" module_name="masked_greater" namespace="'ma'">
    <docstring>Mask an array where greater than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x &gt; value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_greater(a, 2)
masked_array(data = [0 1 2 --],
      mask = [False False False  True],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_greater_equal" module_name="masked_greater_equal" namespace="'ma'">
    <docstring>Mask an array where greater than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x &gt;= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_greater_equal(a, 2)
masked_array(data = [0 1 -- --],
      mask = [False False  True  True],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_inside" module_name="masked_inside" namespace="'ma'">
    <docstring>Mask an array inside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` inside
the interval [v1,v2] (v1 &lt;= x &lt;= v2).  The boundaries `v1` and `v2`
can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
&gt;&gt;&gt; ma.masked_inside(x, -0.3, 0.3)
masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],
      mask = [False False  True  True False False],
      fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

&gt;&gt;&gt; ma.masked_inside(x, 0.3, -0.3)
masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],
      mask = [False False  True  True False False],
      fill_value=1e+20)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v2" name="v2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="v1" name="v1" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_invalid" module_name="masked_invalid" namespace="'ma'">
    <docstring>Mask an array where invalid values occur (NaNs or infs).

This function is a shortcut to ``masked_where``, with
`condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
Only applies to arrays with a dtype where NaNs or infs make sense
(i.e. floating point types), but accepts any array_like object.

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(5, dtype=np.float)
&gt;&gt;&gt; a[2] = np.NaN
&gt;&gt;&gt; a[3] = np.PINF
&gt;&gt;&gt; a
array([  0.,   1.,  NaN,  Inf,   4.])
&gt;&gt;&gt; ma.masked_invalid(a)
masked_array(data = [0.0 1.0 -- -- 4.0],
      mask = [False False  True  True False],
      fill_value=1e+20)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_less" module_name="masked_less" namespace="'ma'">
    <docstring>Mask an array where less than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x &lt; value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_less(a, 2)
masked_array(data = [-- -- 2 3],
      mask = [ True  True False False],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_less_equal" module_name="masked_less_equal" namespace="'ma'">
    <docstring>Mask an array where less than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x &lt;= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_less_equal(a, 2)
masked_array(data = [-- -- -- 3],
      mask = [ True  True  True False],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_not_equal" module_name="masked_not_equal" namespace="'ma'">
    <docstring>Mask an array where `not` equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x != value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_not_equal(a, 2)
masked_array(data = [-- -- 2 --],
      mask = [ True  True False  True],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_object" module_name="masked_object" namespace="'ma'">
    <docstring>Mask the array `x` where the data are exactly equal to value.

This function is similar to `masked_values`, but only suitable
for object arrays: for floating point, use `masked_values` instead.

Parameters
----------
x : array_like
    Array to mask
value : object
    Comparison value
copy : {True, False}, optional
    Whether to return a copy of `x`.
shrink : {True, False}, optional
    Whether to collapse a mask full of False to nomask

Returns
-------
result : MaskedArray
    The result of masking `x` where equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).
masked_values : Mask using floating point equality.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; food = np.array(['green_eggs', 'ham'], dtype=object)
&gt;&gt;&gt; # don't eat spoiled food
&gt;&gt;&gt; eat = ma.masked_object(food, 'green_eggs')
&gt;&gt;&gt; print eat
[-- ham]
&gt;&gt;&gt; # plain ol` ham is boring
&gt;&gt;&gt; fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
&gt;&gt;&gt; eat = ma.masked_object(fresh_food, 'green_eggs')
&gt;&gt;&gt; print eat
[cheese ham pineapple]

Note that `mask` is set to ``nomask`` if possible.

&gt;&gt;&gt; eat
masked_array(data = [cheese ham pineapple],
      mask = False,
      fill_value=?)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array to mask</docstring>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:List" show_port="True">
      <docstring>Comparison value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>Whether to return a copy of `x`.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to collapse a mask full of False to nomask</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The result of masking `x` where equal to `value`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_outside" module_name="masked_outside" namespace="'ma'">
    <docstring>Mask an array outside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` outside
the interval [v1,v2] (x &lt; v1)|(x &gt; v2).
The boundaries `v1` and `v2` can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
&gt;&gt;&gt; ma.masked_outside(x, -0.3, 0.3)
masked_array(data = [-- -- 0.01 0.2 -- --],
      mask = [ True  True False False  True  True],
      fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

&gt;&gt;&gt; ma.masked_outside(x, 0.3, -0.3)
masked_array(data = [-- -- 0.01 0.2 -- --],
      mask = [ True  True False False  True  True],
      fill_value=1e+20)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v2" name="v2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="v1" name="v1" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_values" module_name="masked_values" namespace="'ma'">
    <docstring>Mask using floating point equality.

Return a MaskedArray, masked where the data in array `x` are approximately
equal to `value`, i.e. where the following condition is True

(abs(x - value) &lt;= atol+rtol*abs(value))

The fill_value is set to `value` and the mask is set to ``nomask`` if
possible.  For integers, consider using ``masked_equal``.

Parameters
----------
x : array_like
    Array to mask.
value : float
    Masking value.
rtol : float, optional
    Tolerance parameter.
atol : float, optional
    Tolerance parameter (1e-8).
copy : bool, optional
    Whether to return a copy of `x`.
shrink : bool, optional
    Whether to collapse a mask full of False to ``nomask``.

Returns
-------
result : MaskedArray
    The result of masking `x` where approximately equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = np.array([1, 1.1, 2, 1.1, 3])
&gt;&gt;&gt; ma.masked_values(x, 1.1)
masked_array(data = [1.0 -- 2.0 -- 3.0],
      mask = [False  True False  True False],
      fill_value=1.1)

Note that `mask` is set to ``nomask`` if possible.

&gt;&gt;&gt; ma.masked_values(x, 1.5)
masked_array(data = [ 1.   1.1  2.   1.1  3. ],
      mask = False,
      fill_value=1.5)

For integers, the fill value will be different in general to the
result of ``masked_equal``.

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; x
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; ma.masked_values(x, 2)
masked_array(data = [0 1 -- 3 4],
      mask = [False False  True False False],
      fill_value=2)
&gt;&gt;&gt; ma.masked_equal(x, 2)
masked_array(data = [0 1 -- 3 4],
      mask = [False False  True False False],
      fill_value=999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array to mask.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="value" name="value" port_type="basic:Float" show_port="True">
      <docstring>Masking value.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>Tolerance parameter.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>Tolerance parameter (1e-8).</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>Whether to return a copy of `x`.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to collapse a mask full of False to ``nomask``.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The result of masking `x` where approximately equal to `value`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_where" module_name="masked_where" namespace="'ma'">
    <docstring>Mask an array where a condition is met.

Return `a` as an array masked where `condition` is True.
Any masked values of `a` or `condition` are also masked in the output.

Parameters
----------
condition : array_like
    Masking condition.  When `condition` tests floating point values for
    equality, consider using ``masked_values`` instead.
a : array_like
    Array to mask.
copy : bool
    If True (default) make a copy of `a` in the result.  If False modify
    `a` in place and return a view.

Returns
-------
result : MaskedArray
    The result of masking `a` where `condition` is True.

See Also
--------
masked_values : Mask using floating point equality.
masked_equal : Mask where equal to a given value.
masked_not_equal : Mask where `not` equal to a given value.
masked_less_equal : Mask where less than or equal to a given value.
masked_greater_equal : Mask where greater than or equal to a given value.
masked_less : Mask where less than a given value.
masked_greater : Mask where greater than a given value.
masked_inside : Mask inside a given interval.
masked_outside : Mask outside a given interval.
masked_invalid : Mask invalid values (NaNs or infs).

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; ma.masked_where(a &lt;= 2, a)
masked_array(data = [-- -- -- 3],
      mask = [ True  True  True False],
      fill_value=999999)

Mask array `b` conditional on `a`.

&gt;&gt;&gt; b = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; ma.masked_where(a == 2, b)
masked_array(data = [a b -- d],
      mask = [False False  True False],
      fill_value=N/A)

Effect of the `copy` argument.

&gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a)
&gt;&gt;&gt; c
masked_array(data = [-- -- -- 3],
      mask = [ True  True  True False],
      fill_value=999999)
&gt;&gt;&gt; c[0] = 99
&gt;&gt;&gt; c
masked_array(data = [99 -- -- 3],
      mask = [False  True  True False],
      fill_value=999999)
&gt;&gt;&gt; a
array([0, 1, 2, 3])
&gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a, copy=False)
&gt;&gt;&gt; c[0] = 99
&gt;&gt;&gt; c
masked_array(data = [99 -- -- 3],
      mask = [False  True  True False],
      fill_value=999999)
&gt;&gt;&gt; a
array([99,  1,  2,  3])

When `condition` or `a` contain masked values.

&gt;&gt;&gt; a = np.arange(4)
&gt;&gt;&gt; a = ma.masked_where(a == 2, a)
&gt;&gt;&gt; a
masked_array(data = [0 1 -- 3],
      mask = [False False  True False],
      fill_value=999999)
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; b = ma.masked_where(b == 0, b)
&gt;&gt;&gt; b
masked_array(data = [-- 1 2 3],
      mask = [ True False False False],
      fill_value=999999)
&gt;&gt;&gt; ma.masked_where(a == 3, b)
masked_array(data = [-- 1 -- --],
      mask = [ True False  True  True],
      fill_value=999999)</docstring>
    <inputPortSpec arg="condition" name="condition" port_type="basic:List" show_port="True">
      <docstring>Masking condition.  When `condition` tests floating point values for
equality, consider using ``masked_values`` instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to mask.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>If True (default) make a copy of `a` in the result.  If False modify
`a` in place and return a view.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The result of masking `a` where `condition` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.max" module_name="max" namespace="'ma'">
    <docstring>Return the maximum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of maximum_fill_value().

Returns
-------
amax : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
maximum_fill_value
    Returns the maximum filling value for a given datatype.</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to operate.  By default, ``axis`` is None and the
flattened input is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value">
      <docstring>Value used to fill in the masked values.
If None, use the output of maximum_fill_value().</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['var']]</values>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="amax" name="amax" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>New array holding the result.
If ``out`` was specified, ``out`` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.maximum_fill_value" module_name="maximum_fill_value" namespace="'ma'">
    <docstring>Return the minimum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the maximum of an array with a given dtype.

Parameters
----------
obj : {ndarray, dtype}
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The minimum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
minimum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.int8()
&gt;&gt;&gt; ma.maximum_fill_value(a)
-128
&gt;&gt;&gt; a = np.int32()
&gt;&gt;&gt; ma.maximum_fill_value(a)
-2147483648

An array of numeric data can also be passed.

&gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)
&gt;&gt;&gt; ma.maximum_fill_value(a)
-128
&gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)
&gt;&gt;&gt; ma.maximum_fill_value(a)
-inf</docstring>
    <inputPortSpec arg="obj" name="objScalar" show_port="True">
      <docstring>An object that can be queried for it's numeric type.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dtype']]</values>
      <alternateSpec arg="obj" name="objSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="val" name="val" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The minimum representable value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.min" module_name="min" namespace="'ma'">
    <docstring>Return the minimum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must be of
    the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of `minimum_fill_value`.

Returns
-------
amin : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
minimum_fill_value
    Returns the minimum filling value for a given datatype.</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to operate.  By default, ``axis`` is None and the
flattened input is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must be of
the same shape and buffer length as the expected output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value">
      <docstring>Value used to fill in the masked values.
If None, use the output of `minimum_fill_value`.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['var']]</values>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="amin" name="amin" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>New array holding the result.
If ``out`` was specified, ``out`` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.minimum_fill_value" module_name="minimum_fill_value" namespace="'ma'">
    <docstring>Return the maximum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the minimum of an array with a given dtype.

Parameters
----------
obj : ndarray or dtype
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The maximum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
maximum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.int8()
&gt;&gt;&gt; ma.minimum_fill_value(a)
127
&gt;&gt;&gt; a = np.int32()
&gt;&gt;&gt; ma.minimum_fill_value(a)
2147483647

An array of numeric data can also be passed.

&gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)
&gt;&gt;&gt; ma.minimum_fill_value(a)
127
&gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)
&gt;&gt;&gt; ma.minimum_fill_value(a)
inf</docstring>
    <inputPortSpec arg="obj" name="objScalar" show_port="True">
      <docstring>An object that can be queried for it's numeric type.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dtype']]</values>
      <alternateSpec arg="obj" name="objSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="val" name="val" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The maximum representable value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.ndim" module_name="ndim" namespace="'ma'">
    <docstring>Return the number of dimensions of an array.

Parameters
----------
a : array_like
    Input array.  If it is not already an ndarray, a conversion is
    attempted.

Returns
-------
number_of_dimensions : int
    The number of dimensions in `a`.  Scalars are zero-dimensional.

See Also
--------
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
&gt;&gt;&gt; np.ndim([[1,2,3],[4,5,6]])
2
&gt;&gt;&gt; np.ndim(np.array([[1,2,3],[4,5,6]]))
2
&gt;&gt;&gt; np.ndim(1)
0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.  If it is not already an ndarray, a conversion is
attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="number_of_dimensions" name="number_of_dimensions" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of dimensions in `a`.  Scalars are zero-dimensional.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.outer" module_name="outer" namespace="'ma'">
    <docstring>Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner, einsum

References
----------
.. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a (*very* coarse) grid for computing a Mandelbrot set:

&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
&gt;&gt;&gt; rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
&gt;&gt;&gt; im
array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
&gt;&gt;&gt; grid = rl + im
&gt;&gt;&gt; grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a "vector" of letters:

&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)
&gt;&gt;&gt; np.outer(x, [1, 2, 3])
array([[a, aa, aaa],
       [b, bb, bbb],
       [c, cc, ccc]], dtype=object)



Notes
-----
Masked values are replaced by 0.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First input vector.  Input is flattened if
not already 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second input vector.  Input is flattened if
not already 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>A location where the result is stored

.. versionadded:: 1.9.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>``out[i, j] = a[i] * b[j]``</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.outerproduct" module_name="outerproduct" namespace="'ma'">
    <docstring>Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner, einsum

References
----------
.. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a (*very* coarse) grid for computing a Mandelbrot set:

&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
&gt;&gt;&gt; rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
&gt;&gt;&gt; im
array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
&gt;&gt;&gt; grid = rl + im
&gt;&gt;&gt; grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a "vector" of letters:

&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)
&gt;&gt;&gt; np.outer(x, [1, 2, 3])
array([[a, aa, aaa],
       [b, bb, bbb],
       [c, cc, ccc]], dtype=object)



Notes
-----
Masked values are replaced by 0.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First input vector.  Input is flattened if
not already 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second input vector.  Input is flattened if
not already 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>A location where the result is stored

.. versionadded:: 1.9.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>``out[i, j] = a[i] * b[j]``</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.power" module_name="power" namespace="'ma'">
    <docstring>Returns element-wise base array raised to power from second array.

This is the masked array version of `numpy.power`. For details see
`numpy.power`.

See Also
--------
numpy.power

Notes
-----
The *out* argument to `numpy.power` is not supported, `third` has to be
None.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="third" name="third" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.ptp" module_name="ptp" namespace="'ma'">
    <docstring>Return (maximum - minimum) along the the given dimension
(i.e. peak-to-peak value).

Parameters
----------
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : {None, array_like}, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
fill_value : {var}, optional
    Value used to fill in the masked values.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.</docstring>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to find the peaks.  If None (default) the
flattened array is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value">
      <docstring>Value used to fill in the masked values.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['var']]</values>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="ptp" name="ptp" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result, unless ``out`` was
specified, in which case a reference to ``out`` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.put" module_name="put" namespace="'ma'">
    <docstring>Set storage-indexed locations to corresponding values.

This function is equivalent to `MaskedArray.put`, see that method
for details.

See Also
--------
MaskedArray.put</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="indices" name="indices" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="values" name="values" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="mode" name="mode">
      <defaults>['raise']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.putmask" module_name="putmask" namespace="'ma'">
    <docstring>Changes elements of an array based on conditional and input values.

This is the masked array version of `numpy.putmask`, for details see
`numpy.putmask`.

See Also
--------
numpy.putmask

Notes
-----
Using a masked array as `values` will **not** transform a `ndarray` into
a `MaskedArray`.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="values" name="values" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="mask" name="mask" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.rank" module_name="rank" namespace="'ma'">
    <docstring>Return the number of dimensions of an array.

If `a` is not already an array, a conversion is attempted.
Scalars are zero dimensional.

.. note::
    This function is deprecated in NumPy 1.9 to avoid confusion with
    `numpy.linalg.matrix_rank`. The ``ndim`` attribute or function
    should be used instead.

Parameters
----------
a : array_like
    Array whose number of dimensions is desired. If `a` is not an array,
    a conversion is attempted.

Returns
-------
number_of_dimensions : int
    The number of dimensions in the array.

See Also
--------
ndim : equivalent function
ndarray.ndim : equivalent property
shape : dimensions of array
ndarray.shape : dimensions of array

Notes
-----
In the old Numeric package, `rank` was the term used for the number of
dimensions, but in Numpy `ndim` is used instead.

Examples
--------
&gt;&gt;&gt; np.rank([1,2,3])
1
&gt;&gt;&gt; np.rank(np.array([[1,2,3],[4,5,6]]))
2
&gt;&gt;&gt; np.rank(1)
0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array whose number of dimensions is desired. If `a` is not an array,
a conversion is attempted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="number_of_dimensions" name="number_of_dimensions" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of dimensions in the array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.reshape" module_name="reshape" namespace="'ma'">
    <docstring>Returns an array containing the same data with a new shape.

Refer to `MaskedArray.reshape` for full documentation.

See Also
--------
MaskedArray.reshape : equivalent function</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="new_shape" name="new_shape" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="order" name="order">
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.resize" module_name="resize" namespace="'ma'">
    <docstring>Return a new masked array with the specified size and shape.

This is the masked equivalent of the `numpy.resize` function. The new
array is filled with repeated copies of `x` (in the order that the
data are stored in memory). If `x` is masked, the new array will be
masked, and the new mask will be a repetition of the old one.

See Also
--------
numpy.resize : Equivalent function in the top level NumPy module.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = ma.array([[1, 2] ,[3, 4]])
&gt;&gt;&gt; a[0, 1] = ma.masked
&gt;&gt;&gt; a
masked_array(data =
 [[1 --]
 [3 4]],
             mask =
 [[False  True]
 [False False]],
       fill_value = 999999)
&gt;&gt;&gt; np.resize(a, (3, 3))
array([[1, 2, 3],
       [4, 1, 2],
       [3, 4, 1]])
&gt;&gt;&gt; ma.resize(a, (3, 3))
masked_array(data =
 [[1 -- 3]
 [4 1 --]
 [3 4 1]],
             mask =
 [[False  True False]
 [False False  True]
 [False False False]],
       fill_value = 999999)

A MaskedArray is always returned, regardless of the input type.

&gt;&gt;&gt; a = np.array([[1, 2] ,[3, 4]])
&gt;&gt;&gt; ma.resize(a, (3, 3))
masked_array(data =
 [[1 2 3]
 [4 1 2]
 [3 4 1]],
             mask =
 False,
       fill_value = 999999)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="new_shape" name="new_shape" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.right_shift" module_name="right_shift" namespace="'ma'">
    <docstring>Shift the bits of an integer to the right.

This is the masked array version of `numpy.right_shift`, for details
see that function.

See Also
--------
numpy.right_shift</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.round" module_name="round" namespace="'ma'">
    <docstring>Return a copy of a, rounded to 'decimals' places.

When 'decimals' is negative, it specifies the number of positions
to the left of the decimal point.  The real and imaginary parts of
complex numbers are rounded separately. Nothing is done if the
array is not of float type and 'decimals' is greater than or equal
to 0.

Parameters
----------
decimals : int
    Number of decimals to round to. May be negative.
out : array_like
    Existing array to use for output.
    If not given, returns a default copy of a.

Notes
-----
If out is given and does not have a mask attribute, the mask of a
is lost!</docstring>
    <inputPortSpec arg="decimals" name="decimals" port_type="basic:Integer">
      <docstring>Number of decimals to round to. May be negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List" show_port="True">
      <docstring>Existing array to use for output.
If not given, returns a default copy of a.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.round_" module_name="round_" namespace="'ma'">
    <docstring>Return a copy of a, rounded to 'decimals' places.

When 'decimals' is negative, it specifies the number of positions
to the left of the decimal point.  The real and imaginary parts of
complex numbers are rounded separately. Nothing is done if the
array is not of float type and 'decimals' is greater than or equal
to 0.

Parameters
----------
decimals : int
    Number of decimals to round to. May be negative.
out : array_like
    Existing array to use for output.
    If not given, returns a default copy of a.

Notes
-----
If out is given and does not have a mask attribute, the mask of a
is lost!</docstring>
    <inputPortSpec arg="decimals" name="decimals" port_type="basic:Integer">
      <docstring>Number of decimals to round to. May be negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List" show_port="True">
      <docstring>Existing array to use for output.
If not given, returns a default copy of a.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.set_fill_value" module_name="set_fill_value" namespace="'ma'">
    <docstring>Set the filling value of a, if a is a masked array.

This function changes the fill value of the masked array `a` in place.
If `a` is not a masked array, the function returns silently, without
doing anything.

Parameters
----------
a : array_like
    Input array.
fill_value : dtype
    Filling value. A consistency test is performed to make sure
    the value is compatible with the dtype of `a`.

Returns
-------
None
    Nothing returned by this function.

See Also
--------
maximum_fill_value : Return the default fill value for a dtype.
MaskedArray.fill_value : Return current fill value.
MaskedArray.set_fill_value : Equivalent method.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; a = ma.masked_where(a &lt; 3, a)
&gt;&gt;&gt; a
masked_array(data = [-- -- -- 3 4],
      mask = [ True  True  True False False],
      fill_value=999999)
&gt;&gt;&gt; ma.set_fill_value(a, -999)
&gt;&gt;&gt; a
masked_array(data = [-- -- -- 3 4],
      mask = [ True  True  True False False],
      fill_value=-999)

Nothing happens if `a` is not a masked array.

&gt;&gt;&gt; a = range(5)
&gt;&gt;&gt; a
[0, 1, 2, 3, 4]
&gt;&gt;&gt; ma.set_fill_value(a, 100)
&gt;&gt;&gt; a
[0, 1, 2, 3, 4]
&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; ma.set_fill_value(a, 100)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Variant" show_port="True">
      <docstring>Filling value. A consistency test is performed to make sure
the value is compatible with the dtype of `a`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.shape" module_name="shape" namespace="'ma'">
    <docstring>Return the shape of an array.

Parameters
----------
a : array_like
    Input array.

Returns
-------
shape : tuple of ints
    The elements of the shape tuple give the lengths of the
    corresponding array dimensions.

See Also
--------
alen
ndarray.shape : Equivalent array method.

Examples
--------
&gt;&gt;&gt; np.shape(np.eye(3))
(3, 3)
&gt;&gt;&gt; np.shape([[1, 2]])
(1, 2)
&gt;&gt;&gt; np.shape([0])
(1,)
&gt;&gt;&gt; np.shape(0)
()

&gt;&gt;&gt; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
&gt;&gt;&gt; np.shape(a)
(2,)
&gt;&gt;&gt; a.shape
(2,)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="shape" depth="1" name="shape" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The elements of the shape tuple give the lengths of the
corresponding array dimensions.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.size" module_name="size" namespace="'ma'">
    <docstring>Return the number of elements along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which the elements are counted.  By default, give
    the total number of elements.

Returns
-------
element_count : int
    Number of elements along the specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; np.size(a)
6
&gt;&gt;&gt; np.size(a,1)
3
&gt;&gt;&gt; np.size(a,0)
2</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the elements are counted.  By default, give
the total number of elements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="obj" name="obj" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="element_count" name="element_count" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Number of elements along the specified axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.sort" module_name="sort" namespace="'ma'">
    <docstring>Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort'}, optional
    Sorting algorithm. Default is 'quicksort'.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be forced in the upper indices
    (at the end of the array) (True) or lower indices (at the beginning).
    When the array contains unmasked values of the largest (or smallest if
    False) representable value of the datatype the ordering of these values
    and the masked values is undefined.  To enforce the masked values are
    at the end (beginning) in this case one must sort the mask.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
&gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
&gt;&gt;&gt; # Default
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; print a
[1 3 5 -- --]

&gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
&gt;&gt;&gt; # Put missing values in the front
&gt;&gt;&gt; a.sort(endwith=False)
&gt;&gt;&gt; print a
[-- -- 1 3 5]

&gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
&gt;&gt;&gt; # fill_value takes over endwith
&gt;&gt;&gt; a.sort(endwith=False, fill_value=3)
&gt;&gt;&gt; print a
[1 -- -- 3 5]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to be sorted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Sorting algorithm. Default is 'quicksort'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['quicksort', 'mergesort', 'heapsort']]</values>
      <defaults>['quicksort']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:List">
      <docstring>When `a` is a structured array, this argument specifies which fields
to compare first, second, and so on.  This list does not need to
include all of the fields.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="endwith" name="endwith" port_type="basic:Boolean">
      <docstring>Whether missing values (if any) should be forced in the upper indices
(at the end of the array) (True) or lower indices (at the beginning).
When the array contains unmasked values of the largest (or smallest if
False) representable value of the datatype the ordering of these values
and the masked values is undefined.  To enforce the masked values are
at the end (beginning) in this case one must sort the mask.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value">
      <docstring>Value used internally for the masked values.
If ``fill_value`` is not None, it supersedes ``endwith``.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['var']]</values>
    </inputPortSpec>
    <outputPortSpec arg="sorted_array" name="sorted_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of the same type and shape as `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.squeeze" module_name="squeeze" namespace="'ma'">
    <docstring>Remove single-dimensional entries from the shape of an array.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    .. versionadded:: 1.7.0

    Selects a subset of the single-dimensional entries in the
    shape. If an axis is selected with shape entry greater than
    one, an error is raised.

Returns
-------
squeezed : ndarray
    The input array, but with all or a subset of the
    dimensions of length 1 removed. This is always `a` itself
    or a view into `a`.

Examples
--------
&gt;&gt;&gt; x = np.array([[[0], [1], [2]]])
&gt;&gt;&gt; x.shape
(1, 3, 1)
&gt;&gt;&gt; np.squeeze(x).shape
(3,)
&gt;&gt;&gt; np.squeeze(x, axis=(2,)).shape
(1, 3)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>.. versionadded:: 1.7.0

Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="squeezed" name="squeezed" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The input array, but with all or a subset of the
dimensions of length 1 removed. This is always `a` itself
or a view into `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.take" module_name="take" namespace="'ma'">
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="indices" name="indices" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="mode" name="mode">
      <defaults>['raise']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.transpose" module_name="transpose" namespace="'ma'">
    <docstring>Permute the dimensions of an array.

This function is exactly equivalent to `numpy.transpose`.

See Also
--------
numpy.transpose : Equivalent function in top-level NumPy module.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; x = ma.arange(4).reshape((2,2))
&gt;&gt;&gt; x[1, 1] = ma.masked
&gt;&gt;&gt;&gt; x
masked_array(data =
 [[0 1]
 [2 --]],
             mask =
 [[False False]
 [False  True]],
       fill_value = 999999)
&gt;&gt;&gt; ma.transpose(x)
masked_array(data =
 [[0 2]
 [1 --]],
             mask =
 [[False False]
 [False  True]],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axes" name="axes" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.where" module_name="where" namespace="'ma'">
    <docstring>Return a masked array with elements from x or y, depending on condition.

Returns a masked array, shaped like condition, where the elements
are from `x` when `condition` is True, and from `y` otherwise.
If neither `x` nor `y` are given, the function returns a tuple of
indices where `condition` is True (the result of
``condition.nonzero()``).

Parameters
----------
condition : array_like, bool
    The condition to meet. For each True element, yield the corresponding
    element from `x`, otherwise from `y`.
x, y : array_like, optional
    Values from which to choose. `x` and `y` need to have the same shape
    as condition, or be broadcast-able to that shape.

Returns
-------
out : MaskedArray or tuple of ndarrays
    The resulting masked array if `x` and `y` were given, otherwise
    the result of ``condition.nonzero()``.

See Also
--------
numpy.where : Equivalent function in the top-level NumPy module.

Examples
--------
&gt;&gt;&gt; x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
...                                                    [1, 0, 1],
...                                                    [0, 1, 0]])
&gt;&gt;&gt; print x
[[0.0 -- 2.0]
 [-- 4.0 --]
 [6.0 -- 8.0]]
&gt;&gt;&gt; np.ma.where(x &gt; 5)    # return the indices where x &gt; 5
(array([2, 2]), array([0, 2]))

&gt;&gt;&gt; print np.ma.where(x &gt; 5, x, -3.1416)
[[-3.1416 -- -3.1416]
 [-- -3.1416 --]
 [6.0 -- 8.0]]</docstring>
    <inputPortSpec arg="condition" depth="1" name="condition" port_type="basic:Boolean" show_port="True">
      <docstring>The condition to meet. For each True element, yield the corresponding
element from `x`, otherwise from `y`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>Values from which to choose. `x` and `y` need to have the same shape
as condition, or be broadcast-able to that shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>Values from which to choose. `x` and `y` need to have the same shape
as condition, or be broadcast-able to that shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The resulting masked array if `x` and `y` were given, otherwise
the result of ``condition.nonzero()``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.apply_along_axis" module_name="apply_along_axis" namespace="'ma'">
    <docstring>Apply a function to 1-D slices along the given axis.

Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
is a 1-D slice of `arr` along `axis`.

Parameters
----------
func1d : function
    This function should accept 1-D arrays. It is applied to 1-D
    slices of `arr` along the specified axis.
axis : integer
    Axis along which `arr` is sliced.
arr : ndarray
    Input array.
args : any
    Additional arguments to `func1d`.
kwargs: any
    Additional named arguments to `func1d`.

    .. versionadded:: 1.9.0


Returns
-------
apply_along_axis : ndarray
    The output array. The shape of `outarr` is identical to the shape of
    `arr`, except along the `axis` dimension, where the length of `outarr`
    is equal to the size of the return value of `func1d`.  If `func1d`
    returns a scalar `outarr` will have one fewer dimensions than `arr`.

See Also
--------
apply_over_axes : Apply a function repeatedly over multiple axes.

Examples
--------
&gt;&gt;&gt; def my_func(a):
...     """Average first and last element of a 1-D array"""
...     return (a[0] + a[-1]) * 0.5
&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; np.apply_along_axis(my_func, 0, b)
array([ 4.,  5.,  6.])
&gt;&gt;&gt; np.apply_along_axis(my_func, 1, b)
array([ 2.,  5.,  8.])

For a function that doesn't return a scalar, the number of dimensions in
`outarr` is the same as `arr`.

&gt;&gt;&gt; b = np.array([[8,1,7], [4,3,9], [5,2,6]])
&gt;&gt;&gt; np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])</docstring>
    <inputPortSpec arg="func1d" name="func1d" port_type="basic:Variant" show_port="True">
      <docstring>This function should accept 1-D arrays. It is applied to 1-D
slices of `arr` along the specified axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True">
      <docstring>Axis along which `arr` is sliced.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:Variant" show_port="True">
      <docstring>Additional arguments to `func1d`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="apply_along_axis" name="apply_along_axis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The output array. The shape of `outarr` is identical to the shape of
`arr`, except along the `axis` dimension, where the length of `outarr`
is equal to the size of the return value of `func1d`.  If `func1d`
returns a scalar `outarr` will have one fewer dimensions than `arr`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.apply_over_axes" module_name="apply_over_axes" namespace="'ma'">
    <docstring>Apply a function repeatedly over multiple axes.

`func` is called as `res = func(a, axis)`, where `axis` is the first
element of `axes`.  The result `res` of the function call must have
either the same dimensions as `a` or one less dimension.  If `res`
has one less dimension than `a`, a dimension is inserted before
`axis`.  The call to `func` is then repeated for each axis in `axes`,
with `res` as the first argument.

Parameters
----------
func : function
    This function must take two arguments, `func(a, axis)`.
a : array_like
    Input array.
axes : array_like
    Axes over which `func` is applied; the elements must be integers.

Returns
-------
apply_over_axis : ndarray
    The output array.  The number of dimensions is the same as `a`,
    but the shape can be different.  This depends on whether `func`
    changes the shape of its output with respect to its input.

See Also
--------
apply_along_axis :
    Apply a function to 1-D slices of an array along the given axis.

Examples
--------
&gt;&gt;&gt; a = ma.arange(24).reshape(2,3,4)
&gt;&gt;&gt; a[:,0,1] = ma.masked
&gt;&gt;&gt; a[:,1,:] = ma.masked
&gt;&gt;&gt; print a
[[[0 -- 2 3]
  [-- -- -- --]
  [8 9 10 11]]

 [[12 -- 14 15]
  [-- -- -- --]
  [20 21 22 23]]]
&gt;&gt;&gt; print ma.apply_over_axes(ma.sum, a, [0,2])
[[[46]
  [--]
  [124]]]

Tuple axis arguments to ufuncs are equivalent:

&gt;&gt;&gt; print ma.sum(a, axis=(0,2)).reshape((1,-1,1))
[[[46]
  [--]
  [124]]]</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>This function must take two arguments, `func(a, axis)`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axes" port_type="basic:List" show_port="True">
      <docstring>Axes over which `func` is applied; the elements must be integers.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="apply_over_axis" name="apply_over_axis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The output array.  The number of dimensions is the same as `a`,
but the shape can be different.  This depends on whether `func`
changes the shape of its output with respect to its input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.average" module_name="average" namespace="'ma'" output_type="list">
    <docstring>Return the weighted average of array over the given axis.

Parameters
----------
a : array_like
    Data to be averaged.
    Masked entries are not taken into account in the computation.
axis : int, optional
    Axis along which the average is computed. The default is to compute
    the average of the flattened array.
weights : array_like, optional
    The importance that each element has in the computation of the average.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If ``weights=None``, then all data in `a` are assumed to have a
    weight equal to one.   If `weights` is complex, the imaginary parts
    are ignored.
returned : bool, optional
    Flag indicating whether a tuple ``(result, sum of weights)``
    should be returned as output (True), or just the result (False).
    Default is False.

Returns
-------
average, [sum_of_weights] : (tuple of) scalar or MaskedArray
    The average along the specified axis. When returned is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. The return type is `np.float64`
    if `a` is of integer type and floats smaller than `float64`, or the
    input data-type, otherwise. If returned, `sum_of_weights` is always
    `float64`.

Examples
--------
&gt;&gt;&gt; a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
&gt;&gt;&gt; np.ma.average(a, weights=[3, 1, 0, 0])
1.25

&gt;&gt;&gt; x = np.ma.arange(6.).reshape(3, 2)
&gt;&gt;&gt; print x
[[ 0.  1.]
 [ 2.  3.]
 [ 4.  5.]]
&gt;&gt;&gt; avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
...                                 returned=True)
&gt;&gt;&gt; print avg
[2.66666666667 3.66666666667]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Data to be averaged.
Masked entries are not taken into account in the computation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the average is computed. The default is to compute
the average of the flattened array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>The importance that each element has in the computation of the average.
The weights array can either be 1-D (in which case its length must be
the size of `a` along the given axis) or of the same shape as `a`.
If ``weights=None``, then all data in `a` are assumed to have a
weight equal to one.   If `weights` is complex, the imaginary parts
are ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="returned" name="returned" port_type="basic:Boolean">
      <docstring>Flag indicating whether a tuple ``(result, sum of weights)``
should be returned as output (True), or just the result (False).
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="average" name="average" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The average along the specified axis. When returned is `True`,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is `np.float64`
if `a` is of integer type and floats smaller than `float64`, or the
input data-type, otherwise. If returned, `sum_of_weights` is always
`float64`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="[sum_of_weights]" name="[sum_of_weights]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The average along the specified axis. When returned is `True`,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is `np.float64`
if `a` is of integer type and floats smaller than `float64`, or the
input data-type, otherwise. If returned, `sum_of_weights` is always
`float64`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.clump_masked" module_name="clump_masked" namespace="'ma'">
    <docstring>Returns a list of slices corresponding to the masked clumps of a 1-D array.
(A "clump" is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of masked elements
    in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
notmasked_contiguous, clump_unmasked

Examples
--------
&gt;&gt;&gt; a = np.ma.masked_array(np.arange(10))
&gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
&gt;&gt;&gt; np.ma.clump_masked(a)
[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A one-dimensional masked array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="slices" name="slices" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The list of slices, one for each continuous region of masked elements
in `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.clump_unmasked" module_name="clump_unmasked" namespace="'ma'">
    <docstring>Return list of slices corresponding to the unmasked clumps of a 1-D array.
(A "clump" is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of unmasked
    elements in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
notmasked_contiguous, clump_masked

Examples
--------
&gt;&gt;&gt; a = np.ma.masked_array(np.arange(10))
&gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
&gt;&gt;&gt; np.ma.clump_unmasked(a)
[slice(3, 6, None), slice(7, 8, None)]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A one-dimensional masked array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="slices" name="slices" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The list of slices, one for each continuous region of unmasked
elements in `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.compress_cols" module_name="compress_cols" namespace="'ma'">
    <docstring>Suppress whole columns of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.compress_nd" module_name="compress_nd" namespace="'ma'">
    <docstring>Supress slices from multiple dimensions which contain masked values.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on. If not a MaskedArray instance (or if no array
    elements are masked, `x` is interpreted as a MaskedArray with `mask`
    set to `nomask`.
axis : tuple of ints or int, optional
    Which dimensions to supress slices from can be configured with this
    parameter.
    - If axis is a tuple of ints, those are the axes to supress slices from.
    - If axis is an int, then that is the only axis to supress slices from.
    - If axis is None, all axis are selected.

Returns
-------
compress_array : ndarray
    The compressed array.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array to operate on. If not a MaskedArray instance (or if no array
elements are masked, `x` is interpreted as a MaskedArray with `mask`
set to `nomask`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Which dimensions to supress slices from can be configured with this
parameter.
- If axis is a tuple of ints, those are the axes to supress slices from.
- If axis is an int, then that is the only axis to supress slices from.
- If axis is None, all axis are selected.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="compress_array" name="compress_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The compressed array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.compress_rowcols" module_name="compress_rowcols" namespace="'ma'">
    <docstring>Suppress the rows and/or columns of a 2-D array that contain
masked values.

The suppression behavior is selected with the `axis` parameter.

- If axis is None, both rows and columns are suppressed.
- If axis is 0, only rows are suppressed.
- If axis is 1 or -1, only columns are suppressed.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on.  If not a MaskedArray instance (or if no array
    elements are masked), `x` is interpreted as a MaskedArray with
    `mask` set to `nomask`. Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. Default is None.

Returns
-------
compressed_array : ndarray
    The compressed array.

Examples
--------
&gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
&gt;&gt;&gt; x
masked_array(data =
 [[-- 1 2]
 [-- 4 5]
 [6 7 8]],
             mask =
 [[ True False False]
 [ True False False]
 [False False False]],
       fill_value = 999999)

&gt;&gt;&gt; np.ma.compress_rowcols(x)
array([[7, 8]])
&gt;&gt;&gt; np.ma.compress_rowcols(x, 0)
array([[6, 7, 8]])
&gt;&gt;&gt; np.ma.compress_rowcols(x, 1)
array([[1, 2],
       [4, 5],
       [7, 8]])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array to operate on.  If not a MaskedArray instance (or if no array
elements are masked), `x` is interpreted as a MaskedArray with
`mask` set to `nomask`. Must be a 2D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the operation. Default is None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="compressed_array" name="compressed_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The compressed array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.compress_rows" module_name="compress_rows" namespace="'ma'">
    <docstring>Suppress whole rows of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.count_masked" module_name="count_masked" namespace="'ma'">
    <docstring>Count the number of masked elements along the given axis.

Parameters
----------
arr : array_like
    An array with (possibly) masked elements.
axis : int, optional
    Axis along which to count. If None (default), a flattened
    version of the array is used.

Returns
-------
count : int, ndarray
    The total number of masked elements (axis=None) or the number
    of masked elements along each slice of the given axis.

See Also
--------
MaskedArray.count : Count non-masked elements.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.arange(9).reshape((3,3))
&gt;&gt;&gt; a = ma.array(a)
&gt;&gt;&gt; a[1, 0] = ma.masked
&gt;&gt;&gt; a[1, 2] = ma.masked
&gt;&gt;&gt; a[2, 1] = ma.masked
&gt;&gt;&gt; a
masked_array(data =
 [[0 1 2]
 [-- 4 --]
 [6 -- 8]],
      mask =
 [[False False False]
 [ True False  True]
 [False  True False]],
      fill_value=999999)
&gt;&gt;&gt; ma.count_masked(a)
3

When the `axis` keyword is used an array is returned.

&gt;&gt;&gt; ma.count_masked(a, axis=0)
array([1, 1, 1])
&gt;&gt;&gt; ma.count_masked(a, axis=1)
array([0, 2, 1])</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>An array with (possibly) masked elements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to count. If None (default), a flattened
version of the array is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="count" depth="1" name="count" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The total number of masked elements (axis=None) or the number
of masked elements along each slice of the given axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.corrcoef" module_name="corrcoef" namespace="'ma'">
    <docstring>Return Pearson product-moment correlation coefficients.

Except for the handling of missing data this function does the same as
`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no affect, do not use.

    .. deprecated:: 1.10.0
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises an exception.  Because `bias` is deprecated, this
    argument needs to be treated as keyword only to avoid a warning.
ddof : _NoValue, optional
    Has no affect, do not use.

    .. deprecated:: 1.10.0

See Also
--------
numpy.corrcoef : Equivalent function in top-level NumPy module.
cov : Estimate the covariance matrix.

Notes
-----
This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A 1-D or 2-D array containing multiple variables and observations.
Each row of `x` represents a variable, and each column a single
observation of all those variables. Also see `rowvar` below.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>An additional set of variables and observations. `y` has the same
shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rowvar" name="rowvar" port_type="basic:Boolean">
      <docstring>If `rowvar` is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Variant">
      <docstring>Has no affect, do not use.

.. deprecated:: 1.10.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="allow_masked" name="allow_masked" port_type="basic:Boolean">
      <docstring>If True, masked values are propagated pair-wise: if a value is masked
in `x`, the corresponding value is masked in `y`.
If False, raises an exception.  Because `bias` is deprecated, this
argument needs to be treated as keyword only to avoid a warning.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Variant">
      <docstring>Has no affect, do not use.

.. deprecated:: 1.10.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.cov" module_name="cov" namespace="'ma'">
    <docstring>Estimate the covariance matrix.

Except for the handling of missing data this function does the same as
`numpy.cov`. For more details and examples, see `numpy.cov`.

By default, masked values are recognized as such. If `x` and `y` have the
same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
``y[i,j]`` will also be masked.
Setting `allow_masked` to False will raise an exception if values are
missing in either of the input arrays.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    form as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N-1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. This keyword can be overridden by
    the keyword ``ddof`` in numpy versions &gt;= 1.5.
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises a `ValueError` exception when some values are missing.
ddof : {None, int}, optional
    If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
    the number of observations; this overrides the value implied by
    ``bias``. The default value is ``None``.

    .. versionadded:: 1.5

Raises
------
ValueError
    Raised if some values are missing and `allow_masked` is False.

See Also
--------
numpy.cov</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A 1-D or 2-D array containing multiple variables and observations.
Each row of `x` represents a variable, and each column a single
observation of all those variables. Also see `rowvar` below.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>An additional set of variables and observations. `y` has the same
form as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rowvar" name="rowvar" port_type="basic:Boolean">
      <docstring>If `rowvar` is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Boolean">
      <docstring>Default normalization (False) is by ``(N-1)``, where ``N`` is the
number of observations given (unbiased estimate). If `bias` is True,
then normalization is by ``N``. This keyword can be overridden by
the keyword ``ddof`` in numpy versions &gt;= 1.5.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="allow_masked" name="allow_masked" port_type="basic:Boolean">
      <docstring>If True, masked values are propagated pair-wise: if a value is masked
in `x`, the corresponding value is masked in `y`.
If False, raises a `ValueError` exception when some values are missing.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
the number of observations; this overrides the value implied by
``bias``. The default value is ``None``.

.. versionadded:: 1.5</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.dot" module_name="dot" namespace="'ma'">
    <docstring>Return the dot product of two arrays.

.. note::
  Works only with 2-D arrays at the moment.

This function is the equivalent of `numpy.dot` that takes masked values
into account, see `numpy.dot` for details.

Parameters
----------
a, b : ndarray
    Inputs arrays.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False) for the
    computation. Default is False.
    Propagating the mask means that if a masked value appears in a row or
    column, the whole row or column is considered masked.

See Also
--------
numpy.dot : Equivalent function for ndarrays.

Examples
--------
&gt;&gt;&gt; a = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
&gt;&gt;&gt; b = ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
&gt;&gt;&gt; np.ma.dot(a, b)
masked_array(data =
 [[21 26]
 [45 64]],
             mask =
 [[False False]
 [False False]],
       fill_value = 999999)
&gt;&gt;&gt; np.ma.dot(a, b, strict=True)
masked_array(data =
 [[-- --]
 [-- 64]],
             mask =
 [[ True  True]
 [ True False]],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Inputs arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Inputs arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="strict" name="strict" port_type="basic:Boolean">
      <docstring>Whether masked data are propagated (True) or set to 0 (False) for the
computation. Default is False.
Propagating the mask means that if a masked value appears in a row or
column, the whole row or column is considered masked.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.ediff1d" module_name="ediff1d" namespace="'ma'">
    <docstring>Compute the differences between consecutive elements of an array.

This function is the equivalent of `numpy.ediff1d` that takes masked
values into account, see `numpy.ediff1d` for details.

See Also
--------
numpy.ediff1d : Equivalent function for ndarrays.</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="to_end" name="to_end" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="to_begin" name="to_begin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.flatnotmasked_contiguous" module_name="flatnotmasked_contiguous" namespace="'ma'">
    <docstring>Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : narray
    The input array.

Returns
-------
slice_list : list
    A sorted sequence of slices (start index, end index).

See Also
--------
flatnotmasked_edges, notmasked_contiguous, notmasked_edges,
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
&gt;&gt;&gt; a = np.ma.arange(10)
&gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)
slice(0, 10, None)

&gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)
&gt;&gt;&gt; a[mask] = np.ma.masked
&gt;&gt;&gt; np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

&gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)
[slice(3, 5, None), slice(6, 9, None)]
&gt;&gt;&gt; a[:] = np.ma.masked
&gt;&gt;&gt; print np.ma.flatnotmasked_edges(a)
None</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="slice_list" name="slice_list" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A sorted sequence of slices (start index, end index).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.flatnotmasked_edges" module_name="flatnotmasked_edges" namespace="'ma'">
    <docstring>Find the indices of the first and last unmasked values.

Expects a 1-D `MaskedArray`, returns None if all values are masked.

Parameters
----------
a : array_like
    Input 1-D `MaskedArray`

Returns
-------
edges : ndarray or None
    The indices of first and last non-masked value in the array.
    Returns None if all values are masked.

See Also
--------
flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges,
clump_masked, clump_unmasked

Notes
-----
Only accepts 1-D arrays.

Examples
--------
&gt;&gt;&gt; a = np.ma.arange(10)
&gt;&gt;&gt; flatnotmasked_edges(a)
[0,-1]

&gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)
&gt;&gt;&gt; a[mask] = np.ma.masked
&gt;&gt;&gt; np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

&gt;&gt;&gt; flatnotmasked_edges(a)
array([3, 8])

&gt;&gt;&gt; a[:] = np.ma.masked
&gt;&gt;&gt; print flatnotmasked_edges(ma)
None</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input 1-D `MaskedArray`</docstring>
    </inputPortSpec>
    <outputPortSpec arg="edges" name="edges" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The indices of first and last non-masked value in the array.
Returns None if all values are masked.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.in1d" module_name="in1d" namespace="'ma'">
    <docstring>Test whether each element of an array is also present in a second
array.

The output is always a masked array. See `numpy.in1d` for more details.

See Also
--------
numpy.in1d : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.4.0</docstring>
    <inputPortSpec arg="ar1" name="ar1" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ar2" name="ar2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="invert" name="invert" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="assume_unique" name="assume_unique" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.intersect1d" module_name="intersect1d" namespace="'ma'">
    <docstring>Returns the unique elements common to both arrays.

Masked values are considered equal one to the other.
The output is always a masked array.

See `numpy.intersect1d` for more details.

See Also
--------
numpy.intersect1d : Equivalent function for ndarrays.

Examples
--------
&gt;&gt;&gt; x = array([1, 3, 3, 3], mask=[0, 0, 0, 1])
&gt;&gt;&gt; y = array([3, 1, 1, 1], mask=[0, 0, 0, 1])
&gt;&gt;&gt; intersect1d(x, y)
masked_array(data = [1 3 --],
             mask = [False False  True],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="ar1" name="ar1" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ar2" name="ar2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="assume_unique" name="assume_unique" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.mask_cols" module_name="mask_cols" namespace="'ma'">
    <docstring>Mask columns of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.zeros((3, 3), dtype=np.int)
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
&gt;&gt;&gt; a = ma.masked_equal(a, 1)
&gt;&gt;&gt; a
masked_array(data =
 [[0 0 0]
 [0 -- 0]
 [0 0 0]],
      mask =
 [[False False False]
 [False  True False]
 [False False False]],
      fill_value=999999)
&gt;&gt;&gt; ma.mask_cols(a)
masked_array(data =
 [[0 -- 0]
 [0 -- 0]
 [0 -- 0]],
      mask =
 [[False  True False]
 [False  True False]
 [False  True False]],
      fill_value=999999)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.mask_rowcols" module_name="mask_rowcols" namespace="'ma'">
    <docstring>Mask rows and/or columns of a 2D array that contain masked values.

Mask whole rows and/or columns of a 2D array that contain
masked values.  The masking behavior is selected using the
`axis` parameter.

  - If `axis` is None, rows *and* columns are masked.
  - If `axis` is 0, only rows are masked.
  - If `axis` is 1 or -1, only columns are masked.

Parameters
----------
a : array_like, MaskedArray
    The array to mask.  If not a MaskedArray instance (or if no array
    elements are masked).  The result is a MaskedArray with `mask` set
    to `nomask` (False). Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. If None, applies to a
    flattened version of the array.

Returns
-------
a : MaskedArray
    A modified version of the input array, masked depending on the value
    of the `axis` parameter.

Raises
------
NotImplementedError
    If input array `a` is not 2D.

See Also
--------
mask_rows : Mask rows of a 2D array that contain masked values.
mask_cols : Mask cols of a 2D array that contain masked values.
masked_where : Mask where a condition is met.

Notes
-----
The input array's mask is modified by this function.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.zeros((3, 3), dtype=np.int)
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
&gt;&gt;&gt; a = ma.masked_equal(a, 1)
&gt;&gt;&gt; a
masked_array(data =
 [[0 0 0]
 [0 -- 0]
 [0 0 0]],
      mask =
 [[False False False]
 [False  True False]
 [False False False]],
      fill_value=999999)
&gt;&gt;&gt; ma.mask_rowcols(a)
masked_array(data =
 [[0 -- 0]
 [-- -- --]
 [0 -- 0]],
      mask =
 [[False  True False]
 [ True  True  True]
 [False  True False]],
      fill_value=999999)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array to mask.  If not a MaskedArray instance (or if no array
elements are masked).  The result is a MaskedArray with `mask` set
to `nomask` (False). Must be a 2D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the operation. If None, applies to a
flattened version of the array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A modified version of the input array, masked depending on the value
of the `axis` parameter.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.mask_rows" module_name="mask_rows" namespace="'ma'">
    <docstring>Mask rows of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; a = np.zeros((3, 3), dtype=np.int)
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
&gt;&gt;&gt; a = ma.masked_equal(a, 1)
&gt;&gt;&gt; a
masked_array(data =
 [[0 0 0]
 [0 -- 0]
 [0 0 0]],
      mask =
 [[False False False]
 [False  True False]
 [False False False]],
      fill_value=999999)
&gt;&gt;&gt; ma.mask_rows(a)
masked_array(data =
 [[0 0 0]
 [-- -- --]
 [0 0 0]],
      mask =
 [[False False False]
 [ True  True  True]
 [False False False]],
      fill_value=999999)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_all" module_name="masked_all" namespace="'ma'">
    <docstring>Empty masked array with all elements masked.

Return an empty masked array of the given shape and dtype, where all the
data are masked.

Parameters
----------
shape : tuple
    Shape of the required MaskedArray.
dtype : dtype, optional
    Data type of the output.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

See Also
--------
masked_all_like : Empty masked array modelled on an existing array.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; ma.masked_all((3, 3))
masked_array(data =
 [[-- -- --]
 [-- -- --]
 [-- -- --]],
      mask =
 [[ True  True  True]
 [ True  True  True]
 [ True  True  True]],
      fill_value=1e+20)

The `dtype` parameter defines the underlying data type.

&gt;&gt;&gt; a = ma.masked_all((3, 3))
&gt;&gt;&gt; a.dtype
dtype('float64')
&gt;&gt;&gt; a = ma.masked_all((3, 3), dtype=np.int32)
&gt;&gt;&gt; a.dtype
dtype('int32')</docstring>
    <inputPortSpec arg="shape" name="shape" port_type="basic:List" show_port="True">
      <docstring>Shape of the required MaskedArray.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the output.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A masked array with all data masked.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_all_like" module_name="masked_all_like" namespace="'ma'">
    <docstring>Empty masked array with the properties of an existing array.

Return an empty masked array of the same shape and dtype as
the array `arr`, where all the data are masked.

Parameters
----------
arr : ndarray
    An array describing the shape and dtype of the required MaskedArray.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

Raises
------
AttributeError
    If `arr` doesn't have a shape attribute (i.e. not an ndarray)

See Also
--------
masked_all : Empty masked array with all elements masked.

Examples
--------
&gt;&gt;&gt; import numpy.ma as ma
&gt;&gt;&gt; arr = np.zeros((2, 3), dtype=np.float32)
&gt;&gt;&gt; arr
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]], dtype=float32)
&gt;&gt;&gt; ma.masked_all_like(arr)
masked_array(data =
 [[-- -- --]
 [-- -- --]],
      mask =
 [[ True  True  True]
 [ True  True  True]],
      fill_value=1e+20)

The dtype of the masked array matches the dtype of `arr`.

&gt;&gt;&gt; arr.dtype
dtype('float32')
&gt;&gt;&gt; ma.masked_all_like(arr).dtype
dtype('float32')</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>An array describing the shape and dtype of the required MaskedArray.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A masked array with all data masked.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.median" module_name="median" namespace="'ma'">
    <docstring>Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int, optional
    Axis along which the medians are computed. The default (None) is
    to compute the median along a flattened version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow use of memory of input array (a) for
    calculations. The input array will be modified by the call to
    median. This will save memory when you do not need to preserve
    the contents of the input array. Treat the input as undefined,
    but it will probably be fully or partially sorted. Default is
    False. Note that, if `overwrite_input` is True, and the input
    is not already an `ndarray`, an error will be raised.

Returns
-------
median : ndarray
    A new array holding the result is returned unless out is
    specified, in which case a reference to out is returned.
    Return data-type is `float64` for integers and floats smaller than
    `float64`, or the input data-type, otherwise.

See Also
--------
mean

Notes
-----
Given a vector ``V`` with ``N`` non masked values, the median of ``V``
is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
when ``N`` is even.

Examples
--------
&gt;&gt;&gt; x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
&gt;&gt;&gt; np.ma.median(x)
1.5

&gt;&gt;&gt; x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
&gt;&gt;&gt; np.ma.median(x)
2.5
&gt;&gt;&gt; np.ma.median(x, axis=-1, overwrite_input=True)
masked_array(data = [ 2.  5.],
             mask = False,
       fill_value = 1e+20)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the medians are computed. The default (None) is
to compute the median along a flattened version of the array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_input" name="overwrite_input" port_type="basic:Boolean">
      <docstring>If True, then allow use of memory of input array (a) for
calculations. The input array will be modified by the call to
median. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. Note that, if `overwrite_input` is True, and the input
is not already an `ndarray`, an error will be raised.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="median" name="median" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A new array holding the result is returned unless out is
specified, in which case a reference to out is returned.
Return data-type is `float64` for integers and floats smaller than
`float64`, or the input data-type, otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.notmasked_contiguous" module_name="notmasked_contiguous" namespace="'ma'">
    <docstring>Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array.

Returns
-------
endpoints : list
    A list of slices (start and end indexes) of unmasked indexes
    in the array.

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
&gt;&gt;&gt; a = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; mask = np.zeros_like(a)
&gt;&gt;&gt; mask[1:, 1:] = 1

&gt;&gt;&gt; ma = np.ma.array(a, mask=mask)
&gt;&gt;&gt; np.array(ma[~ma.mask])
array([0, 1, 2, 3, 6])

&gt;&gt;&gt; np.ma.notmasked_contiguous(ma)
[slice(0, 4, None), slice(6, 7, None)]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the operation.
If None (default), applies to a flattened version of the array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="endpoints" name="endpoints" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A list of slices (start and end indexes) of unmasked indexes
in the array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.notmasked_edges" module_name="notmasked_edges" namespace="'ma'">
    <docstring>Find the indices of the first and last unmasked values along an axis.

If all values are masked, return None.  Otherwise, return a list
of two tuples, corresponding to the indices of the first and last
unmasked values respectively.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array.

Returns
-------
edges : ndarray or list
    An array of start and end indexes if there are any masked data in
    the array. If there are no masked data in the array, `edges` is a
    list of the first and last index.

See Also
--------
flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous,
clump_masked, clump_unmasked

Examples
--------
&gt;&gt;&gt; a = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; m = np.zeros_like(a)
&gt;&gt;&gt; m[1:, 1:] = 1

&gt;&gt;&gt; am = np.ma.array(a, mask=m)
&gt;&gt;&gt; np.array(am[~am.mask])
array([0, 1, 2, 3, 6])

&gt;&gt;&gt; np.ma.notmasked_edges(ma)
array([0, 6])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the operation.
If None (default), applies to a flattened version of the array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="edges" name="edges" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of start and end indexes if there are any masked data in
the array. If there are no masked data in the array, `edges` is a
list of the first and last index.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.polyfit" module_name="polyfit" namespace="'ma'" output_type="list">
    <docstring>Least squares polynomial fit.

Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
to points `(x, y)`. Returns a vector of coefficients `p` that minimises
the squared error.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (M,), optional
    weights to apply to the y-coordinates of the sample points.
cov : bool, optional
    Return the estimate and the covariance matrix of the estimate
    If full is True, then cov is not returned.

Returns
-------
p : ndarray, shape (M,) or (M, K)
    Polynomial coefficients, highest power first.  If `y` was 2-D, the
    coefficients for `k`-th data set are in ``p[:,k]``.

residuals, rank, singular_values, rcond :
    Present only if `full` = True.  Residuals of the least-squares fit,
    the effective rank of the scaled Vandermonde coefficient matrix,
    its singular values, and the specified value of `rcond`. For more
    details, see `linalg.lstsq`.

V : ndarray, shape (M,M) or (M,M,K)
    Present only if `full` = False and `cov`=True.  The covariance
    matrix of the polynomial coefficient estimates.  The diagonal of
    this matrix are the variance estimates for each coefficient.  If y
    is a 2-D array, then the covariance matrix for the `k`-th data set
    are in ``V[:,:,k]``


Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.

    The warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
polyval : Computes polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution minimizes the squared error

.. math ::
    E = \sum_{j=0}^k |p(x_j) - y_j|^2

in the equations::

    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
    ...
    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]

The coefficient matrix of the coefficients `p` is a Vandermonde matrix.

`polyfit` issues a `RankWarning` when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.

Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting
.. [2] Wikipedia, "Polynomial interpolation",
       http://en.wikipedia.org/wiki/Polynomial_interpolation

Examples
--------
&gt;&gt;&gt; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
&gt;&gt;&gt; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
&gt;&gt;&gt; z = np.polyfit(x, y, 3)
&gt;&gt;&gt; z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])

It is convenient to use `poly1d` objects for dealing with polynomials:

&gt;&gt;&gt; p = np.poly1d(z)
&gt;&gt;&gt; p(0.5)
0.6143849206349179
&gt;&gt;&gt; p(3.5)
-0.34732142857143039
&gt;&gt;&gt; p(10)
22.579365079365115

High-order polynomials may oscillate wildly:

&gt;&gt;&gt; p30 = np.poly1d(np.polyfit(x, y, 30))
/... RankWarning: Polyfit may be poorly conditioned...
&gt;&gt;&gt; p30(4)
-0.80000000000000204
&gt;&gt;&gt; p30(5)
-0.99999999999999445
&gt;&gt;&gt; p30(4.5)
-0.10547061179440398

Illustration:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; xp = np.linspace(-2, 6, 100)
&gt;&gt;&gt; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
&gt;&gt;&gt; plt.ylim(-2,2)
(-2, 2)
&gt;&gt;&gt; plt.show()



Notes
-----

Any masked values in x is propagated in y, and vice-versa.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the M sample points ``(x[i], y[i])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="yScalar" show_port="True">
      <docstring>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</docstring>
      <alternateSpec arg="y" name="ySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="deg" name="deg" port_type="basic:Integer" show_port="True">
      <docstring>Degree of the fitting polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>weights to apply to the y-coordinates of the sample points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cov" name="cov" port_type="basic:Boolean">
      <docstring>Return the estimate and the covariance matrix of the estimate
If full is True, then cov is not returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="p" name="p" show_port="True" sort_key="0">
      <docstring>Polynomial coefficients, highest power first.  If `y` was 2-D, the
coefficients for `k`-th data set are in ``p[:,k]``.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Present only if `full` = True.  Residuals of the least-squares fit,
the effective rank of the scaled Vandermonde coefficient matrix,
its singular values, and the specified value of `rcond`. For more
details, see `linalg.lstsq`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="2">
      <docstring>Present only if `full` = True.  Residuals of the least-squares fit,
the effective rank of the scaled Vandermonde coefficient matrix,
its singular values, and the specified value of `rcond`. For more
details, see `linalg.lstsq`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3">
      <docstring>Present only if `full` = True.  Residuals of the least-squares fit,
the effective rank of the scaled Vandermonde coefficient matrix,
its singular values, and the specified value of `rcond`. For more
details, see `linalg.lstsq`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="4">
      <docstring>Present only if `full` = True.  Residuals of the least-squares fit,
the effective rank of the scaled Vandermonde coefficient matrix,
its singular values, and the specified value of `rcond`. For more
details, see `linalg.lstsq`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="V" name="V" show_port="True" sort_key="5">
      <docstring>Present only if `full` = False and `cov`=True.  The covariance
matrix of the polynomial coefficient estimates.  The diagonal of
this matrix are the variance estimates for each coefficient.  If y
is a 2-D array, then the covariance matrix for the `k`-th data set
are in ``V[:,:,k]``</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.setdiff1d" module_name="setdiff1d" namespace="'ma'">
    <docstring>Set difference of 1D arrays with unique elements.

The output is always a masked array. See `numpy.setdiff1d` for more
details.

See Also
--------
numpy.setdiff1d : Equivalent function for ndarrays.

Examples
--------
&gt;&gt;&gt; x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
&gt;&gt;&gt; np.ma.setdiff1d(x, [1, 2])
masked_array(data = [3 --],
             mask = [False  True],
       fill_value = 999999)</docstring>
    <inputPortSpec arg="ar1" name="ar1" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ar2" name="ar2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="assume_unique" name="assume_unique" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.setxor1d" module_name="setxor1d" namespace="'ma'">
    <docstring>Set exclusive-or of 1-D arrays with unique elements.

The output is always a masked array. See `numpy.setxor1d` for more details.

See Also
--------
numpy.setxor1d : Equivalent function for ndarrays.</docstring>
    <inputPortSpec arg="ar1" name="ar1" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ar2" name="ar2" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="assume_unique" name="assume_unique" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.unique" module_name="unique" namespace="'ma'">
    <docstring>Finds the unique elements of an array.

Masked values are considered the same element (masked). The output array
is always a masked array. See `numpy.unique` for more details.

See Also
--------
numpy.unique : Equivalent function for ndarrays.</docstring>
    <inputPortSpec arg="return_inverse" name="return_inverse" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="ar1" name="ar1" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="return_index" name="return_index" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.union1d" module_name="union1d" namespace="'ma'">
    <docstring>Union of two arrays.

The output is always a masked array. See `numpy.union1d` for more details.

See also
--------
numpy.union1d : Equivalent function for ndarrays.</docstring>
    <inputPortSpec arg="ar1" name="ar1" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ar2" name="ar2" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.vander" module_name="vander" namespace="'ma'">
    <docstring>Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

    .. versionadded:: 1.9.0

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; N = 3
&gt;&gt;&gt; np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
&gt;&gt;&gt; np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

&gt;&gt;&gt; np.linalg.det(np.vander(x))
48.000000000000043
&gt;&gt;&gt; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48



Notes
-----

Masked values in the input array result in rows of zeros.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of columns in the output.  If `N` is not specified, a square
array is returned (``N = len(x)``).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="increasing" name="increasing" port_type="basic:Boolean">
      <docstring>Order of the powers of the columns.  If True, the powers increase
from left to right, if False (the default) they are reversed.

.. versionadded:: 1.9.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Vandermonde matrix.  If `increasing` is False, the first column is
``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
True, the columns are ``x^0, x^1, ..., x^(N-1)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
</specs>
