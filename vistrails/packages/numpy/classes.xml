<specs>
  <moduleSpec code_ref="numpy.ndarray" module_name="ndarray" namespace="'array'">
    <docstring>ndarray(shape, dtype=float, buffer=None, offset=0,
        strides=None, order=None)

An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)

Arrays should be constructed using `array`, `zeros` or `empty` (refer
to the See Also section below).  The parameters given here refer to
a low-level method (`ndarray(...)`) for instantiating an array.

For more information, refer to the `numpy` module and examine the
the methods and attributes of an array.

Parameters
----------
(for the __new__ method; see Notes below)

shape : tuple of ints
    Shape of created array.
dtype : data-type, optional
    Any object that can be interpreted as a numpy data type.
buffer : object exposing buffer interface, optional
    Used to fill the array with data.
offset : int, optional
    Offset of array data in buffer.
strides : tuple of ints, optional
    Strides of data in memory.
order : {'C', 'F'}, optional
    Row-major (C-style) or column-major (Fortran-style) order.

Attributes
----------
T : ndarray
    Transpose of the array.
data : buffer
    The array's elements, in memory.
dtype : dtype object
    Describes the format of the elements in the array.
flags : dict
    Dictionary containing information related to memory use, e.g.,
    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.
flat : numpy.flatiter object
    Flattened version of the array as an iterator.  The iterator
    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for
    assignment examples; TODO).
imag : ndarray
    Imaginary part of the array.
real : ndarray
    Real part of the array.
size : int
    Number of elements in the array.
itemsize : int
    The memory use of each array element in bytes.
nbytes : int
    The total number of bytes required to store the array data,
    i.e., ``itemsize * size``.
ndim : int
    The array's number of dimensions.
shape : tuple of ints
    Shape of the array.
strides : tuple of ints
    The step-size required to move from one element to the next in
    memory. For example, a contiguous ``(3, 4)`` array of type
    ``int16`` in C-order has strides ``(8, 2)``.  This implies that
    to move from element to element in memory requires jumps of 2 bytes.
    To move from row-to-row, one needs to jump 8 bytes at a time
    (``2 * 4``).
ctypes : ctypes object
    Class containing properties of the array needed for interaction
    with ctypes.
base : ndarray
    If the array is a view into another array, that array is its `base`
    (unless that array is also a view).  The `base` array is where the
    array data is actually stored.

See Also
--------
array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,
        it contains "garbage").
dtype : Create a data-type.

Notes
-----
There are two modes of creating an array using ``__new__``:

1. If `buffer` is None, then only `shape`, `dtype`, and `order`
   are used.
2. If `buffer` is an object exposing the buffer interface, then
   all keywords are interpreted.

No ``__init__`` method is needed because the array is fully initialized
after the ``__new__`` method.

Examples
--------
These examples illustrate the low-level `ndarray` constructor.  Refer
to the `See Also` section above for easier ways of constructing an
ndarray.

First mode, `buffer` is None:

&gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order='F')
array([[ -1.13698227e+002,   4.25087011e-303],
       [  2.88528414e-306,   3.27025015e-309]])         #random

Second mode:

&gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]),
...            offset=np.int_().itemsize,
...            dtype=int) # offset = 1*itemsize, i.e. skip first element
array([2, 3])</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shape" depth="1" method_type="argument" name="shape" port_type="basic:Integer" show_port="True">
      <docstring>Shape of created array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" method_type="argument" name="dtype" port_type="basic:Variant">
      <docstring>Any object that can be interpreted as a numpy data type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="buffer" depth="1" method_type="argument" name="buffer" port_type="basic:Integer">
      <docstring>Used to fill the array with data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="offset" method_type="argument" name="offset" port_type="basic:Integer">
      <docstring>Offset of array data in buffer.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="strides" depth="1" method_type="argument" name="strides" port_type="basic:Integer">
      <docstring>Strides of data in memory.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" method_type="argument" name="order">
      <docstring>Row-major (C-style) or column-major (Fortran-style) order.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ndarray" module_name="ndarrayInspector" namespace="'array'">
    <docstring>ndarray(shape, dtype=float, buffer=None, offset=0,
        strides=None, order=None)

An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)

Arrays should be constructed using `array`, `zeros` or `empty` (refer
to the See Also section below).  The parameters given here refer to
a low-level method (`ndarray(...)`) for instantiating an array.

For more information, refer to the `numpy` module and examine the
the methods and attributes of an array.

Parameters
----------
(for the __new__ method; see Notes below)

shape : tuple of ints
    Shape of created array.
dtype : data-type, optional
    Any object that can be interpreted as a numpy data type.
buffer : object exposing buffer interface, optional
    Used to fill the array with data.
offset : int, optional
    Offset of array data in buffer.
strides : tuple of ints, optional
    Strides of data in memory.
order : {'C', 'F'}, optional
    Row-major (C-style) or column-major (Fortran-style) order.

Attributes
----------
T : ndarray
    Transpose of the array.
data : buffer
    The array's elements, in memory.
dtype : dtype object
    Describes the format of the elements in the array.
flags : dict
    Dictionary containing information related to memory use, e.g.,
    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.
flat : numpy.flatiter object
    Flattened version of the array as an iterator.  The iterator
    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for
    assignment examples; TODO).
imag : ndarray
    Imaginary part of the array.
real : ndarray
    Real part of the array.
size : int
    Number of elements in the array.
itemsize : int
    The memory use of each array element in bytes.
nbytes : int
    The total number of bytes required to store the array data,
    i.e., ``itemsize * size``.
ndim : int
    The array's number of dimensions.
shape : tuple of ints
    Shape of the array.
strides : tuple of ints
    The step-size required to move from one element to the next in
    memory. For example, a contiguous ``(3, 4)`` array of type
    ``int16`` in C-order has strides ``(8, 2)``.  This implies that
    to move from element to element in memory requires jumps of 2 bytes.
    To move from row-to-row, one needs to jump 8 bytes at a time
    (``2 * 4``).
ctypes : ctypes object
    Class containing properties of the array needed for interaction
    with ctypes.
base : ndarray
    If the array is a view into another array, that array is its `base`
    (unless that array is also a view).  The `base` array is where the
    array data is actually stored.

See Also
--------
array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,
        it contains "garbage").
dtype : Create a data-type.

Notes
-----
There are two modes of creating an array using ``__new__``:

1. If `buffer` is None, then only `shape`, `dtype`, and `order`
   are used.
2. If `buffer` is an object exposing the buffer interface, then
   all keywords are interpreted.

No ``__init__`` method is needed because the array is fully initialized
after the ``__new__`` method.

Examples
--------
These examples illustrate the low-level `ndarray` constructor.  Refer
to the `See Also` section above for easier ways of constructing an
ndarray.

First mode, `buffer` is None:

&gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order='F')
array([[ -1.13698227e+002,   4.25087011e-303],
       [  2.88528414e-306,   3.27025015e-309]])         #random

Second mode:

&gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]),
...            offset=np.int_().itemsize,
...            dtype=int) # offset = 1*itemsize, i.e. skip first element
array([2, 3])</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" method_type="attribute" name="T" port_type="basic:List" sort_key="1000">
      <docstring>Same as self.transpose(), except that self is returned if
self.ndim &lt; 2.

Examples
--------
&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])
&gt;&gt;&gt; x
array([[ 1.,  2.],
       [ 3.,  4.]])
&gt;&gt;&gt; x.T
array([[ 1.,  3.],
       [ 2.,  4.]])
&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])
&gt;&gt;&gt; x
array([ 1.,  2.,  3.,  4.])
&gt;&gt;&gt; x.T
array([ 1.,  2.,  3.,  4.])</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="attribute" name="data" port_type="basic:Variant" sort_key="1001">
      <docstring>Python buffer object pointing to the start of the array's data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" method_type="attribute" name="dtype" port_type="basic:List" sort_key="1002">
      <docstring>Data-type of the array's elements.

Parameters
----------
None

Returns
-------
d : numpy dtype object

See Also
--------
numpy.dtype

Examples
--------
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; x.dtype
dtype('int32')
&gt;&gt;&gt; type(x.dtype)
&lt;type 'numpy.dtype'&gt;</docstring>
    </inputPortSpec>
    <inputPortSpec arg="flags" method_type="attribute" name="flags" port_type="basic:Dictionary" sort_key="1003">
      <docstring>Information about the memory layout of the array.

Attributes
----------
C_CONTIGUOUS (C)
    The data is in a single, C-style contiguous segment.
F_CONTIGUOUS (F)
    The data is in a single, Fortran-style contiguous segment.
OWNDATA (O)
    The array owns the memory it uses or borrows it from another object.
WRITEABLE (W)
    The data area can be written to.  Setting this to False locks
    the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
    from its base array at creation time, but a view of a writeable
    array may be subsequently locked while the base array remains writeable.
    (The opposite is not true, in that a view of a locked array may not
    be made writeable.  However, currently, locking a base object does not
    lock any views that already reference it, so under that circumstance it
    is possible to alter the contents of a locked array via a previously
    created writeable view onto it.)  Attempting to change a non-writeable
    array raises a RuntimeError exception.
ALIGNED (A)
    The data and all elements are aligned appropriately for the hardware.
UPDATEIFCOPY (U)
    This array is a copy of some other array. When this array is
    deallocated, the base array will be updated with the contents of
    this array.
FNC
    F_CONTIGUOUS and not C_CONTIGUOUS.
FORC
    F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
BEHAVED (B)
    ALIGNED and WRITEABLE.
CARRAY (CA)
    BEHAVED and C_CONTIGUOUS.
FARRAY (FA)
    BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.

Notes
-----
The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
names are only supported in dictionary access.

Only the UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by
the user, via direct assignment to the attribute or dictionary entry,
or by calling `ndarray.setflags`.

The array flags cannot be set arbitrarily:

- UPDATEIFCOPY can only be set ``False``.
- ALIGNED can only be set ``True`` if the data is truly aligned.
- WRITEABLE can only be set ``True`` if the array owns its own memory
  or the ultimate owner of the memory exposes a writeable buffer
  interface or is a string.

Arrays can be both C-style and Fortran-style contiguous simultaneously.
This is clear for 1-dimensional arrays, but can also be true for higher
dimensional arrays.

Even for contiguous arrays a stride for a given dimension
``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``
or the array has no elements.
It does *not* generally hold that ``self.strides[-1] == self.itemsize``
for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for
Fortran-style contiguous arrays is true.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="flat" method_type="attribute" name="flat" port_type="basic:List" sort_key="1004">
      <docstring>A 1-D iterator over the array.

This is a `numpy.flatiter` instance, which acts similarly to, but is not
a subclass of, Python's built-in iterator object.

See Also
--------
flatten : Return a copy of the array collapsed into one dimension.

flatiter

Examples
--------
&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; x.flat[3]
4
&gt;&gt;&gt; x.T
array([[1, 4],
       [2, 5],
       [3, 6]])
&gt;&gt;&gt; x.T.flat[3]
5
&gt;&gt;&gt; type(x.flat)
&lt;type 'numpy.flatiter'&gt;

An assignment example:

&gt;&gt;&gt; x.flat = 3; x
array([[3, 3, 3],
       [3, 3, 3]])
&gt;&gt;&gt; x.flat[[1,4]] = 1; x
array([[3, 1, 3],
       [3, 1, 3]])</docstring>
    </inputPortSpec>
    <inputPortSpec arg="imag" method_type="attribute" name="imag" port_type="basic:List" sort_key="1005">
      <docstring>The imaginary part of the array.

Examples
--------
&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])
&gt;&gt;&gt; x.imag
array([ 0.        ,  0.70710678])
&gt;&gt;&gt; x.imag.dtype
dtype('float64')</docstring>
    </inputPortSpec>
    <inputPortSpec arg="real" method_type="attribute" name="real" port_type="basic:List" sort_key="1006">
      <docstring>The real part of the array.

Examples
--------
&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])
&gt;&gt;&gt; x.real
array([ 1.        ,  0.70710678])
&gt;&gt;&gt; x.real.dtype
dtype('float64')

See Also
--------
numpy.real : equivalent function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" method_type="attribute" name="size" port_type="basic:Integer" sort_key="1007">
      <docstring>Number of elements in the array.

Equivalent to ``np.prod(a.shape)``, i.e., the product of the array's
dimensions.

Examples
--------
&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)
&gt;&gt;&gt; x.size
30
&gt;&gt;&gt; np.prod(x.shape)
30</docstring>
    </inputPortSpec>
    <inputPortSpec arg="itemsize" method_type="attribute" name="itemsize" port_type="basic:Integer" sort_key="1008">
      <docstring>Length of one array element in bytes.

Examples
--------
&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)
&gt;&gt;&gt; x.itemsize
8
&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)
&gt;&gt;&gt; x.itemsize
16</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nbytes" method_type="attribute" name="nbytes" port_type="basic:Integer" sort_key="1009">
      <docstring>Total bytes consumed by the elements of the array.

Notes
-----
Does not include memory consumed by non-element attributes of the
array object.

Examples
--------
&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)
&gt;&gt;&gt; x.nbytes
480
&gt;&gt;&gt; np.prod(x.shape) * x.itemsize
480</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ndim" method_type="attribute" name="ndim" port_type="basic:Integer" sort_key="1010">
      <docstring>Number of array dimensions.

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3])
&gt;&gt;&gt; x.ndim
1
&gt;&gt;&gt; y = np.zeros((2, 3, 4))
&gt;&gt;&gt; y.ndim
3</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shape" depth="1" method_type="attribute" name="shape" port_type="basic:Integer" sort_key="1011">
      <docstring>Tuple of array dimensions.

Notes
-----
May be used to "reshape" the array, as long as this would not
require a change in the total number of elements

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 4])
&gt;&gt;&gt; x.shape
(4,)
&gt;&gt;&gt; y = np.zeros((2, 3, 4))
&gt;&gt;&gt; y.shape
(2, 3, 4)
&gt;&gt;&gt; y.shape = (3, 8)
&gt;&gt;&gt; y
array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; y.shape = (3, 6)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: total size of new array must be unchanged</docstring>
    </inputPortSpec>
    <inputPortSpec arg="strides" depth="1" method_type="attribute" name="strides" port_type="basic:Integer" sort_key="1012">
      <docstring>Tuple of bytes to step in each dimension when traversing an array.

The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
is::

    offset = sum(np.array(i) * a.strides)

A more detailed explanation of strides can be found in the
"ndarray.rst" file in the NumPy reference guide.

Notes
-----
Imagine an array of 32-bit integers (each 4 bytes)::

  x = np.array([[0, 1, 2, 3, 4],
                [5, 6, 7, 8, 9]], dtype=np.int32)

This array is stored in memory as 40 bytes, one after the other
(known as a contiguous block of memory).  The strides of an array tell
us how many bytes we have to skip in memory to move to the next position
along a certain axis.  For example, we have to skip 4 bytes (1 value) to
move to the next column, but 20 bytes (5 values) to get to the same
position in the next row.  As such, the strides for the array `x` will be
``(20, 4)``.

See Also
--------
numpy.lib.stride_tricks.as_strided

Examples
--------
&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))
&gt;&gt;&gt; y
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])
&gt;&gt;&gt; y.strides
(48, 16, 4)
&gt;&gt;&gt; y[1,1,1]
17
&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))
&gt;&gt;&gt; offset/y.itemsize
17

&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)
&gt;&gt;&gt; x.strides
(32, 4, 224, 1344)
&gt;&gt;&gt; i = np.array([3,5,2,2])
&gt;&gt;&gt; offset = sum(i * x.strides)
&gt;&gt;&gt; x[3,5,2,2]
813
&gt;&gt;&gt; offset / x.itemsize
813</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ctypes" method_type="attribute" name="ctypes" port_type="basic:List" sort_key="1013">
      <docstring>An object to simplify the interaction of the array with the ctypes
module.

This attribute creates an object that makes it easier to use arrays
when calling shared libraries with the ctypes module. The returned
object has, among others, data, shape, and strides attributes (see
Notes below) which themselves return ctypes objects that can be used
as arguments to a shared library.

Parameters
----------
None

Returns
-------
c : Python object
    Possessing attributes data, shape, strides, etc.

See Also
--------
numpy.ctypeslib

Notes
-----
Below are the public attributes of this object which were documented
in "Guide to NumPy" (we have omitted undocumented public attributes,
as well as documented private attributes):

* data: A pointer to the memory area of the array as a Python integer.
  This memory area may contain data that is not aligned, or not in correct
  byte-order. The memory area may not even be writeable. The array
  flags and data-type of this array should be respected when passing this
  attribute to arbitrary C-code to avoid trouble that can include Python
  crashing. User Beware! The value of this attribute is exactly the same
  as self._array_interface_['data'][0].

* shape (c_intp*self.ndim): A ctypes array of length self.ndim where
  the basetype is the C-integer corresponding to dtype('p') on this
  platform. This base-type could be c_int, c_long, or c_longlong
  depending on the platform. The c_intp type is defined accordingly in
  numpy.ctypeslib. The ctypes array contains the shape of the underlying
  array.

* strides (c_intp*self.ndim): A ctypes array of length self.ndim where
  the basetype is the same as for the shape attribute. This ctypes array
  contains the strides information from the underlying array. This strides
  information is important for showing how many bytes must be jumped to
  get to the next element in the array.

* data_as(obj): Return the data pointer cast to a particular c-types object.
  For example, calling self._as_parameter_ is equivalent to
  self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
  pointer to a ctypes array of floating-point data:
  self.data_as(ctypes.POINTER(ctypes.c_double)).

* shape_as(obj): Return the shape tuple as an array of some other c-types
  type. For example: self.shape_as(ctypes.c_short).

* strides_as(obj): Return the strides tuple as an array of some other
  c-types type. For example: self.strides_as(ctypes.c_longlong).

Be careful using the ctypes attribute - especially on temporary
arrays or arrays constructed on the fly. For example, calling
``(a+b).ctypes.data_as(ctypes.c_void_p)`` returns a pointer to memory
that is invalid because the array created as (a+b) is deallocated
before the next Python statement. You can avoid this problem using
either ``c=a+b`` or ``ct=(a+b).ctypes``. In the latter case, ct will
hold a reference to the array until ct is deleted or re-assigned.

If the ctypes module is not available, then the ctypes attribute
of array objects still returns something useful, but ctypes objects
are not returned and errors may be raised instead. In particular,
the object will still have the as parameter attribute which will
return an integer equal to the data attribute.

Examples
--------
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; x.ctypes.data
30439712
&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))
&lt;ctypes.LP_c_long object at 0x01F01300&gt;
&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents
c_long(0)
&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents
c_longlong(4294967296L)
&gt;&gt;&gt; x.ctypes.shape
&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;
&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)
&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;
&gt;&gt;&gt; x.ctypes.strides
&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;
&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)
&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;</docstring>
    </inputPortSpec>
    <inputPortSpec arg="base" method_type="attribute" name="base" port_type="basic:List" sort_key="1014">
      <docstring>Base object if memory is from some other object.

Examples
--------
The base of an array that owns its memory is None:

&gt;&gt;&gt; x = np.array([1,2,3,4])
&gt;&gt;&gt; x.base is None
True

Slicing creates a view, whose memory is shared with x:

&gt;&gt;&gt; y = x[2:]
&gt;&gt;&gt; y.base is x
True</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="T" method_type="attribute" name="T" port_type="basic:List" sort_key="1000">
      <docstring>Same as self.transpose(), except that self is returned if
self.ndim &lt; 2.

Examples
--------
&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])
&gt;&gt;&gt; x
array([[ 1.,  2.],
       [ 3.,  4.]])
&gt;&gt;&gt; x.T
array([[ 1.,  3.],
       [ 2.,  4.]])
&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])
&gt;&gt;&gt; x
array([ 1.,  2.,  3.,  4.])
&gt;&gt;&gt; x.T
array([ 1.,  2.,  3.,  4.])</docstring>
    </outputPortSpec>
    <outputPortSpec arg="data" method_type="attribute" name="data" port_type="basic:Variant" sort_key="1001">
      <docstring>Python buffer object pointing to the start of the array's data.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="dtype" method_type="attribute" name="dtype" port_type="basic:List" sort_key="1002">
      <docstring>Data-type of the array's elements.

Parameters
----------
None

Returns
-------
d : numpy dtype object

See Also
--------
numpy.dtype

Examples
--------
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; x.dtype
dtype('int32')
&gt;&gt;&gt; type(x.dtype)
&lt;type 'numpy.dtype'&gt;</docstring>
    </outputPortSpec>
    <outputPortSpec arg="flags" method_type="attribute" name="flags" port_type="basic:Dictionary" sort_key="1003">
      <docstring>Information about the memory layout of the array.

Attributes
----------
C_CONTIGUOUS (C)
    The data is in a single, C-style contiguous segment.
F_CONTIGUOUS (F)
    The data is in a single, Fortran-style contiguous segment.
OWNDATA (O)
    The array owns the memory it uses or borrows it from another object.
WRITEABLE (W)
    The data area can be written to.  Setting this to False locks
    the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
    from its base array at creation time, but a view of a writeable
    array may be subsequently locked while the base array remains writeable.
    (The opposite is not true, in that a view of a locked array may not
    be made writeable.  However, currently, locking a base object does not
    lock any views that already reference it, so under that circumstance it
    is possible to alter the contents of a locked array via a previously
    created writeable view onto it.)  Attempting to change a non-writeable
    array raises a RuntimeError exception.
ALIGNED (A)
    The data and all elements are aligned appropriately for the hardware.
UPDATEIFCOPY (U)
    This array is a copy of some other array. When this array is
    deallocated, the base array will be updated with the contents of
    this array.
FNC
    F_CONTIGUOUS and not C_CONTIGUOUS.
FORC
    F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
BEHAVED (B)
    ALIGNED and WRITEABLE.
CARRAY (CA)
    BEHAVED and C_CONTIGUOUS.
FARRAY (FA)
    BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.

Notes
-----
The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
names are only supported in dictionary access.

Only the UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by
the user, via direct assignment to the attribute or dictionary entry,
or by calling `ndarray.setflags`.

The array flags cannot be set arbitrarily:

- UPDATEIFCOPY can only be set ``False``.
- ALIGNED can only be set ``True`` if the data is truly aligned.
- WRITEABLE can only be set ``True`` if the array owns its own memory
  or the ultimate owner of the memory exposes a writeable buffer
  interface or is a string.

Arrays can be both C-style and Fortran-style contiguous simultaneously.
This is clear for 1-dimensional arrays, but can also be true for higher
dimensional arrays.

Even for contiguous arrays a stride for a given dimension
``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``
or the array has no elements.
It does *not* generally hold that ``self.strides[-1] == self.itemsize``
for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for
Fortran-style contiguous arrays is true.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="flat" method_type="attribute" name="flat" port_type="basic:List" sort_key="1004">
      <docstring>A 1-D iterator over the array.

This is a `numpy.flatiter` instance, which acts similarly to, but is not
a subclass of, Python's built-in iterator object.

See Also
--------
flatten : Return a copy of the array collapsed into one dimension.

flatiter

Examples
--------
&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; x.flat[3]
4
&gt;&gt;&gt; x.T
array([[1, 4],
       [2, 5],
       [3, 6]])
&gt;&gt;&gt; x.T.flat[3]
5
&gt;&gt;&gt; type(x.flat)
&lt;type 'numpy.flatiter'&gt;

An assignment example:

&gt;&gt;&gt; x.flat = 3; x
array([[3, 3, 3],
       [3, 3, 3]])
&gt;&gt;&gt; x.flat[[1,4]] = 1; x
array([[3, 1, 3],
       [3, 1, 3]])</docstring>
    </outputPortSpec>
    <outputPortSpec arg="imag" method_type="attribute" name="imag" port_type="basic:List" sort_key="1005">
      <docstring>The imaginary part of the array.

Examples
--------
&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])
&gt;&gt;&gt; x.imag
array([ 0.        ,  0.70710678])
&gt;&gt;&gt; x.imag.dtype
dtype('float64')</docstring>
    </outputPortSpec>
    <outputPortSpec arg="real" method_type="attribute" name="real" port_type="basic:List" sort_key="1006">
      <docstring>The real part of the array.

Examples
--------
&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])
&gt;&gt;&gt; x.real
array([ 1.        ,  0.70710678])
&gt;&gt;&gt; x.real.dtype
dtype('float64')

See Also
--------
numpy.real : equivalent function</docstring>
    </outputPortSpec>
    <outputPortSpec arg="size" method_type="attribute" name="size" port_type="basic:Integer" sort_key="1007">
      <docstring>Number of elements in the array.

Equivalent to ``np.prod(a.shape)``, i.e., the product of the array's
dimensions.

Examples
--------
&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)
&gt;&gt;&gt; x.size
30
&gt;&gt;&gt; np.prod(x.shape)
30</docstring>
    </outputPortSpec>
    <outputPortSpec arg="itemsize" method_type="attribute" name="itemsize" port_type="basic:Integer" sort_key="1008">
      <docstring>Length of one array element in bytes.

Examples
--------
&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)
&gt;&gt;&gt; x.itemsize
8
&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)
&gt;&gt;&gt; x.itemsize
16</docstring>
    </outputPortSpec>
    <outputPortSpec arg="nbytes" method_type="attribute" name="nbytes" port_type="basic:Integer" sort_key="1009">
      <docstring>Total bytes consumed by the elements of the array.

Notes
-----
Does not include memory consumed by non-element attributes of the
array object.

Examples
--------
&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)
&gt;&gt;&gt; x.nbytes
480
&gt;&gt;&gt; np.prod(x.shape) * x.itemsize
480</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ndim" method_type="attribute" name="ndim" port_type="basic:Integer" sort_key="1010">
      <docstring>Number of array dimensions.

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3])
&gt;&gt;&gt; x.ndim
1
&gt;&gt;&gt; y = np.zeros((2, 3, 4))
&gt;&gt;&gt; y.ndim
3</docstring>
    </outputPortSpec>
    <outputPortSpec arg="shape" depth="1" method_type="attribute" name="shape" port_type="basic:Integer" sort_key="1011">
      <docstring>Tuple of array dimensions.

Notes
-----
May be used to "reshape" the array, as long as this would not
require a change in the total number of elements

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 4])
&gt;&gt;&gt; x.shape
(4,)
&gt;&gt;&gt; y = np.zeros((2, 3, 4))
&gt;&gt;&gt; y.shape
(2, 3, 4)
&gt;&gt;&gt; y.shape = (3, 8)
&gt;&gt;&gt; y
array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; y.shape = (3, 6)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: total size of new array must be unchanged</docstring>
    </outputPortSpec>
    <outputPortSpec arg="strides" depth="1" method_type="attribute" name="strides" port_type="basic:Integer" sort_key="1012">
      <docstring>Tuple of bytes to step in each dimension when traversing an array.

The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
is::

    offset = sum(np.array(i) * a.strides)

A more detailed explanation of strides can be found in the
"ndarray.rst" file in the NumPy reference guide.

Notes
-----
Imagine an array of 32-bit integers (each 4 bytes)::

  x = np.array([[0, 1, 2, 3, 4],
                [5, 6, 7, 8, 9]], dtype=np.int32)

This array is stored in memory as 40 bytes, one after the other
(known as a contiguous block of memory).  The strides of an array tell
us how many bytes we have to skip in memory to move to the next position
along a certain axis.  For example, we have to skip 4 bytes (1 value) to
move to the next column, but 20 bytes (5 values) to get to the same
position in the next row.  As such, the strides for the array `x` will be
``(20, 4)``.

See Also
--------
numpy.lib.stride_tricks.as_strided

Examples
--------
&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))
&gt;&gt;&gt; y
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])
&gt;&gt;&gt; y.strides
(48, 16, 4)
&gt;&gt;&gt; y[1,1,1]
17
&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))
&gt;&gt;&gt; offset/y.itemsize
17

&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)
&gt;&gt;&gt; x.strides
(32, 4, 224, 1344)
&gt;&gt;&gt; i = np.array([3,5,2,2])
&gt;&gt;&gt; offset = sum(i * x.strides)
&gt;&gt;&gt; x[3,5,2,2]
813
&gt;&gt;&gt; offset / x.itemsize
813</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ctypes" method_type="attribute" name="ctypes" port_type="basic:List" sort_key="1013">
      <docstring>An object to simplify the interaction of the array with the ctypes
module.

This attribute creates an object that makes it easier to use arrays
when calling shared libraries with the ctypes module. The returned
object has, among others, data, shape, and strides attributes (see
Notes below) which themselves return ctypes objects that can be used
as arguments to a shared library.

Parameters
----------
None

Returns
-------
c : Python object
    Possessing attributes data, shape, strides, etc.

See Also
--------
numpy.ctypeslib

Notes
-----
Below are the public attributes of this object which were documented
in "Guide to NumPy" (we have omitted undocumented public attributes,
as well as documented private attributes):

* data: A pointer to the memory area of the array as a Python integer.
  This memory area may contain data that is not aligned, or not in correct
  byte-order. The memory area may not even be writeable. The array
  flags and data-type of this array should be respected when passing this
  attribute to arbitrary C-code to avoid trouble that can include Python
  crashing. User Beware! The value of this attribute is exactly the same
  as self._array_interface_['data'][0].

* shape (c_intp*self.ndim): A ctypes array of length self.ndim where
  the basetype is the C-integer corresponding to dtype('p') on this
  platform. This base-type could be c_int, c_long, or c_longlong
  depending on the platform. The c_intp type is defined accordingly in
  numpy.ctypeslib. The ctypes array contains the shape of the underlying
  array.

* strides (c_intp*self.ndim): A ctypes array of length self.ndim where
  the basetype is the same as for the shape attribute. This ctypes array
  contains the strides information from the underlying array. This strides
  information is important for showing how many bytes must be jumped to
  get to the next element in the array.

* data_as(obj): Return the data pointer cast to a particular c-types object.
  For example, calling self._as_parameter_ is equivalent to
  self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
  pointer to a ctypes array of floating-point data:
  self.data_as(ctypes.POINTER(ctypes.c_double)).

* shape_as(obj): Return the shape tuple as an array of some other c-types
  type. For example: self.shape_as(ctypes.c_short).

* strides_as(obj): Return the strides tuple as an array of some other
  c-types type. For example: self.strides_as(ctypes.c_longlong).

Be careful using the ctypes attribute - especially on temporary
arrays or arrays constructed on the fly. For example, calling
``(a+b).ctypes.data_as(ctypes.c_void_p)`` returns a pointer to memory
that is invalid because the array created as (a+b) is deallocated
before the next Python statement. You can avoid this problem using
either ``c=a+b`` or ``ct=(a+b).ctypes``. In the latter case, ct will
hold a reference to the array until ct is deleted or re-assigned.

If the ctypes module is not available, then the ctypes attribute
of array objects still returns something useful, but ctypes objects
are not returned and errors may be raised instead. In particular,
the object will still have the as parameter attribute which will
return an integer equal to the data attribute.

Examples
--------
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; x.ctypes.data
30439712
&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))
&lt;ctypes.LP_c_long object at 0x01F01300&gt;
&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents
c_long(0)
&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents
c_longlong(4294967296L)
&gt;&gt;&gt; x.ctypes.shape
&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;
&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)
&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;
&gt;&gt;&gt; x.ctypes.strides
&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;
&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)
&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;</docstring>
    </outputPortSpec>
    <outputPortSpec arg="base" method_type="attribute" name="base" port_type="basic:List" sort_key="1014">
      <docstring>Base object if memory is from some other object.

Examples
--------
The base of an array that owns its memory is None:

&gt;&gt;&gt; x = np.array([1,2,3,4])
&gt;&gt;&gt; x.base is None
True

Slicing creates a view, whose memory is shared with x:

&gt;&gt;&gt; y = x[2:]
&gt;&gt;&gt; y.base is x
True</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.bool_" module_name="bool_" namespace="'dtypes'">
    <docstring>Numpy's Boolean type.  Character code: ``?``.  Alias: bool8</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.int8" module_name="int8" namespace="'dtypes'">
    <docstring>8-bit integer. Character code ``b``. C char compatible.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.int16" module_name="int16" namespace="'dtypes'">
    <docstring>16-bit integer. Character code ``h``. C short compatible.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.int32" module_name="int32" namespace="'dtypes'">
    <docstring>32-bit integer. Character code 'i'. C int compatible.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.int64" module_name="int64" namespace="'dtypes'">
    <docstring>64-bit integer. Character code 'l'. Python int compatible.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.uint8" module_name="uint8" namespace="'dtypes'">
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.uint16" module_name="uint16" namespace="'dtypes'">
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.uint32" module_name="uint32" namespace="'dtypes'">
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.uint64" module_name="uint64" namespace="'dtypes'">
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.float16" module_name="float16" namespace="'dtypes'">
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.float32" module_name="float32" namespace="'dtypes'">
    <docstring>32-bit floating-point number. Character code 'f'. C float compatible.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.float64" module_name="float64" namespace="'dtypes'">
    <docstring>64-bit floating-point number. Character code 'd'. Python float compatible.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.complex64" module_name="complex64" namespace="'dtypes'">
    <docstring>Composed of two 32 bit floats</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.complex128" module_name="complex128" namespace="'dtypes'">
    <docstring>Composed of two 64 bit floats</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.polynomial.Polynomial" module_name="Polynomial" namespace="'polynomial|polynomial'">
    <docstring>A power series class.

The Polynomial class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Polynomial coefficients in order of increasing degree, i.e.,
    ``(1, 2, 3)`` give ``1 + 2*x + 3*x**2``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coef" method_type="argument" name="coef" port_type="basic:List" show_port="True">
      <docstring>Polynomial coefficients in order of increasing degree, i.e.,
``(1, 2, 3)`` give ``1 + 2*x + 3*x**2``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" method_type="argument" name="domain" port_type="basic:List">
      <docstring>Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
to the interval ``[window[0], window[1]]`` by shifting and scaling.
The default value is [-1, 1].</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" method_type="argument" name="window" port_type="basic:List">
      <docstring>Window, see `domain` for its use. The default value is [-1, 1].

.. versionadded:: 1.6.0</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.chebyshev.Chebyshev" module_name="Chebyshev" namespace="'polynomial|chebyshev'">
    <docstring>A Chebyshev series class.

The Chebyshev class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
methods listed below.

Parameters
----------
coef : array_like
    Chebyshev coefficients in order of increasing degree, i.e.,
    ``(1, 2, 3)`` gives ``1*T_0(x) + 2*T_1(x) + 3*T_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coef" method_type="argument" name="coef" port_type="basic:List" show_port="True">
      <docstring>Chebyshev coefficients in order of increasing degree, i.e.,
``(1, 2, 3)`` gives ``1*T_0(x) + 2*T_1(x) + 3*T_2(x)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" method_type="argument" name="domain" port_type="basic:List">
      <docstring>Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
to the interval ``[window[0], window[1]]`` by shifting and scaling.
The default value is [-1, 1].</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" method_type="argument" name="window" port_type="basic:List">
      <docstring>Window, see `domain` for its use. The default value is [-1, 1].

.. versionadded:: 1.6.0</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.legendre.Legendre" module_name="Legendre" namespace="'polynomial|legendre'">
    <docstring>A Legendre series class.

The Legendre class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Legendre coefficients in order of increasing degree, i.e.,
    ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coef" method_type="argument" name="coef" port_type="basic:List" show_port="True">
      <docstring>Legendre coefficients in order of increasing degree, i.e.,
``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" method_type="argument" name="domain" port_type="basic:List">
      <docstring>Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
to the interval ``[window[0], window[1]]`` by shifting and scaling.
The default value is [-1, 1].</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" method_type="argument" name="window" port_type="basic:List">
      <docstring>Window, see `domain` for its use. The default value is [-1, 1].

.. versionadded:: 1.6.0</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.laguerre.Laguerre" module_name="Laguerre" namespace="'polynomial|laguerre'">
    <docstring>A Laguerre series class.

The Laguerre class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Laguerre coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [0, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [0, 1].

    .. versionadded:: 1.6.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coef" method_type="argument" name="coef" port_type="basic:List" show_port="True">
      <docstring>Laguerre coefficients in order of increasing degree, i.e,
``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" method_type="argument" name="domain" port_type="basic:List">
      <docstring>Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
to the interval ``[window[0], window[1]]`` by shifting and scaling.
The default value is [0, 1].</docstring>
      <defaults>[[0, 1]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" method_type="argument" name="window" port_type="basic:List">
      <docstring>Window, see `domain` for its use. The default value is [0, 1].

.. versionadded:: 1.6.0</docstring>
      <defaults>[[0, 1]]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite.Hermite" module_name="Hermite" namespace="'polynomial|hermite'">
    <docstring>An Hermite series class.

The Hermite class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Hermite coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*H_0(x) + 2*H_1(X) + 3*H_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coef" method_type="argument" name="coef" port_type="basic:List" show_port="True">
      <docstring>Hermite coefficients in order of increasing degree, i.e,
``(1, 2, 3)`` gives ``1*H_0(x) + 2*H_1(X) + 3*H_2(x)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" method_type="argument" name="domain" port_type="basic:List">
      <docstring>Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
to the interval ``[window[0], window[1]]`` by shifting and scaling.
The default value is [-1, 1].</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" method_type="argument" name="window" port_type="basic:List">
      <docstring>Window, see `domain` for its use. The default value is [-1, 1].

.. versionadded:: 1.6.0</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.polynomial.hermite_e.HermiteE" module_name="HermiteE" namespace="'polynomial|hermite_e'">
    <docstring>An HermiteE series class.

The HermiteE class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    HermiteE coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coef" method_type="argument" name="coef" port_type="basic:List" show_port="True">
      <docstring>HermiteE coefficients in order of increasing degree, i.e,
``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" method_type="argument" name="domain" port_type="basic:List">
      <docstring>Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
to the interval ``[window[0], window[1]]`` by shifting and scaling.
The default value is [-1, 1].</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" method_type="argument" name="window" port_type="basic:List">
      <docstring>Window, see `domain` for its use. The default value is [-1, 1].

.. versionadded:: 1.6.0</docstring>
      <defaults>[[-1, 1]]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.MAError" module_name="MAError" namespace="'ma'">
    <docstring>Class for masked array related errors.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.MaskError" module_name="MaskError" namespace="'ma'">
    <docstring>Class for mask related errors.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.MaskType" module_name="MaskType" namespace="'ma'">
    <docstring>Numpy's Boolean type.  Character code: ``?``.  Alias: bool8</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.MaskedArray" module_name="MaskedArray" namespace="'ma'">
    <docstring>An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None,
                  copy=False, subok=True, ndmin=0, fill_value=None,
                  keep_mask=True, hard_mask=None, shrink=True)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="argument" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mask" method_type="argument" name="mask" port_type="basic:List">
      <docstring>Mask. Must be convertible to an array of booleans with the same
shape as `data`. True indicates a masked (i.e. invalid) data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" method_type="argument" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the output.
If `dtype` is None, the type of the data argument (``data.dtype``)
is used. If `dtype` is not None and different from ``data.dtype``,
a copy is performed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" method_type="argument" name="copy" port_type="basic:Boolean">
      <docstring>Whether to copy the input data (True), or to use a reference instead.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="subok" method_type="argument" name="subok" port_type="basic:Boolean">
      <docstring>Whether to return a subclass of `MaskedArray` if possible (True) or a
plain `MaskedArray`. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndmin" method_type="argument" name="ndmin" port_type="basic:Integer">
      <docstring>Minimum number of dimensions. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Float">
      <docstring>Value used to fill in the masked values when necessary.
If None, a default based on the data-type is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keep_mask" method_type="argument" name="keep_mask" port_type="basic:Boolean">
      <docstring>Whether to combine `mask` with the mask of the input data, if any
(True), or to use only `mask` for the output (False). Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hard_mask" method_type="argument" name="hard_mask" port_type="basic:Boolean">
      <docstring>Whether to use a hard mask or not. With a hard mask, masked values
cannot be unmasked. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" method_type="argument" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to force compression of an empty mask. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.bool_" module_name="bool_" namespace="'ma'">
    <docstring>Numpy's Boolean type.  Character code: ``?``.  Alias: bool8</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.masked_array" module_name="masked_array" namespace="'ma'">
    <docstring>An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None,
                  copy=False, subok=True, ndmin=0, fill_value=None,
                  keep_mask=True, hard_mask=None, shrink=True)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="argument" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mask" method_type="argument" name="mask" port_type="basic:List">
      <docstring>Mask. Must be convertible to an array of booleans with the same
shape as `data`. True indicates a masked (i.e. invalid) data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" method_type="argument" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the output.
If `dtype` is None, the type of the data argument (``data.dtype``)
is used. If `dtype` is not None and different from ``data.dtype``,
a copy is performed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" method_type="argument" name="copy" port_type="basic:Boolean">
      <docstring>Whether to copy the input data (True), or to use a reference instead.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="subok" method_type="argument" name="subok" port_type="basic:Boolean">
      <docstring>Whether to return a subclass of `MaskedArray` if possible (True) or a
plain `MaskedArray`. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndmin" method_type="argument" name="ndmin" port_type="basic:Integer">
      <docstring>Minimum number of dimensions. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Float">
      <docstring>Value used to fill in the masked values when necessary.
If None, a default based on the data-type is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keep_mask" method_type="argument" name="keep_mask" port_type="basic:Boolean">
      <docstring>Whether to combine `mask` with the mask of the input data, if any
(True), or to use only `mask` for the output (False). Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hard_mask" method_type="argument" name="hard_mask" port_type="basic:Boolean">
      <docstring>Whether to use a hard mask or not. With a hard mask, masked values
cannot be unmasked. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="shrink" method_type="argument" name="shrink" port_type="basic:Boolean">
      <docstring>Whether to force compression of an empty mask. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="numpy.ma.mvoid" module_name="mvoid" namespace="'ma'">
    <docstring>Fake a 'void' object to use for masked array with structured dtypes.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
</specs>
