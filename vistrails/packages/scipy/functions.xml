<specs>
  <moduleSpec code_ref="scipy.interpolate._monotone.Akima1DInterpolator.__call__" is_method="True" module_name="Akima1DInterpolator.__call__" namespace="'interpolate|Akima1DInterpolatorMethods'">
    <docstring>Evaluate the piecewise polynomial or its derivative

Parameters
----------
x : array_like
    Points to evaluate the interpolant at.
nu : int, optional
    Order of derivative to evaluate. Must be non-negative.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Returns
-------
y : array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Points to evaluate the interpolant at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. Must be non-negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.Akima1DInterpolator.derivative" is_method="True" module_name="Akima1DInterpolator.derivative" namespace="'interpolate|Akima1DInterpolatorMethods'">
    <docstring>Construct a new piecewise polynomial representing the derivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the antiderivative is returned.

Returns
-------
pp : PPoly
    Piecewise polynomial of order k2 = k - n representing the derivative
    of this polynomial.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the antiderivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="pp" name="pp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k - n representing the derivative
of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.Akima1DInterpolator.antiderivative" is_method="True" module_name="Akima1DInterpolator.antiderivative" namespace="'interpolate|Akima1DInterpolatorMethods'">
    <docstring>Construct a new piecewise polynomial representing the antiderivative.

Antiderivativative is also the indefinite integral of the function,
and derivative is its inverse operation.

Parameters
----------
nu : int, optional
    Order of antiderivative to evaluate. (Default: 1)
    If negative, the derivative is returned.

Returns
-------
pp : PPoly
    Piecewise polynomial of order k2 = k + n representing
    the antiderivative of this polynomial.

Notes
-----
The antiderivative returned by this function is continuous and
continuously differentiable to order n-1, up to floating point
rounding error.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of antiderivative to evaluate. (Default: 1)
If negative, the derivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="pp" name="pp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k + n representing
the antiderivative of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.Akima1DInterpolator.roots" is_method="True" module_name="Akima1DInterpolator.roots" namespace="'interpolate|Akima1DInterpolatorMethods'">
    <docstring>Find real roots of the piecewise polynomial.

Parameters
----------
discontinuity : bool, optional
    Whether to report sign changes across discontinuities at
    breakpoints as roots.
extrapolate : bool, optional
    Whether to return roots from the polynomial extrapolated
    based on first and last intervals.

Returns
-------
roots : ndarray
    Roots of the polynomial(s).

    If the PPoly object describes multiple polynomials, the
    return value is an object array whose each element is an
    ndarray containing the roots.

Notes
-----
This routine works only on real-valued polynomials.

If the piecewise polynomial contains sections that are
identically zero, the root list will contain the start point
of the corresponding interval, followed by a ``nan`` value.

If the polynomial is discontinuous across a breakpoint, and
there is a sign change across the breakpoint, this is reported
if the `discont` parameter is True.

Examples
--------

Finding roots of ``[x**2 - 1, (x - 1)**2]`` defined on intervals
``[-2, 1], [1, 2]``:

&gt;&gt;&gt; from scipy.interpolate import PPoly
&gt;&gt;&gt; pp = PPoly(np.array([[1, 0, -1], [1, 0, 0]]).T, [-2, 1, 2])
&gt;&gt;&gt; pp.roots()
array([-1.,  1.])</docstring>
    <inputPortSpec arg="discontinuity" name="discontinuity" port_type="basic:Boolean">
      <docstring>Whether to report sign changes across discontinuities at
breakpoints as roots.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to return roots from the polynomial extrapolated
based on first and last intervals.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Roots of the polynomial(s).

If the PPoly object describes multiple polynomials, the
return value is an object array whose each element is an
ndarray containing the roots.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.BPoly.__call__" is_method="True" module_name="BPoly.__call__" namespace="'interpolate|BPolyMethods'">
    <docstring>Evaluate the piecewise polynomial or its derivative

Parameters
----------
x : array_like
    Points to evaluate the interpolant at.
nu : int, optional
    Order of derivative to evaluate. Must be non-negative.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Returns
-------
y : array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Points to evaluate the interpolant at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. Must be non-negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.BPoly.extend" is_method="True" module_name="BPoly.extend" namespace="'interpolate|BPolyMethods'">
    <docstring>Add additional breakpoints and coefficients to the polynomial.

Parameters
----------
c : ndarray, size (k, m, ...)
    Additional coefficients for polynomials in intervals
    ``self.x[-1] &lt;= x &lt; x_right[0]``, ``x_right[0] &lt;= x &lt; x_right[1]``,
    ..., ``x_right[m-2] &lt;= x &lt; x_right[m-1]``
x : ndarray, size (m,)
    Additional breakpoints. Must be sorted and either to
    the right or to the left of the current breakpoints.
right : bool, optional
    Whether the new intervals are to the right or to the left
    of the current intervals.</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Additional coefficients for polynomials in intervals
``self.x[-1] &lt;= x &lt; x_right[0]``, ``x_right[0] &lt;= x &lt; x_right[1]``,
..., ``x_right[m-2] &lt;= x &lt; x_right[m-1]``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Additional breakpoints. Must be sorted and either to
the right or to the left of the current breakpoints.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="right" name="right" port_type="basic:Boolean">
      <docstring>Whether the new intervals are to the right or to the left
of the current intervals.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.BPoly.derivative" is_method="True" module_name="BPoly.derivative" namespace="'interpolate|BPolyMethods'">
    <docstring>Construct a new piecewise polynomial representing the derivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the antiderivative is returned.

Returns
-------
bp : BPoly
    Piecewise polynomial of order k2 = k - nu representing the derivative
    of this polynomial.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the antiderivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k - nu representing the derivative
of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.BPoly.antiderivative" is_method="True" module_name="BPoly.antiderivative" namespace="'interpolate|BPolyMethods'">
    <docstring>Construct a new piecewise polynomial representing the antiderivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the derivative is returned.

Returns
-------
bp : BPoly
    Piecewise polynomial of order k2 = k + nu representing the
    antiderivative of this polynomial.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the derivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k + nu representing the
antiderivative of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.BPoly.integrate" is_method="True" module_name="BPoly.integrate" namespace="'interpolate|BPolyMethods'">
    <docstring>Compute a definite integral over a piecewise polynomial.

Parameters
----------
a : float
    Lower integration bound
b : float
    Upper integration bound
extrapolate : bool, optional
    Whether to extrapolate to out-of-bounds points based on first
    and last intervals, or to return NaNs.
    Defaults to ``self.extrapolate``.

Returns
-------
array_like
    Definite integral of the piecewise polynomial over [a, b]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Lower integration bound</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Upper integration bound</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to out-of-bounds points based on first
and last intervals, or to return NaNs.
Defaults to ``self.extrapolate``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Definite integral of the piecewise polynomial over [a, b]</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="__builtin__.type.construct_fast" is_method="True" module_name="type.construct_fast" namespace="'interpolate|BPolyMethods'">
    <docstring>Construct the piecewise polynomial without making checks.

Takes the same parameters as the constructor. Input arguments
`c` and `x` must be arrays of the correct shape and type.  The
`c` array can only be of dtypes float and complex, and `x`
array must have dtype float.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="c" name="c" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="cls" name="cls" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="__builtin__.type.from_power_basis" is_method="True" module_name="type.from_power_basis" namespace="'interpolate|BPolyMethods'">
    <docstring>Construct a piecewise polynomial in Bernstein basis
from a power basis polynomial.

Parameters
----------
pp : PPoly
    A piecewise polynomial in the power basis
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.</docstring>
    <inputPortSpec arg="pp" name="pp" port_type="basic:Variant" show_port="True">
      <docstring>A piecewise polynomial in the power basis</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs. Default: True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cls" name="cls" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="__builtin__.type.from_derivatives" is_method="True" module_name="type.from_derivatives" namespace="'interpolate|BPolyMethods'">
    <docstring>Construct a piecewise polynomial in the Bernstein basis,
compatible with the specified values and derivatives at breakpoints.

Parameters
----------
xi : array_like
    sorted 1D array of x-coordinates
yi : array_like or list of array_likes
    ``yi[i][j]`` is the ``j``-th derivative known at ``xi[i]``
orders : None or int or array_like of ints. Default: None.
    Specifies the degree of local polynomials. If not None, some
    derivatives are ignored.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.

Notes
-----
If ``k`` derivatives are specified at a breakpoint ``x``, the
constructed polynomial is exactly ``k`` times continuously
differentiable at ``x``, unless the ``order`` is provided explicitly.
In the latter case, the smoothness of the polynomial at
the breakpoint is controlled by the ``order``.

Deduces the number of derivatives to match at each end
from ``order`` and the number of derivatives available. If
possible it uses the same number of derivatives from
each end; if the number is odd it tries to take the
extra one from y2. In any case if not enough derivatives
are available at one end or another it draws enough to
make up the total from the other end.

If the order is too high and not enough derivatives are available,
an exception is raised.

Examples
--------

&gt;&gt;&gt; BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])

Creates a polynomial `f(x)` of degree 3, defined on `[0, 1]`
such that `f(0) = 1, df/dx(0) = 2, f(1) = 3, df/dx(1) = 4`

&gt;&gt;&gt; BPoly.from_derivatives([0, 1, 2], [[0, 1], [0], [2]])

Creates a piecewise polynomial `f(x)`, such that
`f(0) = f(1) = 0`, `f(2) = 2`, and `df/dx(0) = 1`.
Based on the number of derivatives provided, the order of the
local polynomials is 2 on `[0, 1]` and 1 on `[1, 2]`.
Notice that no restriction is imposed on the derivatives at
`x = 1` and `x = 2`.

Indeed, the explicit form of the polynomial is::

    f(x) = | x * (1 - x),  0 &lt;= x &lt; 1
           | 2 * (x - 1),  1 &lt;= x &lt;= 2

So that f'(1-0) = -1 and f'(1+0) = 2</docstring>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>sorted 1D array of x-coordinates</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" name="yi" port_type="basic:List" show_port="True">
      <docstring>``yi[i][j]`` is the ``j``-th derivative known at ``xi[i]``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="orders" name="ordersScalar" port_type="basic:Integer" show_port="True">
      <docstring>Specifies the degree of local polynomials. If not None, some
derivatives are ignored.</docstring>
      <alternateSpec arg="orders" depth="1" name="ordersSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs. Default: True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cls" name="cls" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpnd.CloughTocher2DInterpolator.__call__" is_method="True" module_name="CloughTocher2DInterpolator.__call__" namespace="'interpolate|CloughTocher2DInterpolatorMethods'">
    <docstring>interpolator(xi)

Evaluate interpolator at given points.

Parameters
----------
xi : ndarray of float, shape (..., ndim)
    Points where to interpolate data at.</docstring>
    <inputPortSpec arg="xi" depth="1" name="xi" port_type="basic:Float" show_port="True">
      <docstring>Points where to interpolate data at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpnd.LinearNDInterpolator.__call__" is_method="True" module_name="LinearNDInterpolator.__call__" namespace="'interpolate|LinearNDInterpolatorMethods'">
    <docstring>interpolator(xi)

Evaluate interpolator at given points.

Parameters
----------
xi : ndarray of float, shape (..., ndim)
    Points where to interpolate data at.</docstring>
    <inputPortSpec arg="xi" depth="1" name="xi" port_type="basic:Float" show_port="True">
      <docstring>Points where to interpolate data at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.ndgriddata.NearestNDInterpolator.__call__" is_method="True" module_name="NearestNDInterpolator.__call__" namespace="'interpolate|NearestNDInterpolatorMethods'">
    <docstring>Evaluate interpolator at given points.

Parameters
----------
xi : ndarray of float, shape (..., ndim)
    Points where to interpolate data at.</docstring>
    <inputPortSpec arg="xi" depth="1" name="xi" port_type="basic:Float" show_port="True">
      <docstring>Points where to interpolate data at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.PPoly.__call__" is_method="True" module_name="PPoly.__call__" namespace="'interpolate|PPolyMethods'">
    <docstring>Evaluate the piecewise polynomial or its derivative

Parameters
----------
x : array_like
    Points to evaluate the interpolant at.
nu : int, optional
    Order of derivative to evaluate. Must be non-negative.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Returns
-------
y : array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Points to evaluate the interpolant at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. Must be non-negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.PPoly.derivative" is_method="True" module_name="PPoly.derivative" namespace="'interpolate|PPolyMethods'">
    <docstring>Construct a new piecewise polynomial representing the derivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the antiderivative is returned.

Returns
-------
pp : PPoly
    Piecewise polynomial of order k2 = k - n representing the derivative
    of this polynomial.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the antiderivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="pp" name="pp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k - n representing the derivative
of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.PPoly.antiderivative" is_method="True" module_name="PPoly.antiderivative" namespace="'interpolate|PPolyMethods'">
    <docstring>Construct a new piecewise polynomial representing the antiderivative.

Antiderivativative is also the indefinite integral of the function,
and derivative is its inverse operation.

Parameters
----------
nu : int, optional
    Order of antiderivative to evaluate. (Default: 1)
    If negative, the derivative is returned.

Returns
-------
pp : PPoly
    Piecewise polynomial of order k2 = k + n representing
    the antiderivative of this polynomial.

Notes
-----
The antiderivative returned by this function is continuous and
continuously differentiable to order n-1, up to floating point
rounding error.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of antiderivative to evaluate. (Default: 1)
If negative, the derivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="pp" name="pp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k + n representing
the antiderivative of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.PPoly.integrate" is_method="True" module_name="PPoly.integrate" namespace="'interpolate|PPolyMethods'">
    <docstring>Compute a definite integral over a piecewise polynomial.

Parameters
----------
a : float
    Lower integration bound
b : float
    Upper integration bound
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Returns
-------
ig : array_like
    Definite integral of the piecewise polynomial over [a, b]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Lower integration bound</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Upper integration bound</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="ig" name="ig" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Definite integral of the piecewise polynomial over [a, b]</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.PPoly.roots" is_method="True" module_name="PPoly.roots" namespace="'interpolate|PPolyMethods'">
    <docstring>Find real roots of the piecewise polynomial.

Parameters
----------
discontinuity : bool, optional
    Whether to report sign changes across discontinuities at
    breakpoints as roots.
extrapolate : bool, optional
    Whether to return roots from the polynomial extrapolated
    based on first and last intervals.

Returns
-------
roots : ndarray
    Roots of the polynomial(s).

    If the PPoly object describes multiple polynomials, the
    return value is an object array whose each element is an
    ndarray containing the roots.

Notes
-----
This routine works only on real-valued polynomials.

If the piecewise polynomial contains sections that are
identically zero, the root list will contain the start point
of the corresponding interval, followed by a ``nan`` value.

If the polynomial is discontinuous across a breakpoint, and
there is a sign change across the breakpoint, this is reported
if the `discont` parameter is True.

Examples
--------

Finding roots of ``[x**2 - 1, (x - 1)**2]`` defined on intervals
``[-2, 1], [1, 2]``:

&gt;&gt;&gt; from scipy.interpolate import PPoly
&gt;&gt;&gt; pp = PPoly(np.array([[1, 0, -1], [1, 0, 0]]).T, [-2, 1, 2])
&gt;&gt;&gt; pp.roots()
array([-1.,  1.])</docstring>
    <inputPortSpec arg="discontinuity" name="discontinuity" port_type="basic:Boolean">
      <docstring>Whether to report sign changes across discontinuities at
breakpoints as roots.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to return roots from the polynomial extrapolated
based on first and last intervals.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="roots" name="roots" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Roots of the polynomial(s).

If the PPoly object describes multiple polynomials, the
return value is an object array whose each element is an
ndarray containing the roots.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.PPoly.extend" is_method="True" module_name="PPoly.extend" namespace="'interpolate|PPolyMethods'">
    <docstring>Add additional breakpoints and coefficients to the polynomial.

Parameters
----------
c : ndarray, size (k, m, ...)
    Additional coefficients for polynomials in intervals
    ``self.x[-1] &lt;= x &lt; x_right[0]``, ``x_right[0] &lt;= x &lt; x_right[1]``,
    ..., ``x_right[m-2] &lt;= x &lt; x_right[m-1]``
x : ndarray, size (m,)
    Additional breakpoints. Must be sorted and either to
    the right or to the left of the current breakpoints.
right : bool, optional
    Whether the new intervals are to the right or to the left
    of the current intervals.</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Additional coefficients for polynomials in intervals
``self.x[-1] &lt;= x &lt; x_right[0]``, ``x_right[0] &lt;= x &lt; x_right[1]``,
..., ``x_right[m-2] &lt;= x &lt; x_right[m-1]``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Additional breakpoints. Must be sorted and either to
the right or to the left of the current breakpoints.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="right" name="right" port_type="basic:Boolean">
      <docstring>Whether the new intervals are to the right or to the left
of the current intervals.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="__builtin__.type.from_spline" is_method="True" module_name="type.from_spline" namespace="'interpolate|PPolyMethods'">
    <docstring>Construct a piecewise polynomial from a spline

Parameters
----------
tck
    A spline, as returned by `splrep`
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.</docstring>
    <inputPortSpec arg="tck" name="tck" port_type="basic:Variant" show_port="True">
      <docstring>A spline, as returned by `splrep`</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs. Default: True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cls" name="cls" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="__builtin__.type.from_bernstein_basis" is_method="True" module_name="type.from_bernstein_basis" namespace="'interpolate|PPolyMethods'">
    <docstring>Construct a piecewise polynomial in the power basis
from a polynomial in Bernstein basis.

Parameters
----------
bp : BPoly
    A Bernstein basis polynomial, as created by BPoly
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.</docstring>
    <inputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True">
      <docstring>A Bernstein basis polynomial, as created by BPoly</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs. Default: True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cls" name="cls" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="__builtin__.type.construct_fast" is_method="True" module_name="type.construct_fast" namespace="'interpolate|PPolyMethods'">
    <docstring>Construct the piecewise polynomial without making checks.

Takes the same parameters as the constructor. Input arguments
`c` and `x` must be arrays of the correct shape and type.  The
`c` array can only be of dtypes float and complex, and `x`
array must have dtype float.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="c" name="c" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="cls" name="cls" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.PchipInterpolator.__call__" is_method="True" module_name="PchipInterpolator.__call__" namespace="'interpolate|PchipInterpolatorMethods'">
    <docstring>Evaluate the piecewise polynomial or its derivative

Parameters
----------
x : array_like
    Points to evaluate the interpolant at.
nu : int, optional
    Order of derivative to evaluate. Must be non-negative.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Returns
-------
y : array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Points to evaluate the interpolant at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. Must be non-negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.PchipInterpolator.derivative" is_method="True" module_name="PchipInterpolator.derivative" namespace="'interpolate|PchipInterpolatorMethods'">
    <docstring>Construct a new piecewise polynomial representing the derivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the antiderivative is returned.

Returns
-------
bp : BPoly
    Piecewise polynomial of order k2 = k - nu representing the derivative
    of this polynomial.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the antiderivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k - nu representing the derivative
of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.PchipInterpolator.antiderivative" is_method="True" module_name="PchipInterpolator.antiderivative" namespace="'interpolate|PchipInterpolatorMethods'">
    <docstring>Construct a new piecewise polynomial representing the antiderivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the derivative is returned.

Returns
-------
bp : BPoly
    Piecewise polynomial of order k2 = k + nu representing the
    antiderivative of this polynomial.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the derivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k + nu representing the
antiderivative of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.RegularGridInterpolator.__call__" is_method="True" module_name="RegularGridInterpolator.__call__" namespace="'interpolate|RegularGridInterpolatorMethods'">
    <docstring>Interpolation at coordinates

Parameters
----------
xi : ndarray of shape (..., ndim)
    The coordinates to sample the gridded data at

method : str
    The method of interpolation to perform. Supported are "linear" and
    "nearest".</docstring>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>The coordinates to sample the gridded data at
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method" show_port="True">
      <docstring>The method of interpolation to perform. Supported are "linear" and
"nearest".</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.interp1d.__call__" is_method="True" module_name="interp1d.__call__" namespace="'interpolate|interp1dMethods'">
    <docstring>Evaluate the interpolant

Parameters
----------
x : array_like
    Points to evaluate the interpolant at.

Returns
-------
y : array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Points to evaluate the interpolant at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpolate.interp2d.__call__" is_method="True" module_name="interp2d.__call__" namespace="'interpolate|interp2dMethods'">
    <docstring>Interpolate the function.

Parameters
----------
x : 1D array
    x-coordinates of the mesh on which to interpolate.
y : 1D array
    y-coordinates of the mesh on which to interpolate.
dx : int &gt;= 0, &lt; kx
    Order of partial derivatives in x.
dy : int &gt;= 0, &lt; ky
    Order of partial derivatives in y.
assume_sorted : bool, optional
    If False, values of `x` and `y` can be in any order and they are
    sorted first.
    If True, `x` and `y` have to be arrays of monotonically
    increasing values.

Returns
-------
z : 2D array with shape (len(y), len(x))
    The interpolated values.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>x-coordinates of the mesh on which to interpolate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>y-coordinates of the mesh on which to interpolate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Integer">
      <docstring>Order of partial derivatives in x.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dy" name="dy" port_type="basic:Integer">
      <docstring>Order of partial derivatives in y.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="assume_sorted" name="assume_sorted" port_type="basic:Boolean">
      <docstring>If False, values of `x` and `y` can be in any order and they are
sorted first.
If True, `x` and `y` have to be arrays of monotonically
increasing values.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The interpolated values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.PchipInterpolator.__call__" is_method="True" module_name="PchipInterpolator.__call__" namespace="'interpolate|pchipMethods'">
    <docstring>Evaluate the piecewise polynomial or its derivative

Parameters
----------
x : array_like
    Points to evaluate the interpolant at.
nu : int, optional
    Order of derivative to evaluate. Must be non-negative.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Returns
-------
y : array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

Notes
-----
Derivatives are evaluated piecewise for each polynomial
segment, even if the polynomial is not differentiable at the
breakpoints. The polynomial intervals are considered half-open,
``[a, b)``, except for the last interval which is closed
``[a, b]``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Points to evaluate the interpolant at.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. Must be non-negative.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.PchipInterpolator.derivative" is_method="True" module_name="PchipInterpolator.derivative" namespace="'interpolate|pchipMethods'">
    <docstring>Construct a new piecewise polynomial representing the derivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the antiderivative is returned.

Returns
-------
bp : BPoly
    Piecewise polynomial of order k2 = k - nu representing the derivative
    of this polynomial.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the antiderivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k - nu representing the derivative
of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate._monotone.PchipInterpolator.antiderivative" is_method="True" module_name="PchipInterpolator.antiderivative" namespace="'interpolate|pchipMethods'">
    <docstring>Construct a new piecewise polynomial representing the antiderivative.

Parameters
----------
nu : int, optional
    Order of derivative to evaluate. (Default: 1)
    If negative, the derivative is returned.

Returns
-------
bp : BPoly
    Piecewise polynomial of order k2 = k + nu representing the
    antiderivative of this polynomial.</docstring>
    <inputPortSpec arg="nu" name="nu" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. (Default: 1)
If negative, the derivative is returned.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg_pos="0" max_conns="1" min_conns="1" name="Instance" port_type="basic:Variant" show_port="True" sort_key="-1000" />
    <outputPortSpec arg="bp" name="bp" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Piecewise polynomial of order k2 = k + nu representing the
antiderivative of this polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.vq.whiten" module_name="whiten" namespace="'cluster|vq'">
    <docstring>Normalize a group of observations on a per feature basis.

Before running k-means, it is beneficial to rescale each feature
dimension of the observation set with whitening. Each feature is
divided by its standard deviation across all observations to give
it unit variance.

Parameters
----------
obs : ndarray
    Each row of the array is an observation.  The
    columns are the features seen during each observation.

    &gt;&gt;&gt; #         f0    f1    f2
    &gt;&gt;&gt; obs = [[  1.,   1.,   1.],  #o0
    ...        [  2.,   2.,   2.],  #o1
    ...        [  3.,   3.,   3.],  #o2
    ...        [  4.,   4.,   4.]]  #o3

check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default: True

Returns
-------
result : ndarray
    Contains the values in `obs` scaled by the standard deviation
    of each column.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.vq import whiten
&gt;&gt;&gt; features  = np.array([[1.9, 2.3, 1.7],
...                       [1.5, 2.5, 2.2],
...                       [0.8, 0.6, 1.7,]])
&gt;&gt;&gt; whiten(features)
array([[ 4.17944278,  2.69811351,  7.21248917],
       [ 3.29956009,  2.93273208,  9.33380951],
       [ 1.75976538,  0.7038557 ,  7.21248917]])</docstring>
    <inputPortSpec arg="obs" name="obs" port_type="basic:List" show_port="True">
      <docstring>Each row of the array is an observation.  The
columns are the features seen during each observation.

&gt;&gt;&gt; #         f0    f1    f2
&gt;&gt;&gt; obs = [[  1.,   1.,   1.],  #o0
...        [  2.,   2.,   2.],  #o1
...        [  3.,   3.,   3.],  #o2
...        [  4.,   4.,   4.]]  #o3
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Contains the values in `obs` scaled by the standard deviation
of each column.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.vq.vq" module_name="vq" namespace="'cluster|vq'" output_type="list">
    <docstring>Assign codes from a code book to observations.

Assigns a code from a code book to each observation. Each
observation vector in the 'M' by 'N' `obs` array is compared with the
centroids in the code book and assigned the code of the closest
centroid.

The features in `obs` should have unit variance, which can be
achieved by passing them through the whiten function.  The code
book can be created with the k-means algorithm or a different
encoding algorithm.

Parameters
----------
obs : ndarray
    Each row of the 'M' x 'N' array is an observation.  The columns are
    the "features" seen during each observation. The features must be
    whitened first using the whiten function or something equivalent.
code_book : ndarray
    The code book is usually generated using the k-means algorithm.
    Each row of the array holds a different code, and the columns are
    the features of the code.

     &gt;&gt;&gt; #              f0    f1    f2   f3
     &gt;&gt;&gt; code_book = [
     ...             [  1.,   2.,   3.,   4.],  #c0
     ...             [  1.,   2.,   3.,   4.],  #c1
     ...             [  1.,   2.,   3.,   4.]]  #c2

check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default: True

Returns
-------
code : ndarray
    A length M array holding the code book index for each observation.
dist : ndarray
    The distortion (distance) between the observation and its nearest
    code.

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.cluster.vq import vq
&gt;&gt;&gt; code_book = array([[1.,1.,1.],
...                    [2.,2.,2.]])
&gt;&gt;&gt; features  = array([[  1.9,2.3,1.7],
...                    [  1.5,2.5,2.2],
...                    [  0.8,0.6,1.7]])
&gt;&gt;&gt; vq(features,code_book)
(array([1, 1, 0],'i'), array([ 0.43588989,  0.73484692,  0.83066239]))</docstring>
    <inputPortSpec arg="obs" name="obs" port_type="basic:List" show_port="True">
      <docstring>Each row of the 'M' x 'N' array is an observation.  The columns are
the "features" seen during each observation. The features must be
whitened first using the whiten function or something equivalent.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="code_book" name="code_book" port_type="basic:List" show_port="True">
      <docstring>The code book is usually generated using the k-means algorithm.
Each row of the array holds a different code, and the columns are
the features of the code.

 &gt;&gt;&gt; #              f0    f1    f2   f3
 &gt;&gt;&gt; code_book = [
 ...             [  1.,   2.,   3.,   4.],  #c0
 ...             [  1.,   2.,   3.,   4.],  #c1
 ...             [  1.,   2.,   3.,   4.]]  #c2
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="code" name="code" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A length M array holding the code book index for each observation.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="dist" name="dist" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The distortion (distance) between the observation and its nearest
code.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.vq.kmeans" module_name="kmeans" namespace="'cluster|vq'" output_type="list">
    <docstring>Performs k-means on a set of observation vectors forming k clusters.

The k-means algorithm adjusts the centroids until sufficient
progress cannot be made, i.e. the change in distortion since
the last iteration is less than some threshold. This yields
a code book mapping centroids to codes and vice versa.

Distortion is defined as the sum of the squared differences
between the observations and the corresponding centroid.

Parameters
----------
obs : ndarray
   Each row of the M by N array is an observation vector. The
   columns are the features seen during each observation.
   The features must be whitened first with the `whiten` function.

k_or_guess : int or ndarray
   The number of centroids to generate. A code is assigned to
   each centroid, which is also the row index of the centroid
   in the code_book matrix generated.

   The initial k centroids are chosen by randomly selecting
   observations from the observation matrix. Alternatively,
   passing a k by N array specifies the initial k centroids.

iter : int, optional
   The number of times to run k-means, returning the codebook
   with the lowest distortion. This argument is ignored if
   initial centroids are specified with an array for the
   ``k_or_guess`` parameter. This parameter does not represent the
   number of iterations of the k-means algorithm.

thresh : float, optional
   Terminates the k-means algorithm if the change in
   distortion since the last k-means iteration is less than
   or equal to thresh.

check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default: True

Returns
-------
codebook : ndarray
   A k by N array of k centroids. The i'th centroid
   codebook[i] is represented with the code i. The centroids
   and codes generated represent the lowest distortion seen,
   not necessarily the globally minimal distortion.

distortion : float
   The distortion between the observations passed and the
   centroids generated.

See Also
--------
kmeans2 : a different implementation of k-means clustering
   with more methods for generating initial centroids but without
   using a distortion change threshold as a stopping criterion.

whiten : must be called prior to passing an observation matrix
   to kmeans.

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.cluster.vq import vq, kmeans, whiten
&gt;&gt;&gt; features  = array([[ 1.9,2.3],
...                    [ 1.5,2.5],
...                    [ 0.8,0.6],
...                    [ 0.4,1.8],
...                    [ 0.1,0.1],
...                    [ 0.2,1.8],
...                    [ 2.0,0.5],
...                    [ 0.3,1.5],
...                    [ 1.0,1.0]])
&gt;&gt;&gt; whitened = whiten(features)
&gt;&gt;&gt; book = array((whitened[0],whitened[2]))
&gt;&gt;&gt; kmeans(whitened,book)
(array([[ 2.3110306 ,  2.86287398],
       [ 0.93218041,  1.24398691]]), 0.85684700941625547)

&gt;&gt;&gt; from numpy import random
&gt;&gt;&gt; random.seed((1000,2000))
&gt;&gt;&gt; codes = 3
&gt;&gt;&gt; kmeans(whitened,codes)
(array([[ 2.3110306 ,  2.86287398],
       [ 1.32544402,  0.65607529],
       [ 0.40782893,  2.02786907]]), 0.5196582527686241)</docstring>
    <inputPortSpec arg="obs" name="obs" port_type="basic:List" show_port="True">
      <docstring>Each row of the M by N array is an observation vector. The
columns are the features seen during each observation.
The features must be whitened first with the `whiten` function.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k_or_guess" name="k_or_guessScalar" port_type="basic:Integer" show_port="True">
      <docstring>The number of centroids to generate. A code is assigned to
each centroid, which is also the row index of the centroid
in the code_book matrix generated.

The initial k centroids are chosen by randomly selecting
observations from the observation matrix. Alternatively,
passing a k by N array specifies the initial k centroids.
</docstring>
      <alternateSpec arg="k_or_guess" name="k_or_guessSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>The number of times to run k-means, returning the codebook
with the lowest distortion. This argument is ignored if
initial centroids are specified with an array for the
``k_or_guess`` parameter. This parameter does not represent the
number of iterations of the k-means algorithm.
</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="thresh" name="thresh" port_type="basic:Float">
      <docstring>Terminates the k-means algorithm if the change in
distortion since the last k-means iteration is less than
or equal to thresh.
</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="codebook" name="codebook" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A k by N array of k centroids. The i'th centroid
codebook[i] is represented with the code i. The centroids
and codes generated represent the lowest distortion seen,
not necessarily the globally minimal distortion.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="distortion" name="distortion" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The distortion between the observations passed and the
centroids generated.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.vq.kmeans2" module_name="kmeans2" namespace="'cluster|vq'" output_type="list">
    <docstring>Classify a set of observations into k clusters using the k-means algorithm.

The algorithm attempts to minimize the Euclidian distance between
observations and centroids. Several initialization methods are
included.

Parameters
----------
data : ndarray
    A 'M' by 'N' array of 'M' observations in 'N' dimensions or a length
    'M' array of 'M' one-dimensional observations.
k : int or ndarray
    The number of clusters to form as well as the number of
    centroids to generate. If `minit` initialization string is
    'matrix', or if a ndarray is given instead, it is
    interpreted as initial cluster to use instead.
iter : int, optional
    Number of iterations of the k-means algrithm to run. Note
    that this differs in meaning from the iters parameter to
    the kmeans function.
thresh : float, optional
    (not used yet)
minit : str, optional
    Method for initialization. Available methods are 'random',
    'points', 'uniform', and 'matrix':

    'random': generate k centroids from a Gaussian with mean and
    variance estimated from the data.

    'points': choose k observations (rows) at random from data for
    the initial centroids.

    'uniform': generate k observations from the data from a uniform
    distribution defined by the data set (unsupported).

    'matrix': interpret the k parameter as a k by M (or length k
    array for one-dimensional data) array of initial centroids.
missing : str, optional
    Method to deal with empty clusters. Available methods are
    'warn' and 'raise':

    'warn': give a warning and continue.

    'raise': raise an ClusterError and terminate the algorithm.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default: True

Returns
-------
centroid : ndarray
    A 'k' by 'N' array of centroids found at the last iteration of
    k-means.
label : ndarray
    label[i] is the code or index of the centroid the
    i'th observation is closest to.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>A 'M' by 'N' array of 'M' observations in 'N' dimensions or a length
'M' array of 'M' one-dimensional observations.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="kScalar" port_type="basic:Integer" show_port="True">
      <docstring>The number of clusters to form as well as the number of
centroids to generate. If `minit` initialization string is
'matrix', or if a ndarray is given instead, it is
interpreted as initial cluster to use instead.</docstring>
      <alternateSpec arg="k" name="kSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations of the k-means algrithm to run. Note
that this differs in meaning from the iters parameter to
the kmeans function.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="thresh" name="thresh" port_type="basic:Float">
      <docstring>(not used yet)</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="minit" name="minit">
      <docstring>Method for initialization. Available methods are 'random',
'points', 'uniform', and 'matrix':

'random': generate k centroids from a Gaussian with mean and
variance estimated from the data.

'points': choose k observations (rows) at random from data for
the initial centroids.

'uniform': generate k observations from the data from a uniform
distribution defined by the data set (unsupported).

'matrix': interpret the k parameter as a k by M (or length k
array for one-dimensional data) array of initial centroids.</docstring>
      <defaults>['random']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="missing" name="missing">
      <docstring>Method to deal with empty clusters. Available methods are
'warn' and 'raise':

'warn': give a warning and continue.

'raise': raise an ClusterError and terminate the algorithm.</docstring>
      <defaults>['warn']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="centroid" name="centroid" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 'k' by 'N' array of centroids found at the last iteration of
k-means.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="label" name="label" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>label[i] is the code or index of the centroid the
i'th observation is closest to.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.average" module_name="average" namespace="'cluster|hierarchy'">
    <docstring>Performs average/UPGMA linkage on a condensed distance matrix

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The upper triangular of the distance matrix. The result of
``pdist`` is returned in this form.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A linkage matrix containing the hierarchical clustering. See
the ``linkage`` function documentation for more information
on its structure.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.centroid" module_name="centroid" namespace="'cluster|hierarchy'">
    <docstring>Performs centroid/UPGMC linkage.

See ``linkage`` for more information on the return structure
and algorithm.

The following are common calling conventions:

1. ``Z = centroid(y)``

   Performs centroid/UPGMC linkage on the condensed distance
   matrix ``y``.  See ``linkage`` for more information on the return
   structure and algorithm.

2. ``Z = centroid(X)``

   Performs centroid/UPGMC linkage on the observation matrix ``X``
   using Euclidean distance as the distance metric. See ``linkage``
   for more information on the return structure and algorithm.

Parameters
----------
y : ndarray
    A condensed or redundant distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    a m by n array.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>A condensed or redundant distance matrix. A condensed
distance matrix is a flat array containing the upper
triangular of the distance matrix. This is the form that
``pdist`` returns. Alternatively, a collection of
m observation vectors in n dimensions may be passed as
a m by n array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A linkage matrix containing the hierarchical clustering. See
the ``linkage`` function documentation for more information
on its structure.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.complete" module_name="complete" namespace="'cluster|hierarchy'">
    <docstring>Performs complete/max/farthest point linkage on a condensed distance matrix

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The upper triangular of the distance matrix. The result of
``pdist`` is returned in this form.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A linkage matrix containing the hierarchical clustering. See
the ``linkage`` function documentation for more information
on its structure.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.cophenet" module_name="cophenet" namespace="'cluster|hierarchy'" output_type="list">
    <docstring>Calculates the cophenetic distances between each observation in
the hierarchical clustering defined by the linkage ``Z``.

Suppose ``p`` and ``q`` are original observations in
disjoint clusters ``s`` and ``t``, respectively and
``s`` and ``t`` are joined by a direct parent cluster
``u``. The cophenetic distance between observations
``i`` and ``j`` is simply the distance between
clusters ``s`` and ``t``.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as an array
    (see ``linkage`` function).

Y : ndarray (optional)
    Calculates the cophenetic correlation coefficient ``c`` of a
    hierarchical clustering defined by the linkage matrix `Z`
    of a set of :math:`n` observations in :math:`m`
    dimensions. `Y` is the condensed distance matrix from which
    `Z` was generated.

Returns
-------
c : ndarray
    The cophentic correlation distance (if ``y`` is passed).
d : ndarray
    The cophenetic distance matrix in condensed form. The
    :math:`ij` th entry is the cophenetic distance between
    original observations :math:`i` and :math:`j`.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded as an array
(see ``linkage`` function).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Y" name="Y" port_type="basic:List">
      <docstring>Calculates the cophenetic correlation coefficient ``c`` of a
hierarchical clustering defined by the linkage matrix `Z`
of a set of :math:`n` observations in :math:`m`
dimensions. `Y` is the condensed distance matrix from which
`Z` was generated.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The cophentic correlation distance (if ``y`` is passed).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="d" name="d" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The cophenetic distance matrix in condensed form. The
:math:`ij` th entry is the cophenetic distance between
original observations :math:`i` and :math:`j`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.correspond" module_name="correspond" namespace="'cluster|hierarchy'">
    <docstring>Checks for correspondence between linkage and condensed distance matrices

They must have the same number of original observations for
the check to succeed.

This function is useful as a sanity check in algorithms that make
extensive use of linkage and distance matrices that must
correspond to the same set of original observations.

Parameters
----------
Z : array_like
    The linkage matrix to check for correspondence.
Y : array_like
    The condensed distance matrix to check for correspondence.

Returns
-------
b : bool
    A boolean indicating whether the linkage matrix and distance
    matrix could possibly correspond to one another.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The linkage matrix to check for correspondence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Y" name="Y" port_type="basic:List" show_port="True">
      <docstring>The condensed distance matrix to check for correspondence.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>A boolean indicating whether the linkage matrix and distance
matrix could possibly correspond to one another.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.dendrogram" module_name="dendrogram" namespace="'cluster|hierarchy'">
    <docstring>Plots the hierarchical clustering as a dendrogram.

The dendrogram illustrates how each cluster is
composed by drawing a U-shaped link between a non-singleton
cluster and its children. The height of the top of the U-link is
the distance between its children clusters. It is also the
cophenetic distance between original observations in the two
children clusters. It is expected that the distances in Z[:,2] be
monotonic, otherwise crossings appear in the dendrogram.

Parameters
----------
Z : ndarray
    The linkage matrix encoding the hierarchical clustering to
    render as a dendrogram. See the ``linkage`` function for more
    information on the format of ``Z``.
p : int, optional
    The ``p`` parameter for ``truncate_mode``.
truncate_mode : str, optional
    The dendrogram can be hard to read when the original
    observation matrix from which the linkage is derived is
    large. Truncation is used to condense the dendrogram. There
    are several modes:

    ``None/'none'``
      No truncation is performed (Default).

    ``'lastp'``
      The last ``p`` non-singleton formed in the linkage are the only
      non-leaf nodes in the linkage; they correspond to rows
      ``Z[n-p-2:end]`` in ``Z``. All other non-singleton clusters are
      contracted into leaf nodes.

    ``'mlab'``
      This corresponds to MATLAB(TM) behavior. (not implemented yet)

    ``'level'/'mtica'``
      No more than ``p`` levels of the dendrogram tree are displayed.
      This corresponds to Mathematica(TM) behavior.

color_threshold : double, optional
    For brevity, let :math:`t` be the ``color_threshold``.
    Colors all the descendent links below a cluster node
    :math:`k` the same color if :math:`k` is the first node below
    the cut threshold :math:`t`. All links connecting nodes with
    distances greater than or equal to the threshold are colored
    blue. If :math:`t` is less than or equal to zero, all nodes
    are colored blue. If ``color_threshold`` is None or
    'default', corresponding with MATLAB(TM) behavior, the
    threshold is set to ``0.7*max(Z[:,2])``.
get_leaves : bool, optional
    Includes a list ``R['leaves']=H`` in the result
    dictionary. For each :math:`i`, ``H[i] == j``, cluster node
    ``j`` appears in position ``i`` in the left-to-right traversal
    of the leaves, where :math:`j &lt; 2n-1` and :math:`i &lt; n`.
orientation : str, optional
    The direction to plot the dendrogram, which can be any
    of the following strings:

    ``'top'``
      Plots the root at the top, and plot descendent links going downwards.
      (default).

    ``'bottom'``
      Plots the root at the bottom, and plot descendent links going
      upwards.

    ``'left'``
      Plots the root at the left, and plot descendent links going right.

    ``'right'``
      Plots the root at the right, and plot descendent links going left.

labels : ndarray, optional
    By default ``labels`` is None so the index of the original observation
    is used to label the leaf nodes.  Otherwise, this is an :math:`n`
    -sized list (or tuple). The ``labels[i]`` value is the text to put
    under the :math:`i` th leaf node only if it corresponds to an original
    observation and not a non-singleton cluster.
count_sort : str or bool, optional
    For each node n, the order (visually, from left-to-right) n's
    two descendent links are plotted is determined by this
    parameter, which can be any of the following values:

    ``False``
      Nothing is done.

    ``'ascending'`` or ``True``
      The child with the minimum number of original objects in its cluster
      is plotted first.

    ``'descendent'``
      The child with the maximum number of original objects in its cluster
      is plotted first.

    Note ``distance_sort`` and ``count_sort`` cannot both be True.
distance_sort : str or bool, optional
    For each node n, the order (visually, from left-to-right) n's
    two descendent links are plotted is determined by this
    parameter, which can be any of the following values:

    ``False``
      Nothing is done.

    ``'ascending'`` or ``True``
      The child with the minimum distance between its direct descendents is
      plotted first.

    ``'descending'``
      The child with the maximum distance between its direct descendents is
      plotted first.

    Note ``distance_sort`` and ``count_sort`` cannot both be True.
show_leaf_counts : bool, optional
     When True, leaf nodes representing :math:`k&gt;1` original
     observation are labeled with the number of observations they
     contain in parentheses.
no_plot : bool, optional
    When True, the final rendering is not performed. This is
    useful if only the data structures computed for the rendering
    are needed or if matplotlib is not available.
no_labels : bool, optional
    When True, no labels appear next to the leaf nodes in the
    rendering of the dendrogram.
leaf_rotation : double, optional
    Specifies the angle (in degrees) to rotate the leaf
    labels. When unspecified, the rotation is based on the number of
    nodes in the dendrogram (default is 0).
leaf_font_size : int, optional
    Specifies the font size (in points) of the leaf labels. When
    unspecified, the size based on the number of nodes in the
    dendrogram.
leaf_label_func : lambda or function, optional
    When leaf_label_func is a callable function, for each
    leaf with cluster index :math:`k &lt; 2n-1`. The function
    is expected to return a string with the label for the
    leaf.

    Indices :math:`k &lt; n` correspond to original observations
    while indices :math:`k \geq n` correspond to non-singleton
    clusters.

    For example, to label singletons with their node id and
    non-singletons with their id, count, and inconsistency
    coefficient, simply do:

    &gt;&gt;&gt; # First define the leaf label function.
    &gt;&gt;&gt; def llf(id):
    ...       if id &lt; n:
    ...           return str(id)
    ...       else:
    &gt;&gt;&gt;           return '[%d %d %1.2f]' % (id, count, R[n-id,3])
    &gt;&gt;&gt;
    &gt;&gt;&gt;  # The text for the leaf nodes is going to be big so force
    &gt;&gt;&gt;  # a rotation of 90 degrees.
    &gt;&gt;&gt;  dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)

show_contracted : bool, optional
    When True the heights of non-singleton nodes contracted
    into a leaf node are plotted as crosses along the link
    connecting that leaf node.  This really is only useful when
    truncation is used (see ``truncate_mode`` parameter).
link_color_func : callable, optional
    If given, `link_color_function` is called with each non-singleton id
    corresponding to each U-shaped link it will paint. The function is
    expected to return the color to paint the link, encoded as a matplotlib
    color string code. For example:

    &gt;&gt;&gt; dendrogram(Z, link_color_func=lambda k: colors[k])

    colors the direct links below each untruncated non-singleton node
    ``k`` using ``colors[k]``.
ax : matplotlib Axes instance, optional
    If None and `no_plot` is not True, the dendrogram will be plotted
    on the current axes.  Otherwise if `no_plot` is not True the
    dendrogram will be plotted on the given ``Axes`` instance. This can be
    useful if the dendrogram is part of a more complex figure.
above_threshold_color : str, optional
    This matplotlib color string sets the color of the links above the
    color_threshold. The default is 'b'.

Returns
-------
R : dict
    A dictionary of data structures computed to render the
    dendrogram. Its has the following keys:

    ``'color_list'``
      A list of color names. The k'th element represents the color of the
      k'th link.

    ``'icoord'`` and ``'dcoord'``
      Each of them is a list of lists. Let ``icoord = [I1, I2, ..., Ip]``
      where ``Ik = [xk1, xk2, xk3, xk4]`` and ``dcoord = [D1, D2, ..., Dp]``
      where ``Dk = [yk1, yk2, yk3, yk4]``, then the k'th link painted is
      ``(xk1, yk1)`` - ``(xk2, yk2)`` - ``(xk3, yk3)`` - ``(xk4, yk4)``.

    ``'ivl'``
      A list of labels corresponding to the leaf nodes.

    ``'leaves'``
      For each i, ``H[i] == j``, cluster node ``j`` appears in position
      ``i`` in the left-to-right traversal of the leaves, where
      :math:`j &lt; 2n-1` and :math:`i &lt; n`. If ``j`` is less than ``n``, the
      ``i``-th leaf node corresponds to an original observation.
      Otherwise, it corresponds to a non-singleton cluster.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The linkage matrix encoding the hierarchical clustering to
render as a dendrogram. See the ``linkage`` function for more
information on the format of ``Z``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer">
      <docstring>The ``p`` parameter for ``truncate_mode``.</docstring>
      <defaults>[30]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="truncate_mode" name="truncate_mode">
      <docstring>The dendrogram can be hard to read when the original
observation matrix from which the linkage is derived is
large. Truncation is used to condense the dendrogram. There
are several modes:

``None/'none'``
  No truncation is performed (Default).

``'lastp'``
  The last ``p`` non-singleton formed in the linkage are the only
  non-leaf nodes in the linkage; they correspond to rows
  ``Z[n-p-2:end]`` in ``Z``. All other non-singleton clusters are
  contracted into leaf nodes.

``'mlab'``
  This corresponds to MATLAB(TM) behavior. (not implemented yet)

``'level'/'mtica'``
  No more than ``p`` levels of the dendrogram tree are displayed.
  This corresponds to Mathematica(TM) behavior.
</docstring>
      <defaults>['performed']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="color_threshold" name="color_threshold" port_type="basic:Float">
      <docstring>For brevity, let :math:`t` be the ``color_threshold``.
Colors all the descendent links below a cluster node
:math:`k` the same color if :math:`k` is the first node below
the cut threshold :math:`t`. All links connecting nodes with
distances greater than or equal to the threshold are colored
blue. If :math:`t` is less than or equal to zero, all nodes
are colored blue. If ``color_threshold`` is None or
'default', corresponding with MATLAB(TM) behavior, the
threshold is set to ``0.7*max(Z[:,2])``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="get_leaves" name="get_leaves" port_type="basic:Boolean">
      <docstring>Includes a list ``R['leaves']=H`` in the result
dictionary. For each :math:`i`, ``H[i] == j``, cluster node
``j`` appears in position ``i`` in the left-to-right traversal
of the leaves, where :math:`j &lt; 2n-1` and :math:`i &lt; n`.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="orientation" name="orientation">
      <docstring>The direction to plot the dendrogram, which can be any
of the following strings:

``'top'``
  Plots the root at the top, and plot descendent links going downwards.
  (default).

``'bottom'``
  Plots the root at the bottom, and plot descendent links going
  upwards.

``'left'``
  Plots the root at the left, and plot descendent links going right.

``'right'``
  Plots the root at the right, and plot descendent links going left.
</docstring>
      <defaults>['top']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>By default ``labels`` is None so the index of the original observation
is used to label the leaf nodes.  Otherwise, this is an :math:`n`
-sized list (or tuple). The ``labels[i]`` value is the text to put
under the :math:`i` th leaf node only if it corresponds to an original
observation and not a non-singleton cluster.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="count_sort" name="count_sortScalar">
      <docstring>For each node n, the order (visually, from left-to-right) n's
two descendent links are plotted is determined by this
parameter, which can be any of the following values:

``False``
  Nothing is done.

``'ascending'`` or ``True``
  The child with the minimum number of original objects in its cluster
  is plotted first.

``'descendent'``
  The child with the maximum number of original objects in its cluster
  is plotted first.

Note ``distance_sort`` and ``count_sort`` cannot both be True.</docstring>
      <defaults>[False]</defaults>
      <alternateSpec arg="count_sort" name="count_sortBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="distance_sort" name="distance_sortScalar">
      <docstring>For each node n, the order (visually, from left-to-right) n's
two descendent links are plotted is determined by this
parameter, which can be any of the following values:

``False``
  Nothing is done.

``'ascending'`` or ``True``
  The child with the minimum distance between its direct descendents is
  plotted first.

``'descending'``
  The child with the maximum distance between its direct descendents is
  plotted first.

Note ``distance_sort`` and ``count_sort`` cannot both be True.</docstring>
      <defaults>[False]</defaults>
      <alternateSpec arg="distance_sort" name="distance_sortBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="show_leaf_counts" name="show_leaf_counts" port_type="basic:Boolean">
      <docstring>When True, leaf nodes representing :math:`k&gt;1` original
observation are labeled with the number of observations they
contain in parentheses.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="no_plot" name="no_plot" port_type="basic:Boolean">
      <docstring>When True, the final rendering is not performed. This is
useful if only the data structures computed for the rendering
are needed or if matplotlib is not available.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="no_labels" name="no_labels" port_type="basic:Boolean">
      <docstring>When True, no labels appear next to the leaf nodes in the
rendering of the dendrogram.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="leaf_rotation" name="leaf_rotation" port_type="basic:Float">
      <docstring>Specifies the angle (in degrees) to rotate the leaf
labels. When unspecified, the rotation is based on the number of
nodes in the dendrogram (default is 0).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="leaf_font_size" name="leaf_font_size" port_type="basic:Integer">
      <docstring>Specifies the font size (in points) of the leaf labels. When
unspecified, the size based on the number of nodes in the
dendrogram.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="leaf_label_func" name="leaf_label_func">
      <docstring>When leaf_label_func is a callable function, for each
leaf with cluster index :math:`k &lt; 2n-1`. The function
is expected to return a string with the label for the
leaf.

Indices :math:`k &lt; n` correspond to original observations
while indices :math:`k \geq n` correspond to non-singleton
clusters.

For example, to label singletons with their node id and
non-singletons with their id, count, and inconsistency
coefficient, simply do:

&gt;&gt;&gt; # First define the leaf label function.
&gt;&gt;&gt; def llf(id):
...       if id &lt; n:
...           return str(id)
...       else:
&gt;&gt;&gt;           return '[%d %d %1.2f]' % (id, count, R[n-id,3])
&gt;&gt;&gt;
&gt;&gt;&gt;  # The text for the leaf nodes is going to be big so force
&gt;&gt;&gt;  # a rotation of 90 degrees.
&gt;&gt;&gt;  dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lambda']]</values>
    </inputPortSpec>
    <inputPortSpec arg="show_contracted" name="show_contracted" port_type="basic:Boolean">
      <docstring>When True the heights of non-singleton nodes contracted
into a leaf node are plotted as crosses along the link
connecting that leaf node.  This really is only useful when
truncation is used (see ``truncate_mode`` parameter).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="link_color_func" name="link_color_func" port_type="basic:Variant">
      <docstring>If given, `link_color_function` is called with each non-singleton id
corresponding to each U-shaped link it will paint. The function is
expected to return the color to paint the link, encoded as a matplotlib
color string code. For example:

&gt;&gt;&gt; dendrogram(Z, link_color_func=lambda k: colors[k])

colors the direct links below each untruncated non-singleton node
``k`` using ``colors[k]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ax" name="ax" port_type="basic:Variant">
      <docstring>If None and `no_plot` is not True, the dendrogram will be plotted
on the current axes.  Otherwise if `no_plot` is not True the
dendrogram will be plotted on the given ``Axes`` instance. This can be
useful if the dendrogram is part of a more complex figure.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="above_threshold_color" name="above_threshold_color">
      <docstring>This matplotlib color string sets the color of the links above the
color_threshold. The default is 'b'.</docstring>
      <defaults>['b']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="no_leaves" name="no_leaves" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="color_list" name="color_list" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="R" name="R" port_type="basic:Dictionary" show_port="True" sort_key="0">
      <docstring>A dictionary of data structures computed to render the
dendrogram. Its has the following keys:

``'color_list'``
  A list of color names. The k'th element represents the color of the
  k'th link.

``'icoord'`` and ``'dcoord'``
  Each of them is a list of lists. Let ``icoord = [I1, I2, ..., Ip]``
  where ``Ik = [xk1, xk2, xk3, xk4]`` and ``dcoord = [D1, D2, ..., Dp]``
  where ``Dk = [yk1, yk2, yk3, yk4]``, then the k'th link painted is
  ``(xk1, yk1)`` - ``(xk2, yk2)`` - ``(xk3, yk3)`` - ``(xk4, yk4)``.

``'ivl'``
  A list of labels corresponding to the leaf nodes.

``'leaves'``
  For each i, ``H[i] == j``, cluster node ``j`` appears in position
  ``i`` in the left-to-right traversal of the leaves, where
  :math:`j &lt; 2n-1` and :math:`i &lt; n`. If ``j`` is less than ``n``, the
  ``i``-th leaf node corresponds to an original observation.
  Otherwise, it corresponds to a non-singleton cluster.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.fcluster" module_name="fcluster" namespace="'cluster|hierarchy'">
    <docstring>Forms flat clusters from the hierarchical clustering defined by
the linkage matrix ``Z``.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded with the matrix returned
    by the `linkage` function.
t : float
    The threshold to apply when forming flat clusters.
criterion : str, optional
    The criterion to use in forming flat clusters. This can
    be any of the following values:

      ``inconsistent`` : If a cluster node and all its
          descendants have an inconsistent value less than or equal
          to `t` then all its leaf descendants belong to the
          same flat cluster. When no non-singleton cluster meets
          this criterion, every node is assigned to its own
          cluster. (Default)

      ``distance`` : Forms flat clusters so that the original
          observations in each flat cluster have no greater a
          cophenetic distance than `t`.

      ``maxclust`` : Finds a minimum threshold ``r`` so that
          the cophenetic distance between any two original
          observations in the same flat cluster is no more than
          ``r`` and no more than `t` flat clusters are formed.

      ``monocrit`` : Forms a flat cluster from a cluster node c
          with index i when ``monocrit[j] &lt;= t``.

          For example, to threshold on the maximum mean distance
          as computed in the inconsistency matrix R with a
          threshold of 0.8 do:

            MR = maxRstat(Z, R, 3)

            cluster(Z, t=0.8, criterion='monocrit', monocrit=MR)

      ``maxclust_monocrit`` : Forms a flat cluster from a
          non-singleton cluster node ``c`` when ``monocrit[i] &lt;=
          r`` for all cluster indices ``i`` below and including
          ``c``. ``r`` is minimized such that no more than ``t``
          flat clusters are formed. monocrit must be
          monotonic. For example, to minimize the threshold t on
          maximum inconsistency values so that no more than 3 flat
          clusters are formed, do:

            MI = maxinconsts(Z, R)

            cluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI)

depth : int, optional
    The maximum depth to perform the inconsistency calculation.
    It has no meaning for the other criteria. Default is 2.
R : ndarray, optional
    The inconsistency matrix to use for the 'inconsistent'
    criterion. This matrix is computed if not provided.
monocrit : ndarray, optional
    An array of length n-1. `monocrit[i]` is the
    statistics upon which non-singleton i is thresholded. The
    monocrit vector must be monotonic, i.e. given a node c with
    index i, for all node indices j corresponding to nodes
    below c, `monocrit[i] &gt;= monocrit[j]`.

Returns
-------
fcluster : ndarray
    An array of length n. T[i] is the flat cluster number to
    which original observation i belongs.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded with the matrix returned
by the `linkage` function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:Float" show_port="True">
      <docstring>The threshold to apply when forming flat clusters.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="criterion" name="criterion">
      <docstring>The criterion to use in forming flat clusters. This can
be any of the following values:

  ``inconsistent`` : If a cluster node and all its
      descendants have an inconsistent value less than or equal
      to `t` then all its leaf descendants belong to the
      same flat cluster. When no non-singleton cluster meets
      this criterion, every node is assigned to its own
      cluster. (Default)

  ``distance`` : Forms flat clusters so that the original
      observations in each flat cluster have no greater a
      cophenetic distance than `t`.

  ``maxclust`` : Finds a minimum threshold ``r`` so that
      the cophenetic distance between any two original
      observations in the same flat cluster is no more than
      ``r`` and no more than `t` flat clusters are formed.

  ``monocrit`` : Forms a flat cluster from a cluster node c
      with index i when ``monocrit[j] &lt;= t``.

      For example, to threshold on the maximum mean distance
      as computed in the inconsistency matrix R with a
      threshold of 0.8 do:

        MR = maxRstat(Z, R, 3)

        cluster(Z, t=0.8, criterion='monocrit', monocrit=MR)

  ``maxclust_monocrit`` : Forms a flat cluster from a
      non-singleton cluster node ``c`` when ``monocrit[i] &lt;=
      r`` for all cluster indices ``i`` below and including
      ``c``. ``r`` is minimized such that no more than ``t``
      flat clusters are formed. monocrit must be
      monotonic. For example, to minimize the threshold t on
      maximum inconsistency values so that no more than 3 flat
      clusters are formed, do:

        MI = maxinconsts(Z, R)

        cluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI)
</docstring>
      <defaults>['inconsistent']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="depth" name="depth" port_type="basic:Integer">
      <docstring>The maximum depth to perform the inconsistency calculation.
It has no meaning for the other criteria. Default is 2.</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="R" name="R" port_type="basic:List">
      <docstring>The inconsistency matrix to use for the 'inconsistent'
criterion. This matrix is computed if not provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="monocrit" name="monocrit" port_type="basic:List">
      <docstring>An array of length n-1. `monocrit[i]` is the
statistics upon which non-singleton i is thresholded. The
monocrit vector must be monotonic, i.e. given a node c with
index i, for all node indices j corresponding to nodes
below c, `monocrit[i] &gt;= monocrit[j]`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fcluster" name="fcluster" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of length n. T[i] is the flat cluster number to
which original observation i belongs.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.fclusterdata" module_name="fclusterdata" namespace="'cluster|hierarchy'">
    <docstring>Cluster observation data using a given metric.

Clusters the original observations in the n-by-m data
matrix X (n observations in m dimensions), using the euclidean
distance metric to calculate distances between original observations,
performs hierarchical clustering using the single linkage algorithm,
and forms flat clusters using the inconsistency method with `t` as the
cut-off threshold.

A one-dimensional array T of length n is returned. T[i] is the index
of the flat cluster to which the original observation i belongs.

Parameters
----------
X : (N, M) ndarray
    N by M data matrix with N observations in M dimensions.
t : float
    The threshold to apply when forming flat clusters.
criterion : str, optional
    Specifies the criterion for forming flat clusters.  Valid
    values are 'inconsistent' (default), 'distance', or 'maxclust'
    cluster formation algorithms. See `fcluster` for descriptions.
metric : str, optional
    The distance metric for calculating pairwise distances. See
    `distance.pdist` for descriptions and linkage to verify
    compatibility with the linkage method.
depth : int, optional
    The maximum depth for the inconsistency calculation. See
    `inconsistent` for more information.
method : str, optional
    The linkage method to use (single, complete, average,
    weighted, median centroid, ward). See `linkage` for more
    information. Default is "single".
R : ndarray, optional
    The inconsistency matrix. It will be computed if necessary
    if it is not passed.

Returns
-------
fclusterdata : ndarray
    A vector of length n. T[i] is the flat cluster number to
    which original observation i belongs.

Notes
-----
This function is similar to the MATLAB function clusterdata.</docstring>
    <inputPortSpec arg="X" name="X" port_type="basic:List" show_port="True">
      <docstring>N by M data matrix with N observations in M dimensions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:Float" show_port="True">
      <docstring>The threshold to apply when forming flat clusters.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="criterion" name="criterion">
      <docstring>Specifies the criterion for forming flat clusters.  Valid
values are 'inconsistent' (default), 'distance', or 'maxclust'
cluster formation algorithms. See `fcluster` for descriptions.</docstring>
      <defaults>['inconsistent']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="metric" name="metric">
      <docstring>The distance metric for calculating pairwise distances. See
`distance.pdist` for descriptions and linkage to verify
compatibility with the linkage method.</docstring>
      <defaults>['euclidean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="depth" name="depth" port_type="basic:Integer">
      <docstring>The maximum depth for the inconsistency calculation. See
`inconsistent` for more information.</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>The linkage method to use (single, complete, average,
weighted, median centroid, ward). See `linkage` for more
information. Default is "single".</docstring>
      <defaults>['single']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="R" name="R" port_type="basic:List">
      <docstring>The inconsistency matrix. It will be computed if necessary
if it is not passed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fclusterdata" name="fclusterdata" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A vector of length n. T[i] is the flat cluster number to
which original observation i belongs.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.from_mlab_linkage" module_name="from_mlab_linkage" namespace="'cluster|hierarchy'">
    <docstring>Converts a linkage matrix generated by MATLAB(TM) to a new
linkage matrix compatible with this module.

The conversion does two things:

 * the indices are converted from ``1..N`` to ``0..(N-1)`` form,
   and

 * a fourth column Z[:,3] is added where Z[i,3] is represents the
   number of original observations (leaves) in the non-singleton
   cluster i.

This function is useful when loading in linkages from legacy data
files generated by MATLAB.

Parameters
----------
Z : ndarray
    A linkage matrix generated by MATLAB(TM).

Returns
-------
ZS : ndarray
    A linkage matrix compatible with this library.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>A linkage matrix generated by MATLAB(TM).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="ZS" name="ZS" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A linkage matrix compatible with this library.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.inconsistent" module_name="inconsistent" namespace="'cluster|hierarchy'">
    <docstring>Calculates inconsistency statistics on a linkage.

Note: This function behaves similarly to the MATLAB(TM)
inconsistent function.

Parameters
----------
Z : ndarray
    The :math:`(n-1)` by 4 matrix encoding the linkage
    (hierarchical clustering).  See ``linkage`` documentation
    for more information on its form.
d : int, optional
    The number of links up to `d` levels below each
    non-singleton cluster.

Returns
-------
R : ndarray
    A :math:`(n-1)` by 5 matrix where the ``i``'th row
    contains the link statistics for the non-singleton cluster
    ``i``. The link statistics are computed over the link
    heights for links :math:`d` levels below the cluster
    ``i``. ``R[i,0]`` and ``R[i,1]`` are the mean and standard
    deviation of the link heights, respectively; ``R[i,2]`` is
    the number of links included in the calculation; and
    ``R[i,3]`` is the inconsistency coefficient,

    .. math:: \frac{\mathtt{Z[i,2]}-\mathtt{R[i,0]}} {R[i,1]}</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The :math:`(n-1)` by 4 matrix encoding the linkage
(hierarchical clustering).  See ``linkage`` documentation
for more information on its form.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d" name="d" port_type="basic:Integer">
      <docstring>The number of links up to `d` levels below each
non-singleton cluster.</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="R" name="R" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A :math:`(n-1)` by 5 matrix where the ``i``'th row
contains the link statistics for the non-singleton cluster
``i``. The link statistics are computed over the link
heights for links :math:`d` levels below the cluster
``i``. ``R[i,0]`` and ``R[i,1]`` are the mean and standard
deviation of the link heights, respectively; ``R[i,2]`` is
the number of links included in the calculation; and
``R[i,3]`` is the inconsistency coefficient,

.. math:: \frac{\mathtt{Z[i,2]}-\mathtt{R[i,0]}} {R[i,1]}</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.is_isomorphic" module_name="is_isomorphic" namespace="'cluster|hierarchy'">
    <docstring>Determines if two different cluster assignments are equivalent.

Parameters
----------
T1 : array_like
    An assignment of singleton cluster ids to flat cluster ids.
T2 : array_like
    An assignment of singleton cluster ids to flat cluster ids.

Returns
-------
b : bool
    Whether the flat cluster assignments `T1` and `T2` are
    equivalent.</docstring>
    <inputPortSpec arg="T1" name="T1" port_type="basic:List" show_port="True">
      <docstring>An assignment of singleton cluster ids to flat cluster ids.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T2" name="T2" port_type="basic:List" show_port="True">
      <docstring>An assignment of singleton cluster ids to flat cluster ids.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Whether the flat cluster assignments `T1` and `T2` are
equivalent.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.is_monotonic" module_name="is_monotonic" namespace="'cluster|hierarchy'">
    <docstring>Returns True if the linkage passed is monotonic.

The linkage is monotonic if for every cluster :math:`s` and :math:`t`
joined, the distance between them is no less than the distance
between any previously joined clusters.

Parameters
----------
Z : ndarray
    The linkage matrix to check for monotonicity.

Returns
-------
b : bool
    A boolean indicating whether the linkage is monotonic.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The linkage matrix to check for monotonicity.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>A boolean indicating whether the linkage is monotonic.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.is_valid_im" module_name="is_valid_im" namespace="'cluster|hierarchy'">
    <docstring>Returns True if the inconsistency matrix passed is valid.

It must be a :math:`n` by 4 numpy array of doubles. The standard
deviations ``R[:,1]`` must be nonnegative. The link counts
``R[:,2]`` must be positive and no greater than :math:`n-1`.

Parameters
----------
R : ndarray
    The inconsistency matrix to check for validity.
warning : bool, optional
     When True, issues a Python warning if the linkage
     matrix passed is invalid.
throw : bool, optional
     When True, throws a Python exception if the linkage
     matrix passed is invalid.
name : str, optional
     This string refers to the variable name of the invalid
     linkage matrix.

Returns
-------
b : bool
    True if the inconsistency matrix is valid.</docstring>
    <inputPortSpec arg="R" name="R" port_type="basic:List" show_port="True">
      <docstring>The inconsistency matrix to check for validity.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="warning" name="warning" port_type="basic:Boolean">
      <docstring>When True, issues a Python warning if the linkage
matrix passed is invalid.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="throw" name="throw" port_type="basic:Boolean">
      <docstring>When True, throws a Python exception if the linkage
matrix passed is invalid.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="name" name="name">
      <docstring>This string refers to the variable name of the invalid
linkage matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if the inconsistency matrix is valid.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.is_valid_linkage" module_name="is_valid_linkage" namespace="'cluster|hierarchy'">
    <docstring>Checks the validity of a linkage matrix.

A linkage matrix is valid if it is a two dimensional
ndarray (type double) with :math:`n`
rows and 4 columns.  The first two columns must contain indices
between 0 and :math:`2n-1`. For a given row ``i``,
:math:`0 \leq \mathtt{Z[i,0]} \leq i+n-1`
and :math:`0 \leq Z[i,1] \leq i+n-1`
(i.e. a cluster cannot join another cluster unless the cluster
being joined has been generated.)

Parameters
----------
Z : array_like
    Linkage matrix.
warning : bool, optional
    When True, issues a Python warning if the linkage
    matrix passed is invalid.
throw : bool, optional
    When True, throws a Python exception if the linkage
    matrix passed is invalid.
name : str, optional
       This string refers to the variable name of the invalid
       linkage matrix.

Returns
-------
b : bool
    True iff the inconsistency matrix is valid.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>Linkage matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="warning" name="warning" port_type="basic:Boolean">
      <docstring>When True, issues a Python warning if the linkage
matrix passed is invalid.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="throw" name="throw" port_type="basic:Boolean">
      <docstring>When True, throws a Python exception if the linkage
matrix passed is invalid.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="name" name="name">
      <docstring>This string refers to the variable name of the invalid
linkage matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True iff the inconsistency matrix is valid.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.leaders" module_name="leaders" namespace="'cluster|hierarchy'" output_type="list">
    <docstring>Returns the root nodes in a hierarchical clustering.

Returns the root nodes in a hierarchical clustering corresponding
to a cut defined by a flat cluster assignment vector ``T``. See
the ``fcluster`` function for more information on the format of ``T``.

For each flat cluster :math:`j` of the :math:`k` flat clusters
represented in the n-sized flat cluster assignment vector ``T``,
this function finds the lowest cluster node :math:`i` in the linkage
tree Z such that:

  * leaf descendents belong only to flat cluster j
    (i.e. ``T[p]==j`` for all :math:`p` in :math:`S(i)` where
    :math:`S(i)` is the set of leaf ids of leaf nodes descendent
    with cluster node :math:`i`)

  * there does not exist a leaf that is not descendent with
    :math:`i` that also belongs to cluster :math:`j`
    (i.e. ``T[q]!=j`` for all :math:`q` not in :math:`S(i)`).  If
    this condition is violated, ``T`` is not a valid cluster
    assignment vector, and an exception will be thrown.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.
T : ndarray
    The flat cluster assignment vector.

Returns
-------
L : ndarray
    The leader linkage node id's stored as a k-element 1-D array
    where ``k`` is the number of flat clusters found in ``T``.

    ``L[j]=i`` is the linkage cluster node id that is the
    leader of flat cluster with id M[j].  If ``i &lt; n``, ``i``
    corresponds to an original observation, otherwise it
    corresponds to a non-singleton cluster.

    For example: if ``L[3]=2`` and ``M[3]=8``, the flat cluster with
    id 8's leader is linkage node 2.
M : ndarray
    The leader linkage node id's stored as a k-element 1-D array where
    ``k`` is the number of flat clusters found in ``T``. This allows the
    set of flat cluster ids to be any arbitrary set of ``k`` integers.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded as a matrix. See
``linkage`` for more information.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:List" show_port="True">
      <docstring>The flat cluster assignment vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="L" name="L" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The leader linkage node id's stored as a k-element 1-D array
where ``k`` is the number of flat clusters found in ``T``.

``L[j]=i`` is the linkage cluster node id that is the
leader of flat cluster with id M[j].  If ``i &lt; n``, ``i``
corresponds to an original observation, otherwise it
corresponds to a non-singleton cluster.

For example: if ``L[3]=2`` and ``M[3]=8``, the flat cluster with
id 8's leader is linkage node 2.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="M" name="M" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The leader linkage node id's stored as a k-element 1-D array where
``k`` is the number of flat clusters found in ``T``. This allows the
set of flat cluster ids to be any arbitrary set of ``k`` integers.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.leaves_list" module_name="leaves_list" namespace="'cluster|hierarchy'">
    <docstring>Returns a list of leaf node ids

The return corresponds to the observation vector index as it appears
in the tree from left to right. Z is a linkage matrix.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix.  `Z` is
    a linkage matrix.  See ``linkage`` for more information.

Returns
-------
leaves_list : ndarray
    The list of leaf node ids.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded as a matrix.  `Z` is
a linkage matrix.  See ``linkage`` for more information.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="leaves_list" name="leaves_list" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The list of leaf node ids.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.linkage" module_name="linkage" namespace="'cluster|hierarchy'">
    <docstring>Performs hierarchical/agglomerative clustering on the condensed
distance matrix y.

y must be a :math:`{n \choose 2}` sized
vector where n is the number of original observations paired
in the distance matrix. The behavior of this function is very
similar to the MATLAB linkage function.

A 4 by :math:`(n-1)` matrix ``Z`` is returned. At the
:math:`i`-th iteration, clusters with indices ``Z[i, 0]`` and
``Z[i, 1]`` are combined to form cluster :math:`n + i`. A
cluster with an index less than :math:`n` corresponds to one of
the :math:`n` original observations. The distance between
clusters ``Z[i, 0]`` and ``Z[i, 1]`` is given by ``Z[i, 2]``. The
fourth value ``Z[i, 3]`` represents the number of original
observations in the newly formed cluster.

The following linkage methods are used to compute the distance
:math:`d(s, t)` between two clusters :math:`s` and
:math:`t`. The algorithm begins with a forest of clusters that
have yet to be used in the hierarchy being formed. When two
clusters :math:`s` and :math:`t` from this forest are combined
into a single cluster :math:`u`, :math:`s` and :math:`t` are
removed from the forest, and :math:`u` is added to the
forest. When only one cluster remains in the forest, the algorithm
stops, and this cluster becomes the root.

A distance matrix is maintained at each iteration. The ``d[i,j]``
entry corresponds to the distance between cluster :math:`i` and
:math:`j` in the original forest.

At each iteration, the algorithm must update the distance matrix
to reflect the distance of the newly formed cluster u with the
remaining clusters in the forest.

Suppose there are :math:`|u|` original observations
:math:`u[0], \ldots, u[|u|-1]` in cluster :math:`u` and
:math:`|v|` original objects :math:`v[0], \ldots, v[|v|-1]` in
cluster :math:`v`. Recall :math:`s` and :math:`t` are
combined to form cluster :math:`u`. Let :math:`v` be any
remaining cluster in the forest that is not :math:`u`.

The following are methods for calculating the distance between the
newly formed cluster :math:`u` and each :math:`v`.

  * method='single' assigns

    .. math::
       d(u,v) = \min(dist(u[i],v[j]))

    for all points :math:`i` in cluster :math:`u` and
    :math:`j` in cluster :math:`v`. This is also known as the
    Nearest Point Algorithm.

  * method='complete' assigns

    .. math::
       d(u, v) = \max(dist(u[i],v[j]))

    for all points :math:`i` in cluster u and :math:`j` in
    cluster :math:`v`. This is also known by the Farthest Point
    Algorithm or Voor Hees Algorithm.

  * method='average' assigns

    .. math::
       d(u,v) = \sum_{ij} \frac{d(u[i], v[j])}
                               {(|u|*|v|)}

    for all points :math:`i` and :math:`j` where :math:`|u|`
    and :math:`|v|` are the cardinalities of clusters :math:`u`
    and :math:`v`, respectively. This is also called the UPGMA
    algorithm.

  * method='weighted' assigns

    .. math::
       d(u,v) = (dist(s,v) + dist(t,v))/2

    where cluster u was formed with cluster s and t and v
    is a remaining cluster in the forest. (also called WPGMA)

  * method='centroid' assigns

    .. math::
       dist(s,t) = ||c_s-c_t||_2

    where :math:`c_s` and :math:`c_t` are the centroids of
    clusters :math:`s` and :math:`t`, respectively. When two
    clusters :math:`s` and :math:`t` are combined into a new
    cluster :math:`u`, the new centroid is computed over all the
    original objects in clusters :math:`s` and :math:`t`. The
    distance then becomes the Euclidean distance between the
    centroid of :math:`u` and the centroid of a remaining cluster
    :math:`v` in the forest. This is also known as the UPGMC
    algorithm.

  * method='median' assigns :math:`d(s,t)` like the ``centroid``
    method. When two clusters :math:`s` and :math:`t` are combined
    into a new cluster :math:`u`, the average of centroids s and t
    give the new centroid :math:`u`. This is also known as the
    WPGMC algorithm.

  * method='ward' uses the Ward variance minimization algorithm.
    The new entry :math:`d(u,v)` is computed as follows,

    .. math::

       d(u,v) = \sqrt{\frac{|v|+|s|}
                           {T}d(v,s)^2
                    + \frac{|v|+|t|}
                           {T}d(v,t)^2
                    - \frac{|v|}
                           {T}d(s,t)^2}

    where :math:`u` is the newly joined cluster consisting of
    clusters :math:`s` and :math:`t`, :math:`v` is an unused
    cluster in the forest, :math:`T=|v|+|s|+|t|`, and
    :math:`|*|` is the cardinality of its argument. This is also
    known as the incremental algorithm.

Warning: When the minimum distance pair in the forest is chosen, there
may be two or more pairs with the same minimum distance. This
implementation may chose a different minimum than the MATLAB
version.

Parameters
----------
y : ndarray
    A condensed or redundant distance matrix. A condensed distance matrix
    is a flat array containing the upper triangular of the distance matrix.
    This is the form that ``pdist`` returns. Alternatively, a collection of
    :math:`m` observation vectors in n dimensions may be passed as an
    :math:`m` by :math:`n` array.
method : str, optional
    The linkage algorithm to use. See the ``Linkage Methods`` section below
    for full descriptions.
metric : str or function, optional
    The distance metric to use. See the ``distance.pdist`` function for a
    list of valid distance metrics. The customized distance can also be
    used. See the ``distance.pdist`` function for details.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>A condensed or redundant distance matrix. A condensed distance matrix
is a flat array containing the upper triangular of the distance matrix.
This is the form that ``pdist`` returns. Alternatively, a collection of
:math:`m` observation vectors in n dimensions may be passed as an
:math:`m` by :math:`n` array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>The linkage algorithm to use. See the ``Linkage Methods`` section below
for full descriptions.</docstring>
      <defaults>['single']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="metric" name="metric">
      <docstring>The distance metric to use. See the ``distance.pdist`` function for a
list of valid distance metrics. The customized distance can also be
used. See the ``distance.pdist`` function for details.</docstring>
      <defaults>['euclidean']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The hierarchical clustering encoded as a linkage matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.maxRstat" module_name="maxRstat" namespace="'cluster|hierarchy'">
    <docstring>Returns the maximum statistic for each non-singleton cluster and
its descendents.

Parameters
----------
Z : array_like
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.
R : array_like
    The inconsistency matrix.
i : int
    The column of `R` to use as the statistic.

Returns
-------
MR : ndarray
    Calculates the maximum statistic for the i'th column of the
    inconsistency matrix `R` for each non-singleton cluster
    node. ``MR[j]`` is the maximum over ``R[Q(j)-n, i]`` where
    ``Q(j)`` the set of all node ids corresponding to nodes below
    and including ``j``.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded as a matrix. See
``linkage`` for more information.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="R" name="R" port_type="basic:List" show_port="True">
      <docstring>The inconsistency matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="i" name="i" port_type="basic:Integer" show_port="True">
      <docstring>The column of `R` to use as the statistic.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="MR" name="MR" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Calculates the maximum statistic for the i'th column of the
inconsistency matrix `R` for each non-singleton cluster
node. ``MR[j]`` is the maximum over ``R[Q(j)-n, i]`` where
``Q(j)`` the set of all node ids corresponding to nodes below
and including ``j``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.maxdists" module_name="maxdists" namespace="'cluster|hierarchy'">
    <docstring>Returns the maximum distance between any non-singleton cluster.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.

Returns
-------
maxdists : ndarray
    A ``(n-1)`` sized numpy array of doubles; ``MD[i]`` represents
    the maximum distance between any cluster (including
    singletons) below and including the node with index i. More
    specifically, ``MD[i] = Z[Q(i)-n, 2].max()`` where ``Q(i)`` is the
    set of all node indices below and including node i.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded as a matrix. See
``linkage`` for more information.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="maxdists" name="maxdists" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A ``(n-1)`` sized numpy array of doubles; ``MD[i]`` represents
the maximum distance between any cluster (including
singletons) below and including the node with index i. More
specifically, ``MD[i] = Z[Q(i)-n, 2].max()`` where ``Q(i)`` is the
set of all node indices below and including node i.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.maxinconsts" module_name="maxinconsts" namespace="'cluster|hierarchy'">
    <docstring>Returns the maximum inconsistency coefficient for each
non-singleton cluster and its descendents.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.
R : ndarray
    The inconsistency matrix.

Returns
-------
MI : ndarray
    A monotonic ``(n-1)``-sized numpy array of doubles.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The hierarchical clustering encoded as a matrix. See
``linkage`` for more information.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="R" name="R" port_type="basic:List" show_port="True">
      <docstring>The inconsistency matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="MI" name="MI" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A monotonic ``(n-1)``-sized numpy array of doubles.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.median" module_name="median" namespace="'cluster|hierarchy'">
    <docstring>Performs median/WPGMC linkage.

See ``linkage`` for more information on the return structure
and algorithm.

 The following are common calling conventions:

 1. ``Z = median(y)``

    Performs median/WPGMC linkage on the condensed distance matrix
    ``y``.  See ``linkage`` for more information on the return
    structure and algorithm.

 2. ``Z = median(X)``

    Performs median/WPGMC linkage on the observation matrix ``X``
    using Euclidean distance as the distance metric. See linkage
    for more information on the return structure and algorithm.

Parameters
----------
y : ndarray
    A condensed or redundant distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    a m by n array.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>A condensed or redundant distance matrix. A condensed
distance matrix is a flat array containing the upper
triangular of the distance matrix. This is the form that
``pdist`` returns. Alternatively, a collection of
m observation vectors in n dimensions may be passed as
a m by n array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The hierarchical clustering encoded as a linkage matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.num_obs_linkage" module_name="num_obs_linkage" namespace="'cluster|hierarchy'">
    <docstring>Returns the number of original observations of the linkage matrix
passed.

Parameters
----------
Z : ndarray
    The linkage matrix on which to perform the operation.

Returns
-------
n : int
    The number of original observations in the linkage.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The linkage matrix on which to perform the operation.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of original observations in the linkage.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.set_link_color_palette" module_name="set_link_color_palette" namespace="'cluster|hierarchy'">
    <docstring>Set list of matplotlib color codes for dendrogram color_threshold.

Parameters
----------
palette : list
    A list of matplotlib color codes. The order of
    the color codes is the order in which the colors are cycled
    through when color thresholding in the dendrogram.</docstring>
    <inputPortSpec arg="palette" name="palette" port_type="basic:List" show_port="True">
      <docstring>A list of matplotlib color codes. The order of
the color codes is the order in which the colors are cycled
through when color thresholding in the dendrogram.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.single" module_name="single" namespace="'cluster|hierarchy'">
    <docstring>Performs single/min/nearest linkage on the condensed distance matrix ``y``

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    The linkage matrix.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The upper triangular of the distance matrix. The result of
``pdist`` is returned in this form.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The linkage matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.to_mlab_linkage" module_name="to_mlab_linkage" namespace="'cluster|hierarchy'">
    <docstring>Converts a linkage matrix to a MATLAB(TM) compatible one.

Converts a linkage matrix ``Z`` generated by the linkage function
of this module to a MATLAB(TM) compatible one. The return linkage
matrix has the last column removed and the cluster indices are
converted to ``1..N`` indexing.

Parameters
----------
Z : ndarray
    A linkage matrix generated by this library.

Returns
-------
to_mlab_linkage : ndarray
    A linkage matrix compatible with MATLAB(TM)'s hierarchical
    clustering functions.

    The return linkage matrix has the last column removed
    and the cluster indices are converted to ``1..N`` indexing.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>A linkage matrix generated by this library.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="to_mlab_linkage" name="to_mlab_linkage" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A linkage matrix compatible with MATLAB(TM)'s hierarchical
clustering functions.

The return linkage matrix has the last column removed
and the cluster indices are converted to ``1..N`` indexing.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.to_tree" module_name="to_tree" namespace="'cluster|hierarchy'">
    <docstring>Converts a hierarchical clustering encoded in the matrix ``Z`` (by
linkage) into an easy-to-use tree object.

The reference r to the root ClusterNode object is returned.

Each ClusterNode object has a left, right, dist, id, and count
attribute. The left and right attributes point to ClusterNode objects
that were combined to generate the cluster. If both are None then
the ClusterNode object is a leaf node, its count must be 1, and its
distance is meaningless but set to 0.

Note: This function is provided for the convenience of the library
user. ClusterNodes are not used as input to any of the functions in this
library.

Parameters
----------
Z : ndarray
    The linkage matrix in proper form (see the ``linkage``
    function documentation).

rd : bool, optional
    When False, a reference to the root ClusterNode object is
    returned.  Otherwise, a tuple (r,d) is returned. ``r`` is a
    reference to the root node while ``d`` is a dictionary
    mapping cluster ids to ClusterNode references. If a cluster id is
    less than n, then it corresponds to a singleton cluster
    (leaf node). See ``linkage`` for more information on the
    assignment of cluster ids to clusters.

Returns
-------
L : list
    The pre-order traversal.</docstring>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>The linkage matrix in proper form (see the ``linkage``
function documentation).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rd" name="rd" port_type="basic:Boolean">
      <docstring>When False, a reference to the root ClusterNode object is
returned.  Otherwise, a tuple (r,d) is returned. ``r`` is a
reference to the root node while ``d`` is a dictionary
mapping cluster ids to ClusterNode references. If a cluster id is
less than n, then it corresponds to a singleton cluster
(leaf node). See ``linkage`` for more information on the
assignment of cluster ids to clusters.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="L" name="L" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pre-order traversal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.ward" module_name="ward" namespace="'cluster|hierarchy'">
    <docstring>Performs Ward's linkage on a condensed or redundant distance matrix.

See linkage for more information on the return structure
and algorithm.

The following are common calling conventions:

1. ``Z = ward(y)``
   Performs Ward's linkage on the condensed distance matrix ``Z``. See
   linkage for more information on the return structure and
   algorithm.

2. ``Z = ward(X)``
   Performs Ward's linkage on the observation matrix ``X`` using
   Euclidean distance as the distance metric. See linkage for more
   information on the return structure and algorithm.

Parameters
----------
y : ndarray
    A condensed or redundant distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    a m by n array.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>A condensed or redundant distance matrix. A condensed
distance matrix is a flat array containing the upper
triangular of the distance matrix. This is the form that
``pdist`` returns. Alternatively, a collection of
m observation vectors in n dimensions may be passed as
a m by n array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The hierarchical clustering encoded as a linkage matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.cluster.hierarchy.weighted" module_name="weighted" namespace="'cluster|hierarchy'">
    <docstring>Performs weighted/WPGMA linkage on the condensed distance matrix.

See ``linkage`` for more information on the return
structure and algorithm.

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The upper triangular of the distance matrix. The result of
``pdist`` is returned in this form.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A linkage matrix containing the hierarchical clustering. See
the ``linkage`` function documentation for more information
on its structure.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.fft" module_name="fft" namespace="'fftpack'">
    <docstring>Return discrete Fourier transform of real or complex sequence.

The returned complex array contains ``y(0), y(1),..., y(n-1)`` where

``y(j) = (x * exp(-2*pi*sqrt(-1)*j*np.arange(n)/n)).sum()``.

Parameters
----------
x : array_like
    Array to Fourier transform.
n : int, optional
    Length of the Fourier transform.  If ``n &lt; x.shape[axis]``, `x` is
    truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
    default results in ``n = x.shape[axis]``.
axis : int, optional
    Axis along which the fft's are computed; the default is over the
    last axis (i.e., ``axis=-1``).
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
z : complex ndarray
    with the elements::

        [y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even
        [y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd

    where::

        y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k* 2*pi/n), j = 0..n-1

    Note that ``y(-j) = y(n-j).conjugate()``.

See Also
--------
ifft : Inverse FFT
rfft : FFT of a real sequence

Notes
-----
The packing of the result is "standard": If ``A = fft(a, n)``, then
``A[0]`` contains the zero-frequency term, ``A[1:n/2]`` contains the
positive-frequency terms, and ``A[n/2:]`` contains the negative-frequency
terms, in order of decreasingly negative frequency. So for an 8-point
transform, the frequencies of the result are [0, 1, 2, 3, -4, -3, -2, -1].
To rearrange the fft output so that the zero-frequency component is
centered, like [-4, -3, -2, -1,  0,  1,  2,  3], use `fftshift`.

For `n` even, ``A[n/2]`` contains the sum of the positive and
negative-frequency terms.  For `n` even and `x` real, ``A[n/2]`` will
always be real.

This function is most efficient when `n` is a power of two, and least
efficient when `n` is prime.

If the data type of `x` is real, a "real FFT" algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use `rfft`, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the `dct` can again double the efficiency, by generating
half of the spectrum from half of the signal.

Examples
--------
&gt;&gt;&gt; from scipy.fftpack import fft, ifft
&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.allclose(fft(ifft(x)), x, atol=1e-15)  # within numerical accuracy.
True</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array to Fourier transform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the Fourier transform.  If ``n &lt; x.shape[axis]``, `x` is
truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
default results in ``n = x.shape[axis]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the fft's are computed; the default is over the
last axis (i.e., ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>with the elements::

    [y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even
    [y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd

where::

    y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k* 2*pi/n), j = 0..n-1

Note that ``y(-j) = y(n-j).conjugate()``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.ifft" module_name="ifft" namespace="'fftpack'">
    <docstring>Return discrete inverse Fourier transform of real or complex sequence.

The returned complex array contains ``y(0), y(1),..., y(n-1)`` where

``y(j) = (x * exp(2*pi*sqrt(-1)*j*np.arange(n)/n)).mean()``.

Parameters
----------
x : array_like
    Transformed data to invert.
n : int, optional
    Length of the inverse Fourier transform.  If ``n &lt; x.shape[axis]``,
    `x` is truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded.
    The default results in ``n = x.shape[axis]``.
axis : int, optional
    Axis along which the ifft's are computed; the default is over the
    last axis (i.e., ``axis=-1``).
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
ifft : ndarray of floats
    The inverse discrete Fourier transform.

See Also
--------
fft : Forward FFT

Notes
-----
This function is most efficient when `n` is a power of two, and least
efficient when `n` is prime.

If the data type of `x` is real, a "real IFFT" algorithm is automatically
used, which roughly halves the computation time.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Transformed data to invert.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the inverse Fourier transform.  If ``n &lt; x.shape[axis]``,
`x` is truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded.
The default results in ``n = x.shape[axis]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the ifft's are computed; the default is over the
last axis (i.e., ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ifft" depth="1" name="ifft" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The inverse discrete Fourier transform.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.fftn" module_name="fftn" namespace="'fftpack'">
    <docstring>Return multidimensional discrete Fourier transform.

The returned array contains::

  y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
     x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)*2*pi/n_i * j_i * k_i)

where d = len(x.shape) and n = x.shape.
Note that ``y[..., -j_i, ...] = y[..., n_i-j_i, ...].conjugate()``.

Parameters
----------
x : array_like
    The (n-dimensional) array to transform.
shape : tuple of ints, optional
    The shape of the result.  If both `shape` and `axes` (see below) are
    None, `shape` is ``x.shape``; if `shape` is None but `axes` is
    not None, then `shape` is ``scipy.take(x.shape, axes, axis=0)``.
    If ``shape[i] &gt; x.shape[i]``, the i-th dimension is padded with zeros.
    If ``shape[i] &lt; x.shape[i]``, the i-th dimension is truncated to
    length ``shape[i]``.
axes : array_like of ints, optional
    The axes of `x` (`y` if `shape` is not None) along which the
    transform is applied.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed.  Default is False.

Returns
-------
y : complex-valued n-dimensional numpy array
    The (n-dimensional) DFT of the input array.

See Also
--------
ifftn

Examples
--------
&gt;&gt;&gt; from scipy.fftpack import fftn, ifftn
&gt;&gt;&gt; y = (-np.arange(16), 8 - np.arange(16), np.arange(16))
&gt;&gt;&gt; np.allclose(y, fftn(ifftn(y)))
True</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The (n-dimensional) array to transform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shape" depth="1" name="shape" port_type="basic:Integer">
      <docstring>The shape of the result.  If both `shape` and `axes` (see below) are
None, `shape` is ``x.shape``; if `shape` is None but `axes` is
not None, then `shape` is ``scipy.take(x.shape, axes, axis=0)``.
If ``shape[i] &gt; x.shape[i]``, the i-th dimension is padded with zeros.
If ``shape[i] &lt; x.shape[i]``, the i-th dimension is truncated to
length ``shape[i]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>The axes of `x` (`y` if `shape` is not None) along which the
transform is applied.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The (n-dimensional) DFT of the input array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.ifftn" module_name="ifftn" namespace="'fftpack'">
    <docstring>Return inverse multi-dimensional discrete Fourier transform of
arbitrary type sequence x.

The returned array contains::

  y[j_1,..,j_d] = 1/p * sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
     x[k_1,..,k_d] * prod[i=1..d] exp(sqrt(-1)*2*pi/n_i * j_i * k_i)

where ``d = len(x.shape)``, ``n = x.shape``, and ``p = prod[i=1..d] n_i``.

For description of parameters see `fftn`.

See Also
--------
fftn : for detailed information.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="shape" name="shape" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axes" name="axes" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.rfft" module_name="rfft" namespace="'fftpack'">
    <docstring>Discrete Fourier transform of a real sequence.

Parameters
----------
x : array_like, real-valued
    The data to transform.
n : int, optional
    Defines the length of the Fourier transform.  If `n` is not specified
    (the default) then ``n = x.shape[axis]``.  If ``n &lt; x.shape[axis]``,
    `x` is truncated, if ``n &gt; x.shape[axis]``, `x` is zero-padded.
axis : int, optional
    The axis along which the transform is applied.  The default is the
    last axis.
overwrite_x : bool, optional
    If set to true, the contents of `x` can be overwritten. Default is
    False.

Returns
-------
z : real ndarray
    The returned real array contains::

      [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even
      [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd

    where::

      y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k*2*pi/n)
      j = 0..n-1

    Note that ``y(-j) == y(n-j).conjugate()``.

See Also
--------
fft, irfft, scipy.fftpack.basic

Notes
-----
Within numerical accuracy, ``y == rfft(irfft(y))``.

Examples
--------
&gt;&gt;&gt; from scipy.fftpack import fft, rfft
&gt;&gt;&gt; a = [9, -9, 1, 3]
&gt;&gt;&gt; fft(a)
array([  4. +0.j,   8.+12.j,  16. +0.j,   8.-12.j])
&gt;&gt;&gt; rfft(a)
array([  4.,   8.,  12.,  16.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The data to transform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Defines the length of the Fourier transform.  If `n` is not specified
(the default) then ``n = x.shape[axis]``.  If ``n &lt; x.shape[axis]``,
`x` is truncated, if ``n &gt; x.shape[axis]``, `x` is zero-padded.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the transform is applied.  The default is the
last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If set to true, the contents of `x` can be overwritten. Default is
False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The returned real array contains::

  [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even
  [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd

where::

  y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k*2*pi/n)
  j = 0..n-1

Note that ``y(-j) == y(n-j).conjugate()``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.irfft" module_name="irfft" namespace="'fftpack'">
    <docstring>Return inverse discrete Fourier transform of real sequence x.

The contents of `x` are interpreted as the output of the `rfft`
function.

Parameters
----------
x : array_like
    Transformed data to invert.
n : int, optional
    Length of the inverse Fourier transform.
    If n &lt; x.shape[axis], x is truncated.
    If n &gt; x.shape[axis], x is zero-padded.
    The default results in n = x.shape[axis].
axis : int, optional
    Axis along which the ifft's are computed; the default is over
    the last axis (i.e., axis=-1).
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
irfft : ndarray of floats
    The inverse discrete Fourier transform.

See Also
--------
rfft, ifft

Notes
-----
The returned real array contains::

    [y(0),y(1),...,y(n-1)]

where for n is even::

    y(j) = 1/n (sum[k=1..n/2-1] (x[2*k-1]+sqrt(-1)*x[2*k])
                                 * exp(sqrt(-1)*j*k* 2*pi/n)
                + c.c. + x[0] + (-1)**(j) x[n-1])

and for n is odd::

    y(j) = 1/n (sum[k=1..(n-1)/2] (x[2*k-1]+sqrt(-1)*x[2*k])
                                 * exp(sqrt(-1)*j*k* 2*pi/n)
                + c.c. + x[0])

c.c. denotes complex conjugate of preceding expression.

For details on input parameters, see `rfft`.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Transformed data to invert.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the inverse Fourier transform.
If n &lt; x.shape[axis], x is truncated.
If n &gt; x.shape[axis], x is zero-padded.
The default results in n = x.shape[axis].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the ifft's are computed; the default is over
the last axis (i.e., axis=-1).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="irfft" depth="1" name="irfft" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The inverse discrete Fourier transform.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.fft2" module_name="fft2" namespace="'fftpack'">
    <docstring>2-D discrete Fourier transform.

Return the two-dimensional discrete Fourier transform of the 2-D argument
`x`.

See Also
--------
fftn : for detailed information.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="shape" name="shape" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <defaults>[(-2, -1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.ifft2" module_name="ifft2" namespace="'fftpack'">
    <docstring>2-D discrete inverse Fourier transform of real or complex sequence.

Return inverse two-dimensional discrete Fourier transform of
arbitrary type sequence x.

See `ifft` for more information.

See also
--------
fft2, ifft</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="shape" name="shape" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <defaults>[(-2, -1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.diff" module_name="diff" namespace="'fftpack'">
    <docstring>Return k-th derivative (or integral) of a periodic sequence x.

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = pow(sqrt(-1)*j*2*pi/period, order) * x_j
  y_0 = 0 if order is not 0.

Parameters
----------
x : array_like
    Input array.
order : int, optional
    The order of differentiation. Default order is 1. If order is
    negative, then integration is carried out under the assumption
    that ``x_0 == 0``.
period : float, optional
    The assumed period of the sequence. Default is ``2*pi``.

Notes
-----
If ``sum(x, axis=0) = 0`` then ``diff(diff(x, k), -k) == x`` (within
numerical accuracy).

For odd order and even ``len(x)``, the Nyquist mode is taken zero.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of differentiation. Default order is 1. If order is
negative, then integration is carried out under the assumption
that ``x_0 == 0``.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The assumed period of the sequence. Default is ``2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.tilbert" module_name="tilbert" namespace="'fftpack'">
    <docstring>Return h-Tilbert transform of a periodic sequence x.

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

    y_j = sqrt(-1)*coth(j*h*2*pi/period) * x_j
    y_0 = 0

Parameters
----------
x : array_like
    The input array to transform.
h : float
    Defines the parameter of the Tilbert transform.
period : float, optional
    The assumed period of the sequence.  Default period is ``2*pi``.

Returns
-------
tilbert : ndarray
    The result of the transform.

Notes
-----
If ``sum(x, axis=0) == 0`` and ``n = len(x)`` is odd then
``tilbert(itilbert(x)) == x``.

If ``2 * pi * h / period`` is approximately 10 or larger, then
numerically ``tilbert == hilbert``
(theoretically oo-Tilbert == Hilbert).

For even ``len(x)``, the Nyquist mode of ``x`` is taken zero.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array to transform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="h" name="h" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameter of the Tilbert transform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The assumed period of the sequence.  Default period is ``2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="tilbert" name="tilbert" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of the transform.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.itilbert" module_name="itilbert" namespace="'fftpack'">
    <docstring>Return inverse h-Tilbert transform of a periodic sequence x.

If ``x_j`` and ``y_j`` are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = -sqrt(-1)*tanh(j*h*2*pi/period) * x_j
  y_0 = 0

For more details, see `tilbert`.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="period" name="period" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="h" name="h" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.hilbert" module_name="hilbert" namespace="'fftpack'">
    <docstring>Return Hilbert transform of a periodic sequence x.

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = sqrt(-1)*sign(j) * x_j
  y_0 = 0

Parameters
----------
x : array_like
    The input array, should be periodic.
_cache : dict, optional
    Dictionary that contains the kernel used to do a convolution with.

Returns
-------
y : ndarray
    The transformed input.

Notes
-----
If ``sum(x, axis=0) == 0`` then ``hilbert(ihilbert(x)) == x``.

For even len(x), the Nyquist mode of x is taken zero.

The sign of the returned transform does not have a factor -1 that is more
often than not found in the definition of the Hilbert transform.  Note also
that ``scipy.signal.hilbert`` does have an extra -1 factor compared to this
function.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array, should be periodic.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache">
      <docstring>Dictionary that contains the kernel used to do a convolution with.</docstring>
      <defaults>[{}]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The transformed input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.ihilbert" module_name="ihilbert" namespace="'fftpack'">
    <docstring>Return inverse Hilbert transform of a periodic sequence x.

If ``x_j`` and ``y_j`` are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = -sqrt(-1)*sign(j) * x_j
  y_0 = 0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.sc_diff" module_name="sc_diff" namespace="'fftpack'">
    <docstring>Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = sqrt(-1)*sinh(j*a*2*pi/period)/cosh(j*b*2*pi/period) * x_j
  y_0 = 0

Parameters
----------
x : array_like
    Input array.
a,b : float
    Defines the parameters of the sinh/cosh pseudo-differential
    operator.
period : float, optional
    The period of the sequence x. Default is 2*pi.

Notes
-----
``sc_diff(cs_diff(x,a,b),b,a) == x``
For even ``len(x)``, the Nyquist mode of x is taken as zero.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the sinh/cosh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the sinh/cosh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The period of the sequence x. Default is 2*pi.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.cs_diff" module_name="cs_diff" namespace="'fftpack'">
    <docstring>Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence.

If ``x_j`` and ``y_j`` are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = -sqrt(-1)*cosh(j*a*2*pi/period)/sinh(j*b*2*pi/period) * x_j
  y_0 = 0

Parameters
----------
x : array_like
    The array to take the pseudo-derivative from.
a, b : float
    Defines the parameters of the cosh/sinh pseudo-differential
    operator.
period : float, optional
    The period of the sequence. Default period is ``2*pi``.

Returns
-------
cs_diff : ndarray
    Pseudo-derivative of periodic sequence `x`.

Notes
-----
For even len(`x`), the Nyquist mode of `x` is taken as zero.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array to take the pseudo-derivative from.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the cosh/sinh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the cosh/sinh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The period of the sequence. Default period is ``2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="cs_diff" name="cs_diff" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Pseudo-derivative of periodic sequence `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.cc_diff" module_name="cc_diff" namespace="'fftpack'">
    <docstring>Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence.

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = cosh(j*a*2*pi/period)/cosh(j*b*2*pi/period) * x_j

Parameters
----------
x : array_like
    The array to take the pseudo-derivative from.
a,b : float
    Defines the parameters of the sinh/sinh pseudo-differential
    operator.
period : float, optional
    The period of the sequence x. Default is ``2*pi``.

Returns
-------
cc_diff : ndarray
    Pseudo-derivative of periodic sequence `x`.

Notes
-----
``cc_diff(cc_diff(x,a,b),b,a) == x``</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array to take the pseudo-derivative from.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the sinh/sinh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the sinh/sinh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The period of the sequence x. Default is ``2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="cc_diff" name="cc_diff" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Pseudo-derivative of periodic sequence `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.ss_diff" module_name="ss_diff" namespace="'fftpack'">
    <docstring>Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

  y_j = sinh(j*a*2*pi/period)/sinh(j*b*2*pi/period) * x_j
  y_0 = a/b * x_0

Parameters
----------
x : array_like
    The array to take the pseudo-derivative from.
a,b
    Defines the parameters of the sinh/sinh pseudo-differential
    operator.
period : float, optional
    The period of the sequence x. Default is ``2*pi``.

Notes
-----
``ss_diff(ss_diff(x,a,b),b,a) == x``</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array to take the pseudo-derivative from.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>Defines the parameters of the sinh/sinh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True">
      <docstring>Defines the parameters of the sinh/sinh pseudo-differential
operator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The period of the sequence x. Default is ``2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.shift" module_name="shift" namespace="'fftpack'">
    <docstring>Shift periodic sequence x by a: y(u) = x(u+a).

If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::

      y_j = exp(j*a*2*pi/period*sqrt(-1)) * x_f

Parameters
----------
x : array_like
    The array to take the pseudo-derivative from.
a : float
    Defines the parameters of the sinh/sinh pseudo-differential
period : float, optional
    The period of the sequences x and y. Default period is ``2*pi``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array to take the pseudo-derivative from.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Defines the parameters of the sinh/sinh pseudo-differential</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="period" port_type="basic:Float">
      <docstring>The period of the sequences x and y. Default period is ``2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="_cache" name="_cache" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.rfftfreq" module_name="rfftfreq" namespace="'fftpack'">
    <docstring>DFT sample frequencies (for usage with rfft, irfft).

The returned float array contains the frequency bins in
cycles/unit (with zero at the start) given a window length `n` and a
sample spacing `d`::

  f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2]/(d*n)   if n is even
  f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2,n/2]/(d*n)   if n is odd

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing. Default is 1.

Returns
-------
out : ndarray
    The array of length `n`, containing the sample frequencies.

Examples
--------
&gt;&gt;&gt; from scipy import fftpack
&gt;&gt;&gt; sig = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
&gt;&gt;&gt; sig_fft = fftpack.rfft(sig)
&gt;&gt;&gt; n = sig_fft.size
&gt;&gt;&gt; timestep = 0.1
&gt;&gt;&gt; freq = fftpack.rfftfreq(n, d=timestep)
&gt;&gt;&gt; freq
array([ 0.  ,  1.25,  1.25,  2.5 ,  2.5 ,  3.75,  3.75,  5.  ])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Window length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d" name="d" port_type="basic:Float">
      <docstring>Sample spacing. Default is 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array of length `n`, containing the sample frequencies.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.dct" module_name="dct" namespace="'fftpack'">
    <docstring>Return the Discrete Cosine Transform of arbitrary type sequence x.

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DCT (see Notes). Default type is 2.
n : int, optional
    Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
    truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
    default results in ``n = x.shape[axis]``.
axis : int, optional
    Axis along which the dct is computed; the default is over the
    last axis (i.e., ``axis=-1``).
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
y : ndarray of real
    The transformed input array.

See Also
--------
idct : Inverse DCT

Notes
-----
For a single dimension array ``x``, ``dct(x, norm='ortho')`` is equal to
MATLAB ``dct(x)``.

There are theoretically 8 types of the DCT, only the first 3 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.

**Type I**

There are several definitions of the DCT-I; we use the following
(for ``norm=None``)::

                                     N-2
  y[k] = x[0] + (-1)**k x[N-1] + 2 * sum x[n]*cos(pi*k*n/(N-1))
                                     n=1

Only None is supported as normalization mode for DCT-I. Note also that the
DCT-I is only supported for input size &gt; 1

**Type II**

There are several definitions of the DCT-II; we use the following
(for ``norm=None``)::


            N-1
  y[k] = 2* sum x[n]*cos(pi*k*(2n+1)/(2*N)), 0 &lt;= k &lt; N.
            n=0

If ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor `f`::

  f = sqrt(1/(4*N)) if k = 0,
  f = sqrt(1/(2*N)) otherwise.

Which makes the corresponding matrix of coefficients orthonormal
(``OO' = Id``).

**Type III**

There are several definitions, we use the following
(for ``norm=None``)::

                    N-1
  y[k] = x[0] + 2 * sum x[n]*cos(pi*(k+0.5)*n/N), 0 &lt;= k &lt; N.
                    n=1

or, for ``norm='ortho'`` and 0 &lt;= k &lt; N::

                                      N-1
  y[k] = x[0] / sqrt(N) + sqrt(2/N) * sum x[n]*cos(pi*(k+0.5)*n/N)
                                      n=1

The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor `2N`. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.

References
----------
.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
       Makhoul, `IEEE Transactions on acoustics, speech and signal
       processing` vol. 28(1), pp. 27-34,
       http://dx.doi.org/10.1109/TASSP.1980.1163351 (1980).
.. [2] Wikipedia, "Discrete cosine transform",
       http://en.wikipedia.org/wiki/Discrete_cosine_transform

Examples
--------
The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:

&gt;&gt;&gt; from scipy.fftpack import fft, dct
&gt;&gt;&gt; fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
&gt;&gt;&gt; dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>Type of the DCT (see Notes). Default type is 2.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2, 3]]</values>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
default results in ``n = x.shape[axis]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the dct is computed; the default is over the
last axis (i.e., ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>Normalization mode (see Notes). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The transformed input array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.idct" module_name="idct" namespace="'fftpack'">
    <docstring>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DCT (see Notes). Default type is 2.
n : int, optional
    Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
    truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
    default results in ``n = x.shape[axis]``.
axis : int, optional
    Axis along which the idct is computed; the default is over the
    last axis (i.e., ``axis=-1``).
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
idct : ndarray of real
    The transformed input array.

See Also
--------
dct : Forward DCT

Notes
-----
For a single dimension array `x`, ``idct(x, norm='ortho')`` is equal to
MATLAB ``idct(x)``.

'The' IDCT is the IDCT of type 2, which is the same as DCT of type 3.

IDCT of type 1 is the DCT of type 1, IDCT of type 2 is the DCT of type
3, and IDCT of type 3 is the DCT of type 2. For the definition of these
types, see `dct`.

Examples
--------
The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:

&gt;&gt;&gt; from scipy.fftpack import ifft, idct
&gt;&gt;&gt; ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
&gt;&gt;&gt; idct(np.array([ 30.,  -8.,   6.,  -2.]), 1) / 6
array([  4.,   3.,   5.,  10.])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>Type of the DCT (see Notes). Default type is 2.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2, 3]]</values>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
default results in ``n = x.shape[axis]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the idct is computed; the default is over the
last axis (i.e., ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>Normalization mode (see Notes). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="idct" name="idct" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The transformed input array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.dst" module_name="dst" namespace="'fftpack'">
    <docstring>Return the Discrete Sine Transform of arbitrary type sequence x.

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DST (see Notes). Default type is 2.
n : int, optional
    Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
    truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
    default results in ``n = x.shape[axis]``.
axis : int, optional
    Axis along which the dst is computed; the default is over the
    last axis (i.e., ``axis=-1``).
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
dst : ndarray of reals
    The transformed input array.

See Also
--------
idst : Inverse DST

Notes
-----
For a single dimension array ``x``.

There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
3 types are implemented in scipy.

**Type I**

There are several definitions of the DST-I; we use the following
for ``norm=None``.  DST-I assumes the input is odd around n=-1 and n=N. ::

             N-1
  y[k] = 2 * sum x[n]*sin(pi*(k+1)*(n+1)/(N+1))
             n=0

Only None is supported as normalization mode for DCT-I. Note also that the
DCT-I is only supported for input size &gt; 1
The (unnormalized) DCT-I is its own inverse, up to a factor `2(N+1)`.

**Type II**

There are several definitions of the DST-II; we use the following
for ``norm=None``.  DST-II assumes the input is odd around n=-1/2 and
n=N-1/2; the output is odd around k=-1 and even around k=N-1 ::

            N-1
  y[k] = 2* sum x[n]*sin(pi*(k+1)*(n+0.5)/N), 0 &lt;= k &lt; N.
            n=0

if ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor `f` ::

    f = sqrt(1/(4*N)) if k == 0
    f = sqrt(1/(2*N)) otherwise.

**Type III**

There are several definitions of the DST-III, we use the following
(for ``norm=None``).  DST-III assumes the input is odd around n=-1
and even around n=N-1 ::

                             N-2
  y[k] = x[N-1]*(-1)**k + 2* sum x[n]*sin(pi*(k+0.5)*(n+1)/N), 0 &lt;= k &lt; N.
                             n=0

The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor `2N`.  The orthonormalized DST-III is exactly the inverse of
the orthonormalized DST-II.

.. versionadded:: 0.11.0

References
----------
.. [1] Wikipedia, "Discrete sine transform",
       http://en.wikipedia.org/wiki/Discrete_sine_transform</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>Type of the DST (see Notes). Default type is 2.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2, 3]]</values>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
default results in ``n = x.shape[axis]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the dst is computed; the default is over the
last axis (i.e., ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>Normalization mode (see Notes). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="dst" name="dst" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The transformed input array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.fftpack.idst" module_name="idst" namespace="'fftpack'">
    <docstring>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DST (see Notes). Default type is 2.
n : int, optional
    Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
    truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
    default results in ``n = x.shape[axis]``.
axis : int, optional
    Axis along which the idst is computed; the default is over the
    last axis (i.e., ``axis=-1``).
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.

Returns
-------
idst : ndarray of real
    The transformed input array.

See Also
--------
dst : Forward DST

Notes
-----
'The' IDST is the IDST of type 2, which is the same as DST of type 3.

IDST of type 1 is the DST of type 1, IDST of type 2 is the DST of type
3, and IDST of type 3 is the DST of type 2. For the definition of these
types, see `dst`.

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>Type of the DST (see Notes). Default type is 2.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2, 3]]</values>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Length of the transform.  If ``n &lt; x.shape[axis]``, `x` is
truncated.  If ``n &gt; x.shape[axis]``, `x` is zero-padded. The
default results in ``n = x.shape[axis]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the idst is computed; the default is over the
last axis (i.e., ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm">
      <docstring>Normalization mode (see Notes). Default is None.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ortho']]</values>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_x" name="overwrite_x" port_type="basic:Boolean">
      <docstring>If True, the contents of `x` can be destroyed; the default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="idst" name="idst" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The transformed input array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.cumtrapz" module_name="cumtrapz" namespace="'integrate'">
    <docstring>Cumulatively integrate y(x) using the composite trapezoidal rule.

Parameters
----------
y : array_like
    Values to integrate.
x : array_like, optional
    The coordinate to integrate along.  If None (default), use spacing `dx`
    between consecutive elements in `y`.
dx : int, optional
    Spacing between elements of `y`.  Only used if `x` is None.
axis : int, optional
    Specifies the axis to cumulate.  Default is -1 (last axis).
initial : scalar, optional
    If given, uses this value as the first value in the returned result.
    Typically this value should be 0.  Default is None, which means no
    value at ``x[0]`` is returned and `res` has one element less than `y`
    along the axis of integration.

Returns
-------
res : ndarray
    The result of cumulative integration of `y` along `axis`.
    If `initial` is None, the shape is such that the axis of integration
    has one less value than `y`.  If `initial` is given, the shape is equal
    to that of `y`.

See Also
--------
numpy.cumsum, numpy.cumprod
quad: adaptive quadrature using QUADPACK
romberg: adaptive Romberg quadrature
quadrature: adaptive Gaussian quadrature
fixed_quad: fixed-order Gaussian quadrature
dblquad: double integrals
tplquad: triple integrals
romb: integrators for sampled data
ode: ODE integrators
odeint: ODE integrators

Examples
--------
&gt;&gt;&gt; from scipy import integrate
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; x = np.linspace(-2, 2, num=20)
&gt;&gt;&gt; y = x
&gt;&gt;&gt; y_int = integrate.cumtrapz(y, x, initial=0)
&gt;&gt;&gt; plt.plot(x, y_int, 'ro', x, y[0] + 0.5 * x**2, 'b-')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Values to integrate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>The coordinate to integrate along.  If None (default), use spacing `dx`
between consecutive elements in `y`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <docstring>Spacing between elements of `y`.  Only used if `x` is None.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Specifies the axis to cumulate.  Default is -1 (last axis).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="initial" name="initial" port_type="basic:Float">
      <docstring>If given, uses this value as the first value in the returned result.
Typically this value should be 0.  Default is None, which means no
value at ``x[0]`` is returned and `res` has one element less than `y`
along the axis of integration.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of cumulative integration of `y` along `axis`.
If `initial` is None, the shape is such that the axis of integration
has one less value than `y`.  If `initial` is given, the shape is equal
to that of `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.dblquad" module_name="dblquad" namespace="'integrate'" output_type="list">
    <docstring>Compute a double integral.

Return the double (definite) integral of ``func(y, x)`` from ``x = a..b``
and ``y = gfun(x)..hfun(x)``.

Parameters
----------
func : callable
    A Python function or method of at least two variables: y must be the
    first argument and x the second argument.
a, b : float
    The limits of integration in x: `a` &lt; `b`
gfun : callable
    The lower boundary curve in y which is a function taking a single
    floating point argument (x) and returning a floating point result: a
    lambda function can be useful here.
hfun : callable
    The upper boundary curve in y (same requirements as `gfun`).
args : sequence, optional
    Extra arguments to pass to `func`.
epsabs : float, optional
    Absolute tolerance passed directly to the inner 1-D quadrature
    integration. Default is 1.49e-8.
epsrel : float, optional
    Relative tolerance of the inner 1-D integrals. Default is 1.49e-8.

Returns
-------
y : float
    The resultant integral.
abserr : float
    An estimate of the error.

See also
--------
quad : single integral
tplquad : triple integral
nquad : N-dimensional integrals
fixed_quad : fixed-order Gaussian quadrature
quadrature : adaptive Gaussian quadrature
odeint : ODE integrator
ode : ODE integrator
simps : integrator for sampled data
romb : integrator for sampled data
scipy.special : for coefficients and roots of orthogonal polynomials</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>A Python function or method of at least two variables: y must be the
first argument and x the second argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>The limits of integration in x: `a` &lt; `b`</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>The limits of integration in x: `a` &lt; `b`</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gfun" name="gfun" port_type="basic:Variant" show_port="True">
      <docstring>The lower boundary curve in y which is a function taking a single
floating point argument (x) and returning a floating point result: a
lambda function can be useful here.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hfun" name="hfun" port_type="basic:Variant" show_port="True">
      <docstring>The upper boundary curve in y (same requirements as `gfun`).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to `func`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsabs" name="epsabs" port_type="basic:Float">
      <docstring>Absolute tolerance passed directly to the inner 1-D quadrature
integration. Default is 1.49e-8.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsrel" name="epsrel" port_type="basic:Float">
      <docstring>Relative tolerance of the inner 1-D integrals. Default is 1.49e-8.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The resultant integral.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="abserr" name="abserr" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>An estimate of the error.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.fixed_quad" module_name="fixed_quad" namespace="'integrate'">
    <docstring>Compute a definite integral using fixed-order Gaussian quadrature.

Integrate `func` from `a` to `b` using Gaussian quadrature of
order `n`.

Parameters
----------
func : callable
    A Python function or method to integrate (must accept vector inputs).
a : float
    Lower limit of integration.
b : float
    Upper limit of integration.
args : tuple, optional
    Extra arguments to pass to function, if any.
n : int, optional
    Order of quadrature integration. Default is 5.

Returns
-------
val : float
    Gaussian quadrature approximation to the integral

See Also
--------
quad : adaptive quadrature using QUADPACK
dblquad : double integrals
tplquad : triple integrals
romberg : adaptive Romberg quadrature
quadrature : adaptive Gaussian quadrature
romb : integrators for sampled data
simps : integrators for sampled data
cumtrapz : cumulative integration for sampled data
ode : ODE integrator
odeint : ODE integrator</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>A Python function or method to integrate (must accept vector inputs).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Lower limit of integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Upper limit of integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to function, if any.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Order of quadrature integration. Default is 5.</docstring>
      <defaults>[5]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="val" name="val" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Gaussian quadrature approximation to the integral</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.newton_cotes" module_name="newton_cotes" namespace="'integrate'" output_type="list">
    <docstring>Return weights and error coefficient for Newton-Cotes integration.

Suppose we have (N+1) samples of f at the positions
x_0, x_1, ..., x_N.  Then an N-point Newton-Cotes formula for the
integral between x_0 and x_N is:

:math:`\int_{x_0}^{x_N} f(x)dx = \Delta x \sum_{i=0}^{N} a_i f(x_i)
+ B_N (\Delta x)^{N+2} f^{N+1} (\xi)`

where :math:`\xi \in [x_0,x_N]` and :math:`\Delta x = \frac{x_N-x_0}{N}`
is the averages samples spacing.

If the samples are equally-spaced and N is even, then the error
term is :math:`B_N (\Delta x)^{N+3} f^{N+2}(\xi)`.

Parameters
----------
rn : int
    The integer order for equally-spaced data or the relative positions of
    the samples with the first sample at 0 and the last at N, where N+1 is
    the length of `rn`.  N is the order of the Newton-Cotes integration.
equal : int, optional
    Set to 1 to enforce equally spaced data.

Returns
-------
an : ndarray
    1-D array of weights to apply to the function at the provided sample
    positions.
B : float
    Error coefficient.

Notes
-----
Normally, the Newton-Cotes rules are used on smaller integration
regions and a composite rule is used to return the total integral.</docstring>
    <inputPortSpec arg="rn" name="rn" port_type="basic:Integer" show_port="True">
      <docstring>The integer order for equally-spaced data or the relative positions of
the samples with the first sample at 0 and the last at N, where N+1 is
the length of `rn`.  N is the order of the Newton-Cotes integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="equal" name="equal" port_type="basic:Integer">
      <docstring>Set to 1 to enforce equally spaced data.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="an" name="an" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>1-D array of weights to apply to the function at the provided sample
positions.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Error coefficient.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.nquad" module_name="nquad" namespace="'integrate'" output_type="list">
    <docstring>Integration over multiple variables.

Wraps `quad` to enable integration over multiple variables.
Various options allow improved integration of discontinuous functions, as
well as the use of weighted integration, and generally finer control of the
integration process.

Parameters
----------
func : callable
    The function to be integrated. Has arguments of ``x0, ... xn``,
    ``t0, tm``, where integration is carried out over ``x0, ... xn``, which
    must be floats.  Function signature should be
    ``func(x0, x1, ..., xn, t0, t1, ..., tm)``.  Integration is carried out
    in order.  That is, integration over ``x0`` is the innermost integral,
    and ``xn`` is the outermost.
    If performance is a concern, this function may be a ctypes function of
    the form::

        f(int n, double args[n])

    where ``n`` is the number of extra parameters and args is an array
    of doubles of the additional parameters.  This function may then
    be compiled to a dynamic/shared library then imported through
    ``ctypes``, setting the function's argtypes to ``(c_int, c_double)``,
    and the function's restype to ``(c_double)``.  Its pointer may then be
    passed into `nquad` normally.
    This allows the underlying Fortran library to evaluate the function in
    the innermost integration calls without callbacks to Python, and also
    speeds up the evaluation of the function itself.
ranges : iterable object
    Each element of ranges may be either a sequence  of 2 numbers, or else
    a callable that returns such a sequence.  ``ranges[0]`` corresponds to
    integration over x0, and so on.  If an element of ranges is a callable,
    then it will be called with all of the integration arguments available.
    e.g. if ``func = f(x0, x1, x2)``, then ``ranges[0]`` may be defined as
    either ``(a, b)`` or else as ``(a, b) = range0(x1, x2)``.
args : iterable object, optional
    Additional arguments ``t0, ..., tn``, required by `func`.
opts : iterable object or dict, optional
    Options to be passed to `quad`.  May be empty, a dict, or
    a sequence of dicts or functions that return a dict.  If empty, the
    default options from scipy.integrate.quadare used.  If a dict, the same
    options are used for all levels of integraion.  If a sequence, then each
    element of the sequence corresponds to a particular integration. e.g.
    opts[0] corresponds to integration over x0, and so on. The available
    options together with their default values are:

      - epsabs = 1.49e-08
      - epsrel = 1.49e-08
      - limit  = 50
      - points = None
      - weight = None
      - wvar   = None
      - wopts  = None

    The ``full_output`` option from `quad` is unavailable, due to the
    complexity of handling the large amount of data such an option would
    return for this kind of nested integration.  For more information on
    these options, see `quad` and `quad_explain`.

Returns
-------
result : float
    The result of the integration.
abserr : float
    The maximum of the estimates of the absolute error in the various
    integration results.

See Also
--------
quad : 1-dimensional numerical integration
dblquad, tplquad : double and triple integrals
fixed_quad : fixed-order Gaussian quadrature
quadrature : adaptive Gaussian quadrature

Examples
--------
&gt;&gt;&gt; from scipy import integrate
&gt;&gt;&gt; func = lambda x0,x1,x2,x3 : x0**2 + x1*x2 - x3**3 + np.sin(x0) + (
...                                 1 if (x0-.2*x3-.5-.25*x1&gt;0) else 0)
&gt;&gt;&gt; points = [[lambda (x1,x2,x3) : 0.2*x3 + 0.5 + 0.25*x1], [], [], []]
&gt;&gt;&gt; def opts0(*args, **kwargs):
...     return {'points':[0.2*args[2] + 0.5 + 0.25*args[0]]}
&gt;&gt;&gt; integrate.nquad(func, [[0,1], [-1,1], [.13,.8], [-.15,1]],
...                 opts=[opts0,{},{},{}])
(1.5267454070738633, 2.9437360001402324e-14)

&gt;&gt;&gt; scale = .1
&gt;&gt;&gt; def func2(x0, x1, x2, x3, t0, t1):
...     return x0*x1*x3**2 + np.sin(x2) + 1 + (1 if x0+t1*x1-t0&gt;0 else 0)
&gt;&gt;&gt; def lim0(x1, x2, x3, t0, t1):
...     return [scale * (x1**2 + x2 + np.cos(x3)*t0*t1 + 1) - 1,
...             scale * (x1**2 + x2 + np.cos(x3)*t0*t1 + 1) + 1]
&gt;&gt;&gt; def lim1(x2, x3, t0, t1):
...     return [scale * (t0*x2 + t1*x3) - 1,
...             scale * (t0*x2 + t1*x3) + 1]
&gt;&gt;&gt; def lim2(x3, t0, t1):
...     return [scale * (x3 + t0**2*t1**3) - 1,
...             scale * (x3 + t0**2*t1**3) + 1]
&gt;&gt;&gt; def lim3(t0, t1):
...     return [scale * (t0+t1) - 1, scale * (t0+t1) + 1]
&gt;&gt;&gt; def opts0(x1, x2, x3, t0, t1):
...     return {'points' : [t0 - t1*x1]}
&gt;&gt;&gt; def opts1(x2, x3, t0, t1):
...     return {}
&gt;&gt;&gt; def opts2(x3, t0, t1):
...     return {}
&gt;&gt;&gt; def opts3(t0, t1):
...     return {}
&gt;&gt;&gt; integrate.nquad(func2, [lim0, lim1, lim2, lim3], args=(0,0),
...                 opts=[opts0, opts1, opts2, opts3])
(25.066666666666666, 2.7829590483937256e-13)</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>The function to be integrated. Has arguments of ``x0, ... xn``,
``t0, tm``, where integration is carried out over ``x0, ... xn``, which
must be floats.  Function signature should be
``func(x0, x1, ..., xn, t0, t1, ..., tm)``.  Integration is carried out
in order.  That is, integration over ``x0`` is the innermost integral,
and ``xn`` is the outermost.
If performance is a concern, this function may be a ctypes function of
the form::

    f(int n, double args[n])

where ``n`` is the number of extra parameters and args is an array
of doubles of the additional parameters.  This function may then
be compiled to a dynamic/shared library then imported through
``ctypes``, setting the function's argtypes to ``(c_int, c_double)``,
and the function's restype to ``(c_double)``.  Its pointer may then be
passed into `nquad` normally.
This allows the underlying Fortran library to evaluate the function in
the innermost integration calls without callbacks to Python, and also
speeds up the evaluation of the function itself.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ranges" name="ranges" port_type="basic:List" show_port="True">
      <docstring>Each element of ranges may be either a sequence  of 2 numbers, or else
a callable that returns such a sequence.  ``ranges[0]`` corresponds to
integration over x0, and so on.  If an element of ranges is a callable,
then it will be called with all of the integration arguments available.
e.g. if ``func = f(x0, x1, x2)``, then ``ranges[0]`` may be defined as
either ``(a, b)`` or else as ``(a, b) = range0(x1, x2)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Additional arguments ``t0, ..., tn``, required by `func`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="opts" name="opts" port_type="basic:Dictionary">
      <docstring>Options to be passed to `quad`.  May be empty, a dict, or
a sequence of dicts or functions that return a dict.  If empty, the
default options from scipy.integrate.quadare used.  If a dict, the same
options are used for all levels of integraion.  If a sequence, then each
element of the sequence corresponds to a particular integration. e.g.
opts[0] corresponds to integration over x0, and so on. The available
options together with their default values are:

  - epsabs = 1.49e-08
  - epsrel = 1.49e-08
  - limit  = 50
  - points = None
  - weight = None
  - wvar   = None
  - wopts  = None

The ``full_output`` option from `quad` is unavailable, due to the
complexity of handling the large amount of data such an option would
return for this kind of nested integration.  For more information on
these options, see `quad` and `quad_explain`.</docstring>
      <alternateSpec arg="opts" name="optsSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The result of the integration.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="abserr" name="abserr" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The maximum of the estimates of the absolute error in the various
integration results.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.odeint" module_name="odeint" namespace="'integrate'" output_type="list">
    <docstring>Integrate a system of ordinary differential equations.

Solve a system of ordinary differential equations using lsoda from the
FORTRAN library odepack.

Solves the initial value problem for stiff or non-stiff systems
of first order ode-s::

    dy/dt = func(y,t0,...)

where y can be a vector.

Parameters
----------
func : callable(y, t0, ...)
    Computes the derivative of y at t0.
y0 : array
    Initial condition on y (can be a vector).
t : array
    A sequence of time points for which to solve for y.  The initial
    value point should be the first element of this sequence.
args : tuple, optional
    Extra arguments to pass to function.
Dfun : callable(y, t0, ...)
    Gradient (Jacobian) of `func`.
col_deriv : bool, optional
    True if `Dfun` defines derivatives down columns (faster),
    otherwise `Dfun` should define derivatives across rows.
full_output : bool, optional
    True if to return a dictionary of optional outputs as the second output
printmessg : bool, optional
    Whether to print the convergence message

Returns
-------
y : array, shape (len(t), len(y0))
    Array containing the value of y for each desired time in t,
    with the initial value `y0` in the first row.
infodict : dict, only returned if full_output == True
    Dictionary containing additional output information

    =======  ============================================================
    key      meaning
    =======  ============================================================
    'hu'     vector of step sizes successfully used for each time step.
    'tcur'   vector with the value of t reached for each time step.
             (will always be at least as large as the input times).
    'tolsf'  vector of tolerance scale factors, greater than 1.0,
             computed when a request for too much accuracy was detected.
    'tsw'    value of t at the time of the last method switch
             (given for each time step)
    'nst'    cumulative number of time steps
    'nfe'    cumulative number of function evaluations for each time step
    'nje'    cumulative number of jacobian evaluations for each time step
    'nqu'    a vector of method orders for each successful step.
    'imxer'  index of the component of largest magnitude in the
             weighted local error vector (e / ewt) on an error return, -1
             otherwise.
    'lenrw'  the length of the double work array required.
    'leniw'  the length of integer work array required.
    'mused'  a vector of method indicators for each successful time step:
             1: adams (nonstiff), 2: bdf (stiff)
    =======  ============================================================

Other Parameters
----------------
ml, mu : int, optional
    If either of these are not None or non-negative, then the
    Jacobian is assumed to be banded.  These give the number of
    lower and upper non-zero diagonals in this banded matrix.
    For the banded case, `Dfun` should return a matrix whose
    rows contain the non-zero bands (starting with the lowest diagonal).
    Thus, the return matrix `jac` from `Dfun` should have shape
    ``(ml + mu + 1, len(y0))`` when ``ml &gt;=0`` or ``mu &gt;=0``.
    The data in `jac` must be stored such that ``jac[i - j + mu, j]``
    holds the derivative of the `i`th equation with respect to the `j`th
    state variable.  If `col_deriv` is True, the transpose of this
    `jac` must be returned.
rtol, atol : float, optional
    The input parameters `rtol` and `atol` determine the error
    control performed by the solver.  The solver will control the
    vector, e, of estimated local errors in y, according to an
    inequality of the form ``max-norm of (e / ewt) &lt;= 1``,
    where ewt is a vector of positive error weights computed as
    ``ewt = rtol * abs(y) + atol``.
    rtol and atol can be either vectors the same length as y or scalars.
    Defaults to 1.49012e-8.
tcrit : ndarray, optional
    Vector of critical points (e.g. singularities) where integration
    care should be taken.
h0 : float, (0: solver-determined), optional
    The step size to be attempted on the first step.
hmax : float, (0: solver-determined), optional
    The maximum absolute step size allowed.
hmin : float, (0: solver-determined), optional
    The minimum absolute step size allowed.
ixpr : bool, optional
    Whether to generate extra printing at method switches.
mxstep : int, (0: solver-determined), optional
    Maximum number of (internally defined) steps allowed for each
    integration point in t.
mxhnil : int, (0: solver-determined), optional
    Maximum number of messages printed.
mxordn : int, (0: solver-determined), optional
    Maximum order to be allowed for the non-stiff (Adams) method.
mxords : int, (0: solver-determined), optional
    Maximum order to be allowed for the stiff (BDF) method.

See Also
--------
ode : a more object-oriented integrator based on VODE.
quad : for finding the area under a curve.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Computes the derivative of y at t0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y0" name="y0" port_type="basic:List" show_port="True">
      <docstring>Initial condition on y (can be a vector).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:List" show_port="True">
      <docstring>A sequence of time points for which to solve for y.  The initial
value point should be the first element of this sequence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Dfun" name="Dfun" port_type="basic:Variant" show_port="True">
      <docstring>Gradient (Jacobian) of `func`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="col_deriv" name="col_derivScalar" port_type="basic:Integer">
      <docstring>True if `Dfun` defines derivatives down columns (faster),
otherwise `Dfun` should define derivatives across rows.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="col_deriv" name="col_derivBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>True if to return a dictionary of optional outputs as the second output</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="printmessg" name="printmessgScalar" port_type="basic:Integer">
      <docstring>Whether to print the convergence message</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="printmessg" name="printmessgBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="ml" name="ml" port_type="basic:Integer">
      <docstring>If either of these are not None or non-negative, then the
Jacobian is assumed to be banded.  These give the number of
lower and upper non-zero diagonals in this banded matrix.
For the banded case, `Dfun` should return a matrix whose
rows contain the non-zero bands (starting with the lowest diagonal).
Thus, the return matrix `jac` from `Dfun` should have shape
``(ml + mu + 1, len(y0))`` when ``ml &gt;=0`` or ``mu &gt;=0``.
The data in `jac` must be stored such that ``jac[i - j + mu, j]``
holds the derivative of the `i`th equation with respect to the `j`th
state variable.  If `col_deriv` is True, the transpose of this
`jac` must be returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Integer">
      <docstring>If either of these are not None or non-negative, then the
Jacobian is assumed to be banded.  These give the number of
lower and upper non-zero diagonals in this banded matrix.
For the banded case, `Dfun` should return a matrix whose
rows contain the non-zero bands (starting with the lowest diagonal).
Thus, the return matrix `jac` from `Dfun` should have shape
``(ml + mu + 1, len(y0))`` when ``ml &gt;=0`` or ``mu &gt;=0``.
The data in `jac` must be stored such that ``jac[i - j + mu, j]``
holds the derivative of the `i`th equation with respect to the `j`th
state variable.  If `col_deriv` is True, the transpose of this
`jac` must be returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The input parameters `rtol` and `atol` determine the error
control performed by the solver.  The solver will control the
vector, e, of estimated local errors in y, according to an
inequality of the form ``max-norm of (e / ewt) &lt;= 1``,
where ewt is a vector of positive error weights computed as
``ewt = rtol * abs(y) + atol``.
rtol and atol can be either vectors the same length as y or scalars.
Defaults to 1.49012e-8.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>The input parameters `rtol` and `atol` determine the error
control performed by the solver.  The solver will control the
vector, e, of estimated local errors in y, according to an
inequality of the form ``max-norm of (e / ewt) &lt;= 1``,
where ewt is a vector of positive error weights computed as
``ewt = rtol * abs(y) + atol``.
rtol and atol can be either vectors the same length as y or scalars.
Defaults to 1.49012e-8.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tcrit" name="tcrit" port_type="basic:List">
      <docstring>Vector of critical points (e.g. singularities) where integration
care should be taken.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="h0" name="h0" port_type="basic:Float">
      <docstring>The step size to be attempted on the first step.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hmax" name="hmax" port_type="basic:Float">
      <docstring>The maximum absolute step size allowed.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hmin" name="hmin" port_type="basic:Float">
      <docstring>The minimum absolute step size allowed.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ixpr" name="ixprScalar" port_type="basic:Integer">
      <docstring>Whether to generate extra printing at method switches.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="ixpr" name="ixprBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="mxstep" name="mxstep" port_type="basic:Integer">
      <docstring>Maximum number of (internally defined) steps allowed for each
integration point in t.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mxhnil" name="mxhnil" port_type="basic:Integer">
      <docstring>Maximum number of messages printed.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mxordn" name="mxordn" port_type="basic:Integer">
      <docstring>Maximum order to be allowed for the non-stiff (Adams) method.</docstring>
      <defaults>[12]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mxords" name="mxords" port_type="basic:Integer">
      <docstring>Maximum order to be allowed for the stiff (BDF) method.</docstring>
      <defaults>[5]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array containing the value of y for each desired time in t,
with the initial value `y0` in the first row.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="infodict" name="infodict" port_type="basic:Dictionary" show_port="True" sort_key="1">
      <docstring>Dictionary containing additional output information

=======  ============================================================
key      meaning
=======  ============================================================
'hu'     vector of step sizes successfully used for each time step.
'tcur'   vector with the value of t reached for each time step.
         (will always be at least as large as the input times).
'tolsf'  vector of tolerance scale factors, greater than 1.0,
         computed when a request for too much accuracy was detected.
'tsw'    value of t at the time of the last method switch
         (given for each time step)
'nst'    cumulative number of time steps
'nfe'    cumulative number of function evaluations for each time step
'nje'    cumulative number of jacobian evaluations for each time step
'nqu'    a vector of method orders for each successful step.
'imxer'  index of the component of largest magnitude in the
         weighted local error vector (e / ewt) on an error return, -1
         otherwise.
'lenrw'  the length of the double work array required.
'leniw'  the length of integer work array required.
'mused'  a vector of method indicators for each successful time step:
         1: adams (nonstiff), 2: bdf (stiff)
=======  ============================================================</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.quad" module_name="quad" namespace="'integrate'" output_type="list">
    <docstring>Compute a definite integral.

Integrate func from `a` to `b` (possibly infinite interval) using a
technique from the Fortran library QUADPACK.

Parameters
----------
func : function
    A Python function or method to integrate.  If `func` takes many
    arguments, it is integrated along the axis corresponding to the
    first argument.
    If the user desires improved integration performance, then f may
    instead be a ``ctypes`` function of the form:

        f(int n, double args[n]),

    where ``args`` is an array of function arguments and ``n`` is the
    length of ``args``. ``f.argtypes`` should be set to
    ``(c_int, c_double)``, and ``f.restype`` should be ``(c_double,)``.
a : float
    Lower limit of integration (use -numpy.inf for -infinity).
b : float
    Upper limit of integration (use numpy.inf for +infinity).
args : tuple, optional
    Extra arguments to pass to `func`.
full_output : int, optional
    Non-zero to return a dictionary of integration information.
    If non-zero, warning messages are also suppressed and the
    message is appended to the output tuple.

Returns
-------
y : float
    The integral of func from `a` to `b`.
abserr : float
    An estimate of the absolute error in the result.
infodict : dict
    A dictionary containing additional information.
    Run scipy.integrate.quad_explain() for more information.
message :
    A convergence message.
explain :
    Appended only with 'cos' or 'sin' weighting and infinite
    integration limits, it contains an explanation of the codes in
    infodict['ierlst']

Other Parameters
----------------
epsabs : float or int, optional
    Absolute error tolerance.
epsrel : float or int, optional
    Relative error tolerance.
limit : float or int, optional
    An upper bound on the number of subintervals used in the adaptive
    algorithm.
points : (sequence of floats,ints), optional
    A sequence of break points in the bounded integration interval
    where local difficulties of the integrand may occur (e.g.,
    singularities, discontinuities). The sequence does not have
    to be sorted.
weight : float or int, optional
    String indicating weighting function. Full explanation for this
    and the remaining arguments can be found below.
wvar : optional
    Variables for use with weighting functions.
wopts : optional
    Optional input for reusing Chebyshev moments.
maxp1 : float or int, optional
    An upper bound on the number of Chebyshev moments.
limlst : int, optional
    Upper bound on the number of cycles (&gt;=3) for use with a sinusoidal
    weighting and an infinite end-point.

See Also
--------
dblquad : double integral
tplquad : triple integral
nquad : n-dimensional integrals (uses `quad` recursively)
fixed_quad : fixed-order Gaussian quadrature
quadrature : adaptive Gaussian quadrature
odeint : ODE integrator
ode : ODE integrator
simps : integrator for sampled data
romb : integrator for sampled data
scipy.special : for coefficients and roots of orthogonal polynomials

Notes
-----

**Extra information for quad() inputs and outputs**

If full_output is non-zero, then the third output argument
(infodict) is a dictionary with entries as tabulated below.  For
infinite limits, the range is transformed to (0,1) and the
optional outputs are given with respect to this transformed range.
Let M be the input argument limit and let K be infodict['last'].
The entries are:

'neval'
    The number of function evaluations.
'last'
    The number, K, of subintervals produced in the subdivision process.
'alist'
    A rank-1 array of length M, the first K elements of which are the
    left end points of the subintervals in the partition of the
    integration range.
'blist'
    A rank-1 array of length M, the first K elements of which are the
    right end points of the subintervals.
'rlist'
    A rank-1 array of length M, the first K elements of which are the
    integral approximations on the subintervals.
'elist'
    A rank-1 array of length M, the first K elements of which are the
    moduli of the absolute error estimates on the subintervals.
'iord'
    A rank-1 integer array of length M, the first L elements of
    which are pointers to the error estimates over the subintervals
    with ``L=K`` if ``K&lt;=M/2+2`` or ``L=M+1-K`` otherwise. Let I be the
    sequence ``infodict['iord']`` and let E be the sequence
    ``infodict['elist']``.  Then ``E[I[1]], ..., E[I[L]]`` forms a
    decreasing sequence.

If the input argument points is provided (i.e. it is not None),
the following additional outputs are placed in the output
dictionary.  Assume the points sequence is of length P.

'pts'
    A rank-1 array of length P+2 containing the integration limits
    and the break points of the intervals in ascending order.
    This is an array giving the subintervals over which integration
    will occur.
'level'
    A rank-1 integer array of length M (=limit), containing the
    subdivision levels of the subintervals, i.e., if (aa,bb) is a
    subinterval of ``(pts[1], pts[2])`` where ``pts[0]`` and ``pts[2]``
    are adjacent elements of ``infodict['pts']``, then (aa,bb) has level l
    if ``|bb-aa| = |pts[2]-pts[1]| * 2**(-l)``.
'ndin'
    A rank-1 integer array of length P+2.  After the first integration
    over the intervals (pts[1], pts[2]), the error estimates over some
    of the intervals may have been increased artificially in order to
    put their subdivision forward.  This array has ones in slots
    corresponding to the subintervals for which this happens.

**Weighting the integrand**

The input variables, *weight* and *wvar*, are used to weight the
integrand by a select list of functions.  Different integration
methods are used to compute the integral with these weighting
functions.  The possible values of weight and the corresponding
weighting functions are.

==========  ===================================   =====================
``weight``  Weight function used                  ``wvar``
==========  ===================================   =====================
'cos'       cos(w*x)                              wvar = w
'sin'       sin(w*x)                              wvar = w
'alg'       g(x) = ((x-a)**alpha)*((b-x)**beta)   wvar = (alpha, beta)
'alg-loga'  g(x)*log(x-a)                         wvar = (alpha, beta)
'alg-logb'  g(x)*log(b-x)                         wvar = (alpha, beta)
'alg-log'   g(x)*log(x-a)*log(b-x)                wvar = (alpha, beta)
'cauchy'    1/(x-c)                               wvar = c
==========  ===================================   =====================

wvar holds the parameter w, (alpha, beta), or c depending on the weight
selected.  In these expressions, a and b are the integration limits.

For the 'cos' and 'sin' weighting, additional inputs and outputs are
available.

For finite integration limits, the integration is performed using a
Clenshaw-Curtis method which uses Chebyshev moments.  For repeated
calculations, these moments are saved in the output dictionary:

'momcom'
    The maximum level of Chebyshev moments that have been computed,
    i.e., if ``M_c`` is ``infodict['momcom']`` then the moments have been
    computed for intervals of length ``|b-a| * 2**(-l)``,
    ``l=0,1,...,M_c``.
'nnlog'
    A rank-1 integer array of length M(=limit), containing the
    subdivision levels of the subintervals, i.e., an element of this
    array is equal to l if the corresponding subinterval is
    ``|b-a|* 2**(-l)``.
'chebmo'
    A rank-2 array of shape (25, maxp1) containing the computed
    Chebyshev moments.  These can be passed on to an integration
    over the same interval by passing this array as the second
    element of the sequence wopts and passing infodict['momcom'] as
    the first element.

If one of the integration limits is infinite, then a Fourier integral is
computed (assuming w neq 0).  If full_output is 1 and a numerical error
is encountered, besides the error message attached to the output tuple,
a dictionary is also appended to the output tuple which translates the
error codes in the array ``info['ierlst']`` to English messages.  The
output information dictionary contains the following entries instead of
'last', 'alist', 'blist', 'rlist', and 'elist':

'lst'
    The number of subintervals needed for the integration (call it ``K_f``).
'rslst'
    A rank-1 array of length M_f=limlst, whose first ``K_f`` elements
    contain the integral contribution over the interval
    ``(a+(k-1)c, a+kc)`` where ``c = (2*floor(|w|) + 1) * pi / |w|``
    and ``k=1,2,...,K_f``.
'erlst'
    A rank-1 array of length ``M_f`` containing the error estimate
    corresponding to the interval in the same position in
    ``infodict['rslist']``.
'ierlst'
    A rank-1 integer array of length ``M_f`` containing an error flag
    corresponding to the interval in the same position in
    ``infodict['rslist']``.  See the explanation dictionary (last entry
    in the output tuple) for the meaning of the codes.

Examples
--------
Calculate :math:`\int^4_0 x^2 dx` and compare with an analytic result

&gt;&gt;&gt; from scipy import integrate
&gt;&gt;&gt; x2 = lambda x: x**2
&gt;&gt;&gt; integrate.quad(x2, 0, 4)
(21.333333333333332, 2.3684757858670003e-13)
&gt;&gt;&gt; print(4**3 / 3.)  # analytical result
21.3333333333

Calculate :math:`\int^\infty_0 e^{-x} dx`

&gt;&gt;&gt; invexp = lambda x: np.exp(-x)
&gt;&gt;&gt; integrate.quad(invexp, 0, np.inf)
(1.0, 5.842605999138044e-11)

&gt;&gt;&gt; f = lambda x,a : a*x
&gt;&gt;&gt; y, err = integrate.quad(f, 0, 1, args=(1,))
&gt;&gt;&gt; y
0.5
&gt;&gt;&gt; y, err = integrate.quad(f, 0, 1, args=(3,))
&gt;&gt;&gt; y
1.5

Calculate :math:`\int^1_0 x^2 + y^2 dx` with ctypes, holding
y parameter as 1::

    testlib.c =&gt;
        double func(int n, double args[n]){
            return args[0]*args[0] + args[1]*args[1];}
    compile to library testlib.*

&gt;&gt;&gt; from scipy import integrate
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; lib = ctypes.CDLL('/home/.../testlib.*') #use absolute path
&gt;&gt;&gt; lib.func.restype = ctypes.c_double
&gt;&gt;&gt; lib.func.argtypes = (ctypes.c_int,ctypes.c_double)
&gt;&gt;&gt; integrate.quad(lib.func,0,1,(1))
(1.3333333333333333, 1.4802973661668752e-14)
&gt;&gt;&gt; print((1.0**3/3.0 + 1.0) - (0.0**3/3.0 + 0.0)) #Analytic result
1.3333333333333333</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>A Python function or method to integrate.  If `func` takes many
arguments, it is integrated along the axis corresponding to the
first argument.
If the user desires improved integration performance, then f may
instead be a ``ctypes`` function of the form:

    f(int n, double args[n]),

where ``args`` is an array of function arguments and ``n`` is the
length of ``args``. ``f.argtypes`` should be set to
``(c_int, c_double)``, and ``f.restype`` should be ``(c_double,)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Lower limit of integration (use -numpy.inf for -infinity).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Upper limit of integration (use numpy.inf for +infinity).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to `func`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Integer">
      <docstring>Non-zero to return a dictionary of integration information.
If non-zero, warning messages are also suppressed and the
message is appended to the output tuple.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsabs" name="epsabs" port_type="basic:Float">
      <docstring>Absolute error tolerance.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsrel" name="epsrel" port_type="basic:Float">
      <docstring>Relative error tolerance.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="limit" name="limit" port_type="basic:Float">
      <docstring>An upper bound on the number of subintervals used in the adaptive
algorithm.</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" name="points" port_type="basic:Integer">
      <docstring>A sequence of break points in the bounded integration interval
where local difficulties of the integrand may occur (e.g.,
singularities, discontinuities). The sequence does not have
to be sorted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weight" name="weight" port_type="basic:Float">
      <docstring>String indicating weighting function. Full explanation for this
and the remaining arguments can be found below.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="wvar" name="wvar" port_type="basic:Variant">
      <docstring>Variables for use with weighting functions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="wopts" name="wopts" port_type="basic:Variant">
      <docstring>Optional input for reusing Chebyshev moments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxp1" name="maxp1" port_type="basic:Float">
      <docstring>An upper bound on the number of Chebyshev moments.</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="limlst" name="limlst" port_type="basic:Integer">
      <docstring>Upper bound on the number of cycles (&gt;=3) for use with a sinusoidal
weighting and an infinite end-point.</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The integral of func from `a` to `b`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="abserr" name="abserr" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>An estimate of the absolute error in the result.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="infodict" name="infodict" port_type="basic:Dictionary" show_port="True" sort_key="2">
      <docstring>A dictionary containing additional information.
Run scipy.integrate.quad_explain() for more information.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3">
      <docstring>A convergence message.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="4">
      <docstring>Appended only with 'cos' or 'sin' weighting and infinite
integration limits, it contains an explanation of the codes in
infodict['ierlst']</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.quad_explain" module_name="quad_explain" namespace="'integrate'">
    <docstring>Print extra information about integrate.quad() parameters and returns.

Parameters
----------
output : instance with "write" method, optional
    Information about `quad` is passed to ``output.write()``.
    Default is ``sys.stdout``.

Returns
-------
None</docstring>
    <inputPortSpec arg="output" name="output" port_type="basic:Variant">
      <docstring>Information about `quad` is passed to ``output.write()``.
Default is ``sys.stdout``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.quadrature" module_name="quadrature" namespace="'integrate'" output_type="list">
    <docstring>Compute a definite integral using fixed-tolerance Gaussian quadrature.

Integrate `func` from `a` to `b` using Gaussian quadrature
with absolute tolerance `tol`.

Parameters
----------
func : function
    A Python function or method to integrate.
a : float
    Lower limit of integration.
b : float
    Upper limit of integration.
args : tuple, optional
    Extra arguments to pass to function.
tol, rtol : float, optional
    Iteration stops when error between last two iterates is less than
    `tol` OR the relative change is less than `rtol`.
maxiter : int, optional
    Maximum order of Gaussian quadrature.
vec_func : bool, optional
    True or False if func handles arrays as arguments (is
    a "vector" function). Default is True.
miniter : int, optional
    Minimum order of Gaussian quadrature.

Returns
-------
val : float
    Gaussian quadrature approximation (within tolerance) to integral.
err : float
    Difference between last two estimates of the integral.

See also
--------
romberg: adaptive Romberg quadrature
fixed_quad: fixed-order Gaussian quadrature
quad: adaptive quadrature using QUADPACK
dblquad: double integrals
tplquad: triple integrals
romb: integrator for sampled data
simps: integrator for sampled data
cumtrapz: cumulative integration for sampled data
ode: ODE integrator
odeint: ODE integrator</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>A Python function or method to integrate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Lower limit of integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Upper limit of integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Iteration stops when error between last two iterates is less than
`tol` OR the relative change is less than `rtol`.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>Iteration stops when error between last two iterates is less than
`tol` OR the relative change is less than `rtol`.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum order of Gaussian quadrature.</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vec_func" name="vec_func" port_type="basic:Boolean">
      <docstring>True or False if func handles arrays as arguments (is
a "vector" function). Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="miniter" name="miniter" port_type="basic:Integer">
      <docstring>Minimum order of Gaussian quadrature.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="val" name="val" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Gaussian quadrature approximation (within tolerance) to integral.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="err" name="err" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Difference between last two estimates of the integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.romb" module_name="romb" namespace="'integrate'">
    <docstring>Romberg integration using samples of a function.

Parameters
----------
y : array_like
    A vector of ``2**k + 1`` equally-spaced samples of a function.
dx : float, optional
    The sample spacing. Default is 1.
axis : int, optional
    The axis along which to integrate. Default is -1 (last axis).
show : bool, optional
    When `y` is a single 1-D array, then if this argument is True
    print the table showing Richardson extrapolation from the
    samples. Default is False.

Returns
-------
romb : ndarray
    The integrated result for `axis`.

See also
--------
quad : adaptive quadrature using QUADPACK
romberg : adaptive Romberg quadrature
quadrature : adaptive Gaussian quadrature
fixed_quad : fixed-order Gaussian quadrature
dblquad : double integrals
tplquad : triple integrals
simps : integrators for sampled data
cumtrapz : cumulative integration for sampled data
ode : ODE integrators
odeint : ODE integrators</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>A vector of ``2**k + 1`` equally-spaced samples of a function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <docstring>The sample spacing. Default is 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which to integrate. Default is -1 (last axis).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="show" name="show" port_type="basic:Boolean">
      <docstring>When `y` is a single 1-D array, then if this argument is True
print the table showing Richardson extrapolation from the
samples. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="romb" name="romb" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The integrated result for `axis`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.romberg" module_name="romberg" namespace="'integrate'">
    <docstring>Romberg integration of a callable function or method.

Returns the integral of `function` (a function of one variable)
over the interval (`a`, `b`).

If `show` is 1, the triangular array of the intermediate results
will be printed.  If `vec_func` is True (default is False), then
`function` is assumed to support vector arguments.

Parameters
----------
function : callable
    Function to be integrated.
a : float
    Lower limit of integration.
b : float
    Upper limit of integration.

Returns
-------
results  : float
    Result of the integration.

Other Parameters
----------------
args : tuple, optional
    Extra arguments to pass to function. Each element of `args` will
    be passed as a single argument to `func`. Default is to pass no
    extra arguments.
tol, rtol : float, optional
    The desired absolute and relative tolerances. Defaults are 1.48e-8.
show : bool, optional
    Whether to print the results. Default is False.
divmax : int, optional
    Maximum order of extrapolation. Default is 10.
vec_func : bool, optional
    Whether `func` handles arrays as arguments (i.e whether it is a
    "vector" function). Default is False.

See Also
--------
fixed_quad : Fixed-order Gaussian quadrature.
quad : Adaptive quadrature using QUADPACK.
dblquad : Double integrals.
tplquad : Triple integrals.
romb : Integrators for sampled data.
simps : Integrators for sampled data.
cumtrapz : Cumulative integration for sampled data.
ode : ODE integrator.
odeint : ODE integrator.

References
----------
.. [1] 'Romberg's method' http://en.wikipedia.org/wiki/Romberg%27s_method

Examples
--------
Integrate a gaussian from 0 to 1 and compare to the error function.

&gt;&gt;&gt; from scipy import integrate
&gt;&gt;&gt; from scipy.special import erf
&gt;&gt;&gt; gaussian = lambda x: 1/np.sqrt(np.pi) * np.exp(-x**2)
&gt;&gt;&gt; result = integrate.romberg(gaussian, 0, 1, show=True)
Romberg integration of &lt;function vfunc at ...&gt; from [0, 1]

::

   Steps  StepSize  Results
       1  1.000000  0.385872
       2  0.500000  0.412631  0.421551
       4  0.250000  0.419184  0.421368  0.421356
       8  0.125000  0.420810  0.421352  0.421350  0.421350
      16  0.062500  0.421215  0.421350  0.421350  0.421350  0.421350
      32  0.031250  0.421317  0.421350  0.421350  0.421350  0.421350  0.421350

The final result is 0.421350396475 after 33 function evaluations.

&gt;&gt;&gt; print("%g %g" % (2*result, erf(1)))
0.842701 0.842701</docstring>
    <inputPortSpec arg="function" name="function" port_type="basic:Variant" show_port="True">
      <docstring>Function to be integrated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Lower limit of integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>Upper limit of integration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to function. Each element of `args` will
be passed as a single argument to `func`. Default is to pass no
extra arguments.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>The desired absolute and relative tolerances. Defaults are 1.48e-8.</docstring>
      <defaults>[1.48e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The desired absolute and relative tolerances. Defaults are 1.48e-8.</docstring>
      <defaults>[1.48e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="show" name="show" port_type="basic:Boolean">
      <docstring>Whether to print the results. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="divmax" name="divmax" port_type="basic:Integer">
      <docstring>Maximum order of extrapolation. Default is 10.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vec_func" name="vec_func" port_type="basic:Boolean">
      <docstring>Whether `func` handles arrays as arguments (i.e whether it is a
"vector" function). Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="results" name="results" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Result of the integration.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.simps" module_name="simps" namespace="'integrate'">
    <docstring>Integrate y(x) using samples along the given axis and the composite
Simpson's rule.  If x is None, spacing of dx is assumed.

If there are an even number of samples, N, then there are an odd
number of intervals (N-1), but Simpson's rule requires an even number
of intervals.  The parameter 'even' controls how this is handled.

Parameters
----------
y : array_like
    Array to be integrated.
x : array_like, optional
    If given, the points at which `y` is sampled.
dx : int, optional
    Spacing of integration points along axis of `y`. Only used when
    `x` is None. Default is 1.
axis : int, optional
    Axis along which to integrate. Default is the last axis.
even : {'avg', 'first', 'str'}, optional
    'avg' : Average two results:1) use the first N-2 intervals with
              a trapezoidal rule on the last interval and 2) use the last
              N-2 intervals with a trapezoidal rule on the first interval.

    'first' : Use Simpson's rule for the first N-2 intervals with
            a trapezoidal rule on the last interval.

    'last' : Use Simpson's rule for the last N-2 intervals with a
           trapezoidal rule on the first interval.

See Also
--------
quad: adaptive quadrature using QUADPACK
romberg: adaptive Romberg quadrature
quadrature: adaptive Gaussian quadrature
fixed_quad: fixed-order Gaussian quadrature
dblquad: double integrals
tplquad: triple integrals
romb: integrators for sampled data
cumtrapz: cumulative integration for sampled data
ode: ODE integrators
odeint: ODE integrators

Notes
-----
For an odd number of samples that are equally spaced the result is
exact if the function is a polynomial of order 3 or less.  If
the samples are not equally spaced, then the result is exact only
if the function is a polynomial of order 2 or less.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Array to be integrated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>If given, the points at which `y` is sampled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Integer">
      <docstring>Spacing of integration points along axis of `y`. Only used when
`x` is None. Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to integrate. Default is the last axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="even" name="even">
      <docstring>'avg' : Average two results:1) use the first N-2 intervals with
          a trapezoidal rule on the last interval and 2) use the last
          N-2 intervals with a trapezoidal rule on the first interval.

'first' : Use Simpson's rule for the first N-2 intervals with
        a trapezoidal rule on the last interval.

'last' : Use Simpson's rule for the last N-2 intervals with a
       trapezoidal rule on the first interval.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['avg', 'first']]</values>
      <defaults>['avg']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.tplquad" module_name="tplquad" namespace="'integrate'" output_type="list">
    <docstring>Compute a triple (definite) integral.

Return the triple integral of ``func(z, y, x)`` from ``x = a..b``,
``y = gfun(x)..hfun(x)``, and ``z = qfun(x,y)..rfun(x,y)``.

Parameters
----------
func : function
    A Python function or method of at least three variables in the
    order (z, y, x).
a, b : float
    The limits of integration in x: `a` &lt; `b`
gfun : function
    The lower boundary curve in y which is a function taking a single
    floating point argument (x) and returning a floating point result:
    a lambda function can be useful here.
hfun : function
    The upper boundary curve in y (same requirements as `gfun`).
qfun : function
    The lower boundary surface in z.  It must be a function that takes
    two floats in the order (x, y) and returns a float.
rfun : function
    The upper boundary surface in z. (Same requirements as `qfun`.)
args : tuple, optional
    Extra arguments to pass to `func`.
epsabs : float, optional
    Absolute tolerance passed directly to the innermost 1-D quadrature
    integration. Default is 1.49e-8.
epsrel : float, optional
    Relative tolerance of the innermost 1-D integrals. Default is 1.49e-8.

Returns
-------
y : float
    The resultant integral.
abserr : float
    An estimate of the error.

See Also
--------
quad: Adaptive quadrature using QUADPACK
quadrature: Adaptive Gaussian quadrature
fixed_quad: Fixed-order Gaussian quadrature
dblquad: Double integrals
nquad : N-dimensional integrals
romb: Integrators for sampled data
simps: Integrators for sampled data
ode: ODE integrators
odeint: ODE integrators
scipy.special: For coefficients and roots of orthogonal polynomials</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>A Python function or method of at least three variables in the
order (z, y, x).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>The limits of integration in x: `a` &lt; `b`</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>The limits of integration in x: `a` &lt; `b`</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gfun" name="gfun" port_type="basic:Variant" show_port="True">
      <docstring>The lower boundary curve in y which is a function taking a single
floating point argument (x) and returning a floating point result:
a lambda function can be useful here.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hfun" name="hfun" port_type="basic:Variant" show_port="True">
      <docstring>The upper boundary curve in y (same requirements as `gfun`).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="qfun" name="qfun" port_type="basic:Variant" show_port="True">
      <docstring>The lower boundary surface in z.  It must be a function that takes
two floats in the order (x, y) and returns a float.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rfun" name="rfun" port_type="basic:Variant" show_port="True">
      <docstring>The upper boundary surface in z. (Same requirements as `qfun`.)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to `func`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsabs" name="epsabs" port_type="basic:Float">
      <docstring>Absolute tolerance passed directly to the innermost 1-D quadrature
integration. Default is 1.49e-8.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsrel" name="epsrel" port_type="basic:Float">
      <docstring>Relative tolerance of the innermost 1-D integrals. Default is 1.49e-8.</docstring>
      <defaults>[1.49e-08]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The resultant integral.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="abserr" name="abserr" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>An estimate of the error.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.integrate.trapz" module_name="trapz" namespace="'integrate'">
    <docstring>Integrate along the given axis using the composite trapezoidal rule.

Integrate `y` (`x`) along given axis.

Parameters
----------
y : array_like
    Input array to integrate.
x : array_like, optional
    If `x` is None, then spacing between all `y` elements is `dx`.
dx : scalar, optional
    If `x` is None, spacing given by `dx` is assumed. Default is 1.
axis : int, optional
    Specify the axis.

Returns
-------
trapz : float
    Definite integral as approximated by trapezoidal rule.

See Also
--------
sum, cumsum

Notes
-----
Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
will be taken from `y` array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with `x` array
or with `dx` scalar.  Return value will be equal to combined area under
the red lines.


References
----------
.. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule

.. [2] Illustration image:
       http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

Examples
--------
&gt;&gt;&gt; np.trapz([1,2,3])
4.0
&gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])
8.0
&gt;&gt;&gt; np.trapz([1,2,3], dx=2)
8.0
&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.trapz(a, axis=0)
array([ 1.5,  2.5,  3.5])
&gt;&gt;&gt; np.trapz(a, axis=1)
array([ 2.,  8.])</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input array to integrate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>If `x` is None, then spacing between all `y` elements is `dx`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <docstring>If `x` is None, spacing given by `dx` is assumed. Default is 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Specify the axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trapz" name="trapz" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Definite integral as approximated by trapezoidal rule.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.approximate_taylor_polynomial" module_name="approximate_taylor_polynomial" namespace="'interpolate'">
    <docstring>Estimate the Taylor polynomial of f at x by polynomial fitting.

Parameters
----------
f : callable
    The function whose Taylor polynomial is sought. Should accept
    a vector of `x` values.
x : scalar
    The point at which the polynomial is to be evaluated.
degree : int
    The degree of the Taylor polynomial
scale : scalar
    The width of the interval to use to evaluate the Taylor polynomial.
    Function values spread over a range this wide are used to fit the
    polynomial. Must be chosen carefully.
order : int or None, optional
    The order of the polynomial to be used in the fitting; `f` will be
    evaluated ``order+1`` times. If None, use `degree`.

Returns
-------
p : poly1d instance
    The Taylor polynomial (translated to the origin, so that
    for example p(0)=f(x)).

Notes
-----
The appropriate choice of "scale" is a trade-off; too large and the
function differs from its Taylor polynomial too much to get a good
answer, too small and round-off errors overwhelm the higher-order terms.
The algorithm used becomes numerically unstable around order 30 even
under ideal circumstances.

Choosing order somewhat larger than degree may improve the higher-order
terms.</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>The function whose Taylor polynomial is sought. Should accept
a vector of `x` values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:Float" show_port="True">
      <docstring>The point at which the polynomial is to be evaluated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="degree" name="degree" port_type="basic:Integer" show_port="True">
      <docstring>The degree of the Taylor polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Float" show_port="True">
      <docstring>The width of the interval to use to evaluate the Taylor polynomial.
Function values spread over a range this wide are used to fit the
polynomial. Must be chosen carefully.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>The order of the polynomial to be used in the fitting; `f` will be
evaluated ``order+1`` times. If None, use `degree`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The Taylor polynomial (translated to the origin, so that
for example p(0)=f(x)).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.barycentric_interpolate" module_name="barycentric_interpolate" namespace="'interpolate'">
    <docstring>Convenience function for polynomial interpolation.

Constructs a polynomial that passes through a given set of points,
then evaluates the polynomial. For reasons of numerical stability,
this function does not compute the coefficients of the polynomial.

This function uses a "barycentric interpolation" method that treats
the problem as a special case of rational function interpolation.
This algorithm is quite stable, numerically, but even in a world of
exact computation, unless the `x` coordinates are chosen very
carefully - Chebyshev zeros (e.g. cos(i*pi/n)) are a good choice -
polynomial interpolation itself is a very ill-conditioned process
due to the Runge phenomenon.

Parameters
----------
xi : array_like
    1-d array of x coordinates of the points the polynomial should
    pass through
yi : array_like
    The y coordinates of the points the polynomial should pass through.
x : scalar or array_like
    Points to evaluate the interpolator at.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

Returns
-------
y : scalar or array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

See Also
--------
BarycentricInterpolator

Notes
-----
Construction of the interpolation weights is a relatively slow process.
If you want to call this many times with the same xi (but possibly
varying yi or x) you should use the class `BarycentricInterpolator`.
This is what this function uses internally.</docstring>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>1-d array of x coordinates of the points the polynomial should
pass through</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" name="yi" port_type="basic:List" show_port="True">
      <docstring>The y coordinates of the points the polynomial should pass through.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Float" show_port="True">
      <docstring>Points to evaluate the interpolator at.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis in the yi array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.bisplev" module_name="bisplev" namespace="'interpolate'">
    <docstring>Evaluate a bivariate B-spline and its derivatives.

Return a rank-2 array of spline function values (or spline derivative
values) at points given by the cross-product of the rank-1 arrays `x` and
`y`.  In special cases, return an array or just a float if either `x` or
`y` or both are floats.  Based on BISPEV from FITPACK.

Parameters
----------
x, y : ndarray
    Rank-1 arrays specifying the domain over which to evaluate the
    spline or its derivative.
tck : tuple
    A sequence of length 5 returned by `bisplrep` containing the knot
    locations, the coefficients, and the degree of the spline:
    [tx, ty, c, kx, ky].
dx, dy : int, optional
    The orders of the partial derivatives in `x` and `y` respectively.

Returns
-------
vals : ndarray
    The B-spline or its derivative evaluated over the set formed by
    the cross-product of `x` and `y`.

See Also
--------
splprep, splrep, splint, sproot, splev
UnivariateSpline, BivariateSpline

Notes
-----
    See `bisplrep` to generate the `tck` representation.

References
----------
.. [1] Dierckx P. : An algorithm for surface fitting
   with spline functions
   Ima J. Numer. Anal. 1 (1981) 267-283.
.. [2] Dierckx P. : An algorithm for surface fitting
   with spline functions
   report tw50, Dept. Computer Science,K.U.Leuven, 1980.
.. [3] Dierckx P. : Curve and surface fitting with splines,
   Monographs on Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Rank-1 arrays specifying the domain over which to evaluate the
spline or its derivative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Rank-1 arrays specifying the domain over which to evaluate the
spline or its derivative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>A sequence of length 5 returned by `bisplrep` containing the knot
locations, the coefficients, and the degree of the spline:
[tx, ty, c, kx, ky].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Integer">
      <docstring>The orders of the partial derivatives in `x` and `y` respectively.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dy" name="dy" port_type="basic:Integer">
      <docstring>The orders of the partial derivatives in `x` and `y` respectively.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="vals" name="vals" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The B-spline or its derivative evaluated over the set formed by
the cross-product of `x` and `y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.bisplrep" module_name="bisplrep" namespace="'interpolate'" output_type="list">
    <docstring>Find a bivariate B-spline representation of a surface.

Given a set of data points (x[i], y[i], z[i]) representing a surface
z=f(x,y), compute a B-spline representation of the surface. Based on
the routine SURFIT from FITPACK.

Parameters
----------
x, y, z : ndarray
    Rank-1 arrays of data points.
w : ndarray, optional
    Rank-1 array of weights. By default ``w=np.ones(len(x))``.
xb, xe : float, optional
    End points of approximation interval in `x`.
    By default ``xb = x.min(), xe=x.max()``.
yb, ye : float, optional
    End points of approximation interval in `y`.
    By default ``yb=y.min(), ye = y.max()``.
kx, ky : int, optional
    The degrees of the spline (1 &lt;= kx, ky &lt;= 5).
    Third order (kx=ky=3) is recommended.
task : int, optional
    If task=0, find knots in x and y and coefficients for a given
    smoothing factor, s.
    If task=1, find knots and coefficients for another value of the
    smoothing factor, s.  bisplrep must have been previously called
    with task=0 or task=1.
    If task=-1, find coefficients for a given set of knots tx, ty.
s : float, optional
    A non-negative smoothing factor.  If weights correspond
    to the inverse of the standard-deviation of the errors in z,
    then a good s-value should be found in the range
    ``(m-sqrt(2*m),m+sqrt(2*m))`` where m=len(x).
eps : float, optional
    A threshold for determining the effective rank of an
    over-determined linear system of equations (0 &lt; eps &lt; 1).
    `eps` is not likely to need changing.
tx, ty : ndarray, optional
    Rank-1 arrays of the knots of the spline for task=-1
full_output : int, optional
    Non-zero to return optional outputs.
nxest, nyest : int, optional
    Over-estimates of the total number of knots. If None then
    ``nxest = max(kx+sqrt(m/2),2*kx+3)``,
    ``nyest = max(ky+sqrt(m/2),2*ky+3)``.
quiet : int, optional
    Non-zero to suppress printing of messages.
    This parameter is deprecated; use standard Python warning filters
    instead.

Returns
-------
tck : array_like
    A list [tx, ty, c, kx, ky] containing the knots (tx, ty) and
    coefficients (c) of the bivariate B-spline representation of the
    surface along with the degree of the spline.
fp : ndarray
    The weighted sum of squared residuals of the spline approximation.
ier : int
    An integer flag about splrep success.  Success is indicated if
    ier&lt;=0. If ier in [1,2,3] an error occurred but was not raised.
    Otherwise an error is raised.
msg : str
    A message corresponding to the integer flag, ier.

See Also
--------
splprep, splrep, splint, sproot, splev
UnivariateSpline, BivariateSpline

Notes
-----
See `bisplev` to evaluate the value of the B-spline given its tck
representation.

References
----------
.. [1] Dierckx P.:An algorithm for surface fitting with spline functions
   Ima J. Numer. Anal. 1 (1981) 267-283.
.. [2] Dierckx P.:An algorithm for surface fitting with spline functions
   report tw50, Dept. Computer Science,K.U.Leuven, 1980.
.. [3] Dierckx P.:Curve and surface fitting with splines, Monographs on
   Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Rank-1 arrays of data points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Rank-1 arrays of data points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Rank-1 arrays of data points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Rank-1 array of weights. By default ``w=np.ones(len(x))``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xb" name="xb" port_type="basic:Float">
      <docstring>End points of approximation interval in `x`.
By default ``xb = x.min(), xe=x.max()``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xe" name="xe" port_type="basic:Float">
      <docstring>End points of approximation interval in `x`.
By default ``xb = x.min(), xe=x.max()``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yb" name="yb" port_type="basic:Float">
      <docstring>End points of approximation interval in `y`.
By default ``yb=y.min(), ye = y.max()``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ye" name="ye" port_type="basic:Float">
      <docstring>End points of approximation interval in `y`.
By default ``yb=y.min(), ye = y.max()``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kx" name="kx" port_type="basic:Integer">
      <docstring>The degrees of the spline (1 &lt;= kx, ky &lt;= 5).
Third order (kx=ky=3) is recommended.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ky" name="ky" port_type="basic:Integer">
      <docstring>The degrees of the spline (1 &lt;= kx, ky &lt;= 5).
Third order (kx=ky=3) is recommended.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="task" name="task" port_type="basic:Integer">
      <docstring>If task=0, find knots in x and y and coefficients for a given
smoothing factor, s.
If task=1, find knots and coefficients for another value of the
smoothing factor, s.  bisplrep must have been previously called
with task=0 or task=1.
If task=-1, find coefficients for a given set of knots tx, ty.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:Float">
      <docstring>A non-negative smoothing factor.  If weights correspond
to the inverse of the standard-deviation of the errors in z,
then a good s-value should be found in the range
``(m-sqrt(2*m),m+sqrt(2*m))`` where m=len(x).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="eps" name="eps" port_type="basic:Float">
      <docstring>A threshold for determining the effective rank of an
over-determined linear system of equations (0 &lt; eps &lt; 1).
`eps` is not likely to need changing.</docstring>
      <defaults>[1e-16]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tx" name="tx" port_type="basic:List">
      <docstring>Rank-1 arrays of the knots of the spline for task=-1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ty" name="ty" port_type="basic:List">
      <docstring>Rank-1 arrays of the knots of the spline for task=-1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Integer">
      <docstring>Non-zero to return optional outputs.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="nxest" name="nxest" port_type="basic:Integer">
      <docstring>Over-estimates of the total number of knots. If None then
``nxest = max(kx+sqrt(m/2),2*kx+3)``,
``nyest = max(ky+sqrt(m/2),2*ky+3)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nyest" name="nyest" port_type="basic:Integer">
      <docstring>Over-estimates of the total number of knots. If None then
``nxest = max(kx+sqrt(m/2),2*kx+3)``,
``nyest = max(ky+sqrt(m/2),2*ky+3)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="quiet" name="quiet" port_type="basic:Integer">
      <docstring>Non-zero to suppress printing of messages.
This parameter is deprecated; use standard Python warning filters
instead.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A list [tx, ty, c, kx, ky] containing the knots (tx, ty) and
coefficients (c) of the bivariate B-spline representation of the
surface along with the degree of the spline.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fp" name="fp" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The weighted sum of squared residuals of the spline approximation.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ier" name="ier" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>An integer flag about splrep success.  Success is indicated if
ier&lt;=0. If ier in [1,2,3] an error occurred but was not raised.
Otherwise an error is raised.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="msg" name="msg" show_port="True" sort_key="3">
      <docstring>A message corresponding to the integer flag, ier.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.griddata" module_name="griddata" namespace="'interpolate'">
    <docstring>Interpolate unstructured D-dimensional data.

Parameters
----------
points : ndarray of floats, shape (n, D)
    Data point coordinates. Can either be an array of
    shape (n, D), or a tuple of `ndim` arrays.
values : ndarray of float or complex, shape (n,)
    Data values.
xi : ndarray of float, shape (M, D)
    Points at which to interpolate data.
method : {'linear', 'nearest', 'cubic'}, optional
    Method of interpolation. One of

    ``nearest``
      return the value at the data point closest to
      the point of interpolation.  See `NearestNDInterpolator` for
      more details.

    ``linear``
      tesselate the input point set to n-dimensional
      simplices, and interpolate linearly on each simplex.  See
      `LinearNDInterpolator` for more details.

    ``cubic`` (1-D)
      return the value determined from a cubic
      spline.

    ``cubic`` (2-D)
      return the value determined from a
      piecewise cubic, continuously differentiable (C1), and
      approximately curvature-minimizing polynomial surface. See
      `CloughTocher2DInterpolator` for more details.
fill_value : float, optional
    Value used to fill in for requested points outside of the
    convex hull of the input points.  If not provided, then the
    default is ``nan``. This option has no effect for the
    'nearest' method.
rescale : bool, optional
    Rescale points to unit cube before performing interpolation.
    This is useful if some of the input dimensions have
    incommensurable units and differ by many orders of magnitude.

    .. versionadded:: 0.14.0

Notes
-----

.. versionadded:: 0.9

Examples
--------

Suppose we want to interpolate the 2-D function

&gt;&gt;&gt; def func(x, y):
...     return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2

on a grid in [0, 1]x[0, 1]

&gt;&gt;&gt; grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]

but we only know its values at 1000 data points:

&gt;&gt;&gt; points = np.random.rand(1000, 2)
&gt;&gt;&gt; values = func(points[:,0], points[:,1])

This can be done with `griddata` -- below we try out all of the
interpolation methods:

&gt;&gt;&gt; from scipy.interpolate import griddata
&gt;&gt;&gt; grid_z0 = griddata(points, values, (grid_x, grid_y), method='nearest')
&gt;&gt;&gt; grid_z1 = griddata(points, values, (grid_x, grid_y), method='linear')
&gt;&gt;&gt; grid_z2 = griddata(points, values, (grid_x, grid_y), method='cubic')

One can see that the exact result is reproduced by all of the
methods to some degree, but for this smooth function the piecewise
cubic interpolant gives the best results:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.subplot(221)
&gt;&gt;&gt; plt.imshow(func(grid_x, grid_y).T, extent=(0,1,0,1), origin='lower')
&gt;&gt;&gt; plt.plot(points[:,0], points[:,1], 'k.', ms=1)
&gt;&gt;&gt; plt.title('Original')
&gt;&gt;&gt; plt.subplot(222)
&gt;&gt;&gt; plt.imshow(grid_z0.T, extent=(0,1,0,1), origin='lower')
&gt;&gt;&gt; plt.title('Nearest')
&gt;&gt;&gt; plt.subplot(223)
&gt;&gt;&gt; plt.imshow(grid_z1.T, extent=(0,1,0,1), origin='lower')
&gt;&gt;&gt; plt.title('Linear')
&gt;&gt;&gt; plt.subplot(224)
&gt;&gt;&gt; plt.imshow(grid_z2.T, extent=(0,1,0,1), origin='lower')
&gt;&gt;&gt; plt.title('Cubic')
&gt;&gt;&gt; plt.gcf().set_size_inches(6, 6)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="points" depth="1" name="points" port_type="basic:Float" show_port="True">
      <docstring>Data point coordinates. Can either be an array of
shape (n, D), or a tuple of `ndim` arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="valuesScalar" show_port="True">
      <docstring>Data values.</docstring>
      <alternateSpec arg="values" depth="1" name="valuesSequence" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="xi" depth="1" name="xi" port_type="basic:Float" show_port="True">
      <docstring>Points at which to interpolate data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Method of interpolation. One of

``nearest``
  return the value at the data point closest to
  the point of interpolation.  See `NearestNDInterpolator` for
  more details.

``linear``
  tesselate the input point set to n-dimensional
  simplices, and interpolate linearly on each simplex.  See
  `LinearNDInterpolator` for more details.

``cubic`` (1-D)
  return the value determined from a cubic
  spline.

``cubic`` (2-D)
  return the value determined from a
  piecewise cubic, continuously differentiable (C1), and
  approximately curvature-minimizing polynomial surface. See
  `CloughTocher2DInterpolator` for more details.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'nearest', 'cubic']]</values>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Float">
      <docstring>Value used to fill in for requested points outside of the
convex hull of the input points.  If not provided, then the
default is ``nan``. This option has no effect for the
'nearest' method.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rescale" name="rescale" port_type="basic:Boolean">
      <docstring>Rescale points to unit cube before performing interpolation.
This is useful if some of the input dimensions have
incommensurable units and differ by many orders of magnitude.

.. versionadded:: 0.14.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.insert" module_name="insert" namespace="'interpolate'">
    <docstring>Insert knots into a B-spline.

Given the knots and coefficients of a B-spline representation, create a
new B-spline with a knot inserted `m` times at point `x`.
This is a wrapper around the FORTRAN routine insert of FITPACK.

Parameters
----------
x (u) : array_like
    A 1-D point at which to insert a new knot(s).  If `tck` was returned
    from ``splprep``, then the parameter values, u should be given.
tck : tuple
    A tuple (t,c,k) returned by ``splrep`` or ``splprep`` containing
    the vector of knots, the B-spline coefficients,
    and the degree of the spline.
m : int, optional
    The number of times to insert the given knot (its multiplicity).
    Default is 1.
per : int, optional
    If non-zero, the input spline is considered periodic.

Returns
-------
tck : tuple
    A tuple (t,c,k) containing the vector of knots, the B-spline
    coefficients, and the degree of the new spline.
    ``t(k+1) &lt;= x &lt;= t(n-k)``, where k is the degree of the spline.
    In case of a periodic spline (``per != 0``) there must be
    either at least k interior knots t(j) satisfying ``t(k+1)&lt;t(j)&lt;=x``
    or at least k interior knots t(j) satisfying ``x&lt;=t(j)&lt;t(n-k)``.

Notes
-----
Based on algorithms from [1]_ and [2]_.

References
----------
.. [1] W. Boehm, "Inserting new knots into b-spline curves.",
    Computer Aided Design, 12, p.199-201, 1980.
.. [2] P. Dierckx, "Curve and surface fitting with splines, Monographs on
    Numerical Analysis", Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>A tuple (t,c,k) returned by ``splrep`` or ``splprep`` containing
the vector of knots, the B-spline coefficients,
and the degree of the spline.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>The number of times to insert the given knot (its multiplicity).
Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="per" name="per" port_type="basic:Integer">
      <docstring>If non-zero, the input spline is considered periodic.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A tuple (t,c,k) containing the vector of knots, the B-spline
coefficients, and the degree of the new spline.
``t(k+1) &lt;= x &lt;= t(n-k)``, where k is the degree of the spline.
In case of a periodic spline (``per != 0``) there must be
either at least k interior knots t(j) satisfying ``t(k+1)&lt;t(j)&lt;=x``
or at least k interior knots t(j) satisfying ``x&lt;=t(j)&lt;t(n-k)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interpn" module_name="interpn" namespace="'interpolate'">
    <docstring>Multidimensional interpolation on regular grids.

Parameters
----------
points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )
    The points defining the regular grid in n dimensions.

values : array_like, shape (m1, ..., mn, ...)
    The data on the regular grid in n dimensions.

xi : ndarray of shape (..., ndim)
    The coordinates to sample the gridded data at

method : str, optional
    The method of interpolation to perform. Supported are "linear" and
    "nearest", and "splinef2d". "splinef2d" is only supported for
    2-dimensional data.

bounds_error : bool, optional
    If True, when interpolated values are requested outside of the
    domain of the input data, a ValueError is raised.
    If False, then `fill_value` is used.

fill_value : number, optional
    If provided, the value to use for points outside of the
    interpolation domain. If None, values outside
    the domain are extrapolated.  Extrapolation is not supported by method
    "splinef2d".

Returns
-------
values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]
    Interpolated values at input coordinates.

Notes
-----

.. versionadded:: 0.14

See also
--------
NearestNDInterpolator : Nearest neighbour interpolation on unstructured
                        data in N dimensions

LinearNDInterpolator : Piecewise linear interpolant on unstructured data
                       in N dimensions

RegularGridInterpolator : Linear and nearest-neighbor Interpolation on a
                          regular grid in arbitrary dimensions

RectBivariateSpline : Bivariate spline approximation over a rectangular mesh</docstring>
    <inputPortSpec arg="points" depth="1" name="points" port_type="basic:Float" show_port="True">
      <docstring>The points defining the regular grid in n dimensions.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>The data on the regular grid in n dimensions.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>The coordinates to sample the gridded data at
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>The method of interpolation to perform. Supported are "linear" and
"nearest", and "splinef2d". "splinef2d" is only supported for
2-dimensional data.
</docstring>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bounds_error" name="bounds_error" port_type="basic:Boolean">
      <docstring>If True, when interpolated values are requested outside of the
domain of the input data, a ValueError is raised.
If False, then `fill_value` is used.
</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" name="fill_value" port_type="basic:Variant">
      <docstring>If provided, the value to use for points outside of the
interpolation domain. If None, values outside
the domain are extrapolated.  Extrapolation is not supported by method
"splinef2d".</docstring>
    </inputPortSpec>
    <outputPortSpec arg="values_x" name="values_x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values at input coordinates.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.krogh_interpolate" module_name="krogh_interpolate" namespace="'interpolate'">
    <docstring>Convenience function for polynomial interpolation.

See `KroghInterpolator` for more details.

Parameters
----------
xi : array_like
    Known x-coordinates.
yi : array_like
    Known y-coordinates, of shape ``(xi.size, R)``.  Interpreted as
    vectors of length R, or scalars if R=1.
x : array_like
    Point or points at which to evaluate the derivatives.
der : int or list, optional
    How many derivatives to extract; None for all potentially
    nonzero derivatives (that is a number equal to the number
    of points), or a list of derivatives to extract. This number
    includes the function value as 0th derivative.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

Returns
-------
d : ndarray
    If the interpolator's values are R-dimensional then the
    returned array will be the number of derivatives by N by R.
    If `x` is a scalar, the middle dimension will be dropped; if
    the `yi` are scalars then the last dimension will be dropped.

See Also
--------
KroghInterpolator

Notes
-----
Construction of the interpolating polynomial is a relatively expensive
process. If you want to evaluate it repeatedly consider using the class
KroghInterpolator (which is what this function uses).</docstring>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>Known x-coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" name="yi" port_type="basic:List" show_port="True">
      <docstring>Known y-coordinates, of shape ``(xi.size, R)``.  Interpreted as
vectors of length R, or scalars if R=1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Point or points at which to evaluate the derivatives.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="der" name="derScalar" port_type="basic:Integer">
      <docstring>How many derivatives to extract; None for all potentially
nonzero derivatives (that is a number equal to the number
of points), or a list of derivatives to extract. This number
includes the function value as 0th derivative.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="der" name="derSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis in the yi array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="d" name="d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If the interpolator's values are R-dimensional then the
returned array will be the number of derivatives by N by R.
If `x` is a scalar, the middle dimension will be dropped; if
the `yi` are scalars then the last dimension will be dropped.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.lagrange" module_name="lagrange" namespace="'interpolate'">
    <docstring>Return a Lagrange interpolating polynomial.

Given two 1-D arrays `x` and `w,` returns the Lagrange interpolating
polynomial through the points ``(x, w)``.

Warning: This implementation is numerically unstable. Do not expect to
be able to use more than about 20 points even if they are chosen optimally.

Parameters
----------
x : array_like
    `x` represents the x-coordinates of a set of datapoints.
w : array_like
    `w` represents the y-coordinates of a set of datapoints, i.e. f(`x`).

Returns
-------
lagrange : numpy.poly1d instance
    The Lagrange interpolating polynomial.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>`x` represents the x-coordinates of a set of datapoints.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List" show_port="True">
      <docstring>`w` represents the y-coordinates of a set of datapoints, i.e. f(`x`).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="lagrange" name="lagrange" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The Lagrange interpolating polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.pchip_interpolate" module_name="pchip_interpolate" namespace="'interpolate'">
    <docstring>Convenience function for pchip interpolation.
xi and yi are arrays of values used to approximate some function f,
with ``yi = f(xi)``.  The interpolant uses monotonic cubic splines
to find the value of new points x and the derivatives there.

See `PchipInterpolator` for details.

Parameters
----------
xi : array_like
    A sorted list of x-coordinates, of length N.
yi :  array_like
    A 1-D array of real values.  `yi`'s length along the interpolation
    axis must be equal to the length of `xi`. If N-D array, use axis
    parameter to select correct axis.
x : scalar or array_like
    Of length M.
der : int or list, optional
    How many derivatives to extract; None for all potentially
    nonzero derivatives (that is a number equal to the number
    of points), or a list of derivatives to extract. This number
    includes the function value as 0th derivative.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

See Also
--------
PchipInterpolator

Returns
-------
y : scalar or array_like
    The result, of length R or length M or M by R,</docstring>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>A sorted list of x-coordinates, of length N.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" name="yi" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of real values.  `yi`'s length along the interpolation
axis must be equal to the length of `xi`. If N-D array, use axis
parameter to select correct axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Float" show_port="True">
      <docstring>Of length M.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="der" name="derScalar" port_type="basic:Integer">
      <docstring>How many derivatives to extract; None for all potentially
nonzero derivatives (that is a number equal to the number
of points), or a list of derivatives to extract. This number
includes the function value as 0th derivative.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="der" name="derSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis in the yi array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The result, of length R or length M or M by R,</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.piecewise_polynomial_interpolate" module_name="piecewise_polynomial_interpolate" namespace="'interpolate'">
    <docstring>Convenience function for piecewise polynomial interpolation.

Parameters
----------
xi : array_like
    A sorted list of x-coordinates.
yi : list of lists
    ``yi[i]`` is the list of derivatives known at ``xi[i]``.
x : scalar or array_like
    Coordinates at which to evalualte the polynomial.
orders : int or list of ints, optional
    A list of polynomial orders, or a single universal order.
der : int or list, optional
    How many derivatives to extract; None for all potentially
    nonzero derivatives (that is a number equal to the number
    of points), or a list of derivatives to extract. This number
    includes the function value as 0th derivative.
axis : int, optional
    Axis in the `yi` array corresponding to the x-coordinate values.

Returns
-------
y : ndarray
    Interpolated values or derivatives. If multiple derivatives
    were requested, these are given along the first axis.

See Also
--------
PiecewisePolynomial

Notes
-----
If `orders` is None, or ``orders[i]`` is None, then the degree of the
polynomial segment is exactly the degree required to match all i
available derivatives at both endpoints.  If ``orders[i]`` is not None,
then some derivatives will be ignored.  The code will try to use an
equal number of derivatives from each end; if the total number of
derivatives needed is odd, it will prefer the rightmost endpoint. If
not enough derivatives are available, an exception is raised.

Construction of these piecewise polynomials can be an expensive process;
if you repeatedly evaluate the same polynomial, consider using the class
PiecewisePolynomial (which is what this function does).</docstring>
    <inputPortSpec arg="xi" name="xi" port_type="basic:List" show_port="True">
      <docstring>A sorted list of x-coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" name="yi" port_type="basic:List" show_port="True">
      <docstring>``yi[i]`` is the list of derivatives known at ``xi[i]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Float" show_port="True">
      <docstring>Coordinates at which to evalualte the polynomial.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="orders" name="ordersScalar" port_type="basic:Integer">
      <docstring>A list of polynomial orders, or a single universal order.</docstring>
      <alternateSpec arg="orders" depth="1" name="ordersSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="der" name="derScalar" port_type="basic:Integer">
      <docstring>How many derivatives to extract; None for all potentially
nonzero derivatives (that is a number equal to the number
of points), or a list of derivatives to extract. This number
includes the function value as 0th derivative.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="der" name="derSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis in the `yi` array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Interpolated values or derivatives. If multiple derivatives
were requested, these are given along the first axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.spalde" module_name="spalde" namespace="'interpolate'">
    <docstring>Evaluate all derivatives of a B-spline.

Given the knots and coefficients of a cubic B-spline compute all
derivatives up to order k at a point (or set of points).

Parameters
----------
x : array_like
    A point or a set of points at which to evaluate the derivatives.
    Note that ``t(k) &lt;= x &lt;= t(n-k+1)`` must hold for each `x`.
tck : tuple
    A tuple (t,c,k) containing the vector of knots,
    the B-spline coefficients, and the degree of the spline.

Returns
-------
results : {ndarray, list of ndarrays}
    An array (or a list of arrays) containing all derivatives
    up to order k inclusive for each point `x`.

See Also
--------
splprep, splrep, splint, sproot, splev, bisplrep, bisplev,
UnivariateSpline, BivariateSpline

References
----------
.. [1] de Boor C : On calculating with b-splines, J. Approximation Theory
   6 (1972) 50-62.
.. [2] Cox M.G. : The numerical evaluation of b-splines, J. Inst. Maths
   applics 10 (1972) 134-149.
.. [3] Dierckx P. : Curve and surface fitting with splines, Monographs on
   Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A point or a set of points at which to evaluate the derivatives.
Note that ``t(k) &lt;= x &lt;= t(n-k+1)`` must hold for each `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>A tuple (t,c,k) containing the vector of knots,
the B-spline coefficients, and the degree of the spline.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="results" name="results" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (or a list of arrays) containing all derivatives
up to order k inclusive for each point `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splantider" module_name="splantider" namespace="'interpolate'">
    <docstring>Compute the spline for the antiderivative (integral) of a given spline.

Parameters
----------
tck : tuple of (t, c, k)
    Spline whose antiderivative to compute
n : int, optional
    Order of antiderivative to evaluate. Default: 1

Returns
-------
tck_ader : tuple of (t2, c2, k2)
    Spline of order k2=k+n representing the antiderivative of the input
    spline.

See Also
--------
splder, splev, spalde

Notes
-----
The `splder` function is the inverse operation of this function.
Namely, ``splder(splantider(tck))`` is identical to `tck`, modulo
rounding error.

.. versionadded:: 0.13.0

Examples
--------
&gt;&gt;&gt; from scipy.interpolate import splrep, splder, splantider, splev
&gt;&gt;&gt; x = np.linspace(0, np.pi/2, 70)
&gt;&gt;&gt; y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)
&gt;&gt;&gt; spl = splrep(x, y)

The derivative is the inverse operation of the antiderivative,
although some floating point error accumulates:

&gt;&gt;&gt; splev(1.7, spl), splev(1.7, splder(splantider(spl)))
(array(2.1565429877197317), array(2.1565429877201865))

Antiderivative can be used to evaluate definite integrals:

&gt;&gt;&gt; ispl = splantider(spl)
&gt;&gt;&gt; splev(np.pi/2, ispl) - splev(0, ispl)
2.2572053588768486

This is indeed an approximation to the complete elliptic integral
:math:`K(m) = \int_0^{\pi/2} [1 - m\sin^2 x]^{-1/2} dx`:

&gt;&gt;&gt; from scipy.special import ellipk
&gt;&gt;&gt; ellipk(0.8)
2.2572053268208538</docstring>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>Spline whose antiderivative to compute</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Order of antiderivative to evaluate. Default: 1</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tck_ader" name="tck_ader" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Spline of order k2=k+n representing the antiderivative of the input
spline.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splder" module_name="splder" namespace="'interpolate'">
    <docstring>Compute the spline representation of the derivative of a given spline

Parameters
----------
tck : tuple of (t, c, k)
    Spline whose derivative to compute
n : int, optional
    Order of derivative to evaluate. Default: 1

Returns
-------
tck_der : tuple of (t2, c2, k2)
    Spline of order k2=k-n representing the derivative
    of the input spline.

Notes
-----

.. versionadded:: 0.13.0

See Also
--------
splantider, splev, spalde

Examples
--------
This can be used for finding maxima of a curve:

&gt;&gt;&gt; from scipy.interpolate import splrep, splder, sproot
&gt;&gt;&gt; x = np.linspace(0, 10, 70)
&gt;&gt;&gt; y = np.sin(x)
&gt;&gt;&gt; spl = splrep(x, y, k=4)

Now, differentiate the spline and find the zeros of the
derivative. (NB: `sproot` only works for order 3 splines, so we
fit an order 4 spline):

&gt;&gt;&gt; dspl = splder(spl)
&gt;&gt;&gt; sproot(dspl) / np.pi
array([ 0.50000001,  1.5       ,  2.49999998])

This agrees well with roots :math:`\pi/2 + n\pi` of
:math:`\cos(x) = \sin'(x)`.</docstring>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>Spline whose derivative to compute</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Order of derivative to evaluate. Default: 1</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tck_der" name="tck_der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Spline of order k2=k-n representing the derivative
of the input spline.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splev" module_name="splev" namespace="'interpolate'">
    <docstring>Evaluate a B-spline or its derivatives.

Given the knots and coefficients of a B-spline representation, evaluate
the value of the smoothing polynomial and its derivatives.  This is a
wrapper around the FORTRAN routines splev and splder of FITPACK.

Parameters
----------
x : array_like
    An array of points at which to return the value of the smoothed
    spline or its derivatives.  If `tck` was returned from `splprep`,
    then the parameter values, u should be given.
tck : tuple
    A sequence of length 3 returned by `splrep` or `splprep` containing
    the knots, coefficients, and degree of the spline.
der : int, optional
    The order of derivative of the spline to compute (must be less than
    or equal to k).
ext : int, optional
    Controls the value returned for elements of ``x`` not in the
    interval defined by the knot sequence.

    * if ext=0, return the extrapolated value.
    * if ext=1, return 0
    * if ext=2, raise a ValueError
    * if ext=3, return the boundary value.

    The default value is 0.

Returns
-------
y : ndarray or list of ndarrays
    An array of values representing the spline function evaluated at
    the points in ``x``.  If `tck` was returned from `splprep`, then this
    is a list of arrays representing the curve in N-dimensional space.

See Also
--------
splprep, splrep, sproot, spalde, splint
bisplrep, bisplev

References
----------
.. [1] C. de Boor, "On calculating with b-splines", J. Approximation
    Theory, 6, p.50-62, 1972.
.. [2] M.G. Cox, "The numerical evaluation of b-splines", J. Inst. Maths
    Applics, 10, p.134-149, 1972.
.. [3] P. Dierckx, "Curve and surface fitting with splines", Monographs
    on Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>An array of points at which to return the value of the smoothed
spline or its derivatives.  If `tck` was returned from `splprep`,
then the parameter values, u should be given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>A sequence of length 3 returned by `splrep` or `splprep` containing
the knots, coefficients, and degree of the spline.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="der" name="der" port_type="basic:Integer">
      <docstring>The order of derivative of the spline to compute (must be less than
or equal to k).</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ext" name="ext" port_type="basic:Integer">
      <docstring>Controls the value returned for elements of ``x`` not in the
interval defined by the knot sequence.

* if ext=0, return the extrapolated value.
* if ext=1, return 0
* if ext=2, raise a ValueError
* if ext=3, return the boundary value.

The default value is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of values representing the spline function evaluated at
the points in ``x``.  If `tck` was returned from `splprep`, then this
is a list of arrays representing the curve in N-dimensional space.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.spleval" module_name="spleval" namespace="'interpolate'">
    <docstring>Evaluate a fixed spline represented by the given tuple at the new x-values

The `xj` values are the interior knot points.  The approximation
region is `xj[0]` to `xj[-1]`.  If N+1 is the length of `xj`, then `cvals`
should have length N+k where `k` is the order of the spline.

Parameters
----------
(xj, cvals, k) : tuple
    Parameters that define the fixed spline
xj : array_like
    Interior knot points
cvals : array_like
    Curvature
k : int
    Order of the spline
xnew : array_like
    Locations to calculate spline
deriv : int
    Deriv

Returns
-------
spleval : ndarray
    If `cvals` represents more than one curve (`cvals.ndim` &gt; 1) and/or
    `xnew` is N-d, then the result is `xnew.shape` + `cvals.shape[1:]`
    providing the interpolation of multiple curves.

Notes
-----
Internally, an additional `k`-1 knot points are added on either side of
the spline.</docstring>
    <inputPortSpec arg="cvals" name="cvals" port_type="basic:List" show_port="True">
      <docstring>Parameters that define the fixed spline</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k)" name="k)" port_type="basic:List" show_port="True">
      <docstring>Parameters that define the fixed spline</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xj" name="xj" port_type="basic:List" show_port="True">
      <docstring>Interior knot points</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cvals" name="cvals" port_type="basic:List" show_port="True">
      <docstring>Curvature</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer" show_port="True">
      <docstring>Order of the spline</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xnew" name="xnew" port_type="basic:List" show_port="True">
      <docstring>Locations to calculate spline</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deriv" name="deriv" port_type="basic:Integer">
      <docstring>Deriv</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xck" name="xck" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="spleval" name="spleval" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `cvals` represents more than one curve (`cvals.ndim` &gt; 1) and/or
`xnew` is N-d, then the result is `xnew.shape` + `cvals.shape[1:]`
providing the interpolation of multiple curves.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.spline" module_name="spline" namespace="'interpolate'">
    <docstring>Interpolate a curve at new points using a spline fit

Parameters
----------
xk, yk : array_like
    The x and y values that define the curve.
xnew : array_like
    The x values where spline should estimate the y values.
order : int
    Default is 3.
kind : string
    One of {'smoothest'}
conds : Don't know
    Don't know

Returns
-------
spline : ndarray
    An array of y values; the spline evaluated at the positions `xnew`.</docstring>
    <inputPortSpec arg="xk" name="xk" port_type="basic:List" show_port="True">
      <docstring>The x and y values that define the curve.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yk" name="yk" port_type="basic:List" show_port="True">
      <docstring>The x and y values that define the curve.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xnew" name="xnew" port_type="basic:List" show_port="True">
      <docstring>The x values where spline should estimate the y values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>One of {'smoothest'}</docstring>
      <defaults>['smoothest']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="conds" name="conds" port_type="basic:Variant" show_port="True">
      <docstring>Don't know</docstring>
    </inputPortSpec>
    <outputPortSpec arg="spline" name="spline" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of y values; the spline evaluated at the positions `xnew`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splint" module_name="splint" namespace="'interpolate'" output_type="list">
    <docstring>Evaluate the definite integral of a B-spline.

Given the knots and coefficients of a B-spline, evaluate the definite
integral of the smoothing polynomial between two given points.

Parameters
----------
a, b : float
    The end-points of the integration interval.
tck : tuple
    A tuple (t,c,k) containing the vector of knots, the B-spline
    coefficients, and the degree of the spline (see `splev`).
full_output : int, optional
    Non-zero to return optional output.

Returns
-------
integral : float
    The resulting integral.
wrk : ndarray
    An array containing the integrals of the normalized B-splines
    defined on the set of knots.

Notes
-----
splint silently assumes that the spline function is zero outside the data
interval (a, b).

See Also
--------
splprep, splrep, sproot, spalde, splev
bisplrep, bisplev
UnivariateSpline, BivariateSpline

References
----------
.. [1] P.W. Gaffney, The calculation of indefinite integrals of b-splines",
    J. Inst. Maths Applics, 17, p.37-41, 1976.
.. [2] P. Dierckx, "Curve and surface fitting with splines", Monographs
    on Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>The end-points of the integration interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Float" show_port="True">
      <docstring>The end-points of the integration interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>A tuple (t,c,k) containing the vector of knots, the B-spline
coefficients, and the degree of the spline (see `splev`).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Integer">
      <docstring>Non-zero to return optional output.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="integral" name="integral" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The resulting integral.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="wrk" name="wrk" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array containing the integrals of the normalized B-splines
defined on the set of knots.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splmake" module_name="splmake" namespace="'interpolate'">
    <docstring>Return a representation of a spline given data-points at internal knots

Parameters
----------
xk : array_like
    The input array of x values of rank 1
yk : array_like
    The input array of y values of rank N. `yk` can be an N-d array to
    represent more than one curve, through the same `xk` points. The first
    dimension is assumed to be the interpolating dimension and is the same
    length of `xk`.
order : int, optional
    Order of the spline
kind : str, optional
    Can be 'smoothest', 'not_a_knot', 'fixed', 'clamped', 'natural',
    'periodic', 'symmetric', 'user', 'mixed' and it is ignored if order &lt; 2
conds : optional
    Conds

Returns
-------
splmake : tuple
    Return a (`xk`, `cvals`, `k`) representation of a spline given
    data-points where the (internal) knots are at the data-points.</docstring>
    <inputPortSpec arg="xk" name="xk" port_type="basic:List" show_port="True">
      <docstring>The input array of x values of rank 1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yk" name="yk" port_type="basic:List" show_port="True">
      <docstring>The input array of y values of rank N. `yk` can be an N-d array to
represent more than one curve, through the same `xk` points. The first
dimension is assumed to be the interpolating dimension and is the same
length of `xk`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>Order of the spline</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Can be 'smoothest', 'not_a_knot', 'fixed', 'clamped', 'natural',
'periodic', 'symmetric', 'user', 'mixed' and it is ignored if order &lt; 2</docstring>
      <defaults>['smoothest']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="conds" name="conds" port_type="basic:Variant">
      <docstring>Conds</docstring>
    </inputPortSpec>
    <outputPortSpec arg="splmake" name="splmake" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Return a (`xk`, `cvals`, `k`) representation of a spline given
data-points where the (internal) knots are at the data-points.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splprep" module_name="splprep" namespace="'interpolate'" output_type="list">
    <docstring>Find the B-spline representation of an N-dimensional curve.

Given a list of N rank-1 arrays, `x`, which represent a curve in
N-dimensional space parametrized by `u`, find a smooth approximating
spline curve g(`u`). Uses the FORTRAN routine parcur from FITPACK.

Parameters
----------
x : array_like
    A list of sample vector arrays representing the curve.
w : array_like, optional
    Strictly positive rank-1 array of weights the same length as `x[0]`.
    The weights are used in computing the weighted least-squares spline
    fit. If the errors in the `x` values have standard-deviation given by
    the vector d, then `w` should be 1/d. Default is ``ones(len(x[0]))``.
u : array_like, optional
    An array of parameter values. If not given, these values are
    calculated automatically as ``M = len(x[0])``, where

        v[0] = 0

        v[i] = v[i-1] + distance(`x[i]`, `x[i-1]`)

        u[i] = v[i] / v[M-1]

ub, ue : int, optional
    The end-points of the parameters interval.  Defaults to
    u[0] and u[-1].
k : int, optional
    Degree of the spline. Cubic splines are recommended.
    Even values of `k` should be avoided especially with a small s-value.
    ``1 &lt;= k &lt;= 5``, default is 3.
task : int, optional
    If task==0 (default), find t and c for a given smoothing factor, s.
    If task==1, find t and c for another value of the smoothing factor, s.
    There must have been a previous call with task=0 or task=1
    for the same set of data.
    If task=-1 find the weighted least square spline for a given set of
    knots, t.
s : float, optional
    A smoothing condition.  The amount of smoothness is determined by
    satisfying the conditions: ``sum((w * (y - g))**2,axis=0) &lt;= s``,
    where g(x) is the smoothed interpolation of (x,y).  The user can
    use `s` to control the trade-off between closeness and smoothness
    of fit.  Larger `s` means more smoothing while smaller values of `s`
    indicate less smoothing. Recommended values of `s` depend on the
    weights, w.  If the weights represent the inverse of the
    standard-deviation of y, then a good `s` value should be found in
    the range ``(m-sqrt(2*m),m+sqrt(2*m))``, where m is the number of
    data points in x, y, and w.
t : int, optional
    The knots needed for task=-1.
full_output : int, optional
    If non-zero, then return optional outputs.
nest : int, optional
    An over-estimate of the total number of knots of the spline to
    help in determining the storage space.  By default nest=m/2.
    Always large enough is nest=m+k+1.
per : int, optional
   If non-zero, data points are considered periodic with period
   ``x[m-1] - x[0]`` and a smooth periodic spline approximation is
   returned.  Values of ``y[m-1]`` and ``w[m-1]`` are not used.
quiet : int, optional
     Non-zero to suppress messages.
     This parameter is deprecated; use standard Python warning filters
     instead.

Returns
-------
tck : tuple
    A tuple (t,c,k) containing the vector of knots, the B-spline
    coefficients, and the degree of the spline.
u : array
    An array of the values of the parameter.
fp : float
    The weighted sum of squared residuals of the spline approximation.
ier : int
    An integer flag about splrep success.  Success is indicated
    if ier&lt;=0. If ier in [1,2,3] an error occurred but was not raised.
    Otherwise an error is raised.
msg : str
    A message corresponding to the integer flag, ier.

See Also
--------
splrep, splev, sproot, spalde, splint,
bisplrep, bisplev
UnivariateSpline, BivariateSpline

Notes
-----
See `splev` for evaluation of the spline and its derivatives.
The number of dimensions N must be smaller than 11.

References
----------
.. [1] P. Dierckx, "Algorithms for smoothing data with periodic and
    parametric splines, Computer Graphics and Image Processing",
    20 (1982) 171-184.
.. [2] P. Dierckx, "Algorithms for smoothing data with periodic and
    parametric splines", report tw55, Dept. Computer Science,
    K.U.Leuven, 1981.
.. [3] P. Dierckx, "Curve and surface fitting with splines", Monographs on
    Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A list of sample vector arrays representing the curve.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Strictly positive rank-1 array of weights the same length as `x[0]`.
The weights are used in computing the weighted least-squares spline
fit. If the errors in the `x` values have standard-deviation given by
the vector d, then `w` should be 1/d. Default is ``ones(len(x[0]))``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="u" name="u" port_type="basic:List">
      <docstring>An array of parameter values. If not given, these values are
calculated automatically as ``M = len(x[0])``, where

    v[0] = 0

    v[i] = v[i-1] + distance(`x[i]`, `x[i-1]`)

    u[i] = v[i] / v[M-1]
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ub" name="ub" port_type="basic:Integer">
      <docstring>The end-points of the parameters interval.  Defaults to
u[0] and u[-1].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ue" name="ue" port_type="basic:Integer">
      <docstring>The end-points of the parameters interval.  Defaults to
u[0] and u[-1].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Degree of the spline. Cubic splines are recommended.
Even values of `k` should be avoided especially with a small s-value.
``1 &lt;= k &lt;= 5``, default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="task" name="task" port_type="basic:Integer">
      <docstring>If task==0 (default), find t and c for a given smoothing factor, s.
If task==1, find t and c for another value of the smoothing factor, s.
There must have been a previous call with task=0 or task=1
for the same set of data.
If task=-1 find the weighted least square spline for a given set of
knots, t.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:Float">
      <docstring>A smoothing condition.  The amount of smoothness is determined by
satisfying the conditions: ``sum((w * (y - g))**2,axis=0) &lt;= s``,
where g(x) is the smoothed interpolation of (x,y).  The user can
use `s` to control the trade-off between closeness and smoothness
of fit.  Larger `s` means more smoothing while smaller values of `s`
indicate less smoothing. Recommended values of `s` depend on the
weights, w.  If the weights represent the inverse of the
standard-deviation of y, then a good `s` value should be found in
the range ``(m-sqrt(2*m),m+sqrt(2*m))``, where m is the number of
data points in x, y, and w.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:Integer">
      <docstring>The knots needed for task=-1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Integer">
      <docstring>If non-zero, then return optional outputs.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="nest" name="nest" port_type="basic:Integer">
      <docstring>An over-estimate of the total number of knots of the spline to
help in determining the storage space.  By default nest=m/2.
Always large enough is nest=m+k+1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="per" name="per" port_type="basic:Integer">
      <docstring>If non-zero, data points are considered periodic with period
``x[m-1] - x[0]`` and a smooth periodic spline approximation is
returned.  Values of ``y[m-1]`` and ``w[m-1]`` are not used.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="quiet" name="quiet" port_type="basic:Integer">
      <docstring>Non-zero to suppress messages.
This parameter is deprecated; use standard Python warning filters
instead.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A tuple (t,c,k) containing the vector of knots, the B-spline
coefficients, and the degree of the spline.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="u" name="u" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array of the values of the parameter.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fp" name="fp" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>The weighted sum of squared residuals of the spline approximation.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ier" name="ier" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>An integer flag about splrep success.  Success is indicated
if ier&lt;=0. If ier in [1,2,3] an error occurred but was not raised.
Otherwise an error is raised.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="msg" name="msg" show_port="True" sort_key="4">
      <docstring>A message corresponding to the integer flag, ier.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.splrep" module_name="splrep" namespace="'interpolate'" output_type="list">
    <docstring>Find the B-spline representation of 1-D curve.

Given the set of data points ``(x[i], y[i])`` determine a smooth spline
approximation of degree k on the interval ``xb &lt;= x &lt;= xe``.

Parameters
----------
x, y : array_like
    The data points defining a curve y = f(x).
w : array_like, optional
    Strictly positive rank-1 array of weights the same length as x and y.
    The weights are used in computing the weighted least-squares spline
    fit. If the errors in the y values have standard-deviation given by the
    vector d, then w should be 1/d. Default is ones(len(x)).
xb, xe : float, optional
    The interval to fit.  If None, these default to x[0] and x[-1]
    respectively.
k : int, optional
    The order of the spline fit. It is recommended to use cubic splines.
    Even order splines should be avoided especially with small s values.
    1 &lt;= k &lt;= 5
task : {1, 0, -1}, optional
    If task==0 find t and c for a given smoothing factor, s.

    If task==1 find t and c for another value of the smoothing factor, s.
    There must have been a previous call with task=0 or task=1 for the same
    set of data (t will be stored an used internally)

    If task=-1 find the weighted least square spline for a given set of
    knots, t. These should be interior knots as knots on the ends will be
    added automatically.
s : float, optional
    A smoothing condition. The amount of smoothness is determined by
    satisfying the conditions: sum((w * (y - g))**2,axis=0) &lt;= s where g(x)
    is the smoothed interpolation of (x,y). The user can use s to control
    the tradeoff between closeness and smoothness of fit. Larger s means
    more smoothing while smaller values of s indicate less smoothing.
    Recommended values of s depend on the weights, w. If the weights
    represent the inverse of the standard-deviation of y, then a good s
    value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is
    the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if
    weights are supplied. s = 0.0 (interpolating) if no weights are
    supplied.
t : array_like, optional
    The knots needed for task=-1. If given then task is automatically set
    to -1.
full_output : bool, optional
    If non-zero, then return optional outputs.
per : bool, optional
    If non-zero, data points are considered periodic with period x[m-1] -
    x[0] and a smooth periodic spline approximation is returned. Values of
    y[m-1] and w[m-1] are not used.
quiet : bool, optional
    Non-zero to suppress messages.
    This parameter is deprecated; use standard Python warning filters
    instead.

Returns
-------
tck : tuple
    (t,c,k) a tuple containing the vector of knots, the B-spline
    coefficients, and the degree of the spline.
fp : array, optional
    The weighted sum of squared residuals of the spline approximation.
ier : int, optional
    An integer flag about splrep success. Success is indicated if ier&lt;=0.
    If ier in [1,2,3] an error occurred but was not raised. Otherwise an
    error is raised.
msg : str, optional
    A message corresponding to the integer flag, ier.

Notes
-----
See splev for evaluation of the spline and its derivatives.

The user is responsible for assuring that the values of *x* are unique.
Otherwise, *splrep* will not return sensible results.

See Also
--------
UnivariateSpline, BivariateSpline
splprep, splev, sproot, spalde, splint
bisplrep, bisplev

Notes
-----
See splev for evaluation of the spline and its derivatives. Uses the
FORTRAN routine curfit from FITPACK.

If provided, knots `t` must satisfy the Schoenberg-Whitney conditions,
i.e., there must be a subset of data points ``x[j]`` such that
``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``.

References
----------
Based on algorithms described in [1]_, [2]_, [3]_, and [4]_:

.. [1] P. Dierckx, "An algorithm for smoothing, differentiation and
   integration of experimental data using spline functions",
   J.Comp.Appl.Maths 1 (1975) 165-184.
.. [2] P. Dierckx, "A fast algorithm for smoothing data on a rectangular
   grid while using spline functions", SIAM J.Numer.Anal. 19 (1982)
   1286-1304.
.. [3] P. Dierckx, "An improved algorithm for curve fitting with spline
   functions", report tw54, Dept. Computer Science,K.U. Leuven, 1981.
.. [4] P. Dierckx, "Curve and surface fitting with splines", Monographs on
   Numerical Analysis, Oxford University Press, 1993.

Examples
--------

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy.interpolate import splev, splrep
&gt;&gt;&gt; x = np.linspace(0, 10, 10)
&gt;&gt;&gt; y = np.sin(x)
&gt;&gt;&gt; tck = splrep(x, y)
&gt;&gt;&gt; x2 = np.linspace(0, 10, 200)
&gt;&gt;&gt; y2 = splev(x2, tck)
&gt;&gt;&gt; plt.plot(x, y, 'o', x2, y2)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The data points defining a curve y = f(x).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The data points defining a curve y = f(x).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Strictly positive rank-1 array of weights the same length as x and y.
The weights are used in computing the weighted least-squares spline
fit. If the errors in the y values have standard-deviation given by the
vector d, then w should be 1/d. Default is ones(len(x)).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xb" name="xb" port_type="basic:Float">
      <docstring>The interval to fit.  If None, these default to x[0] and x[-1]
respectively.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xe" name="xe" port_type="basic:Float">
      <docstring>The interval to fit.  If None, these default to x[0] and x[-1]
respectively.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>The order of the spline fit. It is recommended to use cubic splines.
Even order splines should be avoided especially with small s values.
1 &lt;= k &lt;= 5</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="task" name="task" port_type="basic:Integer">
      <docstring>If task==0 find t and c for a given smoothing factor, s.

If task==1 find t and c for another value of the smoothing factor, s.
There must have been a previous call with task=0 or task=1 for the same
set of data (t will be stored an used internally)

If task=-1 find the weighted least square spline for a given set of
knots, t. These should be interior knots as knots on the ends will be
added automatically.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 0, -1]]</values>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:Float">
      <docstring>A smoothing condition. The amount of smoothness is determined by
satisfying the conditions: sum((w * (y - g))**2,axis=0) &lt;= s where g(x)
is the smoothed interpolation of (x,y). The user can use s to control
the tradeoff between closeness and smoothness of fit. Larger s means
more smoothing while smaller values of s indicate less smoothing.
Recommended values of s depend on the weights, w. If the weights
represent the inverse of the standard-deviation of y, then a good s
value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is
the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if
weights are supplied. s = 0.0 (interpolating) if no weights are
supplied.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:List">
      <docstring>The knots needed for task=-1. If given then task is automatically set
to -1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If non-zero, then return optional outputs.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="per" name="perScalar" port_type="basic:Integer">
      <docstring>If non-zero, data points are considered periodic with period x[m-1] -
x[0] and a smooth periodic spline approximation is returned. Values of
y[m-1] and w[m-1] are not used.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="per" name="perBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="quiet" name="quietScalar" port_type="basic:Integer">
      <docstring>Non-zero to suppress messages.
This parameter is deprecated; use standard Python warning filters
instead.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="quiet" name="quietBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>(t,c,k) a tuple containing the vector of knots, the B-spline
coefficients, and the degree of the spline.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fp" name="fp" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The weighted sum of squared residuals of the spline approximation.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ier" name="ier" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>An integer flag about splrep success. Success is indicated if ier&lt;=0.
If ier in [1,2,3] an error occurred but was not raised. Otherwise an
error is raised.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="msg" name="msg" show_port="True" sort_key="3">
      <docstring>A message corresponding to the integer flag, ier.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.spltopp" module_name="spltopp" namespace="'interpolate'">
    <docstring>Return a piece-wise polynomial object from a fixed-spline tuple.</docstring>
    <inputPortSpec arg="xk" name="xk" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="k" name="k" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="cvals" name="cvals" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.sproot" module_name="sproot" namespace="'interpolate'">
    <docstring>Find the roots of a cubic B-spline.

Given the knots (&gt;=8) and coefficients of a cubic B-spline return the
roots of the spline.

Parameters
----------
tck : tuple
    A tuple (t,c,k) containing the vector of knots,
    the B-spline coefficients, and the degree of the spline.
    The number of knots must be &gt;= 8, and the degree must be 3.
    The knots must be a montonically increasing sequence.
mest : int, optional
    An estimate of the number of zeros (Default is 10).

Returns
-------
zeros : ndarray
    An array giving the roots of the spline.

See also
--------
splprep, splrep, splint, spalde, splev
bisplrep, bisplev
UnivariateSpline, BivariateSpline


References
----------
.. [1] C. de Boor, "On calculating with b-splines", J. Approximation
    Theory, 6, p.50-62, 1972.
.. [2] M.G. Cox, "The numerical evaluation of b-splines", J. Inst. Maths
    Applics, 10, p.134-149, 1972.
.. [3] P. Dierckx, "Curve and surface fitting with splines", Monographs
    on Numerical Analysis, Oxford University Press, 1993.</docstring>
    <inputPortSpec arg="tck" name="tck" port_type="basic:List" show_port="True">
      <docstring>A tuple (t,c,k) containing the vector of knots,
the B-spline coefficients, and the degree of the spline.
The number of knots must be &gt;= 8, and the degree must be 3.
The knots must be a montonically increasing sequence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mest" name="mest" port_type="basic:Integer">
      <docstring>An estimate of the number of zeros (Default is 10).</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="zeros" name="zeros" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array giving the roots of the spline.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.hb_read" module_name="hb_read" namespace="'io'">
    <docstring>Read HB-format file.

Parameters
----------
file : str-like or file-like
    If a string-like object, file is the name of the file to read. If a
    file-like object, the data are read from it.

Returns
-------
data : scipy.sparse.csc_matrix instance
    The data read from the HB file as a sparse matrix.

Notes
-----
At the moment not the full Harwell-Boeing format is supported. Supported
features are:

    - assembled, non-symmetric, real matrices
    - integer for pointer/indices
    - exponential format for float values, and int format</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>If a string-like object, file is the name of the file to read. If a
file-like object, the data are read from it.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['file-like']]</values>
    </inputPortSpec>
    <outputPortSpec arg="data" name="data" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The data read from the HB file as a sparse matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.hb_write" module_name="hb_write" namespace="'io'">
    <docstring>Write HB-format file.

Parameters
----------
file : str-like or file-like
    if a string-like object, file is the name of the file to read. If a
    file-like object, the data are read from it.
m : sparse-matrix
    the sparse matrix to write
hb_info : HBInfo
    contains the meta-data for write

Returns
-------
None

Notes
-----
At the moment not the full Harwell-Boeing format is supported. Supported
features are:

    - assembled, non-symmetric, real matrices
    - integer for pointer/indices
    - exponential format for float values, and int format</docstring>
    <inputPortSpec arg="file" name="file" show_port="True">
      <docstring>if a string-like object, file is the name of the file to read. If a
file-like object, the data are read from it.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['file-like']]</values>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Variant" show_port="True">
      <docstring>the sparse matrix to write</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hb_info" name="hb_info" port_type="basic:Variant" show_port="True">
      <docstring>contains the meta-data for write</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.loadmat" module_name="loadmat" namespace="'io'">
    <docstring>Load MATLAB file

Parameters
----------
file_name : str
   Name of the mat file (do not need .mat extension if
   appendmat==True) Can also pass open file-like object.
m_dict : dict, optional
    Dictionary in which to insert matfile variables.
appendmat : bool, optional
   True to append the .mat extension to the end of the given
   filename, if not already present.
byte_order : str or None, optional
   None by default, implying byte order guessed from mat
   file. Otherwise can be one of ('native', '=', 'little', '&lt;',
   'BIG', '&gt;').
mat_dtype : bool, optional
   If True, return arrays in same dtype as would be loaded into
   MATLAB (instead of the dtype with which they are saved).
squeeze_me : bool, optional
   Whether to squeeze unit matrix dimensions or not.
chars_as_strings : bool, optional
   Whether to convert char arrays to string arrays.
matlab_compatible : bool, optional
   Returns matrices as would be loaded by MATLAB (implies
   squeeze_me=False, chars_as_strings=False, mat_dtype=True,
   struct_as_record=True).
struct_as_record : bool, optional
   Whether to load MATLAB structs as numpy record arrays, or as
   old-style numpy arrays with dtype=object.  Setting this flag to
   False replicates the behavior of scipy version 0.7.x (returning
   numpy object arrays).  The default setting is True, because it
   allows easier round-trip load and save of MATLAB files.
verify_compressed_data_integrity : bool, optional
    Whether the length of compressed sequences in the MATLAB file
    should be checked, to ensure that they are not longer than we expect.
    It is advisable to enable this (the default) because overlong
    compressed sequences in MATLAB files generally indicate that the
    files have experienced some sort of corruption.
variable_names : None or sequence
    If None (the default) - read all variables in file. Otherwise
    `variable_names` should be a sequence of strings, giving names of the
    matlab variables to read from the file.  The reader will skip any
    variable with a name not in this sequence, possibly saving some read
    processing.

Returns
-------
mat_dict : dict
   dictionary with variable names as keys, and loaded matrices as
   values

Notes
-----
v4 (Level 1.0), v6 and v7 to 7.2 matfiles are supported.

You will need an HDF5 python library to read matlab 7.3 format mat
files.  Because scipy does not supply one, we do not implement the
HDF5 / 7.3 interface here.</docstring>
    <inputPortSpec arg="file_name" name="file_name" show_port="True">
      <docstring>Name of the mat file (do not need .mat extension if
appendmat==True) Can also pass open file-like object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m_dict" name="m_dict" port_type="basic:Dictionary">
      <docstring>Dictionary in which to insert matfile variables.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="appendmat" name="appendmat" port_type="basic:Boolean">
      <docstring>True to append the .mat extension to the end of the given
filename, if not already present.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="byte_order" name="byte_order">
      <docstring>None by default, implying byte order guessed from mat
file. Otherwise can be one of ('native', '=', 'little', '&lt;',
'BIG', '&gt;').</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mat_dtype" name="mat_dtype" port_type="basic:Boolean">
      <docstring>If True, return arrays in same dtype as would be loaded into
MATLAB (instead of the dtype with which they are saved).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="squeeze_me" name="squeeze_me" port_type="basic:Boolean">
      <docstring>Whether to squeeze unit matrix dimensions or not.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="chars_as_strings" name="chars_as_strings" port_type="basic:Boolean">
      <docstring>Whether to convert char arrays to string arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="matlab_compatible" name="matlab_compatible" port_type="basic:Boolean">
      <docstring>Returns matrices as would be loaded by MATLAB (implies
squeeze_me=False, chars_as_strings=False, mat_dtype=True,
struct_as_record=True).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="struct_as_record" name="struct_as_record" port_type="basic:Boolean">
      <docstring>Whether to load MATLAB structs as numpy record arrays, or as
old-style numpy arrays with dtype=object.  Setting this flag to
False replicates the behavior of scipy version 0.7.x (returning
numpy object arrays).  The default setting is True, because it
allows easier round-trip load and save of MATLAB files.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verify_compressed_data_integrity" name="verify_compressed_data_integrity" port_type="basic:Boolean">
      <docstring>Whether the length of compressed sequences in the MATLAB file
should be checked, to ensure that they are not longer than we expect.
It is advisable to enable this (the default) because overlong
compressed sequences in MATLAB files generally indicate that the
files have experienced some sort of corruption.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="variable_names" name="variable_names" port_type="basic:List" show_port="True">
      <docstring>If None (the default) - read all variables in file. Otherwise
`variable_names` should be a sequence of strings, giving names of the
matlab variables to read from the file.  The reader will skip any
variable with a name not in this sequence, possibly saving some read
processing.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mdict" name="mdict" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="mat_dict" name="mat_dict" port_type="basic:Dictionary" show_port="True" sort_key="0">
      <docstring>dictionary with variable names as keys, and loaded matrices as
values</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.mminfo" module_name="mminfo" namespace="'io'" output_type="list">
    <docstring>Queries the contents of the Matrix Market file 'filename' to
extract size and storage information.

Parameters
----------

source : file
    Matrix Market filename (extension .mtx) or open file object

Returns
-------

rows,cols : int
   Number of matrix rows and columns
entries : int
    Number of non-zero entries of a sparse matrix
    or rows*cols for a dense matrix
format : str
    Either 'coordinate' or 'array'.
field : str
    Either 'real', 'complex', 'pattern', or 'integer'.
symm : str
    Either 'general', 'symmetric', 'skew-symmetric', or 'hermitian'.</docstring>
    <inputPortSpec arg="source" name="source" port_type="basic:Variant" show_port="True">
      <docstring>Matrix Market filename (extension .mtx) or open file object</docstring>
    </inputPortSpec>
    <outputPortSpec arg="rows" name="rows" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Number of matrix rows and columns</docstring>
    </outputPortSpec>
    <outputPortSpec arg="cols" name="cols" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Number of matrix rows and columns</docstring>
    </outputPortSpec>
    <outputPortSpec arg="entries" name="entries" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Number of non-zero entries of a sparse matrix
or rows*cols for a dense matrix</docstring>
    </outputPortSpec>
    <outputPortSpec arg="format" name="format" show_port="True" sort_key="3">
      <docstring>Either 'coordinate' or 'array'.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="field" name="field" show_port="True" sort_key="4">
      <docstring>Either 'real', 'complex', 'pattern', or 'integer'.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="symm" name="symm" show_port="True" sort_key="5">
      <docstring>Either 'general', 'symmetric', 'skew-symmetric', or 'hermitian'.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.mmread" module_name="mmread" namespace="'io'">
    <docstring>Reads the contents of a Matrix Market file 'filename' into a matrix.

Parameters
----------

source : file
    Matrix Market filename (extensions .mtx, .mtz.gz)
    or open file object.

Returns
-------
a:
    Sparse or full matrix</docstring>
    <inputPortSpec arg="source" name="source" port_type="basic:Variant" show_port="True">
      <docstring>Matrix Market filename (extensions .mtx, .mtz.gz)
or open file object.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Sparse or full matrix</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.mmwrite" module_name="mmwrite" namespace="'io'">
    <docstring>Writes the sparse or dense array `a` to a Matrix Market formatted file.

Parameters
----------
target : file
    Matrix Market filename (extension .mtx) or open file object
a : array like
    Sparse or dense 2D array
comment : str, optional
    comments to be prepended to the Matrix Market file
field : None or str, optional
    Either 'real', 'complex', 'pattern', or 'integer'.
precision : None or int, optional
    Number of digits to display for real or complex values.</docstring>
    <inputPortSpec arg="target" name="target" port_type="basic:Variant" show_port="True">
      <docstring>Matrix Market filename (extension .mtx) or open file object</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Sparse or dense 2D array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="comment" name="comment">
      <docstring>comments to be prepended to the Matrix Market file</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="field" name="field">
      <docstring>Either 'real', 'complex', 'pattern', or 'integer'.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="precision" name="precision" port_type="basic:Integer">
      <docstring>Number of digits to display for real or complex values.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.readsav" module_name="readsav" namespace="'io'">
    <docstring>Read an IDL .sav file

Parameters
----------
file_name : str
    Name of the IDL save file.
idict : dict, optional
    Dictionary in which to insert .sav file variables
python_dict : bool, optional
    By default, the object return is not a Python dictionary, but a
    case-insensitive dictionary with item, attribute, and call access
    to variables. To get a standard Python dictionary, set this option
    to True.
uncompressed_file_name : str, optional
    This option only has an effect for .sav files written with the
    /compress option. If a file name is specified, compressed .sav
    files are uncompressed to this file. Otherwise, readsav will use
    the `tempfile` module to determine a temporary filename
    automatically, and will remove the temporary file upon successfully
    reading it in.
verbose : bool, optional
    Whether to print out information about the save file, including
    the records read, and available variables.

Returns
-------
idl_dict : AttrDict or dict
    If `python_dict` is set to False (default), this function returns a
    case-insensitive dictionary with item, attribute, and call access
    to variables. If `python_dict` is set to True, this function
    returns a Python dictionary with all variable names in lowercase.
    If `idict` was specified, then variables are written to the
    dictionary specified, and the updated dictionary is returned.</docstring>
    <inputPortSpec arg="file_name" name="file_name" show_port="True">
      <docstring>Name of the IDL save file.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="idict" name="idict" port_type="basic:Dictionary">
      <docstring>Dictionary in which to insert .sav file variables</docstring>
    </inputPortSpec>
    <inputPortSpec arg="python_dict" name="python_dict" port_type="basic:Boolean">
      <docstring>By default, the object return is not a Python dictionary, but a
case-insensitive dictionary with item, attribute, and call access
to variables. To get a standard Python dictionary, set this option
to True.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="uncompressed_file_name" name="uncompressed_file_name">
      <docstring>This option only has an effect for .sav files written with the
/compress option. If a file name is specified, compressed .sav
files are uncompressed to this file. Otherwise, readsav will use
the `tempfile` module to determine a temporary filename
automatically, and will remove the temporary file upon successfully
reading it in.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Whether to print out information about the save file, including
the records read, and available variables.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="idl_dict" name="idl_dict" port_type="basic:Dictionary" show_port="True" sort_key="0">
      <docstring>If `python_dict` is set to False (default), this function returns a
case-insensitive dictionary with item, attribute, and call access
to variables. If `python_dict` is set to True, this function
returns a Python dictionary with all variable names in lowercase.
If `idict` was specified, then variables are written to the
dictionary specified, and the updated dictionary is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.savemat" module_name="savemat" namespace="'io'">
    <docstring>Save a dictionary of names and arrays into a MATLAB-style .mat file.

This saves the array objects in the given dictionary to a MATLAB-
style .mat file.

Parameters
----------
file_name : str or file-like object
    Name of the .mat file (.mat extension not needed if ``appendmat ==
    True``).
    Can also pass open file_like object.
mdict : dict
    Dictionary from which to save matfile variables.
appendmat : bool, optional
    True (the default) to append the .mat extension to the end of the
    given filename, if not already present.
format : {'5', '4'}, string, optional
    '5' (the default) for MATLAB 5 and up (to 7.2),
    '4' for MATLAB 4 .mat files
long_field_names : bool, optional
    False (the default) - maximum field name length in a structure is
    31 characters which is the documented maximum length.
    True - maximum field name length in a structure is 63 characters
    which works for MATLAB 7.6+
do_compression : bool, optional
    Whether or not to compress matrices on write.  Default is False.
oned_as : {'row', 'column'}, optional
    If 'column', write 1-D numpy arrays as column vectors.
    If 'row', write 1-D numpy arrays as row vectors.

See also
--------
mio4.MatFile4Writer
mio5.MatFile5Writer</docstring>
    <inputPortSpec arg="file_name" name="file_nameScalar" show_port="True">
      <docstring>Name of the .mat file (.mat extension not needed if ``appendmat ==
True``).
Can also pass open file_like object.</docstring>
      <alternateSpec arg="file_name" name="file_nameSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="mdict" name="mdict" port_type="basic:Dictionary" show_port="True">
      <docstring>Dictionary from which to save matfile variables.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="appendmat" name="appendmat" port_type="basic:Boolean">
      <docstring>True (the default) to append the .mat extension to the end of the
given filename, if not already present.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>'5' (the default) for MATLAB 5 and up (to 7.2),
'4' for MATLAB 4 .mat files</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['5', '4']]</values>
      <defaults>['5']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="long_field_names" name="long_field_names" port_type="basic:Boolean">
      <docstring>False (the default) - maximum field name length in a structure is
31 characters which is the documented maximum length.
True - maximum field name length in a structure is 63 characters
which works for MATLAB 7.6+</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="do_compression" name="do_compression" port_type="basic:Boolean">
      <docstring>Whether or not to compress matrices on write.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="oned_as" name="oned_as">
      <docstring>If 'column', write 1-D numpy arrays as column vectors.
If 'row', write 1-D numpy arrays as row vectors.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['row', 'column']]</values>
      <defaults>['row']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.io.whosmat" module_name="whosmat" namespace="'io'">
    <docstring>List variables inside a MATLAB file

Parameters
----------
file_name : str
   Name of the mat file (do not need .mat extension if
   appendmat==True) Can also pass open file-like object.
appendmat : bool, optional
   True to append the .mat extension to the end of the given
   filename, if not already present.
byte_order : str or None, optional
   None by default, implying byte order guessed from mat
   file. Otherwise can be one of ('native', '=', 'little', '&lt;',
   'BIG', '&gt;').
mat_dtype : bool, optional
   If True, return arrays in same dtype as would be loaded into
   MATLAB (instead of the dtype with which they are saved).
squeeze_me : bool, optional
   Whether to squeeze unit matrix dimensions or not.
chars_as_strings : bool, optional
   Whether to convert char arrays to string arrays.
matlab_compatible : bool, optional
   Returns matrices as would be loaded by MATLAB (implies
   squeeze_me=False, chars_as_strings=False, mat_dtype=True,
   struct_as_record=True).
struct_as_record : bool, optional
   Whether to load MATLAB structs as numpy record arrays, or as
   old-style numpy arrays with dtype=object.  Setting this flag to
   False replicates the behavior of scipy version 0.7.x (returning
   numpy object arrays).  The default setting is True, because it
   allows easier round-trip load and save of MATLAB files.

Returns
-------
variables : list of tuples
    A list of tuples, where each tuple holds the matrix name (a string),
    its shape (tuple of ints), and its data class (a string).
    Possible data classes are: int8, uint8, int16, uint16, int32, uint32,
    int64, uint64, single, double, cell, struct, object, char, sparse,
    function, opaque, logical, unknown.

Notes
-----
v4 (Level 1.0), v6 and v7 to 7.2 matfiles are supported.

You will need an HDF5 python library to read matlab 7.3 format mat
files.  Because scipy does not supply one, we do not implement the
HDF5 / 7.3 interface here.

.. versionadded:: 0.12.0</docstring>
    <inputPortSpec arg="file_name" name="file_name" show_port="True">
      <docstring>Name of the mat file (do not need .mat extension if
appendmat==True) Can also pass open file-like object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="appendmat" name="appendmat" port_type="basic:Boolean">
      <docstring>True to append the .mat extension to the end of the given
filename, if not already present.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="byte_order" name="byte_order">
      <docstring>None by default, implying byte order guessed from mat
file. Otherwise can be one of ('native', '=', 'little', '&lt;',
'BIG', '&gt;').</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mat_dtype" name="mat_dtype" port_type="basic:Boolean">
      <docstring>If True, return arrays in same dtype as would be loaded into
MATLAB (instead of the dtype with which they are saved).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="squeeze_me" name="squeeze_me" port_type="basic:Boolean">
      <docstring>Whether to squeeze unit matrix dimensions or not.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="chars_as_strings" name="chars_as_strings" port_type="basic:Boolean">
      <docstring>Whether to convert char arrays to string arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="matlab_compatible" name="matlab_compatible" port_type="basic:Boolean">
      <docstring>Returns matrices as would be loaded by MATLAB (implies
squeeze_me=False, chars_as_strings=False, mat_dtype=True,
struct_as_record=True).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="struct_as_record" name="struct_as_record" port_type="basic:Boolean">
      <docstring>Whether to load MATLAB structs as numpy record arrays, or as
old-style numpy arrays with dtype=object.  Setting this flag to
False replicates the behavior of scipy version 0.7.x (returning
numpy object arrays).  The default setting is True, because it
allows easier round-trip load and save of MATLAB files.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="variables" name="variables" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A list of tuples, where each tuple holds the matrix name (a string),
its shape (tuple of ints), and its data class (a string).
Possible data classes are: int8, uint8, int16, uint16, int32, uint32,
int64, uint64, single, double, cell, struct, object, char, sparse,
function, opaque, logical, unknown.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.block_diag" module_name="block_diag" namespace="'linalg'">
    <docstring>Create a block diagonal matrix from provided arrays.

Given the inputs `A`, `B` and `C`, the output will have these
arrays arranged on the diagonal::

    [[A, 0, 0],
     [0, B, 0],
     [0, 0, C]]

Parameters
----------
A, B, C, ... : array_like, up to 2-D
    Input arrays.  A 1-D array or array_like sequence of length `n` is
    treated as a 2-D array with shape ``(1,n)``.

Returns
-------
D : ndarray
    Array with `A`, `B`, `C`, ... on the diagonal.  `D` has the
    same dtype as `A`.

Notes
-----
If all the input arrays are square, the output is known as a
block diagonal matrix.

Empty sequences (i.e., array-likes of zero size) are ignored.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import block_diag
&gt;&gt;&gt; A = [[1, 0],
...      [0, 1]]
&gt;&gt;&gt; B = [[3, 4, 5],
...      [6, 7, 8]]
&gt;&gt;&gt; C = [[7]]
&gt;&gt;&gt; block_diag(A, B, C)
[[1 0 0 0 0 0]
 [0 1 0 0 0 0]
 [0 0 3 4 5 0]
 [0 0 6 7 8 0]
 [0 0 0 0 0 7]]
&gt;&gt;&gt; block_diag(1.0, [2, 3], [[4, 5], [6, 7]])
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  2.,  3.,  0.,  0.],
       [ 0.,  0.,  0.,  4.,  5.],
       [ 0.,  0.,  0.,  6.,  7.]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  A 1-D array or array_like sequence of length `n` is
treated as a 2-D array with shape ``(1,n)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  A 1-D array or array_like sequence of length `n` is
treated as a 2-D array with shape ``(1,n)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="C" name="C" port_type="basic:List" show_port="True">
      <docstring>Input arrays.  A 1-D array or array_like sequence of length `n` is
treated as a 2-D array with shape ``(1,n)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>Input arrays.  A 1-D array or array_like sequence of length `n` is
treated as a 2-D array with shape ``(1,n)``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="D" name="D" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array with `A`, `B`, `C`, ... on the diagonal.  `D` has the
same dtype as `A`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.cho_factor" module_name="cho_factor" namespace="'linalg'" output_type="list">
    <docstring>Compute the Cholesky decomposition of a matrix, to use in cho_solve

Returns a matrix containing the Cholesky decomposition,
``A = L L*`` or ``A = U* U`` of a Hermitian positive-definite matrix `a`.
The return value can be directly used as the first parameter to cho_solve.

.. warning::
    The returned matrix also contains random data in the entries not
    used by the Cholesky decomposition. If you need to zero these
    entries, use the function `cholesky` instead.

Parameters
----------
a : (M, M) array_like
    Matrix to be decomposed
lower : bool, optional
    Whether to compute the upper or lower triangular Cholesky factorization
    (Default: upper-triangular)
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
c : (M, M) ndarray
    Matrix whose upper or lower triangle contains the Cholesky factor
    of `a`. Other parts of the matrix contain random data.
lower : bool
    Flag indicating whether the factor is in the lower or upper triangle

Raises
------
LinAlgError
    Raised if decomposition fails.

See also
--------
cho_solve : Solve a linear set equations using the Cholesky factorization
            of a matrix.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be decomposed</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Whether to compute the upper or lower triangular Cholesky factorization
(Default: upper-triangular)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in a (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix whose upper or lower triangle contains the Cholesky factor
of `a`. Other parts of the matrix contain random data.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lower" name="lower" port_type="basic:Boolean" show_port="True" sort_key="1">
      <docstring>Flag indicating whether the factor is in the lower or upper triangle</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.cho_solve" module_name="cho_solve" namespace="'linalg'">
    <docstring>Solve the linear equations A x = b, given the Cholesky factorization of A.

Parameters
----------
(c, lower) : tuple, (array, bool)
    Cholesky factorization of a, as given by cho_factor
b : array
    Right-hand side
overwrite_b : bool, optional
    Whether to overwrite data in b (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : array
    The solution to the system A x = b

See also
--------
cho_factor : Cholesky factorization of a matrix</docstring>
    <inputPortSpec arg="lower)" depth="1" name="lower)" port_type="basic:Boolean" show_port="True">
      <docstring>Cholesky factorization of a, as given by cho_factor</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand side</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in b (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="c_and_lower" name="c_and_lower" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The solution to the system A x = b</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.cho_solve_banded" module_name="cho_solve_banded" namespace="'linalg'">
    <docstring>Solve the linear equations A x = b, given the Cholesky factorization of A.

Parameters
----------
(cb, lower) : tuple, (array, bool)
    `cb` is the Cholesky factorization of A, as given by cholesky_banded.
    `lower` must be the same value that was given to cholesky_banded.
b : array
    Right-hand side
overwrite_b : bool, optional
    If True, the function will overwrite the values in `b`.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : array
    The solution to the system A x = b

See also
--------
cholesky_banded : Cholesky factorization of a banded matrix

Notes
-----

.. versionadded:: 0.8.0</docstring>
    <inputPortSpec arg="lower)" depth="1" name="lower)" port_type="basic:Boolean" show_port="True">
      <docstring>`cb` is the Cholesky factorization of A, as given by cholesky_banded.
`lower` must be the same value that was given to cholesky_banded.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand side</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>If True, the function will overwrite the values in `b`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cb_and_lower" name="cb_and_lower" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The solution to the system A x = b</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.cholesky" module_name="cholesky" namespace="'linalg'">
    <docstring>Compute the Cholesky decomposition of a matrix.

Returns the Cholesky decomposition, :math:`A = L L^*` or
:math:`A = U^* U` of a Hermitian positive-definite matrix A.

Parameters
----------
a : (M, M) array_like
    Matrix to be decomposed
lower : bool, optional
    Whether to compute the upper or lower triangular Cholesky
    factorization.  Default is upper-triangular.
overwrite_a : bool, optional
    Whether to overwrite data in `a` (may improve performance).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
c : (M, M) ndarray
    Upper- or lower-triangular Cholesky factor of `a`.

Raises
------
LinAlgError : if decomposition fails.

Examples
--------
&gt;&gt;&gt; from scipy import array, linalg, dot
&gt;&gt;&gt; a = array([[1,-2j],[2j,5]])
&gt;&gt;&gt; L = linalg.cholesky(a, lower=True)
&gt;&gt;&gt; L
array([[ 1.+0.j,  0.+0.j],
       [ 0.+2.j,  1.+0.j]])
&gt;&gt;&gt; dot(L, L.T.conj())
array([[ 1.+0.j,  0.-2.j],
       [ 0.+2.j,  5.+0.j]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be decomposed</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Whether to compute the upper or lower triangular Cholesky
factorization.  Default is upper-triangular.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in `a` (may improve performance).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Upper- or lower-triangular Cholesky factor of `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.cholesky_banded" module_name="cholesky_banded" namespace="'linalg'">
    <docstring>Cholesky decompose a banded Hermitian positive-definite matrix

The matrix a is stored in ab either in lower diagonal or upper
diagonal ordered form::

    ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
    ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)

Example of ab (shape of a is (6,6), u=2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Parameters
----------
ab : (u + 1, M) array_like
    Banded matrix
overwrite_ab : bool, optional
    Discard data in ab (may enhance performance)
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
c : (u + 1, M) ndarray
    Cholesky factorization of a, in the same banded format as ab</docstring>
    <inputPortSpec arg="ab" name="ab" port_type="basic:List" show_port="True">
      <docstring>Banded matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_ab" name="overwrite_ab" port_type="basic:Boolean">
      <docstring>Discard data in ab (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Is the matrix in the lower form. (Default is upper form)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Cholesky factorization of a, in the same banded format as ab</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.circulant" module_name="circulant" namespace="'linalg'">
    <docstring>Construct a circulant matrix.

Parameters
----------
c : (N,) array_like
    1-D array, the first column of the matrix.

Returns
-------
A : (N, N) ndarray
    A circulant matrix whose first column is `c`.

See also
--------
toeplitz : Toeplitz matrix
hankel : Hankel matrix

Notes
-----
.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import circulant
&gt;&gt;&gt; circulant([1, 2, 3])
array([[1, 3, 2],
       [2, 1, 3],
       [3, 2, 1]])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>1-D array, the first column of the matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A circulant matrix whose first column is `c`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.companion" module_name="companion" namespace="'linalg'">
    <docstring>Create a companion matrix.

Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in `a`.

Parameters
----------
a : (N,) array_like
    1-D array of polynomial coefficients.  The length of `a` must be
    at least two, and ``a[0]`` must not be zero.

Returns
-------
c : (N-1, N-1) ndarray
    The first row of `c` is ``-a[1:]/a[0]``, and the first
    sub-diagonal is all ones.  The data-type of the array is the same
    as the data-type of ``1.0*a[0]``.

Raises
------
ValueError
    If any of the following are true: a) ``a.ndim != 1``;
    b) ``a.size &lt; 2``; c) ``a[0] == 0``.

Notes
-----
.. versionadded:: 0.8.0

References
----------
.. [1] R. A. Horn &amp; C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:
    Cambridge University Press, 1999, pp. 146-7.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import companion
&gt;&gt;&gt; companion([1, -10, 31, -30])
array([[ 10., -31.,  30.],
       [  1.,   0.,   0.],
       [  0.,   1.,   0.]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>1-D array of polynomial coefficients.  The length of `a` must be
at least two, and ``a[0]`` must not be zero.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The first row of `c` is ``-a[1:]/a[0]``, and the first
sub-diagonal is all ones.  The data-type of the array is the same
as the data-type of ``1.0*a[0]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.coshm" module_name="coshm" namespace="'linalg'">
    <docstring>Compute the hyperbolic matrix cosine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
coshm : (N, N) ndarray
    Hyperbolic matrix cosine of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; c = coshm(a)
&gt;&gt;&gt; c
array([[ 11.24592233,  38.76236492],
       [ 12.92078831,  50.00828725]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

&gt;&gt;&gt; t = tanhm(a)
&gt;&gt;&gt; s = sinhm(a)
&gt;&gt;&gt; t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="coshm" name="coshm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hyperbolic matrix cosine of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.cosm" module_name="cosm" namespace="'linalg'">
    <docstring>Compute the matrix cosine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array

Returns
-------
cosm : (N, N) ndarray
    Matrix cosine of A

Examples
--------
&gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

&gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])
&gt;&gt;&gt; expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
&gt;&gt;&gt; cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="cosm" name="cosm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix cosine of A</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.det" module_name="det" namespace="'linalg'">
    <docstring>Compute the determinant of a matrix

The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.

The determinant for a 3x3 matrix, for example, is computed as follows::

    a    b    c
    d    e    f = A
    g    h    i

    det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h

Parameters
----------
a : (M, M) array_like
    A square matrix.
overwrite_a : bool, optional
    Allow overwriting data in a (may enhance performance).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
det : float or complex
    Determinant of `a`.

Notes
-----
The determinant is computed via LU factorization, LAPACK routine z/dgetrf.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; linalg.det(a)
0.0
&gt;&gt;&gt; a = np.array([[0,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; linalg.det(a)
3.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A square matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Allow overwriting data in a (may enhance performance).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="det" name="det" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Determinant of `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.dft" module_name="dft" namespace="'linalg'">
    <docstring>Discrete Fourier transform matrix.

Create the matrix that computes the discrete Fourier transform of a
sequence [1]_.  The n-th primitive root of unity used to generate the
matrix is exp(-2*pi*i/n), where i = sqrt(-1).

Parameters
----------
n : int
    Size the matrix to create.
scale : str, optional
    Must be None, 'sqrtn', or 'n'.
    If `scale` is 'sqrtn', the matrix is divided by `sqrt(n)`.
    If `scale` is 'n', the matrix is divided by `n`.
    If `scale` is None (the default), the matrix is not normalized, and the
    return value is simply the Vandermonde matrix of the roots of unity.

Returns
-------
m : (n, n) ndarray
    The DFT matrix.

Notes
-----
When `scale` is None, multiplying a vector by the matrix returned by
`dft` is mathematically equivalent to (but much less efficient than)
the calculation performed by `scipy.fftpack.fft`.

.. versionadded:: 0.14.0

References
----------
.. [1] "DFT matrix", http://en.wikipedia.org/wiki/DFT_matrix

Examples
--------
&gt;&gt;&gt; from scipy.linalg import dft
&gt;&gt;&gt; np.set_printoptions(precision=5, suppress=True)
&gt;&gt;&gt; x = np.array([1, 2, 3, 0, 3, 2, 1, 0])
&gt;&gt;&gt; m = dft(8)
&gt;&gt;&gt; m.dot(x)   # Compute the DFT of x
array([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,
        -0.+4.j,  -2.+2.j])

Verify that ``m.dot(x)`` is the same as ``fft(x)``.

&gt;&gt;&gt; from scipy.fftpack import fft
&gt;&gt;&gt; fft(x)     # Same result as m.dot(x)
array([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,
         0.+4.j,  -2.+2.j])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Size the matrix to create.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale">
      <docstring>Must be None, 'sqrtn', or 'n'.
If `scale` is 'sqrtn', the matrix is divided by `sqrt(n)`.
If `scale` is 'n', the matrix is divided by `n`.
If `scale` is None (the default), the matrix is not normalized, and the
return value is simply the Vandermonde matrix of the roots of unity.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="m" name="m" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The DFT matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.diagsvd" module_name="diagsvd" namespace="'linalg'">
    <docstring>Construct the sigma matrix in SVD from singular values and size M, N.

Parameters
----------
s : (M,) or (N,) array_like
    Singular values
M : int
    Size of the matrix whose singular values are `s`.
N : int
    Size of the matrix whose singular values are `s`.

Returns
-------
S : (M, N) ndarray
    The S-matrix in the singular value decomposition</docstring>
    <inputPortSpec arg="s" name="sScalar" show_port="True">
      <docstring>Singular values</docstring>
      <alternateSpec arg="s" name="sSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Size of the matrix whose singular values are `s`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>Size of the matrix whose singular values are `s`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The S-matrix in the singular value decomposition</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.eig" module_name="eig" namespace="'linalg'" output_type="list">
    <docstring>Solve an ordinary or generalized eigenvalue problem of a square matrix.

Find eigenvalues w and right or left eigenvectors of a general matrix::

    a   vr[:,i] = w[i]        b   vr[:,i]
    a.H vl[:,i] = w[i].conj() b.H vl[:,i]

where ``.H`` is the Hermitian conjugation.

Parameters
----------
a : (M, M) array_like
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.
b : (M, M) array_like, optional
    Right-hand side matrix in a generalized eigenvalue problem.
    Default is None, identity matrix is assumed.
left : bool, optional
    Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
    Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
    Whether to overwrite `a`; may improve performance.  Default is False.
overwrite_b : bool, optional
    Whether to overwrite `b`; may improve performance.  Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (M,) double or complex ndarray
    The eigenvalues, each repeated according to its multiplicity.
vl : (M, M) double or complex ndarray
    The normalized left eigenvector corresponding to the eigenvalue
    ``w[i]`` is the column vl[:,i]. Only returned if ``left=True``.
vr : (M, M) double or complex ndarray
    The normalized right eigenvector corresponding to the eigenvalue
    ``w[i]`` is the column ``vr[:,i]``.  Only returned if ``right=True``.

Raises
------
LinAlgError
    If eigenvalue computation does not converge.

See Also
--------
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A complex or real matrix whose eigenvalues and eigenvectors
will be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List">
      <docstring>Right-hand side matrix in a generalized eigenvalue problem.
Default is None, identity matrix is assumed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="left" name="left" port_type="basic:Boolean">
      <docstring>Whether to calculate and return left eigenvectors.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="right" name="right" port_type="basic:Boolean">
      <docstring>Whether to calculate and return right eigenvectors.  Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite `a`; may improve performance.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Whether to overwrite `b`; may improve performance.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The eigenvalues, each repeated according to its multiplicity.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vl" name="vl" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The normalized left eigenvector corresponding to the eigenvalue
``w[i]`` is the column vl[:,i]. Only returned if ``left=True``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vr" name="vr" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>The normalized right eigenvector corresponding to the eigenvalue
``w[i]`` is the column ``vr[:,i]``.  Only returned if ``right=True``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.eig_banded" module_name="eig_banded" namespace="'linalg'" output_type="list">
    <docstring>Solve real symmetric or complex hermitian band matrix eigenvalue problem.

Find eigenvalues w and optionally right eigenvectors v of a::

    a v[:,i] = w[i] v[:,i]
    v.H v    = identity

The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:

    a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
    a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)

where u is the number of bands above the diagonal.

Example of a_band (shape of a is (6,6), u=2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Cells marked with * are not used.

Parameters
----------
a_band : (u+1, M) array_like
    The bands of the M by M matrix a.
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
eigvals_only : bool, optional
    Compute only the eigenvalues and no eigenvectors.
    (Default: calculate also eigenvectors)
overwrite_a_band : bool, optional
    Discard data in a_band (may enhance performance)
select : {'a', 'v', 'i'}, optional
    Which eigenvalues to calculate

    ======  ========================================
    select  calculated
    ======  ========================================
    'a'     All eigenvalues
    'v'     Eigenvalues in the interval (min, max]
    'i'     Eigenvalues with indices min &lt;= i &lt;= max
    ======  ========================================
select_range : (min, max), optional
    Range of selected eigenvalues
max_ev : int, optional
    For select=='v', maximum number of eigenvalues expected.
    For other values of select, has no meaning.

    In doubt, leave this parameter untouched.

check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (M,) ndarray
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.
v : (M, M) float or complex ndarray
    The normalized eigenvector corresponding to the eigenvalue w[i] is
    the column v[:,i].

Raises LinAlgError if eigenvalue computation does not converge</docstring>
    <inputPortSpec arg="a_band" name="a_band" port_type="basic:List" show_port="True">
      <docstring>The bands of the M by M matrix a.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Is the matrix in the lower form. (Default is upper form)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="eigvals_only" name="eigvals_only" port_type="basic:Boolean">
      <docstring>Compute only the eigenvalues and no eigenvectors.
(Default: calculate also eigenvectors)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a_band" name="overwrite_a_band" port_type="basic:Boolean">
      <docstring>Discard data in a_band (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="select" name="select">
      <docstring>Which eigenvalues to calculate

======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['a', 'v', 'i']]</values>
      <defaults>['a']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="select_range" name="select_range" port_type="basic:Variant">
      <docstring>Range of selected eigenvalues</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max_ev" name="max_ev" port_type="basic:Integer">
      <docstring>For select=='v', maximum number of eigenvalues expected.
For other values of select, has no meaning.

In doubt, leave this parameter untouched.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The eigenvalues, in ascending order, each repeated according to its
multiplicity.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The normalized eigenvector corresponding to the eigenvalue w[i] is
the column v[:,i].
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="2" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.eigh" module_name="eigh" namespace="'linalg'" output_type="list">
    <docstring>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.

Find eigenvalues w and optionally eigenvectors v of matrix `a`, where
`b` is positive definite::

                  a v[:,i] = w[i] b v[:,i]
    v[i,:].conj() a v[:,i] = w[i]
    v[i,:].conj() b v[:,i] = 1

Parameters
----------
a : (M, M) array_like
    A complex Hermitian or real symmetric matrix whose eigenvalues and
    eigenvectors will be computed.
b : (M, M) array_like, optional
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.
lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of `a`. (Default: lower)
eigvals_only : bool, optional
    Whether to calculate only eigenvalues and no eigenvectors.
    (Default: both are calculated)
turbo : bool, optional
    Use divide and conquer algorithm (faster but expensive in memory,
    only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
    Indexes of the smallest and largest (in ascending order) eigenvalues
    and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
    If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
    Specifies the problem type to be solved:

       type = 1: a   v[:,i] = w[i] b v[:,i]

       type = 2: a b v[:,i] = w[i]   v[:,i]

       type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
    Whether to overwrite data in `a` (may improve performance)
overwrite_b : bool, optional
    Whether to overwrite data in `b` (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (N,) float ndarray
    The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.
v : (M, N) complex ndarray
    (if eigvals_only == False)

    The normalized selected eigenvector corresponding to the
    eigenvalue w[i] is the column v[:,i].

    Normalization:

        type 1 and 3: v.conj() a      v  = w

        type 2: inv(v).conj() a  inv(v) = w

        type = 1 or 2: v.conj() b      v  = I

        type = 3: v.conj() inv(b) v  = I

Raises
------
LinAlgError :
    If eigenvalue computation does not converge,
    an error occurred, or b matrix is not definite positive. Note that
    if input matrices are not symmetric or hermitian, no error is reported
    but results will be wrong.

See Also
--------
eig : eigenvalues and right eigenvectors for non-symmetric arrays</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List">
      <docstring>A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Whether the pertinent array data is taken from the lower or upper
triangle of `a`. (Default: lower)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="eigvals_only" name="eigvals_only" port_type="basic:Boolean">
      <docstring>Whether to calculate only eigenvalues and no eigenvectors.
(Default: both are calculated)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="turbo" name="turbo" port_type="basic:Boolean">
      <docstring>Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="eigvals" name="eigvals" port_type="basic:List">
      <docstring>Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>Specifies the problem type to be solved:

   type = 1: a   v[:,i] = w[i] b v[:,i]

   type = 2: a b v[:,i] = w[i]   v[:,i]

   type = 3: b a v[:,i] = w[i]   v[:,i]</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in `a` (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in `b` (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" depth="1" name="w" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>(if eigvals_only == False)

The normalized selected eigenvector corresponding to the
eigenvalue w[i] is the column v[:,i].

Normalization:

    type 1 and 3: v.conj() a      v  = w

    type 2: inv(v).conj() a  inv(v) = w

    type = 1 or 2: v.conj() b      v  = I

    type = 3: v.conj() inv(b) v  = I</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.eigvals" module_name="eigvals" namespace="'linalg'">
    <docstring>Compute eigenvalues from an ordinary or generalized eigenvalue problem.

Find eigenvalues of a general matrix::

    a   vr[:,i] = w[i]        b   vr[:,i]

Parameters
----------
a : (M, M) array_like
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.
b : (M, M) array_like, optional
    Right-hand side matrix in a generalized eigenvalue problem.
    If omitted, identity matrix is assumed.
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (M,) double or complex ndarray
    The eigenvalues, each repeated according to its multiplicity,
    but not in any specific order.

Raises
------
LinAlgError
    If eigenvalue computation does not converge

See Also
--------
eigvalsh : eigenvalues of symmetric or Hermitian arrays,
eig : eigenvalues and right eigenvectors of general arrays.
eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A complex or real matrix whose eigenvalues and eigenvectors
will be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List">
      <docstring>Right-hand side matrix in a generalized eigenvalue problem.
If omitted, identity matrix is assumed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in a (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The eigenvalues, each repeated according to its multiplicity,
but not in any specific order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.eigvals_banded" module_name="eigvals_banded" namespace="'linalg'" output_type="list">
    <docstring>Solve real symmetric or complex hermitian band matrix eigenvalue problem.

Find eigenvalues w of a::

    a v[:,i] = w[i] v[:,i]
    v.H v    = identity

The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:

    a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
    a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)

where u is the number of bands above the diagonal.

Example of a_band (shape of a is (6,6), u=2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Cells marked with * are not used.

Parameters
----------
a_band : (u+1, M) array_like
    The bands of the M by M matrix a.
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
overwrite_a_band : bool, optional
    Discard data in a_band (may enhance performance)
select : {'a', 'v', 'i'}, optional
    Which eigenvalues to calculate

    ======  ========================================
    select  calculated
    ======  ========================================
    'a'     All eigenvalues
    'v'     Eigenvalues in the interval (min, max]
    'i'     Eigenvalues with indices min &lt;= i &lt;= max
    ======  ========================================
select_range : (min, max), optional
    Range of selected eigenvalues
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (M,) ndarray
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.

Raises LinAlgError if eigenvalue computation does not converge

See Also
--------
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
    band matrices
eigvals : eigenvalues of general arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays</docstring>
    <inputPortSpec arg="a_band" name="a_band" port_type="basic:List" show_port="True">
      <docstring>The bands of the M by M matrix a.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Is the matrix in the lower form. (Default is upper form)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a_band" name="overwrite_a_band" port_type="basic:Boolean">
      <docstring>Discard data in a_band (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="select" name="select">
      <docstring>Which eigenvalues to calculate

======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['a', 'v', 'i']]</values>
      <defaults>['a']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="select_range" name="select_range" port_type="basic:Variant">
      <docstring>Range of selected eigenvalues</docstring>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The eigenvalues, in ascending order, each repeated according to its
multiplicity.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="1" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.eigvalsh" module_name="eigvalsh" namespace="'linalg'">
    <docstring>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.

Find eigenvalues w of matrix a, where b is positive definite::

                  a v[:,i] = w[i] b v[:,i]
    v[i,:].conj() a v[:,i] = w[i]
    v[i,:].conj() b v[:,i] = 1


Parameters
----------
a : (M, M) array_like
    A complex Hermitian or real symmetric matrix whose eigenvalues and
    eigenvectors will be computed.
b : (M, M) array_like, optional
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.
lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of `a`. (Default: lower)
turbo : bool, optional
    Use divide and conquer algorithm (faster but expensive in memory,
    only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
    Indexes of the smallest and largest (in ascending order) eigenvalues
    and corresponding eigenvectors to be returned: 0 &lt;= lo &lt; hi &lt;= M-1.
    If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
    Specifies the problem type to be solved:

       type = 1: a   v[:,i] = w[i] b v[:,i]

       type = 2: a b v[:,i] = w[i]   v[:,i]

       type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
    Whether to overwrite data in `a` (may improve performance)
overwrite_b : bool, optional
    Whether to overwrite data in `b` (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (N,) float ndarray
    The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.

Raises
------
LinAlgError :
    If eigenvalue computation does not converge,
    an error occurred, or b matrix is not definite positive. Note that
    if input matrices are not symmetric or hermitian, no error is reported
    but results will be wrong.

See Also
--------
eigvals : eigenvalues of general arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List">
      <docstring>A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Whether the pertinent array data is taken from the lower or upper
triangle of `a`. (Default: lower)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="turbo" name="turbo" port_type="basic:Boolean">
      <docstring>Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="eigvals" name="eigvals" port_type="basic:List">
      <docstring>Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt; hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>Specifies the problem type to be solved:

   type = 1: a   v[:,i] = w[i] b v[:,i]

   type = 2: a b v[:,i] = w[i]   v[:,i]

   type = 3: b a v[:,i] = w[i]   v[:,i]</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in `a` (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in `b` (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" depth="1" name="w" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.expm" module_name="expm" namespace="'linalg'">
    <docstring>Compute the matrix exponential using Pade approximation.

Parameters
----------
A : (N, N) array_like or sparse matrix
    Matrix to be exponentiated.

Returns
-------
expm : (N, N) ndarray
    Matrix exponential of `A`.

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       "A New Scaling and Squaring Algorithm for the Matrix Exponential."
       SIAM Journal on Matrix Analysis and Applications.
       31 (3). pp. 970-989. ISSN 1095-7162

Examples
--------
&gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm

Matrix version of the formula exp(0) = 1:

&gt;&gt;&gt; expm(np.zeros((2,2)))
array([[ 1.,  0.],
       [ 0.,  1.]])

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

&gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])
&gt;&gt;&gt; expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
&gt;&gt;&gt; cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>Matrix to be exponentiated.</docstring>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="expm" name="expm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix exponential of `A`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.expm2" module_name="expm2" namespace="'linalg'">
    <docstring>`expm2` is deprecated, use `expm` instead!


Compute the matrix exponential using eigenvalue decomposition.

Parameters
----------
A : (N, N) array_like
    Matrix to be exponentiated

Returns
-------
expm2 : (N, N) ndarray
    Matrix exponential of `A`</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix to be exponentiated</docstring>
    </inputPortSpec>
    <outputPortSpec arg="expm2" name="expm2" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix exponential of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.expm3" module_name="expm3" namespace="'linalg'">
    <docstring>`expm3` is deprecated, use `expm` instead!


Compute the matrix exponential using Taylor series.

Parameters
----------
A : (N, N) array_like
    Matrix to be exponentiated
q : int
    Order of the Taylor series used is `q-1`

Returns
-------
expm3 : (N, N) ndarray
    Matrix exponential of `A`</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix to be exponentiated</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:Integer" show_port="True">
      <docstring>Order of the Taylor series used is `q-1`</docstring>
    </inputPortSpec>
    <outputPortSpec arg="expm3" name="expm3" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix exponential of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.expm_cond" module_name="expm_cond" namespace="'linalg'">
    <docstring>Relative condition number of the matrix exponential in the Frobenius norm.

Parameters
----------
A : 2d array_like
    Square input matrix with shape (N, N).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
kappa : float
    The relative condition number of the matrix exponential
    in the Frobenius norm

Notes
-----
A faster estimate for the condition number in the 1-norm
has been published but is not yet implemented in scipy.

.. versionadded:: 0.14.0

See also
--------
expm : Compute the exponential of a matrix.
expm_frechet : Compute the Frechet derivative of the matrix exponential.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Square input matrix with shape (N, N).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="kappa" name="kappa" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The relative condition number of the matrix exponential
in the Frobenius norm</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.expm_frechet" module_name="expm_frechet" namespace="'linalg'" output_type="list">
    <docstring>Frechet derivative of the matrix exponential of A in the direction E.

Parameters
----------
A : (N, N) array_like
    Matrix of which to take the matrix exponential.
E : (N, N) array_like
    Matrix direction in which to take the Frechet derivative.
method : str, optional
    Choice of algorithm.  Should be one of

    - `SPS` (default)
    - `blockEnlarge`

compute_expm : bool, optional
    Whether to compute also `expm_A` in addition to `expm_frechet_AE`.
    Default is True.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
expm_A : ndarray
    Matrix exponential of A.
expm_frechet_AE : ndarray
    Frechet derivative of the matrix exponential of A in the direction E.

For ``compute_expm = False``, only `expm_frechet_AE` is returned.

See also
--------
expm : Compute the exponential of a matrix.

Notes
-----
This section describes the available implementations that can be selected
by the `method` parameter. The default method is *SPS*.

Method *blockEnlarge* is a naive algorithm.

Method *SPS* is Scaling-Pade-Squaring [1]_.
It is a sophisticated implementation which should take
only about 3/8 as much time as the naive implementation.
The asymptotics are the same.

.. versionadded:: 0.13.0

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       Computing the Frechet Derivative of the Matrix Exponential,
       with an application to Condition Number Estimation.
       SIAM Journal On Matrix Analysis and Applications.,
       30 (4). pp. 1639-1657. ISSN 1095-7162

Examples
--------
&gt;&gt;&gt; import scipy.linalg
&gt;&gt;&gt; A = np.random.randn(3, 3)
&gt;&gt;&gt; E = np.random.randn(3, 3)
&gt;&gt;&gt; expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)
&gt;&gt;&gt; expm_A.shape, expm_frechet_AE.shape
((3, 3), (3, 3))

&gt;&gt;&gt; import scipy.linalg
&gt;&gt;&gt; A = np.random.randn(3, 3)
&gt;&gt;&gt; E = np.random.randn(3, 3)
&gt;&gt;&gt; expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)
&gt;&gt;&gt; M = np.zeros((6, 6))
&gt;&gt;&gt; M[:3, :3] = A; M[:3, 3:] = E; M[3:, 3:] = A
&gt;&gt;&gt; expm_M = scipy.linalg.expm(M)
&gt;&gt;&gt; np.allclose(expm_A, expm_M[:3, :3])
True
&gt;&gt;&gt; np.allclose(expm_frechet_AE, expm_M[:3, 3:])
True</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix of which to take the matrix exponential.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="E" name="E" port_type="basic:List" show_port="True">
      <docstring>Matrix direction in which to take the Frechet derivative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Choice of algorithm.  Should be one of

- `SPS` (default)
- `blockEnlarge`
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="compute_expm" name="compute_expm" port_type="basic:Boolean">
      <docstring>Whether to compute also `expm_A` in addition to `expm_frechet_AE`.
Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="expm_A" name="expm_A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix exponential of A.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="expm_frechet_AE" name="expm_frechet_AE" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Frechet derivative of the matrix exponential of A in the direction E.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="2" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.find_best_blas_type" module_name="find_best_blas_type" namespace="'linalg'" output_type="list">
    <docstring>Find best-matching BLAS/LAPACK type.

Arrays are used to determine the optimal prefix of BLAS routines.

Parameters
----------
arrays : sequence of ndarrays, optional
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.
dtype : str or dtype, optional
    Data-type specifier. Not used if `arrays` is non-empty.

Returns
-------
prefix : str
    BLAS/LAPACK prefix character.
dtype : dtype
    Inferred Numpy data type.
prefer_fortran : bool
    Whether to prefer Fortran order routines over C order.</docstring>
    <inputPortSpec arg="arrays" name="arrays" port_type="basic:List">
      <docstring>Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype">
      <docstring>Data-type specifier. Not used if `arrays` is non-empty.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="prefix" name="prefix" show_port="True" sort_key="0">
      <docstring>BLAS/LAPACK prefix character.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="dtype" name="dtype" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Inferred Numpy data type.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="prefer_fortran" name="prefer_fortran" port_type="basic:Boolean" show_port="True" sort_key="2">
      <docstring>Whether to prefer Fortran order routines over C order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.fractional_matrix_power" module_name="fractional_matrix_power" namespace="'linalg'">
    <docstring>Compute the fractional power of a matrix.

Proceeds according to the discussion in section (6) of [1]_.

Parameters
----------
A : (N, N) array_like
    Matrix whose fractional power to evaluate.
t : float
    Fractional power.

Returns
-------
X : (N, N) array_like
    The fractional power of the matrix.

References
----------
.. [1] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

Examples
--------
&gt;&gt;&gt; from scipy.linalg import fractional_matrix_power
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; b = fractional_matrix_power(a, 0.5)
&gt;&gt;&gt; b
array([[ 0.75592895,  1.13389342],
       [ 0.37796447,  1.88982237]])
&gt;&gt;&gt; np.dot(b, b)      # Verify square root
array([[ 1.,  3.],
       [ 1.,  4.]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix whose fractional power to evaluate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:Float" show_port="True">
      <docstring>Fractional power.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="X" name="X" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The fractional power of the matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.funm" module_name="funm" namespace="'linalg'" output_type="list">
    <docstring>Evaluate a matrix function specified by a callable.

Returns the value of matrix-valued function ``f`` at `A`. The
function ``f`` is an extension of the scalar-valued function `func`
to matrices.

Parameters
----------
A : (N, N) array_like
    Matrix at which to evaluate the function
func : callable
    Callable object that evaluates a scalar function f.
    Must be vectorized (eg. using vectorize).
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
funm : (N, N) ndarray
    Value of the matrix function specified by func evaluated at `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

Examples
--------
&gt;&gt;&gt; from scipy.linalg import funm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; funm(a, lambda x: x*x)
array([[  4.,  15.],
       [  5.,  19.]])
&gt;&gt;&gt; a.dot(a)
array([[  4.,  15.],
       [  5.,  19.]])

Notes
-----
This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).

If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do

&gt;&gt;&gt; from scipy.linalg import eigh
&gt;&gt;&gt; def funm_herm(a, func, check_finite=False):
...     w, v = eigh(a, check_finite=check_finite)
...     ## if you further know that your matrix is positive semidefinite,
...     ## you can optionally guard against precision errors by doing
...     # w = np.maximum(w, 0)
...     w = func(w)
...     return (v * w).dot(v.conj().T)

References
----------
.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix at which to evaluate the function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Callable object that evaluates a scalar function f.
Must be vectorized (eg. using vectorize).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="funm" name="funm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Value of the matrix function specified by func evaluated at `A`</docstring>
    </outputPortSpec>
    <outputPortSpec arg="errest" name="errest" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>(if disp == False)

1-norm of the estimated error, ||err||_1 / ||A||_1</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.get_blas_funcs" module_name="get_blas_funcs" namespace="'linalg'">
    <docstring>Return available BLAS function objects from names.

Arrays are used to determine the optimal prefix of BLAS routines.

Parameters
----------
names : str or sequence of str
    Name(s) of BLAS functions without type prefix.

arrays : sequence of ndarrays, optional
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.

dtype : str or dtype, optional
    Data-type specifier. Not used if `arrays` is non-empty.


Returns
-------
funcs : list
    List containing the found function(s).


Notes
-----
This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.

In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes `typecode` and `dtype`
of the returned functions.</docstring>
    <inputPortSpec arg="names" name="namesScalar" show_port="True">
      <docstring>Name(s) of BLAS functions without type prefix.
</docstring>
      <alternateSpec arg="names" depth="1" name="namesSequence" />
    </inputPortSpec>
    <inputPortSpec arg="arrays" name="arrays" port_type="basic:List">
      <docstring>Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.
</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype">
      <docstring>Data-type specifier. Not used if `arrays` is non-empty.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="funcs" name="funcs" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>List containing the found function(s).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.get_lapack_funcs" module_name="get_lapack_funcs" namespace="'linalg'">
    <docstring>Return available LAPACK function objects from names.

Arrays are used to determine the optimal prefix of LAPACK routines.

Parameters
----------
names : str or sequence of str
    Name(s) of LAPACK functions without type prefix.

arrays : sequence of ndarrays, optional
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.

dtype : str or dtype, optional
    Data-type specifier. Not used if `arrays` is non-empty.


Returns
-------
funcs : list
    List containing the found function(s).


Notes
-----
This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.

In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectevely, and
are stored in attribute `typecode` of the returned functions.</docstring>
    <inputPortSpec arg="names" name="namesScalar" show_port="True">
      <docstring>Name(s) of LAPACK functions without type prefix.
</docstring>
      <alternateSpec arg="names" depth="1" name="namesSequence" />
    </inputPortSpec>
    <inputPortSpec arg="arrays" name="arrays" port_type="basic:List">
      <docstring>Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.
</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype">
      <docstring>Data-type specifier. Not used if `arrays` is non-empty.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="funcs" name="funcs" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>List containing the found function(s).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.hadamard" module_name="hadamard" namespace="'linalg'">
    <docstring>Construct a Hadamard matrix.

Constructs an n-by-n Hadamard matrix, using Sylvester's
construction.  `n` must be a power of 2.

Parameters
----------
n : int
    The order of the matrix.  `n` must be a power of 2.
dtype : dtype, optional
    The data type of the array to be constructed.

Returns
-------
H : (n, n) ndarray
    The Hadamard matrix.

Notes
-----
.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hadamard
&gt;&gt;&gt; hadamard(2, dtype=complex)
array([[ 1.+0.j,  1.+0.j],
       [ 1.+0.j, -1.-0.j]])
&gt;&gt;&gt; hadamard(4)
array([[ 1,  1,  1,  1],
       [ 1, -1,  1, -1],
       [ 1,  1, -1, -1],
       [ 1, -1, -1,  1]])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The order of the matrix.  `n` must be a power of 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data type of the array to be constructed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="H" name="H" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Hadamard matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.hankel" module_name="hankel" namespace="'linalg'">
    <docstring>Construct a Hankel matrix.

The Hankel matrix has constant anti-diagonals, with `c` as its
first column and `r` as its last row.  If `r` is not given, then
`r = zeros_like(c)` is assumed.

Parameters
----------
c : array_like
    First column of the matrix.  Whatever the actual shape of `c`, it
    will be converted to a 1-D array.
r : array_like, optional
    Last row of the matrix. If None, ``r = zeros_like(c)`` is assumed.
    r[0] is ignored; the last row of the returned matrix is
    ``[c[-1], r[1:]]``.  Whatever the actual shape of `r`, it will be
    converted to a 1-D array.

Returns
-------
A : (len(c), len(r)) ndarray
    The Hankel matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.

See also
--------
toeplitz : Toeplitz matrix
circulant : circulant matrix

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hankel
&gt;&gt;&gt; hankel([1, 17, 99])
array([[ 1, 17, 99],
       [17, 99,  0],
       [99,  0,  0]])
&gt;&gt;&gt; hankel([1,2,3,4], [4,7,7,8,9])
array([[1, 2, 3, 4, 7],
       [2, 3, 4, 7, 7],
       [3, 4, 7, 7, 8],
       [4, 7, 7, 8, 9]])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>First column of the matrix.  Whatever the actual shape of `c`, it
will be converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" name="r" port_type="basic:List">
      <docstring>Last row of the matrix. If None, ``r = zeros_like(c)`` is assumed.
r[0] is ignored; the last row of the returned matrix is
``[c[-1], r[1:]]``.  Whatever the actual shape of `r`, it will be
converted to a 1-D array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Hankel matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.helmert" module_name="helmert" namespace="'linalg'">
    <docstring>Create a Helmert matrix of order `n`.

This has applications in statistics, compositional or simplicial analysis,
and in Aitchison geometry.

Parameters
----------
n : int
    The size of the array to create.
full : bool, optional
    If True the (n, n) ndarray will be returned.
    Otherwise the submatrix that does not include the first
    row will be returned.
    Default: False.

Returns
-------
M : ndarray
    The Helmert matrix.
    The shape is (n, n) or (n-1, n) depending on the `full` argument.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import helmert
&gt;&gt;&gt; helmert(5, full=True)
array([[ 0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ],
       [ 0.70710678, -0.70710678,  0.        ,  0.        ,  0.        ],
       [ 0.40824829,  0.40824829, -0.81649658,  0.        ,  0.        ],
       [ 0.28867513,  0.28867513,  0.28867513, -0.8660254 ,  0.        ],
       [ 0.2236068 ,  0.2236068 ,  0.2236068 ,  0.2236068 , -0.89442719]])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The size of the array to create.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full" name="full" port_type="basic:Boolean">
      <docstring>If True the (n, n) ndarray will be returned.
Otherwise the submatrix that does not include the first
row will be returned.
Default: False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="M" name="M" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Helmert matrix.
The shape is (n, n) or (n-1, n) depending on the `full` argument.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.hessenberg" module_name="hessenberg" namespace="'linalg'" output_type="list">
    <docstring>Compute Hessenberg form of a matrix.

The Hessenberg decomposition is::

    A = Q H Q^H

where `Q` is unitary/orthogonal and `H` has only zero elements below
the first sub-diagonal.

Parameters
----------
a : (M, M) array_like
    Matrix to bring into Hessenberg form.
calc_q : bool, optional
    Whether to compute the transformation matrix.  Default is False.
overwrite_a : bool, optional
    Whether to overwrite `a`; may improve performance.
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
H : (M, M) ndarray
    Hessenberg form of `a`.
Q : (M, M) ndarray
    Unitary/orthogonal similarity transformation matrix ``A = Q H Q^H``.
    Only returned if ``calc_q=True``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to bring into Hessenberg form.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="calc_q" name="calc_q" port_type="basic:Boolean">
      <docstring>Whether to compute the transformation matrix.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite `a`; may improve performance.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="H" name="H" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hessenberg form of `a`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Q" name="Q" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Unitary/orthogonal similarity transformation matrix ``A = Q H Q^H``.
Only returned if ``calc_q=True``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.hilbert" module_name="hilbert" namespace="'linalg'">
    <docstring>Create a Hilbert matrix of order `n`.

Returns the `n` by `n` array with entries `h[i,j] = 1 / (i + j + 1)`.

Parameters
----------
n : int
    The size of the array to create.

Returns
-------
h : (n, n) ndarray
    The Hilbert matrix.

See Also
--------
invhilbert : Compute the inverse of a Hilbert matrix.

Notes
-----
.. versionadded:: 0.10.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hilbert
&gt;&gt;&gt; hilbert(3)
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.5       ,  0.33333333,  0.25      ],
       [ 0.33333333,  0.25      ,  0.2       ]])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The size of the array to create.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="h" name="h" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Hilbert matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.inv" module_name="inv" namespace="'linalg'">
    <docstring>Compute the inverse of a matrix.

Parameters
----------
a : array_like
    Square matrix to be inverted.
overwrite_a : bool, optional
    Discard data in `a` (may improve performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
ainv : ndarray
    Inverse of the matrix `a`.

Raises
------
LinAlgError :
    If `a` is singular.
ValueError :
    If `a` is not square, or not 2-dimensional.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
&gt;&gt;&gt; linalg.inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
&gt;&gt;&gt; np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
       [ 0.,  1.]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Square matrix to be inverted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Discard data in `a` (may improve performance). Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ainv" name="ainv" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Inverse of the matrix `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.invhilbert" module_name="invhilbert" namespace="'linalg'">
    <docstring>Compute the inverse of the Hilbert matrix of order `n`.

The entries in the inverse of a Hilbert matrix are integers.  When `n`
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers.  The `exact` argument provides two options for
dealing with these large integers.

Parameters
----------
n : int
    The order of the Hilbert matrix.
exact : bool, optional
    If False, the data type of the array that is returned is np.float64,
    and the array is an approximation of the inverse.
    If True, the array is the exact integer inverse array.  To represent
    the exact inverse when n &gt; 14, the returned array is an object array
    of long integers.  For n &lt;= 14, the exact inverse is returned as an
    array with data type np.int64.

Returns
-------
invh : (n, n) ndarray
    The data type of the array is np.float64 if `exact` is False.
    If `exact` is True, the data type is either np.int64 (for n &lt;= 14)
    or object (for n &gt; 14).  In the latter case, the objects in the
    array will be long integers.

See Also
--------
hilbert : Create a Hilbert matrix.

Notes
-----
.. versionadded:: 0.10.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import invhilbert
&gt;&gt;&gt; invhilbert(4)
array([[   16.,  -120.,   240.,  -140.],
       [ -120.,  1200., -2700.,  1680.],
       [  240., -2700.,  6480., -4200.],
       [ -140.,  1680., -4200.,  2800.]])
&gt;&gt;&gt; invhilbert(4, exact=True)
array([[   16,  -120,   240,  -140],
       [ -120,  1200, -2700,  1680],
       [  240, -2700,  6480, -4200],
       [ -140,  1680, -4200,  2800]], dtype=int64)
&gt;&gt;&gt; invhilbert(16)[7,7]
4.2475099528537506e+19
&gt;&gt;&gt; invhilbert(16, exact=True)[7,7]
42475099528537378560L</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The order of the Hilbert matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>If False, the data type of the array that is returned is np.float64,
and the array is an approximation of the inverse.
If True, the array is the exact integer inverse array.  To represent
the exact inverse when n &gt; 14, the returned array is an object array
of long integers.  For n &lt;= 14, the exact inverse is returned as an
array with data type np.int64.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="invh" name="invh" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The data type of the array is np.float64 if `exact` is False.
If `exact` is True, the data type is either np.int64 (for n &lt;= 14)
or object (for n &gt; 14).  In the latter case, the objects in the
array will be long integers.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.invpascal" module_name="invpascal" namespace="'linalg'">
    <docstring>Returns the inverse of the n x n Pascal matrix.

The Pascal matrix is a matrix containing the binomial coefficients as
its elements.

Parameters
----------
n : int
    The size of the matrix to create; that is, the result is an n x n
    matrix.
kind : str, optional
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.
exact : bool, optional
    If `exact` is True, the result is either an array of type
    `numpy.int64` (if `n` &lt;= 35) or an object array of Python integers.
    If `exact` is False, the coefficients in the matrix are computed using
    `scipy.special.comb` with `exact=False`.  The result will be a floating
    point array, and for large `n`, the values in the array will not be the
    exact coefficients.

Returns
-------
invp : (n, n) ndarray
    The inverse of the Pascal matrix.

See Also
--------
pascal

Notes
-----

.. versionadded:: 0.16.0

References
----------
.. [1] "Pascal matrix",  http://en.wikipedia.org/wiki/Pascal_matrix
.. [2] Cohen, A. M., "The inverse of a Pascal matrix", Mathematical
       Gazette, 59(408), pp. 111-112, 1975.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import invpascal, pascal
&gt;&gt;&gt; invp = invpascal(5)
&gt;&gt;&gt; invp
array([[  5, -10,  10,  -5,   1],
       [-10,  30, -35,  19,  -4],
       [ 10, -35,  46, -27,   6],
       [ -5,  19, -27,  17,  -4],
       [  1,  -4,   6,  -4,   1]])

&gt;&gt;&gt; p = pascal(5)
&gt;&gt;&gt; p.dot(invp)
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  1.]])

An example of the use of `kind` and `exact`:

&gt;&gt;&gt; invpascal(5, kind='lower', exact=False)
array([[ 1., -0.,  0., -0.,  0.],
       [-1.,  1., -0.,  0., -0.],
       [ 1., -2.,  1., -0.,  0.],
       [-1.,  3., -3.,  1., -0.],
       [ 1., -4.,  6., -4.,  1.]])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The size of the matrix to create; that is, the result is an n x n
matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Must be one of 'symmetric', 'lower', or 'upper'.
Default is 'symmetric'.</docstring>
      <defaults>['symmetric']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>If `exact` is True, the result is either an array of type
`numpy.int64` (if `n` &lt;= 35) or an object array of Python integers.
If `exact` is False, the coefficients in the matrix are computed using
`scipy.special.comb` with `exact=False`.  The result will be a floating
point array, and for large `n`, the values in the array will not be the
exact coefficients.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="invp" name="invp" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The inverse of the Pascal matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.kron" module_name="kron" namespace="'linalg'">
    <docstring>Kronecker product.

The result is the block matrix::

    a[0,0]*b    a[0,1]*b  ... a[0,-1]*b
    a[1,0]*b    a[1,1]*b  ... a[1,-1]*b
    ...
    a[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b

Parameters
----------
a : (M, N) ndarray
    Input array
b : (P, Q) ndarray
    Input array

Returns
-------
A : (M*P, N*Q) ndarray
    Kronecker product of `a` and `b`.

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.linalg import kron
&gt;&gt;&gt; kron(array([[1,2],[3,4]]), array([[1,1,1]]))
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Kronecker product of `a` and `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.leslie" module_name="leslie" namespace="'linalg'">
    <docstring>Create a Leslie matrix.

Given the length n array of fecundity coefficients `f` and the length
n-1 array of survival coefficents `s`, return the associated Leslie matrix.

Parameters
----------
f : (N,) array_like
    The "fecundity" coefficients.
s : (N-1,) array_like
    The "survival" coefficients, has to be 1-D.  The length of `s`
    must be one less than the length of `f`, and it must be at least 1.

Returns
-------
L : (N, N) ndarray
    The array is zero except for the first row,
    which is `f`, and the first sub-diagonal, which is `s`.
    The data-type of the array will be the data-type of ``f[0]+s[0]``.

Notes
-----
.. versionadded:: 0.8.0

The Leslie matrix is used to model discrete-time, age-structured
population growth [1]_ [2]_. In a population with `n` age classes, two sets
of parameters define a Leslie matrix: the `n` "fecundity coefficients",
which give the number of offspring per-capita produced by each age
class, and the `n` - 1 "survival coefficients", which give the
per-capita survival rate of each age class.

References
----------
.. [1] P. H. Leslie, On the use of matrices in certain population
       mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
       population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
       (Dec. 1948)

Examples
--------
&gt;&gt;&gt; from scipy.linalg import leslie
&gt;&gt;&gt; leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7])
array([[ 0.1,  2. ,  1. ,  0.1],
       [ 0.2,  0. ,  0. ,  0. ],
       [ 0. ,  0.8,  0. ,  0. ],
       [ 0. ,  0. ,  0.7,  0. ]])</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:List" show_port="True">
      <docstring>The "fecundity" coefficients.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:List" show_port="True">
      <docstring>The "survival" coefficients, has to be 1-D.  The length of `s`
must be one less than the length of `f`, and it must be at least 1.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="L" name="L" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array is zero except for the first row,
which is `f`, and the first sub-diagonal, which is `s`.
The data-type of the array will be the data-type of ``f[0]+s[0]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.logm" module_name="logm" namespace="'linalg'" output_type="list">
    <docstring>Compute matrix logarithm.

The matrix logarithm is the inverse of
expm: expm(logm(`A`)) == `A`

Parameters
----------
A : (N, N) array_like
    Matrix whose logarithm to evaluate
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
logm : (N, N) ndarray
    Matrix logarithm of `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       "Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm."
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197

.. [2] Nicholas J. Higham (2008)
       "Functions of Matrices: Theory and Computation"
       ISBN 978-0-898716-46-7

.. [3] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

Examples
--------
&gt;&gt;&gt; from scipy.linalg import logm, expm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; b = logm(a)
&gt;&gt;&gt; b
array([[-1.02571087,  2.05142174],
       [ 0.68380725,  1.02571087]])
&gt;&gt;&gt; expm(b)         # Verify expm(logm(a)) returns a
array([[ 1.,  3.],
       [ 1.,  4.]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix whose logarithm to evaluate</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="logm" name="logm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix logarithm of `A`</docstring>
    </outputPortSpec>
    <outputPortSpec arg="errest" name="errest" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>(if disp == False)

1-norm of the estimated error, ||err||_1 / ||A||_1</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.lstsq" module_name="lstsq" namespace="'linalg'" output_type="list">
    <docstring>Compute least-squares solution to equation Ax = b.

Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.

Parameters
----------
a : (M, N) array_like
    Left hand side matrix (2-D array).
b : (M,) or (M, K) array_like
    Right hand side matrix or vector (1-D or 2-D array).
cond : float, optional
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    ``rcond * largest_singular_value`` are considered zero.
overwrite_a : bool, optional
    Discard data in `a` (may enhance performance). Default is False.
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (N,) or (N, K) ndarray
    Least-squares solution.  Return shape matches shape of `b`.
residues : () or (1,) or (K,) ndarray
    Sums of residues, squared 2-norm for each column in ``b - a x``.
    If rank of matrix a is &lt; N or &gt; M this is an empty array.
    If b was 1-D, this is an (1,) shape array, otherwise the shape is (K,).
rank : int
    Effective rank of matrix `a`.
s : (min(M,N),) ndarray
    Singular values of `a`. The condition number of a is
    ``abs(s[0]/s[-1])``.

Raises
------
LinAlgError :
    If computation does not converge.


See Also
--------
optimize.nnls : linear least squares with non-negativity constraint</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Left hand side matrix (2-D array).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side matrix or vector (1-D or 2-D array).</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="cond" name="cond" port_type="basic:Float">
      <docstring>Cutoff for 'small' singular values; used to determine effective
rank of a. Singular values smaller than
``rcond * largest_singular_value`` are considered zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Discard data in `a` (may enhance performance). Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Discard data in `b` (may enhance performance). Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>Least-squares solution.  Return shape matches shape of `b`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="residues" name="residues" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Sums of residues, squared 2-norm for each column in ``b - a x``.
If rank of matrix a is &lt; N or &gt; M this is an empty array.
If b was 1-D, this is an (1,) shape array, otherwise the shape is (K,).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Effective rank of matrix `a`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Singular values of `a`. The condition number of a is
``abs(s[0]/s[-1])``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.lu" module_name="lu" namespace="'linalg'" output_type="list">
    <docstring>Compute pivoted LU decomposition of a matrix.

The decomposition is::

    A = P L U

where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.

Parameters
----------
a : (M, N) array_like
    Array to decompose
permute_l : bool, optional
    Perform the multiplication P*L  (Default: do not permute)
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
**(If permute_l == False)**

p : (M, M) ndarray
    Permutation matrix
l : (M, K) ndarray
    Lower triangular or trapezoidal matrix with unit diagonal.
    K = min(M, N)
u : (K, N) ndarray
    Upper triangular or trapezoidal matrix

**(If permute_l == True)**

pl : (M, K) ndarray
    Permuted L matrix.
    K = min(M, N)
u : (K, N) ndarray
    Upper triangular or trapezoidal matrix

Notes
-----
This is a LU factorization routine written for Scipy.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array to decompose</docstring>
    </inputPortSpec>
    <inputPortSpec arg="permute_l" name="permute_l" port_type="basic:Boolean">
      <docstring>Perform the multiplication P*L  (Default: do not permute)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in a (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Permutation matrix</docstring>
    </outputPortSpec>
    <outputPortSpec arg="l" name="l" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Lower triangular or trapezoidal matrix with unit diagonal.
K = min(M, N)</docstring>
    </outputPortSpec>
    <outputPortSpec arg="u" name="u" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Upper triangular or trapezoidal matrix
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="4" />
    <outputPortSpec arg="pl" name="pl" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Permuted L matrix.
K = min(M, N)</docstring>
    </outputPortSpec>
    <outputPortSpec arg="u" name="u" port_type="basic:List" show_port="True" sort_key="6">
      <docstring>Upper triangular or trapezoidal matrix</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.lu_factor" module_name="lu_factor" namespace="'linalg'" output_type="list">
    <docstring>Compute pivoted LU decomposition of a matrix.

The decomposition is::

    A = P L U

where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.

Parameters
----------
a : (M, M) array_like
    Matrix to decompose
overwrite_a : bool, optional
    Whether to overwrite data in A (may increase performance)
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
lu : (N, N) ndarray
    Matrix containing U in its upper triangle, and L in its lower triangle.
    The unit diagonal elements of L are not stored.
piv : (N,) ndarray
    Pivot indices representing the permutation matrix P:
    row i of matrix was interchanged with row piv[i].

See also
--------
lu_solve : solve an equation system using the LU factorization of a matrix

Notes
-----
This is a wrapper to the ``*GETRF`` routines from LAPACK.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to decompose</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in A (may increase performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="lu" name="lu" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix containing U in its upper triangle, and L in its lower triangle.
The unit diagonal elements of L are not stored.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="piv" name="piv" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Pivot indices representing the permutation matrix P:
row i of matrix was interchanged with row piv[i].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.lu_solve" module_name="lu_solve" namespace="'linalg'">
    <docstring>Solve an equation system, a x = b, given the LU factorization of a

Parameters
----------
(lu, piv)
    Factorization of the coefficient matrix a, as given by lu_factor
b : array
    Right-hand side
trans : {0, 1, 2}, optional
    Type of system to solve:

    =====  =========
    trans  system
    =====  =========
    0      a x   = b
    1      a^T x = b
    2      a^H x = b
    =====  =========
overwrite_b : bool, optional
    Whether to overwrite data in b (may increase performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : array
    Solution to the system

See also
--------
lu_factor : LU factorize a matrix</docstring>
    <inputPortSpec arg="piv)" name="piv)" port_type="basic:Variant" show_port="True">
      <docstring>Factorization of the coefficient matrix a, as given by lu_factor</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand side</docstring>
    </inputPortSpec>
    <inputPortSpec arg="trans" name="trans" port_type="basic:Integer">
      <docstring>Type of system to solve:

=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1, 2]]</values>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in b (may increase performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lu_and_piv" name="lu_and_piv" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the system</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.norm" module_name="norm" namespace="'linalg'">
    <docstring>Matrix or vector norm.

This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
a : (M,) or (M, N) array_like
    Input array.
ord : {non-zero int, inf, -inf, 'fro'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object.

Returns
-------
norm : float
    Norm of the matrix or vector.

Notes
-----
For values of ``ord &lt;= 0``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
&gt;&gt;&gt; from scipy.linalg import norm
&gt;&gt;&gt; a = np.arange(9) - 4
&gt;&gt;&gt; a
array([-4, -3, -2, -1,  0,  1,  2,  3,  4])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])

&gt;&gt;&gt; norm(a)
7.745966692414834
&gt;&gt;&gt; norm(b)
7.745966692414834
&gt;&gt;&gt; norm(b, 'fro')
7.745966692414834
&gt;&gt;&gt; norm(a, np.inf)
4
&gt;&gt;&gt; norm(b, np.inf)
9
&gt;&gt;&gt; norm(a, -np.inf)
0
&gt;&gt;&gt; norm(b, -np.inf)
2

&gt;&gt;&gt; norm(a, 1)
20
&gt;&gt;&gt; norm(b, 1)
7
&gt;&gt;&gt; norm(a, -1)
-4.6566128774142013e-010
&gt;&gt;&gt; norm(b, -1)
6
&gt;&gt;&gt; norm(a, 2)
7.745966692414834
&gt;&gt;&gt; norm(b, 2)
7.3484692283495345

&gt;&gt;&gt; norm(a, -2)
nan
&gt;&gt;&gt; norm(b, -2)
1.8570331885190563e-016
&gt;&gt;&gt; norm(a, 3)
5.8480354764257312
&gt;&gt;&gt; norm(a, -3)
nan</docstring>
    <inputPortSpec arg="a" name="aScalar" show_port="True">
      <docstring>Input array.</docstring>
      <alternateSpec arg="a" name="aSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="ord" name="ord">
      <docstring>Order of the norm (see table under ``Notes``). inf means numpy's
`inf` object.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['inf', '-inf', 'fro']]</values>
    </inputPortSpec>
    <outputPortSpec arg="norm" name="norm" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Norm of the matrix or vector.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.orth" module_name="orth" namespace="'linalg'">
    <docstring>Construct an orthonormal basis for the range of A using SVD

Parameters
----------
A : (M, N) array_like
    Input array

Returns
-------
Q : (M, K) ndarray
    Orthonormal basis for the range of A.
    K = effective rank of A, as determined by automatic cutoff

See also
--------
svd : Singular value decomposition of a matrix</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Q" name="Q" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Orthonormal basis for the range of A.
K = effective rank of A, as determined by automatic cutoff</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.orthogonal_procrustes" module_name="orthogonal_procrustes" namespace="'linalg'" output_type="list">
    <docstring>Compute the matrix solution of the orthogonal Procrustes problem.

Given matrices A and B of equal shape, find an orthogonal matrix R
that most closely maps A to B [1]_.
Note that unlike higher level Procrustes analyses of spatial data,
this function only uses orthogonal transformations like rotations
and reflections, and it does not use scaling or translation.

Parameters
----------
A : (M, N) array_like
    Matrix to be mapped.
B : (M, N) array_like
    Target matrix.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
R : (N, N) ndarray
    The matrix solution of the orthogonal Procrustes problem.
    Minimizes the Frobenius norm of dot(A, R) - B, subject to
    dot(R.T, R) == I.
scale : float
    Sum of the singular values of ``dot(A.T, B)``.

Raises
------
ValueError
    If the input arrays are incompatibly shaped.
    This may also be raised if matrix A or B contains an inf or nan
    and check_finite is True, or if the matrix product AB contains
    an inf or nan.

Notes
-----
.. versionadded:: 0.15.0

References
----------
.. [1] Peter H. Schonemann, "A generalized solution of the orthogonal
       Procrustes problem", Psychometrica -- Vol. 31, No. 1, March, 1996.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix to be mapped.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>Target matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="R" name="R" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The matrix solution of the orthogonal Procrustes problem.
Minimizes the Frobenius norm of dot(A, R) - B, subject to
dot(R.T, R) == I.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="scale" name="scale" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Sum of the singular values of ``dot(A.T, B)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.pascal" module_name="pascal" namespace="'linalg'">
    <docstring>Returns the n x n Pascal matrix.

The Pascal matrix is a matrix containing the binomial coefficients as
its elements.

Parameters
----------
n : int
    The size of the matrix to create; that is, the result is an n x n
    matrix.
kind : str, optional
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.
exact : bool, optional
    If `exact` is True, the result is either an array of type
    numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
    If `exact` is False, the coefficients in the matrix are computed using
    `scipy.special.comb` with `exact=False`.  The result will be a floating
    point array, and the values in the array will not be the exact
    coefficients, but this version is much faster than `exact=True`.

Returns
-------
p : (n, n) ndarray
    The Pascal matrix.

See Also
--------
invpascal

Notes
-----
See http://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import pascal
&gt;&gt;&gt; pascal(4)
array([[ 1,  1,  1,  1],
       [ 1,  2,  3,  4],
       [ 1,  3,  6, 10],
       [ 1,  4, 10, 20]], dtype=uint64)
&gt;&gt;&gt; pascal(4, kind='lower')
array([[1, 0, 0, 0],
       [1, 1, 0, 0],
       [1, 2, 1, 0],
       [1, 3, 3, 1]], dtype=uint64)
&gt;&gt;&gt; pascal(50)[-1, -1]
25477612258980856902730428600L
&gt;&gt;&gt; from scipy.special import comb
&gt;&gt;&gt; comb(98, 49, exact=True)
25477612258980856902730428600L</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The size of the matrix to create; that is, the result is an n x n
matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>Must be one of 'symmetric', 'lower', or 'upper'.
Default is 'symmetric'.</docstring>
      <defaults>['symmetric']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>If `exact` is True, the result is either an array of type
numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
If `exact` is False, the coefficients in the matrix are computed using
`scipy.special.comb` with `exact=False`.  The result will be a floating
point array, and the values in the array will not be the exact
coefficients, but this version is much faster than `exact=True`.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Pascal matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.pinv" module_name="pinv" namespace="'linalg'" output_type="list">
    <docstring>Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using a least-squares
solver.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
cond, rcond : float, optional
    Cutoff for 'small' singular values in the least-squares solver.
    Singular values smaller than ``rcond * largest_singular_value``
    are considered zero.
return_rank : bool, optional
    if True, return the effective rank of the matrix
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if return_rank == True

Raises
------
LinAlgError
    If computation does not converge.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; B = linalg.pinv(a)
&gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))
True
&gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be pseudo-inverted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cond" name="cond" port_type="basic:Float">
      <docstring>Cutoff for 'small' singular values in the least-squares solver.
Singular values smaller than ``rcond * largest_singular_value``
are considered zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float">
      <docstring>Cutoff for 'small' singular values in the least-squares solver.
Singular values smaller than ``rcond * largest_singular_value``
are considered zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="return_rank" name="return_rank" port_type="basic:Boolean">
      <docstring>if True, return the effective rank of the matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-inverse of matrix `a`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>The effective rank of the matrix.  Returned if return_rank == True</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.pinv2" module_name="pinv2" namespace="'linalg'" output_type="list">
    <docstring>Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
cond, rcond : float or None
    Cutoff for 'small' singular values.
    Singular values smaller than ``rcond*largest_singular_value``
    are considered zero.
    If None or -1, suitable machine precision is used.
return_rank : bool, optional
    if True, return the effective rank of the matrix
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if return_rank == True

Raises
------
LinAlgError
    If SVD computation does not converge.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; B = linalg.pinv2(a)
&gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))
True
&gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be pseudo-inverted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cond" name="cond" port_type="basic:Float" show_port="True">
      <docstring>Cutoff for 'small' singular values.
Singular values smaller than ``rcond*largest_singular_value``
are considered zero.
If None or -1, suitable machine precision is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float" show_port="True">
      <docstring>Cutoff for 'small' singular values.
Singular values smaller than ``rcond*largest_singular_value``
are considered zero.
If None or -1, suitable machine precision is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="return_rank" name="return_rank" port_type="basic:Boolean">
      <docstring>if True, return the effective rank of the matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-inverse of matrix `a`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>The effective rank of the matrix.  Returned if return_rank == True</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.pinvh" module_name="pinvh" namespace="'linalg'" output_type="list">
    <docstring>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.

Calculate a generalized inverse of a Hermitian or real symmetric matrix
using its eigenvalue decomposition and including all eigenvalues with
'large' absolute value.

Parameters
----------
a : (N, N) array_like
    Real symmetric or complex hermetian matrix to be pseudo-inverted
cond, rcond : float or None
    Cutoff for 'small' eigenvalues.
    Singular values smaller than rcond * largest_eigenvalue are considered
    zero.

    If None or -1, suitable machine precision is used.
lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of a. (Default: lower)
return_rank : bool, optional
    if True, return the effective rank of the matrix
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, N) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if return_rank == True

Raises
------
LinAlgError
    If eigenvalue does not converge

Examples
--------
&gt;&gt;&gt; from scipy.linalg import pinvh
&gt;&gt;&gt; a = np.random.randn(9, 6)
&gt;&gt;&gt; a = np.dot(a, a.T)
&gt;&gt;&gt; B = pinvh(a)
&gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))
True
&gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Real symmetric or complex hermetian matrix to be pseudo-inverted</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cond" name="cond" port_type="basic:Float" show_port="True">
      <docstring>Cutoff for 'small' eigenvalues.
Singular values smaller than rcond * largest_eigenvalue are considered
zero.

If None or -1, suitable machine precision is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Float" show_port="True">
      <docstring>Cutoff for 'small' eigenvalues.
Singular values smaller than rcond * largest_eigenvalue are considered
zero.

If None or -1, suitable machine precision is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Whether the pertinent array data is taken from the lower or upper
triangle of a. (Default: lower)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_rank" name="return_rank" port_type="basic:Boolean">
      <docstring>if True, return the effective rank of the matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The pseudo-inverse of matrix `a`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>The effective rank of the matrix.  Returned if return_rank == True</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.polar" module_name="polar" namespace="'linalg'" output_type="list">
    <docstring>Compute the polar decomposition.

Returns the factors of the polar decomposition [1]_ `u` and `p` such
that ``a = up`` (if `side` is "right") or ``a = pu`` (if `side` is
"left"), where `p` is positive semidefinite.  Depending on the shape
of `a`, either the rows or columns of `u` are orthonormal.  When `a`
is a square array, `u` is a square unitary array.  When `a` is not
square, the "canonical polar decomposition" [2]_ is computed.

Parameters
----------
a : (m, n) array_like
    The array to be factored.
side : {'left', 'right'}, optional
    Determines whether a right or left polar decomposition is computed.
    If `side` is "right", then ``a = up``.  If `side` is "left",  then
    ``a = pu``.  The default is "right".

Returns
-------
u : (m, n) ndarray
    If `a` is square, then `u` is unitary.  If m &gt; n, then the columns
    of `a` are orthonormal, and if m &lt; n, then the rows of `u` are
    orthonormal.
p : ndarray
    `p` is Hermitian positive semidefinite.  If `a` is nonsingular, `p`
    is positive definite.  The shape of `p` is (n, n) or (m, m), depending
    on whether `side` is "right" or "left", respectively.

References
----------
.. [1] R. A. Horn and C. R. Johnson, "Matrix Analysis", Cambridge University
       Press, 1985.
.. [2] N. J. Higham, "Functions of Matrices: Theory and Computation",
       SIAM, 2008.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import polar
&gt;&gt;&gt; a = np.array([[1, -1], [2, 4]])
&gt;&gt;&gt; u, p = polar(a)
&gt;&gt;&gt; u
array([[ 0.85749293, -0.51449576],
       [ 0.51449576,  0.85749293]])
&gt;&gt;&gt; p
array([[ 1.88648444,  1.2004901 ],
       [ 1.2004901 ,  3.94446746]])

A non-square example, with m &lt; n:

&gt;&gt;&gt; b = np.array([[0.5, 1, 2], [1.5, 3, 4]])
&gt;&gt;&gt; u, p = polar(b)
&gt;&gt;&gt; u
array([[-0.21196618, -0.42393237,  0.88054056],
       [ 0.39378971,  0.78757942,  0.4739708 ]])
&gt;&gt;&gt; p
array([[ 0.48470147,  0.96940295,  1.15122648],
       [ 0.96940295,  1.9388059 ,  2.30245295],
       [ 1.15122648,  2.30245295,  3.65696431]])
&gt;&gt;&gt; u.dot(p)   # Verify the decomposition.
array([[ 0.5,  1. ,  2. ],
       [ 1.5,  3. ,  4. ]])
&gt;&gt;&gt; u.dot(u.T)   # The rows of u are orthonormal.
array([[  1.00000000e+00,  -2.07353665e-17],
       [ -2.07353665e-17,   1.00000000e+00]])

Another non-square example, with m &gt; n:

&gt;&gt;&gt; c = b.T
&gt;&gt;&gt; u, p = polar(c)
&gt;&gt;&gt; u
array([[-0.21196618,  0.39378971],
       [-0.42393237,  0.78757942],
       [ 0.88054056,  0.4739708 ]])
&gt;&gt;&gt; p
array([[ 1.23116567,  1.93241587],
       [ 1.93241587,  4.84930602]])
&gt;&gt;&gt; u.dot(p)   # Verify the decomposition.
array([[ 0.5,  1.5],
       [ 1. ,  3. ],
       [ 2. ,  4. ]])
&gt;&gt;&gt; u.T.dot(u)  # The columns of u are orthonormal.
array([[  1.00000000e+00,  -1.26363763e-16],
       [ -1.26363763e-16,   1.00000000e+00]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array to be factored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="side" name="side">
      <docstring>Determines whether a right or left polar decomposition is computed.
If `side` is "right", then ``a = up``.  If `side` is "left",  then
``a = pu``.  The default is "right".</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['left', 'right']]</values>
      <defaults>['right']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="u" name="u" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `a` is square, then `u` is unitary.  If m &gt; n, then the columns
of `a` are orthonormal, and if m &lt; n, then the rows of `u` are
orthonormal.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>`p` is Hermitian positive semidefinite.  If `a` is nonsingular, `p`
is positive definite.  The shape of `p` is (n, n) or (m, m), depending
on whether `side` is "right" or "left", respectively.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr" module_name="qr" namespace="'linalg'" output_type="list">
    <docstring>Compute QR decomposition of a matrix.

Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal
and R upper triangular.

Parameters
----------
a : (M, N) array_like
    Matrix to be decomposed
overwrite_a : bool, optional
    Whether data in a is overwritten (may improve performance)
lwork : int, optional
    Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
    is computed.
mode : {'full', 'r', 'economic', 'raw'}, optional
    Determines what information is to be returned: either both Q and R
    ('full', default), only R ('r') or both Q and R but computed in
    economy-size ('economic', see Notes). The final option 'raw'
    (added in Scipy 0.11) makes the function return two matrices
    (Q, TAU) in the internal format used by LAPACK.
pivoting : bool, optional
    Whether or not factorization should include pivoting for rank-revealing
    qr decomposition. If pivoting, compute the decomposition
    ``A P = Q R`` as above, but where P is chosen such that the diagonal
    of R is non-increasing.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
Q : float or complex ndarray
    Of shape (M, M), or (M, K) for ``mode='economic'``.  Not returned
    if ``mode='r'``.
R : float or complex ndarray
    Of shape (M, N), or (K, N) for ``mode='economic'``.  ``K = min(M, N)``.
P : int ndarray
    Of shape (N,) for ``pivoting=True``. Not returned if
    ``pivoting=False``.

Raises
------
LinAlgError
    Raised if decomposition fails

Notes
-----
This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.

If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with ``K=min(M,N)``.

Examples
--------
&gt;&gt;&gt; from scipy import random, linalg, dot, diag, all, allclose
&gt;&gt;&gt; a = random.randn(9, 6)

&gt;&gt;&gt; q, r = linalg.qr(a)
&gt;&gt;&gt; allclose(a, np.dot(q, r))
True
&gt;&gt;&gt; q.shape, r.shape
((9, 9), (9, 6))

&gt;&gt;&gt; r2 = linalg.qr(a, mode='r')
&gt;&gt;&gt; allclose(r, r2)
True

&gt;&gt;&gt; q3, r3 = linalg.qr(a, mode='economic')
&gt;&gt;&gt; q3.shape, r3.shape
((9, 6), (6, 6))

&gt;&gt;&gt; q4, r4, p4 = linalg.qr(a, pivoting=True)
&gt;&gt;&gt; d = abs(diag(r4))
&gt;&gt;&gt; all(d[1:] &lt;= d[:-1])
True
&gt;&gt;&gt; allclose(a[:, p4], dot(q4, r4))
True
&gt;&gt;&gt; q4.shape, r4.shape, p4.shape
((9, 9), (9, 6), (6,))

&gt;&gt;&gt; q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)
&gt;&gt;&gt; q5.shape, r5.shape, p5.shape
((9, 6), (6, 6), (6,))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be decomposed</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether data in a is overwritten (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lwork" name="lwork" port_type="basic:Integer">
      <docstring>Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes). The final option 'raw'
(added in Scipy 0.11) makes the function return two matrices
(Q, TAU) in the internal format used by LAPACK.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'r', 'economic', 'raw']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pivoting" name="pivoting" port_type="basic:Boolean">
      <docstring>Whether or not factorization should include pivoting for rank-revealing
qr decomposition. If pivoting, compute the decomposition
``A P = Q R`` as above, but where P is chosen such that the diagonal
of R is non-increasing.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Q" name="Q" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Of shape (M, M), or (M, K) for ``mode='economic'``.  Not returned
if ``mode='r'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="R" name="R" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Of shape (M, N), or (K, N) for ``mode='economic'``.  ``K = min(M, N)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="P" depth="1" name="P" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Of shape (N,) for ``pivoting=True``. Not returned if
``pivoting=False``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr_delete" module_name="qr_delete" namespace="'linalg'">
    <docstring>qr_delete(Q, R, k, p=1, which='row', overwrite_qr=False, check_finite=True)
QR downdate on row or column deletions

    If ``A = Q R`` is the QR factorization of ``A``, return the QR
    factorization of ``A`` where ``p`` rows or columns have been removed
    starting at row or column ``k``.

    Parameters
    ----------
    Q : (M, M) or (M, N) array_like
        Unitary/orthogonal matrix from QR decomposition.
    R : (M, N) or (N, N) array_like
        Upper triangular matrix from QR decomposition.
    k : int
        Index of the first row or column to delete.
    p : int, optional
        Number of rows or columns to delete, defaults to 1.
    which: {'row', 'col'}, optional
        Determines if rows or columns will be deleted, defaults to 'row'
    overwrite_qr : bool, optional
        If True, consume Q and R, overwriting their contents with their
        downdated versions, and returning approriately sized views.  
        Defaults to False.
    check_finite : bool, optional
        Whether to check that the input matrix contains only finite numbers.
        Disabling may give a performance gain, but may result in problems
        (crashes, non-termination) if the inputs do contain infinities or NaNs.
        Default is True.

    Returns
    -------
    Q1 : ndarray
        Updated unitary/orthogonal factor
    R1 : ndarray
        Updated upper triangular factor

    See Also
    --------
    qr, qr_multiply, qr_insert, qr_update

    Notes
    -----
    This routine does not guarantee that the diagonal entries of ``R1`` are
    positive.

    .. versionadded:: 0.16.0

    References
    ----------
    .. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
           (Johns Hopkins University Press, 1996).

    .. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
           Reorthogonalization and stable algorithms for updating the
           Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).

    .. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
           Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
           (1990).

    Examples
    --------
    &gt;&gt;&gt; from scipy import linalg
    &gt;&gt;&gt; a = np.array([[  3.,  -2.,  -2.],
    ...               [  6.,  -9.,  -3.],
    ...               [ -3.,  10.,   1.],
    ...               [  6.,  -7.,   4.],
    ...               [  7.,   8.,  -6.]])
    &gt;&gt;&gt; q, r = linalg.qr(a)

    Given this QR decomposition, update q and r when 2 rows are removed.

    &gt;&gt;&gt; q1, r1 = linalg.qr_delete(q, r, 2, 2, 'row', False)
    &gt;&gt;&gt; q1
    array([[ 0.30942637,  0.15347579,  0.93845645],
           [ 0.61885275,  0.71680171, -0.32127338],
           [ 0.72199487, -0.68017681, -0.12681844]])
    &gt;&gt;&gt; r1
    array([[  9.69535971,  -0.4125685 ,  -6.80738023],
           [  0.        , -12.19958144,   1.62370412],
           [  0.        ,   0.        ,  -0.15218213]])

    The update is equivalent, but faster than the following.

    &gt;&gt;&gt; a1 = np.delete(a, slice(2,4), 0)
    &gt;&gt;&gt; a1
    array([[ 3., -2., -2.],
           [ 6., -9., -3.],
           [ 7.,  8., -6.]])
    &gt;&gt;&gt; q_direct, r_direct = linalg.qr(a1)

    Check that we have equivalent results:

    &gt;&gt;&gt; np.dot(q1, r1)
    array([[ 3., -2., -2.],
           [ 6., -9., -3.],
           [ 7.,  8., -6.]])
    &gt;&gt;&gt; np.allclose(np.dot(q1, r1), a1)
    True

    And the updated Q is still unitary:

    &gt;&gt;&gt; np.allclose(np.dot(q1.T, q1), np.eye(3))
    True</docstring>
    <inputPortSpec arg="Q" name="QScalar" show_port="True">
      <docstring>    Unitary/orthogonal matrix from QR decomposition.
R : (M, N) or (N, N) array_like
    Upper triangular matrix from QR decomposition.
k : int
    Index of the first row or column to delete.
p : int, optional
    Number of rows or columns to delete, defaults to 1.
which: {'row', 'col'}, optional
    Determines if rows or columns will be deleted, defaults to 'row'
overwrite_qr : bool, optional
    If True, consume Q and R, overwriting their contents with their
    downdated versions, and returning approriately sized views.  
    Defaults to False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.</docstring>
      <alternateSpec arg="Q" name="QSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="overwrite_qr" name="overwrite_qr" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="k" name="k" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="p" name="p" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="R" name="R" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="which" name="which">
      <defaults>['row']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Q1" name="Q1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>    Updated unitary/orthogonal factor
R1 : ndarray
    Updated upper triangular factor</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr_insert" module_name="qr_insert" namespace="'linalg'">
    <docstring>qr_insert(Q, R, u, k, which='row', rcond=None, overwrite_qru=False, check_finite=True)
QR update on row or column insertions

    If ``A = Q R`` is the QR factorization of ``A``, return the QR
    factorization of ``A`` where rows or columns have been inserted starting
    at row or column ``k``.

    Parameters
    ----------
    Q : (M, M) array_like
        Unitary/orthogonal matrix from the QR decomposition of A.
    R : (M, N) array_like
        Upper triangular matrix from the QR decomposition of A.
    u : (N,), (p, N), (M,), or (M, p) array_like
        Rows or columns to insert
    k : int
        Index before which `u` is to be inserted.
    which: {'row', 'col'}, optional
        Determines if rows or columns will be inserted, defaults to 'row'
    rcond : float
        Lower bound on the reciprocal condition number of ``Q`` augmented with
        ``u/||u||`` Only used when updating economic mode (thin, (M,N) (N,N))
        decompositions.  If None, machine precision is used.  Defaults to 
        None.
    overwrite_qru : bool, optional
        If True, consume Q, R, and u, if possible, while performing the update,
        otherwise make copies as necessary. Defaults to False.
    check_finite : bool, optional
        Whether to check that the input matrices contain only finite numbers.
        Disabling may give a performance gain, but may result in problems
        (crashes, non-termination) if the inputs do contain infinities or NaNs.
        Default is True.

    Returns
    -------
    Q1 : ndarray
        Updated unitary/orthogonal factor
    R1 : ndarray
        Updated upper triangular factor

    Raises
    ------
    LinAlgError :
        If updating a (M,N) (N,N) factorization and the reciprocal condition
        number of Q augmented with u/||u|| is smaller than rcond.

    See Also
    --------
    qr, qr_multiply, qr_delete, qr_update

    Notes
    -----
    This routine does not guarantee that the diagonal entries of ``R1`` are
    positive.

    .. versionadded:: 0.16.0

    References
    ----------
    .. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
           (Johns Hopkins University Press, 1996).

    .. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
           Reorthogonalization and stable algorithms for updating the
           Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).

    .. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
           Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
           (1990).

    Examples
    --------
    &gt;&gt;&gt; from scipy import linalg
    &gt;&gt;&gt; a = np.array([[  3.,  -2.,  -2.],
    ...               [  6.,  -7.,   4.],
    ...               [  7.,   8.,  -6.]])
    &gt;&gt;&gt; q, r = linalg.qr(a)

    Given this QR decomposition, update q and r when 2 rows are inserted.
                      
    &gt;&gt;&gt; u = np.array([[  6.,  -9.,  -3.], 
    ...               [ -3.,  10.,   1.]])
    &gt;&gt;&gt; q1, r1 = linalg.qr_insert(q, r, u, 2, 'row')
    &gt;&gt;&gt; q1
    array([[-0.25445668,  0.02246245,  0.18146236, -0.72798806,  0.60979671],
           [-0.50891336,  0.23226178, -0.82836478, -0.02837033, -0.00828114],
           [-0.50891336,  0.35715302,  0.38937158,  0.58110733,  0.35235345],
           [ 0.25445668, -0.52202743, -0.32165498,  0.36263239,  0.65404509],
           [-0.59373225, -0.73856549,  0.16065817, -0.0063658 , -0.27595554]])
    &gt;&gt;&gt; r1
    array([[-11.78982612,   6.44623587,   3.81685018],
           [  0.        , -16.01393278,   3.72202865],
           [  0.        ,   0.        ,  -6.13010256],
           [  0.        ,   0.        ,   0.        ],
           [  0.        ,   0.        ,   0.        ]])

    The update is equivalent, but faster than the following.

    &gt;&gt;&gt; a1 = np.insert(a, 2, u, 0)
    &gt;&gt;&gt; a1
    array([[  3.,  -2.,  -2.],
           [  6.,  -7.,   4.],
           [  6.,  -9.,  -3.],
           [ -3.,  10.,   1.],
           [  7.,   8.,  -6.]])
    &gt;&gt;&gt; q_direct, r_direct = linalg.qr(a1)

    Check that we have equivalent results:

    &gt;&gt;&gt; np.dot(q1, r1)
    array([[  3.,  -2.,  -2.],
           [  6.,  -7.,   4.],
           [  6.,  -9.,  -3.],
           [ -3.,  10.,   1.],
           [  7.,   8.,  -6.]])

    &gt;&gt;&gt; np.allclose(np.dot(q1, r1), a1)
    True

    And the updated Q is still unitary:

    &gt;&gt;&gt; np.allclose(np.dot(q1.T, q1), np.eye(5))
    True</docstring>
    <inputPortSpec arg="Q" name="Q" port_type="basic:List" show_port="True">
      <docstring>    Unitary/orthogonal matrix from the QR decomposition of A.
R : (M, N) array_like
    Upper triangular matrix from the QR decomposition of A.
u : (N,), (p, N), (M,), or (M, p) array_like
    Rows or columns to insert
k : int
    Index before which `u` is to be inserted.
which: {'row', 'col'}, optional
    Determines if rows or columns will be inserted, defaults to 'row'
rcond : float
    Lower bound on the reciprocal condition number of ``Q`` augmented with
    ``u/||u||`` Only used when updating economic mode (thin, (M,N) (N,N))
    decompositions.  If None, machine precision is used.  Defaults to 
    None.
overwrite_qru : bool, optional
    If True, consume Q, R, and u, if possible, while performing the update,
    otherwise make copies as necessary. Defaults to False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="R" name="R" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="u" name="u" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="overwrite_qru" name="overwrite_qru" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="which" name="which">
      <defaults>['row']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rcond" name="rcond" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Q1" name="Q1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>    Updated unitary/orthogonal factor
R1 : ndarray
    Updated upper triangular factor</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr_insert_col" module_name="qr_insert_col" namespace="'linalg'">
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr_insert_row" module_name="qr_insert_row" namespace="'linalg'">
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr_multiply" module_name="qr_multiply" namespace="'linalg'" output_type="list">
    <docstring>Calculate the QR decomposition and multiply Q with a matrix.

Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal
and R upper triangular. Multiply Q with a vector or a matrix c.

Parameters
----------
a : array_like, shape (M, N)
    Matrix to be decomposed
c : array_like, one- or two-dimensional
    calculate the product of c and q, depending on the mode:
mode : {'left', 'right'}, optional
    ``dot(Q, c)`` is returned if mode is 'left',
    ``dot(c, Q)`` is returned if mode is 'right'.
    The shape of c must be appropriate for the matrix multiplications,
    if mode is 'left', ``min(a.shape) == c.shape[0]``,
    if mode is 'right', ``a.shape[0] == c.shape[1]``.
pivoting : bool, optional
    Whether or not factorization should include pivoting for rank-revealing
    qr decomposition, see the documentation of qr.
conjugate : bool, optional
    Whether Q should be complex-conjugated. This might be faster
    than explicit conjugation.
overwrite_a : bool, optional
    Whether data in a is overwritten (may improve performance)
overwrite_c : bool, optional
    Whether data in c is overwritten (may improve performance).
    If this is used, c must be big enough to keep the result,
    i.e. c.shape[0] = a.shape[0] if mode is 'left'.


Returns
-------
CQ : float or complex ndarray
    the product of Q and c, as defined in mode
R : float or complex ndarray
    Of shape (K, N), ``K = min(M, N)``.
P : ndarray of ints
    Of shape (N,) for ``pivoting=True``.
    Not returned if ``pivoting=False``.

Raises
------
LinAlgError
    Raised if decomposition fails

Notes
-----
This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dormqr, zunmqr, dgeqp3, and zgeqp3.

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be decomposed</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" name="cScalar" show_port="True">
      <docstring>calculate the product of c and q, depending on the mode:</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['two-dimensional']]</values>
      <alternateSpec arg="c" name="cSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>``dot(Q, c)`` is returned if mode is 'left',
``dot(c, Q)`` is returned if mode is 'right'.
The shape of c must be appropriate for the matrix multiplications,
if mode is 'left', ``min(a.shape) == c.shape[0]``,
if mode is 'right', ``a.shape[0] == c.shape[1]``.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['left', 'right']]</values>
      <defaults>['right']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pivoting" name="pivoting" port_type="basic:Boolean">
      <docstring>Whether or not factorization should include pivoting for rank-revealing
qr decomposition, see the documentation of qr.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="conjugate" name="conjugate" port_type="basic:Boolean">
      <docstring>Whether Q should be complex-conjugated. This might be faster
than explicit conjugation.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether data in a is overwritten (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_c" name="overwrite_c" port_type="basic:Boolean">
      <docstring>Whether data in c is overwritten (may improve performance).
If this is used, c must be big enough to keep the result,
i.e. c.shape[0] = a.shape[0] if mode is 'left'.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="CQ" name="CQ" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>the product of Q and c, as defined in mode</docstring>
    </outputPortSpec>
    <outputPortSpec arg="R" name="R" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Of shape (K, N), ``K = min(M, N)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="P" depth="1" name="P" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Of shape (N,) for ``pivoting=True``.
Not returned if ``pivoting=False``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qr_update" module_name="qr_update" namespace="'linalg'">
    <docstring>qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)
Rank-k QR update

    If ``A = Q R`` is the QR factorization of ``A``, return the QR
    factorization of ``A + u v**T`` for real ``A`` or ``A + u v**H``
    for complex ``A``.

    Parameters
    ----------
    Q : (M, M) or (M, N) array_like
        Unitary/orthogonal matrix from the qr decomposition of A.
    R : (M, N) or (N, N) array_like
        Upper triangular matrix from the qr decomposition of A.
    u : (M,) or (M, k) array_like
        Left update vector
    v : (N,) or (N, k) array_like
        Right update vector
    overwrite_qruv : bool, optional
        If True, consume Q, R, u, and v, if possible, while performing the
        update, otherwise make copies as necessary. Defaults to False.
    check_finite : bool, optional
        Whether to check that the input matrix contains only finite numbers.
        Disabling may give a performance gain, but may result in problems
        (crashes, non-termination) if the inputs do contain infinities or NaNs.
        Default is True.

    Returns
    -------
    Q1 : ndarray
        Updated unitary/orthogonal factor
    R1 : ndarray
        Updated upper triangular factor

    See Also
    --------
    qr, qr_multiply, qr_delete, qr_insert

    Notes
    -----
    This routine does not guarantee that the diagonal entries of `R1` are
    real or positive.

    .. versionadded:: 0.16.0

    References
    ----------
    .. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
           (Johns Hopkins University Press, 1996).

    .. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
           Reorthogonalization and stable algorithms for updating the
           Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).

    .. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
           Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
           (1990).

    Examples
    --------
    &gt;&gt;&gt; from scipy import linalg
    &gt;&gt;&gt; a = np.array([[  3.,  -2.,  -2.],
    ...               [  6.,  -9.,  -3.],
    ...               [ -3.,  10.,   1.],
    ...               [  6.,  -7.,   4.],
    ...               [  7.,   8.,  -6.]])
    &gt;&gt;&gt; q, r = linalg.qr(a)

    Given this q, r decomposition, perform a rank 1 update.

    &gt;&gt;&gt; u = np.array([7., -2., 4., 3., 5.])
    &gt;&gt;&gt; v = np.array([1., 3., -5.])
    &gt;&gt;&gt; q_up, r_up = linalg.qr_update(q, r, u, v, False)
    &gt;&gt;&gt; q_up
    array([[ 0.54073807,  0.18645997,  0.81707661, -0.02136616,  0.06902409],
           [ 0.21629523, -0.63257324,  0.06567893,  0.34125904, -0.65749222],
           [ 0.05407381,  0.64757787, -0.12781284, -0.20031219, -0.72198188],
           [ 0.48666426, -0.30466718, -0.27487277, -0.77079214,  0.0256951 ],
           [ 0.64888568,  0.23001   , -0.4859845 ,  0.49883891,  0.20253783]])
    &gt;&gt;&gt; r_up
    array([[ 18.49324201,  24.11691794, -44.98940746],
           [  0.        ,  31.95894662, -27.40998201],
           [  0.        ,   0.        ,  -9.25451794],
           [  0.        ,   0.        ,   0.        ],
           [  0.        ,   0.        ,   0.        ]])
    
    The update is equivalent, but faster than the following.

    &gt;&gt;&gt; a_up = a + np.outer(u, v)
    &gt;&gt;&gt; q_direct, r_direct = linalg.qr(a_up)

    Check that we have equivalent results:

    &gt;&gt;&gt; np.allclose(np.dot(q_up, r_up), a_up)
    True

    And the updated Q is still unitary:

    &gt;&gt;&gt; np.allclose(np.dot(q_up.T, q_up), np.eye(5))
    True

    Updating economic (reduced, thin) decompositions is also possible:

    &gt;&gt;&gt; qe, re = linalg.qr(a, mode='economic')
    &gt;&gt;&gt; qe_up, re_up = linalg.qr_update(qe, re, u, v, False)
    &gt;&gt;&gt; qe_up
    array([[ 0.54073807,  0.18645997,  0.81707661],
           [ 0.21629523, -0.63257324,  0.06567893],
           [ 0.05407381,  0.64757787, -0.12781284],
           [ 0.48666426, -0.30466718, -0.27487277],
           [ 0.64888568,  0.23001   , -0.4859845 ]])
    &gt;&gt;&gt; re_up
    array([[ 18.49324201,  24.11691794, -44.98940746],
           [  0.        ,  31.95894662, -27.40998201],
           [  0.        ,   0.        ,  -9.25451794]])
    &gt;&gt;&gt; np.allclose(np.dot(qe_up, re_up), a_up)
    True
    &gt;&gt;&gt; np.allclose(np.dot(qe_up.T, qe_up), np.eye(3))
    True

    Similarly to the above, perform a rank 2 update.

    &gt;&gt;&gt; u2 = np.array([[ 7., -1,],
    ...                [-2.,  4.],
    ...                [ 4.,  2.],
    ...                [ 3., -6.],
    ...                [ 5.,  3.]])
    &gt;&gt;&gt; v2 = np.array([[ 1., 2.],
    ...                [ 3., 4.],
    ...                [-5., 2]])
    &gt;&gt;&gt; q_up2, r_up2 = linalg.qr_update(q, r, u, v, False)
    &gt;&gt;&gt; q_up2
    array([[-0.33626508, -0.03477253,  0.61956287, -0.64352987, -0.29618884],
           [-0.50439762,  0.58319694, -0.43010077, -0.33395279,  0.33008064],
           [-0.21016568, -0.63123106,  0.0582249 , -0.13675572,  0.73163206],
           [ 0.12609941,  0.49694436,  0.64590024,  0.31191919,  0.47187344],
           [-0.75659643, -0.11517748,  0.10284903,  0.5986227 , -0.21299983]])
    &gt;&gt;&gt; r_up2
    array([[-23.79075451, -41.1084062 ,  24.71548348],
           [  0.        , -33.83931057,  11.02226551],
           [  0.        ,   0.        , -48.91476811],
           [ -0.        ,   0.        ,   0.        ],
           [  0.        ,   0.        ,   0.        ]])

    This update is also a valid qr decomposition of ``A + U V**T``.

    &gt;&gt;&gt; a_up2 = a + np.dot(u2, v2.T)
    &gt;&gt;&gt; np.allclose(a_up2, np.dot(q_up2, r_up2))
    True
    &gt;&gt;&gt; np.allclose(np.dot(q_up2.T, q_up2), np.eye(5))
    True</docstring>
    <inputPortSpec arg="Q" name="QScalar" show_port="True">
      <docstring>    Unitary/orthogonal matrix from the qr decomposition of A.
R : (M, N) or (N, N) array_like
    Upper triangular matrix from the qr decomposition of A.
u : (M,) or (M, k) array_like
    Left update vector
v : (N,) or (N, k) array_like
    Right update vector
overwrite_qruv : bool, optional
    If True, consume Q, R, u, and v, if possible, while performing the
    update, otherwise make copies as necessary. Defaults to False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.</docstring>
      <alternateSpec arg="Q" name="QSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="overwrite_qruv" name="overwrite_qruv" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="R" name="R" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="u" name="u" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Q1" name="Q1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>    Updated unitary/orthogonal factor
R1 : ndarray
    Updated upper triangular factor</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.qz" module_name="qz" namespace="'linalg'" output_type="list">
    <docstring>QZ decomposition for generalized eigenvalues of a pair of matrices.

The QZ, or generalized Schur, decomposition for a pair of N x N
nonsymmetric matrices (A,B) is::

    (A,B) = (Q*AA*Z', Q*BB*Z')

where AA, BB is in generalized Schur form if BB is upper-triangular
with non-negative diagonal and AA is upper-triangular, or for real QZ
decomposition (``output='real'``) block upper triangular with 1x1
and 2x2 blocks.  In this case, the 1x1 blocks correspond to real
generalized eigenvalues and 2x2 blocks are 'standardized' by making
the corresponding elements of BB have the form::

    [ a 0 ]
    [ 0 b ]

and the pair of corresponding 2x2 blocks in AA and BB will have a complex
conjugate pair of generalized eigenvalues.  If (``output='complex'``) or
A and B are complex matrices, Z' denotes the conjugate-transpose of Z.
Q and Z are unitary matrices.

Parameters
----------
A : (N, N) array_like
    2d array to decompose
B : (N, N) array_like
    2d array to decompose
output : {'real', 'complex'}, optional
    Construct the real or complex QZ decomposition for real matrices.
    Default is 'real'.
lwork : int, optional
    Work array size.  If None or -1, it is automatically computed.
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
    NOTE: THIS INPUT IS DISABLED FOR NOW, IT DOESN'T WORK WELL ON WINDOWS.

    Specifies whether the upper eigenvalues should be sorted.  A callable
    may be passed that, given a eigenvalue, returns a boolean denoting
    whether the eigenvalue should be sorted to the top-left (True). For
    real matrix pairs, the sort function takes three real arguments
    (alphar, alphai, beta). The eigenvalue x = (alphar + alphai*1j)/beta.
    For complex matrix pairs or output='complex', the sort function
    takes two complex arguments (alpha, beta). The eigenvalue
    x = (alpha/beta).
    Alternatively, string parameters may be used:

        - 'lhp'   Left-hand plane (x.real &lt; 0.0)
        - 'rhp'   Right-hand plane (x.real &gt; 0.0)
        - 'iuc'   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
        - 'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)

    Defaults to None (no sorting).
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
overwrite_b : bool, optional
    Whether to overwrite data in b (may improve performance)
check_finite : bool, optional
    If true checks the elements of `A` and `B` are finite numbers. If
    false does no checking and passes matrix through to
    underlying algorithm.

Returns
-------
AA : (N, N) ndarray
    Generalized Schur form of A.
BB : (N, N) ndarray
    Generalized Schur form of B.
Q : (N, N) ndarray
    The left Schur vectors.
Z : (N, N) ndarray
    The right Schur vectors.
sdim : int, optional
    If sorting was requested, a fifth return value will contain the
    number of eigenvalues for which the sort condition was True.

Notes
-----
Q is transposed versus the equivalent function in Matlab.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; np.random.seed(1234)
&gt;&gt;&gt; A = np.arange(9).reshape((3, 3))
&gt;&gt;&gt; B = np.random.randn(3, 3)

&gt;&gt;&gt; AA, BB, Q, Z = linalg.qz(A, B)
&gt;&gt;&gt; AA
array([[-13.40928183,  -4.62471562,   1.09215523],
       [  0.        ,   0.        ,   1.22805978],
       [  0.        ,   0.        ,   0.31973817]])
&gt;&gt;&gt; BB
array([[ 0.33362547, -1.37393632,  0.02179805],
       [ 0.        ,  1.68144922,  0.74683866],
       [ 0.        ,  0.        ,  0.9258294 ]])
&gt;&gt;&gt; Q
array([[ 0.14134727, -0.97562773,  0.16784365],
       [ 0.49835904, -0.07636948, -0.86360059],
       [ 0.85537081,  0.20571399,  0.47541828]])
&gt;&gt;&gt; Z
array([[-0.24900855, -0.51772687,  0.81850696],
       [-0.79813178,  0.58842606,  0.12938478],
       [-0.54861681, -0.6210585 , -0.55973739]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>2d array to decompose</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>2d array to decompose</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Construct the real or complex QZ decomposition for real matrices.
Default is 'real'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['real', 'complex']]</values>
      <defaults>['real']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lwork" name="lwork" port_type="basic:Integer">
      <docstring>Work array size.  If None or -1, it is automatically computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sort" name="sort">
      <docstring>NOTE: THIS INPUT IS DISABLED FOR NOW, IT DOESN'T WORK WELL ON WINDOWS.

Specifies whether the upper eigenvalues should be sorted.  A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True). For
real matrix pairs, the sort function takes three real arguments
(alphar, alphai, beta). The eigenvalue x = (alphar + alphai*1j)/beta.
For complex matrix pairs or output='complex', the sort function
takes two complex arguments (alpha, beta). The eigenvalue
x = (alpha/beta).
Alternatively, string parameters may be used:

    - 'lhp'   Left-hand plane (x.real &lt; 0.0)
    - 'rhp'   Right-hand plane (x.real &gt; 0.0)
    - 'iuc'   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
    - 'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)

Defaults to None (no sorting).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lhp', 'rhp', 'iuc', 'ouc']]</values>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in a (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in b (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>If true checks the elements of `A` and `B` are finite numbers. If
false does no checking and passes matrix through to
underlying algorithm.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="AA" name="AA" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Generalized Schur form of A.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="BB" name="BB" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Generalized Schur form of B.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Q" name="Q" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The left Schur vectors.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>The right Schur vectors.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sdim" name="sdim" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>If sorting was requested, a fifth return value will contain the
number of eigenvalues for which the sort condition was True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.rq" module_name="rq" namespace="'linalg'" output_type="list">
    <docstring>Compute RQ decomposition of a matrix.

Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal
and R upper triangular.

Parameters
----------
a : (M, N) array_like
    Matrix to be decomposed
overwrite_a : bool, optional
    Whether data in a is overwritten (may improve performance)
lwork : int, optional
    Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
    is computed.
mode : {'full', 'r', 'economic'}, optional
    Determines what information is to be returned: either both Q and R
    ('full', default), only R ('r') or both Q and R but computed in
    economy-size ('economic', see Notes).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
R : float or complex ndarray
    Of shape (M, N) or (M, K) for ``mode='economic'``.  ``K = min(M, N)``.
Q : float or complex ndarray
    Of shape (N, N) or (K, N) for ``mode='economic'``.  Not returned
    if ``mode='r'``.

Raises
------
LinAlgError
    If decomposition fails.

Notes
-----
This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,
sorgrq, dorgrq, cungrq and zungrq.

If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead
of (N,N) and (M,N), with ``K=min(M,N)``.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; from numpy import random, dot, allclose
&gt;&gt;&gt; a = random.randn(6, 9)
&gt;&gt;&gt; r, q = linalg.rq(a)
&gt;&gt;&gt; allclose(a, dot(r, q))
True
&gt;&gt;&gt; r.shape, q.shape
((6, 9), (9, 9))
&gt;&gt;&gt; r2 = linalg.rq(a, mode='r')
&gt;&gt;&gt; allclose(r, r2)
True
&gt;&gt;&gt; r3, q3 = linalg.rq(a, mode='economic')
&gt;&gt;&gt; r3.shape, q3.shape
((6, 6), (6, 9))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to be decomposed</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether data in a is overwritten (may improve performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lwork" name="lwork" port_type="basic:Integer">
      <docstring>Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'r', 'economic']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="R" name="R" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Of shape (M, N) or (M, K) for ``mode='economic'``.  ``K = min(M, N)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Q" name="Q" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Of shape (N, N) or (K, N) for ``mode='economic'``.  Not returned
if ``mode='r'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.rsf2csf" module_name="rsf2csf" namespace="'linalg'" output_type="list">
    <docstring>Convert real Schur form to complex Schur form.

Convert a quasi-diagonal real-valued Schur form to the upper triangular
complex-valued Schur form.

Parameters
----------
T : (M, M) array_like
    Real Schur form of the original matrix
Z : (M, M) array_like
    Schur transformation matrix
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
T : (M, M) ndarray
    Complex Schur form of the original matrix
Z : (M, M) ndarray
    Schur transformation matrix corresponding to the complex form

See also
--------
schur : Schur decompose a matrix</docstring>
    <inputPortSpec arg="T" name="T" port_type="basic:List" show_port="True">
      <docstring>Real Schur form of the original matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True">
      <docstring>Schur transformation matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Complex Schur form of the original matrix</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Schur transformation matrix corresponding to the complex form</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.schur" module_name="schur" namespace="'linalg'" output_type="list">
    <docstring>Compute Schur decomposition of a matrix.

The Schur decomposition is::

    A = Z T Z^H

where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular.  In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.

Parameters
----------
a : (M, M) array_like
    Matrix to decompose
output : {'real', 'complex'}, optional
    Construct the real or complex Schur decomposition (for real matrices).
lwork : int, optional
    Work array size. If None or -1, it is automatically computed.
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance).
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
    Specifies whether the upper eigenvalues should be sorted.  A callable
    may be passed that, given a eigenvalue, returns a boolean denoting
    whether the eigenvalue should be sorted to the top-left (True).
    Alternatively, string parameters may be used::

        'lhp'   Left-hand plane (x.real &lt; 0.0)
        'rhp'   Right-hand plane (x.real &gt; 0.0)
        'iuc'   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
        'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)

    Defaults to None (no sorting).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
T : (M, M) ndarray
    Schur form of A. It is real-valued for the real Schur decomposition.
Z : (M, M) ndarray
    An unitary Schur transformation matrix for A.
    It is real-valued for the real Schur decomposition.
sdim : int
    If and only if sorting was requested, a third return value will
    contain the number of eigenvalues satisfying the sort condition.

Raises
------
LinAlgError
    Error raised under three conditions:

    1. The algorithm failed due to a failure of the QR algorithm to
       compute all eigenvalues
    2. If eigenvalue sorting was requested, the eigenvalues could not be
       reordered due to a failure to separate eigenvalues, usually because
       of poor conditioning
    3. If eigenvalue sorting was requested, roundoff errors caused the
       leading eigenvalues to no longer satisfy the sorting condition

See also
--------
rsf2csf : Convert real Schur form to complex Schur form</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to decompose</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Construct the real or complex Schur decomposition (for real matrices).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['real', 'complex']]</values>
      <defaults>['real']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lwork" name="lwork" port_type="basic:Integer">
      <docstring>Work array size. If None or -1, it is automatically computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite data in a (may improve performance).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sort" name="sort">
      <docstring>Specifies whether the upper eigenvalues should be sorted.  A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True).
Alternatively, string parameters may be used::

    'lhp'   Left-hand plane (x.real &lt; 0.0)
    'rhp'   Right-hand plane (x.real &gt; 0.0)
    'iuc'   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
    'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)

Defaults to None (no sorting).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lhp', 'rhp', 'iuc', 'ouc']]</values>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Schur form of A. It is real-valued for the real Schur decomposition.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Z" name="Z" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An unitary Schur transformation matrix for A.
It is real-valued for the real Schur decomposition.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sdim" name="sdim" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>If and only if sorting was requested, a third return value will
contain the number of eigenvalues satisfying the sort condition.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.signm" module_name="signm" namespace="'linalg'" output_type="list">
    <docstring>Matrix sign function.

Extension of the scalar sign(x) to matrices.

Parameters
----------
A : (N, N) array_like
    Matrix at which to evaluate the sign function
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
signm : (N, N) ndarray
    Value of the sign function at `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

Examples
--------
&gt;&gt;&gt; from scipy.linalg import signm, eigvals
&gt;&gt;&gt; a = [[1,2,3], [1,2,1], [1,1,1]]
&gt;&gt;&gt; eigvals(a)
array([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])
&gt;&gt;&gt; eigvals(signm(a))
array([-1.+0.j,  1.+0.j,  1.+0.j])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix at which to evaluate the sign function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="signm" name="signm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Value of the sign function at `A`</docstring>
    </outputPortSpec>
    <outputPortSpec arg="errest" name="errest" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>(if disp == False)

1-norm of the estimated error, ||err||_1 / ||A||_1</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.sinhm" module_name="sinhm" namespace="'linalg'">
    <docstring>Compute the hyperbolic matrix sine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
sinhm : (N, N) ndarray
    Hyperbolic matrix sine of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; s = sinhm(a)
&gt;&gt;&gt; s
array([[ 10.57300653,  39.28826594],
       [ 13.09608865,  49.86127247]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

&gt;&gt;&gt; t = tanhm(a)
&gt;&gt;&gt; c = coshm(a)
&gt;&gt;&gt; t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sinhm" name="sinhm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hyperbolic matrix sine of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.sinm" module_name="sinm" namespace="'linalg'">
    <docstring>Compute the matrix sine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
sinm : (N, N) ndarray
    Matrix cosine of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import expm, sinm, cosm

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

&gt;&gt;&gt; a = np.array([[1.0, 2.0], [-1.0, 3.0]])
&gt;&gt;&gt; expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
&gt;&gt;&gt; cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sinm" name="sinm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix cosine of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve" module_name="solve" namespace="'linalg'">
    <docstring>Solve the equation ``a x = b`` for ``x``.

Parameters
----------
a : (M, M) array_like
    A square matrix.
b : (M,) or (M, N) array_like
    Right-hand side matrix in ``a x = b``.
sym_pos : bool, optional
    Assume `a` is symmetric and positive definite.
lower : bool, optional
    Use only data contained in the lower triangle of `a`, if `sym_pos` is
    true.  Default is to use upper triangle.
overwrite_a : bool, optional
    Allow overwriting data in `a` (may enhance performance).
    Default is False.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance).
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system ``a x = b``.  Shape of the return matches the
    shape of `b`.

Raises
------
LinAlgError
    If `a` is singular.

Examples
--------
Given `a` and `b`, solve for `x`:

&gt;&gt;&gt; a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
&gt;&gt;&gt; b = np.array([2, 4, -1])
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; x = linalg.solve(a, b)
&gt;&gt;&gt; x
array([ 2., -2.,  9.])
&gt;&gt;&gt; np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A square matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right-hand side matrix in ``a x = b``.</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="sym_pos" name="sym_pos" port_type="basic:Boolean">
      <docstring>Assume `a` is symmetric and positive definite.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Use only data contained in the lower triangle of `a`, if `sym_pos` is
true.  Default is to use upper triangle.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Allow overwriting data in `a` (may enhance performance).
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Allow overwriting data in `b` (may enhance performance).
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="debug" name="debug" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>Solution to the system ``a x = b``.  Shape of the return matches the
shape of `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_banded" module_name="solve_banded" namespace="'linalg'">
    <docstring>Solve the equation a x = b for x, assuming a is banded matrix.

The matrix a is stored in `ab` using the matrix diagonal ordered form::

    ab[u + i - j, j] == a[i,j]

Example of `ab` (shape of a is (6,6), `u` =1, `l` =2)::

    *    a01  a12  a23  a34  a45
    a00  a11  a22  a33  a44  a55
    a10  a21  a32  a43  a54   *
    a20  a31  a42  a53   *    *

Parameters
----------
(l, u) : (integer, integer)
    Number of non-zero lower and upper diagonals
ab : (`l` + `u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b.  Returned shape depends on the
    shape of `b`.</docstring>
    <inputPortSpec arg="u)" name="u)" port_type="basic:Integer" show_port="True">
      <docstring>Number of non-zero lower and upper diagonals</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ab" name="ab" port_type="basic:List" show_port="True">
      <docstring>Banded matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right-hand side</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="overwrite_ab" name="overwrite_ab" port_type="basic:Boolean">
      <docstring>Discard data in `ab` (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Discard data in `b` (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="debug" name="debug" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="l_and_u" name="l_and_u" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The solution to the system a x = b.  Returned shape depends on the
shape of `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_circulant" module_name="solve_circulant" namespace="'linalg'">
    <docstring>Solve C x = b for x, where C is a circulant matrix.

`C` is the circulant matrix associated with the vector `c`.

The system is solved by doing division in Fourier space.  The
calculation is::

    x = ifft(fft(b) / fft(c))

where `fft` and `ifft` are the fast Fourier transform and its inverse,
respectively.  For a large vector `c`, this is *much* faster than
solving the system with the full circulant matrix.

Parameters
----------
c : array_like
    The coefficients of the circulant matrix.
b : array_like
    Right-hand side matrix in ``a x = b``.
singular : str, optional
    This argument controls how a near singular circulant matrix is
    handled.  If `singular` is "raise" and the circulant matrix is
    near singular, a `LinAlgError` is raised.  If `singular` is
    "lstsq", the least squares solution is returned.  Default is "raise".
tol : float, optional
    If any eigenvalue of the circulant matrix has an absolute value
    that is less than or equal to `tol`, the matrix is considered to be
    near singular.  If not given, `tol` is set to::

        tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps

    where `abs_eigs` is the array of absolute values of the eigenvalues
    of the circulant matrix.
caxis : int
    When `c` has dimension greater than 1, it is viewed as a collection
    of circulant vectors.  In this case, `caxis` is the axis of `c` that
    holds the vectors of circulant coefficients.
baxis : int
    When `b` has dimension greater than 1, it is viewed as a collection
    of vectors.  In this case, `baxis` is the axis of `b` that holds the
    right-hand side vectors.
outaxis : int
    When `c` or `b` are multidimensional, the value returned by
    `solve_circulant` is multidimensional.  In this case, `outaxis` is
    the axis of the result that holds the solution vectors.

Returns
-------
x : ndarray
    Solution to the system ``C x = b``.

Raises
------
LinAlgError
    If the circulant matrix associated with `c` is near singular.

See Also
--------
circulant

Notes
-----
For a one-dimensional vector `c` with length `m`, and an array `b`
with shape ``(m, ...)``,

    solve_circulant(c, b)

returns the same result as

    solve(circulant(c), b)

where `solve` and `circulant` are from `scipy.linalg`.

.. versionadded:: 0.16.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import solve_circulant, solve, circulant, lstsq

&gt;&gt;&gt; c = np.array([2, 2, 4])
&gt;&gt;&gt; b = np.array([1, 2, 3])
&gt;&gt;&gt; solve_circulant(c, b)
array([ 0.75, -0.25,  0.25])

Compare that result to solving the system with `scipy.linalg.solve`:

&gt;&gt;&gt; solve(circulant(c), b)
array([ 0.75, -0.25,  0.25])

A singular example:

&gt;&gt;&gt; c = np.array([1, 1, 0, 0])
&gt;&gt;&gt; b = np.array([1, 2, 3, 4])

Calling ``solve_circulant(c, b)`` will raise a `LinAlgError`.  For the
least square solution, use the option ``singular='lstsq'``:

&gt;&gt;&gt; solve_circulant(c, b, singular='lstsq')
array([ 0.25,  1.25,  2.25,  1.25])

Compare to `scipy.linalg.lstsq`:

&gt;&gt;&gt; x, resid, rnk, s = lstsq(circulant(c), b)
&gt;&gt;&gt; x
array([ 0.25,  1.25,  2.25,  1.25])

A broadcasting example:

Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three `b` vectors stored in an array with shape
(3, 5).  For example,

&gt;&gt;&gt; c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])
&gt;&gt;&gt; b = np.arange(15).reshape(-1, 5)

We want to solve all combinations of circulant matrices and `b` vectors,
with the result stored in an array with shape (2, 3, 5).  When we
disregard the axes of `c` and `b` that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting.  To have a broadcast result with shape
(2, 3), we add a trivial dimension to `c`: ``c[:, np.newaxis, :]`` has
shape (2, 1, 5).  The last dimension holds the coefficients of the
circulant matrices, so when we call `solve_circulant`, we can use the
default ``caxis=-1``.  The coefficients of the `b` vectors are in the last
dimension of the array `b`, so we use ``baxis=-1``.  If we use the
default `outaxis`, the result will have shape (5, 2, 3), so we'll use
``outaxis=-1`` to put the solution vectors in the last dimension.

&gt;&gt;&gt; x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)
&gt;&gt;&gt; x.shape
(2, 3, 5)
&gt;&gt;&gt; np.set_printoptions(precision=3)  # For compact output of numbers.
&gt;&gt;&gt; x
array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],
        [ 0.651,  0.989,  2.046,  0.627,  1.072],
        [ 1.42 ,  1.758,  2.816,  1.396,  1.841]],
       [[ 0.401,  0.304,  0.694, -0.867,  0.377],
        [ 0.856,  0.758,  1.149, -0.412,  0.831],
        [ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])

Check by solving one pair of `c` and `b` vectors (cf. ``x[1, 1, :]``):

&gt;&gt;&gt; solve_circulant(c[1], b[1, :])
array([ 0.856,  0.758,  1.149, -0.412,  0.831])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>The coefficients of the circulant matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand side matrix in ``a x = b``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="singular" name="singular">
      <docstring>This argument controls how a near singular circulant matrix is
handled.  If `singular` is "raise" and the circulant matrix is
near singular, a `LinAlgError` is raised.  If `singular` is
"lstsq", the least squares solution is returned.  Default is "raise".</docstring>
      <defaults>['raise']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>If any eigenvalue of the circulant matrix has an absolute value
that is less than or equal to `tol`, the matrix is considered to be
near singular.  If not given, `tol` is set to::

    tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps

where `abs_eigs` is the array of absolute values of the eigenvalues
of the circulant matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="caxis" name="caxis" port_type="basic:Integer">
      <docstring>When `c` has dimension greater than 1, it is viewed as a collection
of circulant vectors.  In this case, `caxis` is the axis of `c` that
holds the vectors of circulant coefficients.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="baxis" name="baxis" port_type="basic:Integer">
      <docstring>When `b` has dimension greater than 1, it is viewed as a collection
of vectors.  In this case, `baxis` is the axis of `b` that holds the
right-hand side vectors.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="outaxis" name="outaxis" port_type="basic:Integer">
      <docstring>When `c` or `b` are multidimensional, the value returned by
`solve_circulant` is multidimensional.  In this case, `outaxis` is
the axis of the result that holds the solution vectors.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the system ``C x = b``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_continuous_are" module_name="solve_continuous_are" namespace="'linalg'">
    <docstring>Solves the continuous algebraic Riccati equation, or CARE, defined
as (A'X + XA - XBR^-1B'X+Q=0) directly using a Schur decomposition
method.

Parameters
----------
a : (M, M) array_like
    Input
b : (M, N) array_like
    Input
q : (M, M) array_like
    Input
r : (N, N) array_like
    Non-singular, square matrix

Returns
-------
x : (M, M) ndarray
    Solution to the continuous algebraic Riccati equation

See Also
--------
solve_discrete_are : Solves the discrete algebraic Riccati equation

Notes
-----
Method taken from:
Laub, "A Schur Method for Solving Algebraic Riccati Equations."
U.S. Energy Research and Development Agency under contract
ERDA-E(49-18)-2087.
http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" name="r" port_type="basic:List" show_port="True">
      <docstring>Non-singular, square matrix</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the continuous algebraic Riccati equation</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_discrete_are" module_name="solve_discrete_are" namespace="'linalg'">
    <docstring>Solves the disctrete algebraic Riccati equation, or DARE, defined as
(X = A'XA-(A'XB)(R+B'XB)^-1(B'XA)+Q), directly using a Schur decomposition
method.

Parameters
----------
a : (M, M) array_like
    Non-singular, square matrix
b : (M, N) array_like
    Input
q : (M, M) array_like
    Input
r : (N, N) array_like
    Non-singular, square matrix

Returns
-------
x : ndarray
    Solution to the continuous Lyapunov equation

See Also
--------
solve_continuous_are : Solves the continuous algebraic Riccati equation

Notes
-----
Method taken from:
Laub, "A Schur Method for Solving Algebraic Riccati Equations."
U.S. Energy Research and Development Agency under contract
ERDA-E(49-18)-2087.
http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Non-singular, square matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" name="r" port_type="basic:List" show_port="True">
      <docstring>Non-singular, square matrix</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the continuous Lyapunov equation</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_discrete_lyapunov" module_name="solve_discrete_lyapunov" namespace="'linalg'">
    <docstring>Solves the discrete Lyapunov equation :math:`(A'XA-X=-Q)`.

Parameters
----------
a : (M, M) array_like
    A square matrix

q : (M, M) array_like
    Right-hand side square matrix

method : {'direct', 'bilinear'}, optional
    Type of solver.

    If not given, chosen to be ``direct`` if ``M`` is less than 10 and
    ``bilinear`` otherwise.

Returns
-------
x : ndarray
    Solution to the discrete Lyapunov equation

See Also
--------
solve_lyapunov : computes the solution to the continuous Lyapunov equation

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *direct* if ``M`` is less than 10
and ``bilinear`` otherwise.

Method *direct* uses a direct analytical solution to the discrete Lyapunov
equation. The algorithm is given in, for example, [1]_. However it requires
the linear solution of a system with dimension :math:`M^2` so that
performance degrades rapidly for even moderately sized matrices.

Method *bilinear* uses a bilinear transformation to convert the discrete
Lyapunov equation to a continuous Lyapunov equation :math:`(B'X+XB=-C)`
where :math:`B=(A-I)(A+I)^{-1}` and
:math:`C=2(A' + I)^{-1} Q (A + I)^{-1}`. The continuous equation can be
efficiently solved since it is a special case of a Sylvester equation.
The transformation algorithm is from Popov (1964) as described in [2]_.

.. versionadded:: 0.11.0

References
----------
.. [1] Hamilton, James D. Time Series Analysis, Princeton: Princeton
   University Press, 1994.  265.  Print.
   http://www.scribd.com/doc/20577138/Hamilton-1994-Time-Series-Analysis
.. [2] Gajic, Z., and M.T.J. Qureshi. 2008.
   Lyapunov Matrix Equation in System Stability and Control.
   Dover Books on Engineering Series. Dover Publications.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A square matrix
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:List" show_port="True">
      <docstring>Right-hand side square matrix
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Type of solver.

If not given, chosen to be ``direct`` if ``M`` is less than 10 and
``bilinear`` otherwise.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['direct', 'bilinear']]</values>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the discrete Lyapunov equation</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_lyapunov" module_name="solve_lyapunov" namespace="'linalg'">
    <docstring>Solves the continuous Lyapunov equation (AX + XA^H = Q) given the values
of A and Q using the Bartels-Stewart algorithm.

Parameters
----------
a : array_like
    A square matrix

q : array_like
    Right-hand side square matrix

Returns
-------
x : array_like
    Solution to the continuous Lyapunov equation

See Also
--------
solve_sylvester : computes the solution to the Sylvester equation

Notes
-----
Because the continuous Lyapunov equation is just a special form of the
Sylvester equation, this solver relies entirely on solve_sylvester for a
solution.

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A square matrix
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:List" show_port="True">
      <docstring>Right-hand side square matrix</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution to the continuous Lyapunov equation</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_sylvester" module_name="solve_sylvester" namespace="'linalg'">
    <docstring>Computes a solution (X) to the Sylvester equation (AX + XB = Q).

Parameters
----------
a : (M, M) array_like
    Leading matrix of the Sylvester equation
b : (N, N) array_like
    Trailing matrix of the Sylvester equation
q : (M, N) array_like
    Right-hand side

Returns
-------
x : (M, N) ndarray
    The solution to the Sylvester equation.

Raises
------
LinAlgError
    If solution was not found

Notes
-----
Computes a solution to the Sylvester matrix equation via the Bartels-
Stewart algorithm.  The A and B matrices first undergo Schur
decompositions.  The resulting matrices are used to construct an
alternative Sylvester equation (``RY + YS^T = F``) where the R and S
matrices are in quasi-triangular form (or, when R, S or F are complex,
triangular form).  The simplified equation is then solved using
``*TRSYL`` from LAPACK directly.

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Leading matrix of the Sylvester equation</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Trailing matrix of the Sylvester equation</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:List" show_port="True">
      <docstring>Right-hand side</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The solution to the Sylvester equation.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_toeplitz" module_name="solve_toeplitz" namespace="'linalg'">
    <docstring>Solve a Toeplitz system using Levinson Recursion

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``.  Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
    Right-hand side in ``T x = b``.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system ``T x = b``.  Shape of return matches shape
    of `b`.

Notes
-----
The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.</docstring>
    <inputPortSpec arg="c_or_cr" name="c_or_cr" port_type="basic:List" show_port="True">
      <docstring>The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
actual shape of ``c``, it will be converted to a 1-D array. If not
supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
of the Toeplitz matrix is ``[c[0], r[1:]]``.  Whatever the actual shape
of ``r``, it will be converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right-hand side in ``T x = b``.</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(result entirely NaNs) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The solution to the system ``T x = b``.  Shape of return matches shape
of `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solve_triangular" module_name="solve_triangular" namespace="'linalg'">
    <docstring>Solve the equation `a x = b` for `x`, assuming a is a triangular matrix.

Parameters
----------
a : (M, M) array_like
    A triangular matrix
b : (M,) or (M, N) array_like
    Right-hand side matrix in `a x = b`
lower : bool, optional
    Use only data contained in the lower triangle of `a`.
    Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
    Type of system to solve:

    ========  =========
    trans     system
    ========  =========
    0 or 'N'  a x  = b
    1 or 'T'  a^T x = b
    2 or 'C'  a^H x = b
    ========  =========
unit_diagonal : bool, optional
    If True, diagonal elements of `a` are assumed to be 1 and
    will not be referenced.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system `a x = b`.  Shape of return matches `b`.

Raises
------
LinAlgError
    If `a` is singular

Notes
-----
.. versionadded:: 0.9.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A triangular matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right-hand side matrix in `a x = b`</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Use only data contained in the lower triangle of `a`.
Default is to use upper triangle.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="trans" name="trans">
      <docstring>Type of system to solve:

========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['N', 'T', 'C']]</values>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="unit_diagonal" name="unit_diagonal" port_type="basic:Boolean">
      <docstring>If True, diagonal elements of `a` are assumed to be 1 and
will not be referenced.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Allow overwriting data in `b` (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="debug" name="debug" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>Solution to the system `a x = b`.  Shape of return matches `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.solveh_banded" module_name="solveh_banded" namespace="'linalg'">
    <docstring>Solve equation a x = b. a is Hermitian positive-definite banded matrix.

The matrix a is stored in `ab` either in lower diagonal or upper
diagonal ordered form:

    ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
    ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)

Example of `ab` (shape of a is (6, 6), `u` =2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Cells marked with * are not used.

Parameters
----------
ab : (`u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b.  Shape of return matches shape
    of `b`.</docstring>
    <inputPortSpec arg="ab" name="ab" port_type="basic:List" show_port="True">
      <docstring>Banded matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right-hand side</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="overwrite_ab" name="overwrite_ab" port_type="basic:Boolean">
      <docstring>Discard data in `ab` (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_b" name="overwrite_b" port_type="basic:Boolean">
      <docstring>Discard data in `b` (may enhance performance)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lower" name="lower" port_type="basic:Boolean">
      <docstring>Is the matrix in the lower form. (Default is upper form)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The solution to the system a x = b.  Shape of return matches shape
of `b`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.sqrtm" module_name="sqrtm" namespace="'linalg'" output_type="list">
    <docstring>Matrix square root.

Parameters
----------
A : (N, N) array_like
    Matrix whose square root to evaluate
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)
blocksize : integer, optional
    If the blocksize is not degenerate with respect to the
    size of the input array, then use a blocked algorithm. (Default: 64)

Returns
-------
sqrtm : (N, N) ndarray
    Value of the sqrt function at `A`

errest : float
    (if disp == False)

    Frobenius norm of the estimated error, ||err||_F / ||A||_F

References
----------
.. [1] Edvin Deadman, Nicholas J. Higham, Rui Ralha (2013)
       "Blocked Schur Algorithms for Computing the Matrix Square Root,
       Lecture Notes in Computer Science, 7782. pp. 171-182.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import sqrtm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; r = sqrtm(a)
&gt;&gt;&gt; r
array([[ 0.75592895,  1.13389342],
       [ 0.37796447,  1.88982237]])
&gt;&gt;&gt; r.dot(r)
array([[ 1.,  3.],
       [ 1.,  4.]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix whose square root to evaluate</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="blocksize" name="blocksize" port_type="basic:Integer">
      <docstring>If the blocksize is not degenerate with respect to the
size of the input array, then use a blocked algorithm. (Default: 64)</docstring>
      <defaults>[64]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sqrtm" name="sqrtm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Value of the sqrt function at `A`
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="errest" name="errest" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>(if disp == False)

Frobenius norm of the estimated error, ||err||_F / ||A||_F</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.svd" module_name="svd" namespace="'linalg'" output_type="list">
    <docstring>Singular Value Decomposition.

Factorizes the matrix a into two unitary matrices U and Vh, and
a 1-D array s of singular values (real, non-negative) such that
``a == U*S*Vh``, where S is a suitably shaped matrix of zeros with
main diagonal s.

Parameters
----------
a : (M, N) array_like
    Matrix to decompose.
full_matrices : bool, optional
    If True, `U` and `Vh` are of shape ``(M,M)``, ``(N,N)``.
    If False, the shapes are ``(M,K)`` and ``(K,N)``, where
    ``K = min(M,N)``.
compute_uv : bool, optional
    Whether to compute also `U` and `Vh` in addition to `s`.
    Default is True.
overwrite_a : bool, optional
    Whether to overwrite `a`; may improve performance.
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
U : ndarray
    Unitary matrix having left singular vectors as columns.
    Of shape ``(M,M)`` or ``(M,K)``, depending on `full_matrices`.
s : ndarray
    The singular values, sorted in non-increasing order.
    Of shape (K,), with ``K = min(M, N)``.
Vh : ndarray
    Unitary matrix having right singular vectors as rows.
    Of shape ``(N,N)`` or ``(K,N)`` depending on `full_matrices`.

For ``compute_uv = False``, only `s` is returned.

Raises
------
LinAlgError
    If SVD computation does not converge.

See also
--------
svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.

Examples
--------
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.random.randn(9, 6) + 1.j*np.random.randn(9, 6)
&gt;&gt;&gt; U, s, Vh = linalg.svd(a)
&gt;&gt;&gt; U.shape, Vh.shape, s.shape
((9, 9), (6, 6), (6,))

&gt;&gt;&gt; U, s, Vh = linalg.svd(a, full_matrices=False)
&gt;&gt;&gt; U.shape, Vh.shape, s.shape
((9, 6), (6, 6), (6,))
&gt;&gt;&gt; S = linalg.diagsvd(s, 6, 6)
&gt;&gt;&gt; np.allclose(a, np.dot(U, np.dot(S, Vh)))
True

&gt;&gt;&gt; s2 = linalg.svd(a, compute_uv=False)
&gt;&gt;&gt; np.allclose(s, s2)
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to decompose.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_matrices" name="full_matrices" port_type="basic:Boolean">
      <docstring>If True, `U` and `Vh` are of shape ``(M,M)``, ``(N,N)``.
If False, the shapes are ``(M,K)`` and ``(K,N)``, where
``K = min(M,N)``.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="compute_uv" name="compute_uv" port_type="basic:Boolean">
      <docstring>Whether to compute also `U` and `Vh` in addition to `s`.
Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite `a`; may improve performance.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="U" name="U" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Unitary matrix having left singular vectors as columns.
Of shape ``(M,M)`` or ``(M,K)``, depending on `full_matrices`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The singular values, sorted in non-increasing order.
Of shape (K,), with ``K = min(M, N)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Vh" name="Vh" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Unitary matrix having right singular vectors as rows.
Of shape ``(N,N)`` or ``(K,N)`` depending on `full_matrices`.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="4" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.svdvals" module_name="svdvals" namespace="'linalg'">
    <docstring>Compute singular values of a matrix.

Parameters
----------
a : (M, N) array_like
    Matrix to decompose.
overwrite_a : bool, optional
    Whether to overwrite `a`; may improve performance.
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
s : (min(M, N),) ndarray
    The singular values, sorted in decreasing order.

Raises
------
LinAlgError
    If SVD computation does not converge.

Notes
-----
``svdvals(a)`` only differs from ``svd(a, compute_uv=False)`` by its
handling of the edge case of empty ``a``, where it returns an
empty sequence:

&gt;&gt;&gt; a = np.empty((0, 2))
&gt;&gt;&gt; from scipy.linalg import svdvals
&gt;&gt;&gt; svdvals(a)
array([], dtype=float64)

See also
--------
svd : Compute the full singular value decomposition of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Matrix to decompose.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="overwrite_a" name="overwrite_a" port_type="basic:Boolean">
      <docstring>Whether to overwrite `a`; may improve performance.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The singular values, sorted in decreasing order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.tanhm" module_name="tanhm" namespace="'linalg'">
    <docstring>Compute the hyperbolic matrix tangent.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array

Returns
-------
tanhm : (N, N) ndarray
    Hyperbolic matrix tangent of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanhm, sinhm, coshm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; t = tanhm(a)
&gt;&gt;&gt; t
array([[ 0.3428582 ,  0.51987926],
       [ 0.17329309,  0.86273746]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

&gt;&gt;&gt; s = sinhm(a)
&gt;&gt;&gt; c = coshm(a)
&gt;&gt;&gt; t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tanhm" name="tanhm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hyperbolic matrix tangent of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.tanm" module_name="tanm" namespace="'linalg'">
    <docstring>Compute the matrix tangent.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
tanm : (N, N) ndarray
    Matrix tangent of `A`

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tanm, sinm, cosm
&gt;&gt;&gt; a = np.array([[1.0, 3.0], [1.0, 4.0]])
&gt;&gt;&gt; t = tanm(a)
&gt;&gt;&gt; t
array([[ -2.00876993,  -8.41880636],
       [ -2.80626879, -10.42757629]])

Verify tanm(a) = sinm(a).dot(inv(cosm(a)))

&gt;&gt;&gt; s = sinm(a)
&gt;&gt;&gt; c = cosm(a)
&gt;&gt;&gt; s.dot(np.linalg.inv(c))
array([[ -2.00876993,  -8.41880636],
       [ -2.80626879, -10.42757629]])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tanm" name="tanm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix tangent of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.toeplitz" module_name="toeplitz" namespace="'linalg'">
    <docstring>Construct a Toeplitz matrix.

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c : array_like
    First column of the matrix.  Whatever the actual shape of `c`, it
    will be converted to a 1-D array.
r : array_like, optional
    First row of the matrix. If None, ``r = conjugate(c)`` is assumed;
    in this case, if c[0] is real, the result is a Hermitian matrix.
    r[0] is ignored; the first row of the returned matrix is
    ``[c[0], r[1:]]``.  Whatever the actual shape of `r`, it will be
    converted to a 1-D array.

Returns
-------
A : (len(c), len(r)) ndarray
    The Toeplitz matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.

See also
--------
circulant : circulant matrix
hankel : Hankel matrix

Notes
-----
The behavior when `c` or `r` is a scalar, or when `c` is complex and
`r` is None, was changed in version 0.8.0.  The behavior in previous
versions was undocumented and is no longer supported.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import toeplitz
&gt;&gt;&gt; toeplitz([1,2,3], [1,4,5,6])
array([[1, 4, 5, 6],
       [2, 1, 4, 5],
       [3, 2, 1, 4]])
&gt;&gt;&gt; toeplitz([1.0, 2+3j, 4-1j])
array([[ 1.+0.j,  2.-3.j,  4.+1.j],
       [ 2.+3.j,  1.+0.j,  2.-3.j],
       [ 4.-1.j,  2.+3.j,  1.+0.j]])</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>First column of the matrix.  Whatever the actual shape of `c`, it
will be converted to a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" name="r" port_type="basic:List">
      <docstring>First row of the matrix. If None, ``r = conjugate(c)`` is assumed;
in this case, if c[0] is real, the result is a Hermitian matrix.
r[0] is ignored; the first row of the returned matrix is
``[c[0], r[1:]]``.  Whatever the actual shape of `r`, it will be
converted to a 1-D array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Toeplitz matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.tri" module_name="tri" namespace="'linalg'">
    <docstring>Construct (N, M) matrix filled with ones at and below the k-th diagonal.

The matrix has A[i,j] == 1 for i &lt;= j + k

Parameters
----------
N : int
    The size of the first dimension of the matrix.
M : int or None, optional
    The size of the second dimension of the matrix. If `M` is None,
    `M = N` is assumed.
k : int, optional
    Number of subdiagonal below which matrix is filled with ones.
    `k` = 0 is the main diagonal, `k` &lt; 0 subdiagonal and `k` &gt; 0
    superdiagonal.
dtype : dtype, optional
    Data type of the matrix.

Returns
-------
tri : (N, M) ndarray
    Tri matrix.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tri
&gt;&gt;&gt; tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])
&gt;&gt;&gt; tri(3, 5, -1, dtype=int)
array([[0, 0, 0, 0, 0],
       [1, 0, 0, 0, 0],
       [1, 1, 0, 0, 0]])</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The size of the first dimension of the matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M">
      <docstring>The size of the second dimension of the matrix. If `M` is None,
`M = N` is assumed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Number of subdiagonal below which matrix is filled with ones.
`k` = 0 is the main diagonal, `k` &lt; 0 subdiagonal and `k` &gt; 0
superdiagonal.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tri" name="tri" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Tri matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.tril" module_name="tril" namespace="'linalg'">
    <docstring>Make a copy of a matrix with elements above the k-th diagonal zeroed.

Parameters
----------
m : array_like
    Matrix whose elements to return
k : int, optional
    Diagonal above which to zero elements.
    `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
    `k` &gt; 0 superdiagonal.

Returns
-------
tril : ndarray
    Return is the same shape and type as `m`.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tril
&gt;&gt;&gt; tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Matrix whose elements to return</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Diagonal above which to zero elements.
`k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
`k` &gt; 0 superdiagonal.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tril" name="tril" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Return is the same shape and type as `m`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.linalg.triu" module_name="triu" namespace="'linalg'">
    <docstring>Make a copy of a matrix with elements below the k-th diagonal zeroed.

Parameters
----------
m : array_like
    Matrix whose elements to return
k : int, optional
    Diagonal below which to zero elements.
    `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
    `k` &gt; 0 superdiagonal.

Returns
-------
triu : ndarray
    Return matrix with zeroed elements below the k-th diagonal and has
    same shape and type as `m`.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import triu
&gt;&gt;&gt; triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>Matrix whose elements to return</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Diagonal below which to zero elements.
`k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
`k` &gt; 0 superdiagonal.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="triu" name="triu" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Return matrix with zeroed elements below the k-th diagonal and has
same shape and type as `m`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.who" module_name="who" namespace="'misc'">
    <docstring>Print the Numpy arrays in the given dictionary.

If there is no dictionary passed in or `vardict` is None then returns
Numpy arrays in the globals() dictionary (all Numpy arrays in the
namespace).

Parameters
----------
vardict : dict, optional
    A dictionary possibly containing ndarrays.  Default is globals().

Returns
-------
out : None
    Returns 'None'.

Notes
-----
Prints out the name, shape, bytes and type of all of the ndarrays
present in `vardict`.

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; b = np.ones(20)
&gt;&gt;&gt; np.who()
Name            Shape            Bytes            Type
===========================================================
a               10               40               int32
b               20               160              float64
Upper bound on total bytes  =       200

&gt;&gt;&gt; d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',
... 'idx':5}
&gt;&gt;&gt; np.who(d)
Name            Shape            Bytes            Type
===========================================================
y               3                24               float64
x               2                16               float64
Upper bound on total bytes  =       40</docstring>
    <inputPortSpec arg="vardict" name="vardict" port_type="basic:Dictionary">
      <docstring>A dictionary possibly containing ndarrays.  Default is globals().</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Returns 'None'.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.source" module_name="source" namespace="'misc'">
    <docstring>Print or write to a file the source code for a Numpy object.

The source code is only returned for objects written in Python. Many
functions and classes are defined in C and will therefore not return
useful information.

Parameters
----------
object : numpy object
    Input object. This can be any object (function, class, module,
    ...).
output : file object, optional
    If `output` not supplied then source code is printed to screen
    (sys.stdout).  File object must be created with either write 'w' or
    append 'a' modes.

See Also
--------
lookfor, info

Examples
--------
&gt;&gt;&gt; np.source(np.interp)                        #doctest: +SKIP
In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py
def interp(x, xp, fp, left=None, right=None):
    """.... (full docstring printed)"""
    if isinstance(x, (float, int, number)):
        return compiled_interp([x], xp, fp, left, right).item()
    else:
        return compiled_interp(x, xp, fp, left, right)

The source code is only returned for objects written in Python.

&gt;&gt;&gt; np.source(np.array)                         #doctest: +SKIP
Not available for this object.</docstring>
    <inputPortSpec arg="object" name="object" port_type="basic:List" show_port="True">
      <docstring>Input object. This can be any object (function, class, module,
...).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>If `output` not supplied then source code is printed to screen
(sys.stdout).  File object must be created with either write 'w' or
append 'a' modes.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.info" module_name="info" namespace="'misc'">
    <docstring>Get help information for a function, class, or module.

Parameters
----------
object : object or str, optional
    Input object or name to get information about. If `object` is a
    numpy object, its docstring is given. If it is a string, available
    modules are searched for matching objects.  If None, information
    about `info` itself is returned.
maxwidth : int, optional
    Printing width.
output : file like object, optional
    File like object that the output is written to, default is
    ``stdout``.  The object has to be opened in 'w' or 'a' mode.
toplevel : str, optional
    Start search at this level.

See Also
--------
source, lookfor

Notes
-----
When used interactively with an object, ``np.info(obj)`` is equivalent
to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython
prompt.

Examples
--------
&gt;&gt;&gt; np.info(np.polyval) # doctest: +SKIP
   polyval(p, x)
     Evaluate the polynomial p at x.
     ...

When using a string for `object` it is possible to get multiple results.

&gt;&gt;&gt; np.info('fft') # doctest: +SKIP
     *** Found in numpy ***
Core FFT routines
...
     *** Found in numpy.fft ***
 fft(a, n=None, axis=-1)
...
     *** Repeat reference found in numpy.fft.fftpack ***
     *** Total of 3 references found. ***</docstring>
    <inputPortSpec arg="object" name="objectScalar">
      <docstring>Input object or name to get information about. If `object` is a
numpy object, its docstring is given. If it is a string, available
modules are searched for matching objects.  If None, information
about `info` itself is returned.</docstring>
      <alternateSpec arg="object" name="objectSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="maxwidth" name="maxwidth" port_type="basic:Integer">
      <docstring>Printing width.</docstring>
      <defaults>[76]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>File like object that the output is written to, default is
``stdout``.  The object has to be opened in 'w' or 'a' mode.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="toplevel" name="toplevel">
      <docstring>Start search at this level.</docstring>
      <defaults>['scipy']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.fromimage" module_name="fromimage" namespace="'misc'">
    <docstring>Return a copy of a PIL image as a numpy array.

Parameters
----------
im : PIL image
    Input image.
flatten : bool
    If true, convert the output to grey-scale.

Returns
-------
fromimage : ndarray
    The different colour bands/channels are stored in the
    third dimension, such that a grey-image is MxN, an
    RGB-image MxNx3 and an RGBA-image MxNx4.</docstring>
    <inputPortSpec arg="im" name="im" port_type="basic:Variant" show_port="True">
      <docstring>Input image.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="flatten" name="flattenScalar" port_type="basic:Integer">
      <docstring>If true, convert the output to grey-scale.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="flatten" name="flattenBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="fromimage" name="fromimage" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The different colour bands/channels are stored in the
third dimension, such that a grey-image is MxN, an
RGB-image MxNx3 and an RGBA-image MxNx4.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.toimage" module_name="toimage" namespace="'misc'">
    <docstring>Takes a numpy array and returns a PIL image.

The mode of the PIL image depends on the array shape and the `pal` and
`mode` keywords.

For 2-D arrays, if `pal` is a valid (N,3) byte-array giving the RGB values
(from 0 to 255) then ``mode='P'``, otherwise ``mode='L'``, unless mode
is given as 'F' or 'I' in which case a float and/or integer array is made.

Notes
-----
For 3-D arrays, the `channel_axis` argument tells which dimension of the
array holds the channel data.

For 3-D arrays if one of the dimensions is 3, the mode is 'RGB'
by default or 'YCbCr' if selected.

The numpy array must be either 2 dimensional or 3 dimensional.</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="cmin" name="cmin" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="high" name="high" port_type="basic:Integer">
      <defaults>[255]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="channel_axis" name="channel_axis" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="low" name="low" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="cmax" name="cmax" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="pal" name="pal" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="mode" name="mode" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.imsave" module_name="imsave" namespace="'misc'">
    <docstring>Save an array as an image.

Parameters
----------
name : str or file object
    Output file name or file object.
arr : ndarray, MxN or MxNx3 or MxNx4
    Array containing image values.  If the shape is ``MxN``, the array
    represents a grey-level image.  Shape ``MxNx3`` stores the red, green
    and blue bands along the last dimension.  An alpha layer may be
    included, specified as the last colour band of an ``MxNx4`` array.
format : str
    Image format. If omitted, the format to use is determined from the
    file name extension. If a file object was used instead of a file name,
    this parameter should always be used.

Examples
--------
Construct an array of gradient intensity values and save to file:

&gt;&gt;&gt; x = np.zeros((255, 255))
&gt;&gt;&gt; x = np.zeros((255, 255), dtype=np.uint8)
&gt;&gt;&gt; x[:] = np.arange(255)
&gt;&gt;&gt; imsave('/tmp/gradient.png', x)

Construct an array with three colour bands (R, G, B) and store to file:

&gt;&gt;&gt; rgb = np.zeros((255, 255, 3), dtype=np.uint8)
&gt;&gt;&gt; rgb[..., 0] = np.arange(255)
&gt;&gt;&gt; rgb[..., 1] = 55
&gt;&gt;&gt; rgb[..., 2] = 1 - np.arange(255)
&gt;&gt;&gt; imsave('/tmp/rgb_gradient.png', rgb)</docstring>
    <inputPortSpec arg="name" name="nameScalar" show_port="True">
      <docstring>Output file name or file object.</docstring>
      <alternateSpec arg="name" name="nameSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="arr" name="arrScalar" show_port="True">
      <docstring>Array containing image values.  If the shape is ``MxN``, the array
represents a grey-level image.  Shape ``MxNx3`` stores the red, green
and blue bands along the last dimension.  An alpha layer may be
included, specified as the last colour band of an ``MxNx4`` array.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['MxNx3', 'MxNx4']]</values>
      <alternateSpec arg="arr" name="arrSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="format" name="format" show_port="True">
      <docstring>Image format. If omitted, the format to use is determined from the
file name extension. If a file object was used instead of a file name,
this parameter should always be used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.imread" module_name="imread" namespace="'misc'">
    <docstring>Read an image from a file as an array.

Parameters
----------
name : str or file object
    The file name or file object to be read.
flatten : bool, optional
    If True, flattens the color layers into a single gray-scale layer.

Returns
-------
imread : ndarray
    The array obtained by reading image from file `imfile`.

Notes
-----
The image is flattened by calling convert('F') on
the resulting image object.</docstring>
    <inputPortSpec arg="name" name="nameScalar" show_port="True">
      <docstring>The file name or file object to be read.</docstring>
      <alternateSpec arg="name" name="nameSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="flatten" name="flattenScalar" port_type="basic:Integer">
      <docstring>If True, flattens the color layers into a single gray-scale layer.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="flatten" name="flattenBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="imread" name="imread" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array obtained by reading image from file `imfile`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.bytescale" module_name="bytescale" namespace="'misc'">
    <docstring>Byte scales an array (image).

Byte scaling means converting the input image to uint8 dtype and scaling
the range to ``(low, high)`` (default 0-255).
If the input image already has dtype uint8, no scaling is done.

Parameters
----------
data : ndarray
    PIL image data array.
cmin : scalar, optional
    Bias scaling of small values. Default is ``data.min()``.
cmax : scalar, optional
    Bias scaling of large values. Default is ``data.max()``.
high : scalar, optional
    Scale max value to `high`.  Default is 255.
low : scalar, optional
    Scale min value to `low`.  Default is 0.

Returns
-------
img_array : uint8 ndarray
    The byte-scaled array.

Examples
--------
&gt;&gt;&gt; img = array([[ 91.06794177,   3.39058326,  84.4221549 ],
                 [ 73.88003259,  80.91433048,   4.88878881],
                 [ 51.53875334,  34.45808177,  27.5873488 ]])
&gt;&gt;&gt; bytescale(img)
array([[255,   0, 236],
       [205, 225,   4],
       [140,  90,  70]], dtype=uint8)
&gt;&gt;&gt; bytescale(img, high=200, low=100)
array([[200, 100, 192],
       [180, 188, 102],
       [155, 135, 128]], dtype=uint8)
&gt;&gt;&gt; bytescale(img, cmin=0, cmax=255)
array([[91,  3, 84],
       [74, 81,  5],
       [52, 34, 28]], dtype=uint8)</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>PIL image data array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmin" name="cmin" port_type="basic:Float">
      <docstring>Bias scaling of small values. Default is ``data.min()``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmax" name="cmax" port_type="basic:Float">
      <docstring>Bias scaling of large values. Default is ``data.max()``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Float">
      <docstring>Scale max value to `high`.  Default is 255.</docstring>
      <defaults>[255]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="low" name="low" port_type="basic:Float">
      <docstring>Scale min value to `low`.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="img_array" depth="1" name="img_array" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The byte-scaled array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.imrotate" module_name="imrotate" namespace="'misc'">
    <docstring>Rotate an image counter-clockwise by angle degrees.

Parameters
----------
arr : ndarray
    Input array of image to be rotated.
angle : float
    The angle of rotation.
interp : str, optional
    Interpolation

    - 'nearest' :  for nearest neighbor
    - 'bilinear' : for bilinear
    - 'cubic' : cubic
    - 'bicubic' : for bicubic

Returns
-------
imrotate : ndarray
    The rotated array of image.</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array of image to be rotated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="angle" name="angle" port_type="basic:Float" show_port="True">
      <docstring>The angle of rotation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="interp" name="interp">
      <docstring>Interpolation

- 'nearest' :  for nearest neighbor
- 'bilinear' : for bilinear
- 'cubic' : cubic
- 'bicubic' : for bicubic</docstring>
      <defaults>['bilinear']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="imrotate" name="imrotate" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The rotated array of image.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.imresize" module_name="imresize" namespace="'misc'">
    <docstring>Resize an image.

Parameters
----------
arr : ndarray
    The array of image to be resized.

size : int, float or tuple
    * int   - Percentage of current size.
    * float - Fraction of current size.
    * tuple - Size of the output image.

interp : str, optional
    Interpolation to use for re-sizing ('nearest', 'bilinear', 'bicubic'
    or 'cubic').

mode : str, optional
    The PIL image mode ('P', 'L', etc.) to convert `arr` before resizing.

Returns
-------
imresize : ndarray
    The resized array of image.

See Also
--------
toimage : Implicitly used to convert `arr` according to `mode`.
scipy.ndimage.zoom : More generic implementation that does not use PIL.</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>The array of image to be resized.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float" show_port="True">
      <docstring>* int   - Percentage of current size.
* float - Fraction of current size.
* tuple - Size of the output image.
</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="interp" name="interp">
      <docstring>Interpolation to use for re-sizing ('nearest', 'bilinear', 'bicubic'
or 'cubic').
</docstring>
      <defaults>['bilinear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The PIL image mode ('P', 'L', etc.) to convert `arr` before resizing.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="imresize" name="imresize" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The resized array of image.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.imshow" module_name="imshow" namespace="'misc'">
    <docstring>Simple showing of an image through an external viewer.

Uses the image viewer specified by the environment variable
SCIPY_PIL_IMAGE_VIEWER, or if that is not defined then `see`,
to view a temporary file generated from array data.

Parameters
----------
arr : ndarray
    Array of image data to show.

Returns
-------
None

Examples
--------
&gt;&gt;&gt; a = np.tile(np.arange(255), (255,1))
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; misc.pilutil.imshow(a)</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Array of image data to show.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.imfilter" module_name="imfilter" namespace="'misc'">
    <docstring>Simple filtering of an image.

Parameters
----------
arr : ndarray
    The array of Image in which the filter is to be applied.
ftype : str
    The filter that has to be applied. Legal values are:
    'blur', 'contour', 'detail', 'edge_enhance', 'edge_enhance_more',
    'emboss', 'find_edges', 'smooth', 'smooth_more', 'sharpen'.

Returns
-------
imfilter : ndarray
    The array with filter applied.

Raises
------
ValueError
    *Unknown filter type.*  If the filter you are trying
    to apply is unsupported.</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>The array of Image in which the filter is to be applied.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ftype" name="ftype" show_port="True">
      <docstring>The filter that has to be applied. Legal values are:
'blur', 'contour', 'detail', 'edge_enhance', 'edge_enhance_more',
'emboss', 'find_edges', 'smooth', 'smooth_more', 'sharpen'.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="imfilter" name="imfilter" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The array with filter applied.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.logsumexp" module_name="logsumexp" namespace="'misc'">
    <docstring>Compute the log of the sum of exponentials of input elements.

Parameters
----------
a : array_like
    Input array.
axis : None or int or tuple of ints, optional
    Axis or axes over which the sum is taken. By default `axis` is None,
    and all elements are summed. Tuple of ints is not accepted if NumPy
    version is lower than 1.7.0.

    .. versionadded:: 0.11.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the original array.

    .. versionadded:: 0.15.0
b : array-like, optional
    Scaling factor for exp(`a`) must be of the same shape as `a` or
    broadcastable to `a`.

    .. versionadded:: 0.12.0

Returns
-------
res : ndarray
    The result, ``np.log(np.sum(np.exp(a)))`` calculated in a numerically
    more stable way. If `b` is given then ``np.log(np.sum(b*np.exp(a)))``
    is returned.

See Also
--------
numpy.logaddexp, numpy.logaddexp2

Notes
-----
Numpy has a logaddexp function which is very similar to `logsumexp`, but
only handles two arguments. `logaddexp.reduce` is similar to this
function, but may be less stable.

Examples
--------
&gt;&gt;&gt; from scipy.misc import logsumexp
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; np.log(np.sum(np.exp(a)))
9.4586297444267107
&gt;&gt;&gt; logsumexp(a)
9.4586297444267107

With weights

&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; b = np.arange(10, 0, -1)
&gt;&gt;&gt; logsumexp(a, b=b)
9.9170178533034665
&gt;&gt;&gt; np.log(np.sum(b*np.exp(a)))
9.9170178533034647</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes over which the sum is taken. By default `axis` is None,
and all elements are summed. Tuple of ints is not accepted if NumPy
version is lower than 1.7.0.

.. versionadded:: 0.11.0</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original array.

.. versionadded:: 0.15.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List">
      <docstring>Scaling factor for exp(`a`) must be of the same shape as `a` or
broadcastable to `a`.

.. versionadded:: 0.12.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result, ``np.log(np.sum(np.exp(a)))`` calculated in a numerically
more stable way. If `b` is given then ``np.log(np.sum(b*np.exp(a)))``
is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.central_diff_weights" module_name="central_diff_weights" namespace="'misc'">
    <docstring>Return weights for an Np-point central derivative.

Assumes equally-spaced function points.

If weights are in the vector w, then
derivative is w[0] * f(x-ho*dx) + ... + w[-1] * f(x+h0*dx)

Parameters
----------
Np : int
    Number of points for the central derivative.
ndiv : int, optional
    Number of divisions.  Default is 1.

Notes
-----
Can be inaccurate for large number of points.</docstring>
    <inputPortSpec arg="Np" name="Np" port_type="basic:Integer" show_port="True">
      <docstring>Number of points for the central derivative.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ndiv" name="ndiv" port_type="basic:Integer">
      <docstring>Number of divisions.  Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.derivative" module_name="derivative" namespace="'misc'">
    <docstring>Find the n-th derivative of a function at a point.

Given a function, use a central difference formula with spacing `dx` to
compute the `n`-th derivative at `x0`.

Parameters
----------
func : function
    Input function.
x0 : float
    The point at which `n`-th derivative is found.
dx : int, optional
    Spacing.
n : int, optional
    Order of the derivative. Default is 1.
args : tuple, optional
    Arguments
order : int, optional
    Number of points to use, must be odd.

Notes
-----
Decreasing the step size too small can result in round-off error.

Examples
--------
&gt;&gt;&gt; def f(x):
...     return x**3 + x**2
...
&gt;&gt;&gt; derivative(f, 1.0, dx=1e-6)
4.9999999999217337</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Input function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:Float" show_port="True">
      <docstring>The point at which `n`-th derivative is found.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <docstring>Spacing.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Order of the derivative. Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Arguments</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>Number of points to use, must be odd.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.pade" module_name="pade" namespace="'misc'" output_type="list">
    <docstring>Return Pade approximation to a polynomial as the ratio of two polynomials.

Parameters
----------
an : (N,) array_like
    Taylor series coefficients.
m : int
    The order of the returned approximating polynomials.

Returns
-------
p, q : Polynomial class
    The pade approximation of the polynomial defined by `an` is
    `p(x)/q(x)`.

Examples
--------
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]
&gt;&gt;&gt; p, q = misc.pade(e_exp, 2)

&gt;&gt;&gt; e_exp.reverse()
&gt;&gt;&gt; e_poly = np.poly1d(e_exp)

Compare ``e_poly(x)`` and the pade approximation ``p(x)/q(x)``

&gt;&gt;&gt; e_poly(1)
2.7166666666666668

&gt;&gt;&gt; p(1)/q(1)
2.7179487179487181</docstring>
    <inputPortSpec arg="an" name="an" port_type="basic:List" show_port="True">
      <docstring>Taylor series coefficients.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>The order of the returned approximating polynomials.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The pade approximation of the polynomial defined by `an` is
`p(x)/q(x)`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="q" name="q" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>The pade approximation of the polynomial defined by `an` is
`p(x)/q(x)`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.lena" module_name="lena" namespace="'misc'">
    <docstring>Get classic image processing example image, Lena, at 8-bit grayscale
bit-depth, 512 x 512 size.

Parameters
----------
None

Returns
-------
lena : ndarray
    Lena image

Notes
-----
Though safe for work in most places, this sexualized image is drawn from
Playboy and makes some viewers uncomfortable.  It has been very widely
used as an example in image processing and is therefore made available
for compatibility.  For new code that needs an example image we recommend
`face` or `ascent`.

Examples
--------
&gt;&gt;&gt; import scipy.misc
&gt;&gt;&gt; lena = scipy.misc.lena()
&gt;&gt;&gt; lena.shape
(512, 512)
&gt;&gt;&gt; lena.max()
245
&gt;&gt;&gt; lena.dtype
dtype('int32')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.gray()
&gt;&gt;&gt; plt.imshow(lena)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="None" name="None" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="lena" name="lena" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Lena image</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.ascent" module_name="ascent" namespace="'misc'">
    <docstring>Get an 8-bit grayscale bit-depth, 512 x 512 derived image for easy use in demos

The image is derived from accent-to-the-top.jpg at
http://www.public-domain-image.com/people-public-domain-images-pictures/

Parameters
----------
None

Returns
-------
ascent : ndarray
   convenient image to use for testing and demonstration

Examples
--------
&gt;&gt;&gt; import scipy.misc
&gt;&gt;&gt; ascent = scipy.misc.ascent()
&gt;&gt;&gt; ascent.shape
(512, 512)
&gt;&gt;&gt; ascent.max()
255

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.gray()
&gt;&gt;&gt; plt.imshow(ascent)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="None" name="None" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="ascent" name="ascent" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>convenient image to use for testing and demonstration</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.misc.face" module_name="face" namespace="'misc'">
    <docstring>Get a 1024 x 768, color image of a raccoon face.

raccoon-procyon-lotor.jpg at http://www.public-domain-image.com

Parameters
----------
gray : bool, optional
    If True then return color image, otherwise return an 8-bit gray-scale

Returns
-------
face : ndarray
    image of a racoon face

Examples
--------
&gt;&gt;&gt; import scipy.misc
&gt;&gt;&gt; face = scipy.misc.face()
&gt;&gt;&gt; face.shape
(768, 1024, 3)
&gt;&gt;&gt; face.max()
230
&gt;&gt;&gt; face.dtype
dtype('uint8')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.gray()
&gt;&gt;&gt; plt.imshow(face)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="gray" name="gray" port_type="basic:Boolean">
      <docstring>If True then return color image, otherwise return an 8-bit gray-scale</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="face" name="face" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>image of a racoon face</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.affine_transform" module_name="affine_transform" namespace="'ndimage'">
    <docstring>Apply an affine transformation.

The given matrix and offset are used to find for each point in the
output the corresponding coordinates in the input by an affine
transformation. The value of the input at those coordinates is
determined by spline interpolation of the requested order. Points
outside the boundaries of the input are filled according to the given
mode.

Parameters
----------
input : ndarray
    The input array.
matrix : ndarray
    The matrix must be two-dimensional or can also be given as a
    one-dimensional sequence or array. In the latter case, it is assumed
    that the matrix is diagonal. A more efficient algorithms is then
    applied that exploits the separability of the problem.
offset : float or sequence, optional
    The offset into the array where the transform is applied. If a float,
    `offset` is the same for each axis. If a sequence, `offset` should
    contain one value for each axis.
output_shape : tuple of ints, optional
    Shape tuple.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array.
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
mode : str, optional
    Points outside the boundaries of the input are filled according
    to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
    Default is 'constant'.
cval : scalar, optional
    Value used for points outside the boundaries of the input if
    ``mode='constant'``. Default is 0.0
prefilter : bool, optional
    The parameter prefilter determines if the input is pre-filtered with
    `spline_filter` before interpolation (necessary for spline
    interpolation of order &gt; 1).  If False, it is assumed that the input is
    already filtered. Default is True.

Returns
-------
affine_transform : ndarray or None
    The transformed input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="matrix" name="matrix" port_type="basic:List" show_port="True">
      <docstring>The matrix must be two-dimensional or can also be given as a
one-dimensional sequence or array. In the latter case, it is assumed
that the matrix is diagonal. A more efficient algorithms is then
applied that exploits the separability of the problem.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="offset" name="offsetScalar" port_type="basic:Float">
      <docstring>The offset into the array where the transform is applied. If a float,
`offset` is the same for each axis. If a sequence, `offset` should
contain one value for each axis.</docstring>
      <defaults>[0.0]</defaults>
      <alternateSpec arg="offset" name="offsetSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="output_shape" depth="1" name="output_shape" port_type="basic:Integer">
      <docstring>Shape tuple.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Points outside the boundaries of the input are filled according
to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
Default is 'constant'.</docstring>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value used for points outside the boundaries of the input if
``mode='constant'``. Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefilter" name="prefilter" port_type="basic:Boolean">
      <docstring>The parameter prefilter determines if the input is pre-filtered with
`spline_filter` before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="affine_transform" name="affine_transform" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The transformed input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_closing" module_name="binary_closing" namespace="'ndimage'">
    <docstring>Multi-dimensional binary closing with the given structuring element.

The *closing* of an input image by a structuring element is the
*erosion* of the *dilation* of the image by the structuring element.

Parameters
----------
input : array_like
    Binary array_like to be closed. Non-zero (True) elements form
    the subset to be closed.
structure : array_like, optional
    Structuring element used for the closing. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one (i.e., only
    nearest neighbors are connected to the center, diagonally-connected
    elements are not considered neighbors).
iterations : {int, float}, optional
    The dilation step of the closing, then the erosion step are each
    repeated `iterations` times (one, by default). If iterations is
    less than 1, each operations is repeated until the result does
    not change anymore.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_closing : ndarray of bools
    Closing of the input by the structuring element.

See also
--------
grey_closing, binary_opening, binary_dilation, binary_erosion,
generate_binary_structure

Notes
-----
*Closing* [1]_ is a mathematical morphology operation [2]_ that
consists in the succession of a dilation and an erosion of the
input with the same structuring element. Closing therefore fills
holes smaller than the structuring element.

Together with *opening* (`binary_opening`), closing can be used for
noise removal.

References
----------
.. [1] http://en.wikipedia.org/wiki/Closing_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((5,5), dtype=np.int)
&gt;&gt;&gt; a[1:-1, 1:-1] = 1; a[2,2] = 0
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Closing removes small holes
&gt;&gt;&gt; ndimage.binary_closing(a).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Closing is the erosion of the dilation of the input
&gt;&gt;&gt; ndimage.binary_dilation(a).astype(np.int)
array([[0, 1, 1, 1, 0],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [0, 1, 1, 1, 0]])
&gt;&gt;&gt; ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])


&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1:6, 2:5] = 1; a[1:3,3] = 0
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; # In addition to removing holes, closing can also
&gt;&gt;&gt; # coarsen boundaries with fine hollows.
&gt;&gt;&gt; ndimage.binary_closing(a).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_closing(a, structure=np.ones((2,2))).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Binary array_like to be closed. Non-zero (True) elements form
the subset to be closed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>Structuring element used for the closing. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one (i.e., only
nearest neighbors are connected to the center, diagonally-connected
elements are not considered neighbors).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iterations" name="iterations" port_type="basic:Float">
      <docstring>The dilation step of the closing, then the erosion step are each
repeated `iterations` times (one, by default). If iterations is
less than 1, each operations is repeated until the result does
not change anymore.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>Placement of the filter, by default 0.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" depth="1" name="originSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="binary_closing" depth="1" name="binary_closing" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Closing of the input by the structuring element.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_dilation" module_name="binary_dilation" namespace="'ndimage'">
    <docstring>Multi-dimensional binary dilation with the given structuring element.

Parameters
----------
input : array_like
    Binary array_like to be dilated. Non-zero (True) elements form
    the subset to be dilated.
structure : array_like, optional
    Structuring element used for the dilation. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one.
iterations : {int, float}, optional
    The dilation is repeated `iterations` times (one, by default).
    If iterations is less than 1, the dilation is repeated until the
    result does not change anymore.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.

Returns
-------
binary_dilation : ndarray of bools
    Dilation of the input by the structuring element.

See also
--------
grey_dilation, binary_erosion, binary_closing, binary_opening,
generate_binary_structure

Notes
-----
Dilation [1]_ is a mathematical morphology operation [2]_ that uses a
structuring element for expanding the shapes in an image. The binary
dilation of an image by a structuring element is the locus of the points
covered by the structuring element, when its center lies within the
non-zero points of the image.

References
----------
.. [1] http://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((5, 5))
&gt;&gt;&gt; a[2, 2] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(a)
array([[False, False, False, False, False],
       [False, False,  True, False, False],
       [False,  True,  True,  True, False],
       [False, False,  True, False, False],
       [False, False, False, False, False]], dtype=bool)
&gt;&gt;&gt; ndimage.binary_dilation(a).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; # 3x3 structuring element with connectivity 1, used by default
&gt;&gt;&gt; struct1 = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; struct1
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; # 3x3 structuring element with connectivity 2
&gt;&gt;&gt; struct2 = ndimage.generate_binary_structure(2, 2)
&gt;&gt;&gt; struct2
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
&gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1,\
... iterations=2).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Binary array_like to be dilated. Non-zero (True) elements form
the subset to be dilated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>Structuring element used for the dilation. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iterations" name="iterations" port_type="basic:Float">
      <docstring>The dilation is repeated `iterations` times (one, by default).
If iterations is less than 1, the dilation is repeated until the
result does not change anymore.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mask" name="mask" port_type="basic:List">
      <docstring>If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>Placement of the filter, by default 0.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" depth="1" name="originSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="border_value" name="border_value">
      <docstring>Value at the border in the output array.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="brute_force" name="brute_force" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="binary_dilation" depth="1" name="binary_dilation" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Dilation of the input by the structuring element.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_erosion" module_name="binary_erosion" namespace="'ndimage'">
    <docstring>Multi-dimensional binary erosion with a given structuring element.

Binary erosion is a mathematical morphology operation used for image
processing.

Parameters
----------
input : array_like
    Binary image to be eroded. Non-zero (True) elements form
    the subset to be eroded.
structure : array_like, optional
    Structuring element used for the erosion. Non-zero elements are
    considered True. If no structuring element is provided, an element
    is generated with a square connectivity equal to one.
iterations : {int, float}, optional
    The erosion is repeated `iterations` times (one, by default).
    If iterations is less than 1, the erosion is repeated until the
    result does not change anymore.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.

Returns
-------
binary_erosion : ndarray of bools
    Erosion of the input by the structuring element.

See also
--------
grey_erosion, binary_dilation, binary_closing, binary_opening,
generate_binary_structure

Notes
-----
Erosion [1]_ is a mathematical morphology operation [2]_ that uses a
structuring element for shrinking the shapes in an image. The binary
erosion of an image by a structuring element is the locus of the points
where a superimposition of the structuring element centered on the point
is entirely contained in the set of non-zero elements of the image.

References
----------
.. [1] http://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1:6, 2:5] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; #Erosion removes objects smaller than the structure
&gt;&gt;&gt; ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Binary image to be eroded. Non-zero (True) elements form
the subset to be eroded.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>Structuring element used for the erosion. Non-zero elements are
considered True. If no structuring element is provided, an element
is generated with a square connectivity equal to one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iterations" name="iterations" port_type="basic:Float">
      <docstring>The erosion is repeated `iterations` times (one, by default).
If iterations is less than 1, the erosion is repeated until the
result does not change anymore.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mask" name="mask" port_type="basic:List">
      <docstring>If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>Placement of the filter, by default 0.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" depth="1" name="originSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="border_value" name="border_value">
      <docstring>Value at the border in the output array.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="brute_force" name="brute_force" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="binary_erosion" depth="1" name="binary_erosion" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Erosion of the input by the structuring element.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_fill_holes" module_name="binary_fill_holes" namespace="'ndimage'">
    <docstring>Fill the holes in binary objects.


Parameters
----------
input : array_like
    n-dimensional binary array with holes to be filled
structure : array_like, optional
    Structuring element used in the computation; large-size elements
    make computations faster but may miss holes separated from the
    background by thin regions. The default element (with a square
    connectivity equal to one) yields the intuitive result where all
    holes in the input have been filled.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int, tuple of ints, optional
    Position of the structuring element.

Returns
-------
out : ndarray
    Transformation of the initial image `input` where holes have been
    filled.

See also
--------
binary_dilation, binary_propagation, label

Notes
-----
The algorithm used in this function consists in invading the complementary
of the shapes in `input` from the outer boundary of the image,
using binary dilations. Holes are not connected to the boundary and are
therefore not invaded. The result is the complementary subset of the
invaded region.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology


Examples
--------
&gt;&gt;&gt; a = np.zeros((5, 5), dtype=int)
&gt;&gt;&gt; a[1:4, 1:4] = 1
&gt;&gt;&gt; a[2,2] = 0
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_fill_holes(a).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Too big structuring element
&gt;&gt;&gt; ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>n-dimensional binary array with holes to be filled</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>Structuring element used in the computation; large-size elements
make computations faster but may miss holes separated from the
background by thin regions. The default element (with a square
connectivity equal to one) yields the intuitive result where all
holes in the input have been filled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>Position of the structuring element.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" depth="1" name="originSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Transformation of the initial image `input` where holes have been
filled.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_hit_or_miss" module_name="binary_hit_or_miss" namespace="'ndimage'">
    <docstring>Multi-dimensional binary hit-or-miss transform.

The hit-or-miss transform finds the locations of a given pattern
inside the input image.

Parameters
----------
input : array_like (cast to booleans)
    Binary image where a pattern is to be detected.
structure1 : array_like (cast to booleans), optional
    Part of the structuring element to be fitted to the foreground
    (non-zero elements) of `input`. If no value is provided, a
    structure of square connectivity 1 is chosen.
structure2 : array_like (cast to booleans), optional
    Second part of the structuring element that has to miss completely
    the foreground. If no value is provided, the complementary of
    `structure1` is taken.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin1 : int or tuple of ints, optional
    Placement of the first part of the structuring element `structure1`,
    by default 0 for a centered structure.
origin2 : int or tuple of ints, optional
    Placement of the second part of the structuring element `structure2`,
    by default 0 for a centered structure. If a value is provided for
    `origin1` and not for `origin2`, then `origin2` is set to `origin1`.

Returns
-------
binary_hit_or_miss : ndarray
    Hit-or-miss transform of `input` with the given structuring
    element (`structure1`, `structure2`).

See also
--------
ndimage.morphology, binary_erosion

References
----------
.. [1] http://en.wikipedia.org/wiki/Hit-or-miss_transform

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])
&gt;&gt;&gt; structure1
array([[1, 0, 0],
       [0, 1, 1],
       [0, 1, 1]])
&gt;&gt;&gt; # Find the matches of structure1 in the array a
&gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Change the origin of the filter
&gt;&gt;&gt; # origin1=1 is equivalent to origin1=(1,1) here
&gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1,\
... origin1=1).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" depth="1" name="input" port_type="basic:Boolean" show_port="True">
      <docstring>Binary image where a pattern is to be detected.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure1" depth="1" name="structure1" port_type="basic:Boolean">
      <docstring>Part of the structuring element to be fitted to the foreground
(non-zero elements) of `input`. If no value is provided, a
structure of square connectivity 1 is chosen.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure2" depth="1" name="structure2" port_type="basic:Boolean">
      <docstring>Second part of the structuring element that has to miss completely
the foreground. If no value is provided, the complementary of
`structure1` is taken.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin1" name="origin1Scalar" port_type="basic:Integer">
      <docstring>Placement of the first part of the structuring element `structure1`,
by default 0 for a centered structure.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin1" depth="1" name="origin1Sequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="origin2" name="origin2Scalar" port_type="basic:Integer">
      <docstring>Placement of the second part of the structuring element `structure2`,
by default 0 for a centered structure. If a value is provided for
`origin1` and not for `origin2`, then `origin2` is set to `origin1`.</docstring>
      <alternateSpec arg="origin2" depth="1" name="origin2Sequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="binary_hit_or_miss" name="binary_hit_or_miss" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Hit-or-miss transform of `input` with the given structuring
element (`structure1`, `structure2`).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_opening" module_name="binary_opening" namespace="'ndimage'">
    <docstring>Multi-dimensional binary opening with the given structuring element.

The *opening* of an input image by a structuring element is the
*dilation* of the *erosion* of the image by the structuring element.

Parameters
----------
input : array_like
    Binary array_like to be opened. Non-zero (True) elements form
    the subset to be opened.
structure : array_like, optional
    Structuring element used for the opening. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one (i.e., only
    nearest neighbors are connected to the center, diagonally-connected
    elements are not considered neighbors).
iterations : {int, float}, optional
    The erosion step of the opening, then the dilation step are each
    repeated `iterations` times (one, by default). If `iterations` is
    less than 1, each operation is repeated until the result does
    not change anymore.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_opening : ndarray of bools
    Opening of the input by the structuring element.

See also
--------
grey_opening, binary_closing, binary_erosion, binary_dilation,
generate_binary_structure

Notes
-----
*Opening* [1]_ is a mathematical morphology operation [2]_ that
consists in the succession of an erosion and a dilation of the
input with the same structuring element. Opening therefore removes
objects smaller than the structuring element.

Together with *closing* (`binary_closing`), opening can be used for
noise removal.

References
----------
.. [1] http://en.wikipedia.org/wiki/Opening_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((5,5), dtype=np.int)
&gt;&gt;&gt; a[1:4, 1:4] = 1; a[4, 4] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 1]])
&gt;&gt;&gt; # Opening removes small objects
&gt;&gt;&gt; ndimage.binary_opening(a, structure=np.ones((3,3))).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Opening can also smooth corners
&gt;&gt;&gt; ndimage.binary_opening(a).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Opening is the dilation of the erosion of the input
&gt;&gt;&gt; ndimage.binary_erosion(a).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Binary array_like to be opened. Non-zero (True) elements form
the subset to be opened.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>Structuring element used for the opening. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one (i.e., only
nearest neighbors are connected to the center, diagonally-connected
elements are not considered neighbors).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iterations" name="iterations" port_type="basic:Float">
      <docstring>The erosion step of the opening, then the dilation step are each
repeated `iterations` times (one, by default). If `iterations` is
less than 1, each operation is repeated until the result does
not change anymore.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>Placement of the filter, by default 0.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" depth="1" name="originSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="binary_opening" depth="1" name="binary_opening" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Opening of the input by the structuring element.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.binary_propagation" module_name="binary_propagation" namespace="'ndimage'">
    <docstring>Multi-dimensional binary propagation with the given structuring element.

Parameters
----------
input : array_like
    Binary image to be propagated inside `mask`.
structure : array_like, optional
    Structuring element used in the successive dilations. The output
    may depend on the structuring element, especially if `mask` has
    several connex components. If no structuring element is
    provided, an element is generated with a squared connectivity equal
    to one.
mask : array_like, optional
    Binary mask defining the region into which `input` is allowed to
    propagate.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_propagation : ndarray
    Binary propagation of `input` inside `mask`.

Notes
-----
This function is functionally equivalent to calling binary_dilation
with the number of iterations less then one: iterative dilation until
the result does not change anymore.

The succession of an erosion and propagation inside the original image
can be used instead of an *opening* for deleting small objects while
keeping the contours of larger objects untouched.

References
----------
.. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15.
.. [2] http://www.qi.tnw.tudelft.nl/Courses/FIP/noframes/fip-Morpholo.html#Heading102

Examples
--------
&gt;&gt;&gt; input = np.zeros((8, 8), dtype=np.int)
&gt;&gt;&gt; input[2, 2] = 1
&gt;&gt;&gt; mask = np.zeros((8, 8), dtype=np.int)
&gt;&gt;&gt; mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1
&gt;&gt;&gt; input
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; mask
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 1],
       [0, 0, 0, 0, 0, 0, 1, 1]])
&gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask,\
... structure=np.ones((3,3))).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])

&gt;&gt;&gt; # Comparison between opening and erosion+propagation
&gt;&gt;&gt; a = np.zeros((6,6), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1
&gt;&gt;&gt; a
array([[1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 1]])
&gt;&gt;&gt; ndimage.binary_opening(a).astype(np.int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; b = ndimage.binary_erosion(a)
&gt;&gt;&gt; b.astype(int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_propagation(b, mask=a).astype(np.int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Binary image to be propagated inside `mask`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>Structuring element used in the successive dilations. The output
may depend on the structuring element, especially if `mask` has
several connex components. If no structuring element is
provided, an element is generated with a squared connectivity equal
to one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mask" name="mask" port_type="basic:List">
      <docstring>Binary mask defining the region into which `input` is allowed to
propagate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>Array of the same shape as input, into which the output is placed.
By default, a new array is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="border_value" name="border_value">
      <docstring>Value at the border in the output array.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>Placement of the filter, by default 0.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" depth="1" name="originSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="binary_propagation" name="binary_propagation" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Binary propagation of `input` inside `mask`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.black_tophat" module_name="black_tophat" namespace="'ndimage'">
    <docstring>Multi-dimensional black tophat filter.

Parameters
----------
input : array_like
    Input.
size : tuple of ints, optional
    Shape of a flat and full structuring element used for the filter.
    Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the black tophat filter.
structure : array of ints, optional
    Structuring element used for the filter. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
black_tophat : ndarray
    Result of the filter of `input` with `structure`.

See also
--------
white_tophat, grey_opening, grey_closing</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer">
      <docstring>Shape of a flat and full structuring element used for the filter.
Optional if `footprint` or `structure` is provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of non-infinite elements of a flat structuring element
used for the black tophat filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the filter. `structure`
may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the output of the filter may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="black_tophat" name="black_tophat" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result of the filter of `input` with `structure`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.center_of_mass" module_name="center_of_mass" namespace="'ndimage'">
    <docstring>Calculate the center of mass of the values of an array at labels.

Parameters
----------
input : ndarray
    Data from which to calculate center-of-mass.
labels : ndarray, optional
    Labels for objects in `input`, as generated by `ndimage.label`.
    Only used with `index`.  Dimensions must be the same as `input`.
index : int or sequence of ints, optional
    Labels for which to calculate centers-of-mass. If not specified,
    all labels greater than zero are used.  Only used with `labels`.

Returns
-------
center_of_mass : tuple, or list of tuples
    Coordinates of centers-of-mass.

Examples
--------
&gt;&gt;&gt; a = np.array(([0,0,0,0],
                  [0,1,1,0],
                  [0,1,1,0],
                  [0,1,1,0]))
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.measurements.center_of_mass(a)
(2.0, 1.5)

Calculation of multiple objects in an image

&gt;&gt;&gt; b = np.array(([0,1,1,0],
                  [0,1,0,0],
                  [0,0,0,0],
                  [0,0,1,1],
                  [0,0,1,1]))
&gt;&gt;&gt; lbl = ndimage.label(b)[0]
&gt;&gt;&gt; ndimage.measurements.center_of_mass(b, lbl, [1,2])
[(0.33333333333333331, 1.3333333333333333), (3.5, 2.5)]</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Data from which to calculate center-of-mass.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>Labels for objects in `input`, as generated by `ndimage.label`.
Only used with `index`.  Dimensions must be the same as `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="indexScalar" port_type="basic:Integer">
      <docstring>Labels for which to calculate centers-of-mass. If not specified,
all labels greater than zero are used.  Only used with `labels`.</docstring>
      <alternateSpec arg="index" depth="1" name="indexSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="center_of_mass" name="center_of_mass" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Coordinates of centers-of-mass.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.convolve" module_name="convolve" namespace="'ndimage'">
    <docstring>Multidimensional convolution.

The array is convolved with the given kernel.

Parameters
----------
input : array_like
    Input array to filter.
weights : array_like
    Array of weights, same number of dimensions as input
output : ndarray, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    the `mode` parameter determines how the array borders are
    handled. For 'constant' mode, values beyond borders are set to be
    `cval`. Default is 'reflect'.
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : array_like, optional
    The `origin` parameter controls the placement of the filter.
    Default is 0.

Returns
-------
result : ndarray
    The result of convolution of `input` with `weights`.

See Also
--------
correlate : Correlate an image with a kernel.

Notes
-----
Each value in result is :math:`C_i = \sum_j{I_{i+j-k} W_j}`, where
W is the `weights` kernel,
j is the n-D spatial index over :math:`W`,
I is the `input` and k is the coordinate of the center of
W, specified by `origin` in the input parameters.

Examples
--------
Perhaps the simplest case to understand is ``mode='constant', cval=0.0``,
because in this case borders (i.e. where the `weights` kernel, centered
on any one value, extends beyond an edge of `input`.

&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
....    [5, 3, 0, 4],
....    [0, 0, 0, 7],
....    [9, 3, 0, 0]])
&gt;&gt;&gt; k = np.array([[1,1,1],[1,1,0],[1,0,0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.convolve(a, k, mode='constant', cval=0.0)
array([[11, 10,  7,  4],
       [10,  3, 11, 11],
       [15, 12, 14,  7],
       [12,  3,  7,  0]])

Setting ``cval=1.0`` is equivalent to padding the outer edge of `input`
with 1.0's (and then extracting only the original region of the result).

&gt;&gt;&gt; ndimage.convolve(a, k, mode='constant', cval=1.0)
array([[13, 11,  8,  7],
       [11,  3, 11, 14],
       [16, 12, 14, 10],
       [15,  6, 10,  5]])

With ``mode='reflect'`` (the default), outer values are reflected at the
edge of `input` to fill in missing values.

&gt;&gt;&gt; b = np.array([[2, 0, 0],
                  [1, 0, 0],
                  [0, 0, 0]])
&gt;&gt;&gt; k = np.array([[0,1,0],[0,1,0],[0,1,0]])
&gt;&gt;&gt; ndimage.convolve(b, k, mode='reflect')
array([[5, 0, 0],
       [3, 0, 0],
       [1, 0, 0]])

This includes diagonally at the corners.

&gt;&gt;&gt; k = np.array([[1,0,0],[0,1,0],[0,0,1]])
&gt;&gt;&gt; ndimage.convolve(b, k)
array([[4, 2, 0],
       [3, 2, 0],
       [1, 1, 0]])

With ``mode='nearest'``, the single nearest value in to an edge in
`input` is repeated as many times as needed to match the overlapping
`weights`.

&gt;&gt;&gt; c = np.array([[2, 0, 1],
                  [1, 0, 0],
                  [0, 0, 0]])
&gt;&gt;&gt; k = np.array([[0, 1, 0],
                  [0, 1, 0],
                  [0, 1, 0],
                  [0, 1, 0],
                  [0, 1, 0]])
&gt;&gt;&gt; ndimage.convolve(c, k, mode='nearest')
array([[7, 0, 3],
       [5, 0, 2],
       [3, 0, 1]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List" show_port="True">
      <docstring>Array of weights, same number of dimensions as input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>the `mode` parameter determines how the array borders are
handled. For 'constant' mode, values beyond borders are set to be
`cval`. Default is 'reflect'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="originScalar" port_type="basic:Integer">
      <docstring>The `origin` parameter controls the placement of the filter.
Default is 0.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="origin" name="originSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of convolution of `input` with `weights`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.convolve1d" module_name="convolve1d" namespace="'ndimage'">
    <docstring>Calculate a one-dimensional convolution along the given axis.

The lines of the array along the given axis are convolved with the
given weights.

Parameters
----------
input : array_like
    Input array to filter.
weights : ndarray
    One-dimensional sequence of numbers.
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.

Returns
-------
convolve1d : ndarray
    Convolved array with same shape as input</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List" show_port="True">
      <docstring>One-dimensional sequence of numbers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="convolve1d" name="convolve1d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Convolved array with same shape as input</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.correlate" module_name="correlate" namespace="'ndimage'">
    <docstring>Multi-dimensional correlation.

The array is correlated with the given kernel.

Parameters
----------
input : array-like
    input array to filter
weights : ndarray
    array of weights, same number of dimensions as input
output : array, optional
    The ``output`` parameter passes an array in which to store the
    filter output.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The ``mode`` parameter determines how the array borders are
    handled, where ``cval`` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if ``mode`` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The ``origin`` parameter controls the placement of the filter.
    Default 0

See Also
--------
convolve : Convolve an image with a kernel.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>input array to filter</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List" show_port="True">
      <docstring>array of weights, same number of dimensions as input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The ``output`` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The ``mode`` parameter determines how the array borders are
handled, where ``cval`` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if ``mode`` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The ``origin`` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.correlate1d" module_name="correlate1d" namespace="'ndimage'">
    <docstring>Calculate a one-dimensional correlation along the given axis.

The lines of the array along the given axis are correlated with the
given weights.

Parameters
----------
input : array_like
    Input array to filter.
weights : array
    One-dimensional sequence of numbers.
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List" show_port="True">
      <docstring>One-dimensional sequence of numbers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.distance_transform_bf" module_name="distance_transform_bf" namespace="'ndimage'" output_type="list">
    <docstring>Distance transform function by a brute force algorithm.

This function calculates the distance transform of the `input`, by
replacing each background element (zero values), with its
shortest distance to the foreground (any element non-zero).

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.

Parameters
----------
input : array_like
    Input
metric : str, optional
    Three types of distance metric are supported: 'euclidean', 'taxicab'
    and 'chessboard'.
sampling : {int, sequence of ints}, optional
    This parameter is only used in the case of the euclidean `metric`
    distance transform.

    The sampling along each axis can be given by the `sampling` parameter
    which should be a sequence of length equal to the input rank, or a
    single number in which the `sampling` is assumed to be equal along all
    axes.
return_distances : bool, optional
    The `return_distances` flag can be used to indicate if the distance
    transform is returned.

    The default is True.
return_indices : bool, optional
    The `return_indices` flags can be used to indicate if the feature
    transform is returned.

    The default is False.
distances : float64 ndarray, optional
    Optional output array to hold distances (if `return_distances` is
    True).
indices : int64 ndarray, optional
    Optional output array to hold indices (if `return_indices` is True).

Returns
-------
distances : ndarray
    Distance array if `return_distances` is True.
indices : ndarray
    Indices array if `return_indices` is True.

Notes
-----
This function employs a slow brute force algorithm, see also the
function distance_transform_cdt for more efficient taxicab and
chessboard algorithms.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="metric" name="metric">
      <docstring>Three types of distance metric are supported: 'euclidean', 'taxicab'
and 'chessboard'.</docstring>
      <defaults>['euclidean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sampling" name="samplingScalar" port_type="basic:Integer">
      <docstring>This parameter is only used in the case of the euclidean `metric`
distance transform.

The sampling along each axis can be given by the `sampling` parameter
which should be a sequence of length equal to the input rank, or a
single number in which the `sampling` is assumed to be equal along all
axes.</docstring>
      <alternateSpec arg="sampling" depth="1" name="samplingSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="return_distances" name="return_distances" port_type="basic:Boolean">
      <docstring>The `return_distances` flag can be used to indicate if the distance
transform is returned.

The default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_indices" name="return_indices" port_type="basic:Boolean">
      <docstring>The `return_indices` flags can be used to indicate if the feature
transform is returned.

The default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="distances" depth="1" name="distances" port_type="basic:Float">
      <docstring>Optional output array to hold distances (if `return_distances` is
True).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="indices" depth="1" name="indices" port_type="basic:Integer">
      <docstring>Optional output array to hold indices (if `return_indices` is True).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="distances" name="distances" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Distance array if `return_distances` is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="indices" name="indices" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Indices array if `return_indices` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.distance_transform_cdt" module_name="distance_transform_cdt" namespace="'ndimage'">
    <docstring>Distance transform for chamfer type of transforms.

Parameters
----------
input : array_like
    Input
metric : {'chessboard', 'taxicab'}, optional
    The `metric` determines the type of chamfering that is done. If the
    `metric` is equal to 'taxicab' a structure is generated using
    generate_binary_structure with a squared distance equal to 1. If
    the `metric` is equal to 'chessboard', a `metric` is generated
    using generate_binary_structure with a squared distance equal to
    the dimensionality of the array. These choices correspond to the
    common interpretations of the 'taxicab' and the 'chessboard'
    distance metrics in two dimensions.

    The default for `metric` is 'chessboard'.
return_distances, return_indices : bool, optional
    The `return_distances`, and `return_indices` flags can be used to
    indicate if the distance transform, the feature transform, or both
    must be returned.

    If the feature transform is returned (``return_indices=True``),
    the index of the closest background element is returned along
    the first axis of the result.

    The `return_distances` default is True, and the
    `return_indices` default is False.
distances, indices : ndarrays of int32, optional
    The `distances` and `indices` arguments can be used to give optional
    output arrays that must be the same shape as `input`.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="metric" name="metric">
      <docstring>The `metric` determines the type of chamfering that is done. If the
`metric` is equal to 'taxicab' a structure is generated using
generate_binary_structure with a squared distance equal to 1. If
the `metric` is equal to 'chessboard', a `metric` is generated
using generate_binary_structure with a squared distance equal to
the dimensionality of the array. These choices correspond to the
common interpretations of the 'taxicab' and the 'chessboard'
distance metrics in two dimensions.

The default for `metric` is 'chessboard'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['chessboard', 'taxicab']]</values>
      <defaults>['chessboard']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_distances" name="return_distances" port_type="basic:Boolean">
      <docstring>The `return_distances`, and `return_indices` flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.

If the feature transform is returned (``return_indices=True``),
the index of the closest background element is returned along
the first axis of the result.

The `return_distances` default is True, and the
`return_indices` default is False.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_indices" name="return_indices" port_type="basic:Boolean">
      <docstring>The `return_distances`, and `return_indices` flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.

If the feature transform is returned (``return_indices=True``),
the index of the closest background element is returned along
the first axis of the result.

The `return_distances` default is True, and the
`return_indices` default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="distances" depth="1" name="distances" port_type="basic:Integer">
      <docstring>The `distances` and `indices` arguments can be used to give optional
output arrays that must be the same shape as `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="indices" depth="1" name="indices" port_type="basic:Integer">
      <docstring>The `distances` and `indices` arguments can be used to give optional
output arrays that must be the same shape as `input`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.distance_transform_edt" module_name="distance_transform_edt" namespace="'ndimage'">
    <docstring>Exact euclidean distance transform.

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.

Parameters
----------
input : array_like
    Input data to transform. Can be any type but will be converted
    into binary: 1 wherever input equates to True, 0 elsewhere.
sampling : float or int, or sequence of same, optional
    Spacing of elements along each dimension. If a sequence, must be of
    length equal to the input rank; if a single number, this is used for
    all axes. If not specified, a grid spacing of unity is implied.
return_distances : bool, optional
    Whether to return distance matrix. At least one of
    return_distances/return_indices must be True. Default is True.
return_indices : bool, optional
    Whether to return indices matrix. Default is False.
distances : ndarray, optional
    Used for output of distance array, must be of type float64.
indices : ndarray, optional
    Used for output of indices, must be of type int32.

Returns
-------
distance_transform_edt : ndarray or list of ndarrays
    Either distance matrix, index matrix, or a list of the two,
    depending on `return_x` flags and `distance` and `indices`
    input parameters.

Notes
-----
The euclidean distance transform gives values of the euclidean
distance::

                n
  y_i = sqrt(sum (x[i]-b[i])**2)
                i

where b[i] is the background point (value 0) with the smallest
Euclidean distance to input points x[i], and n is the
number of dimensions.

Examples
--------
&gt;&gt;&gt; a = np.array(([0,1,1,1,1],
                  [0,0,1,1,1],
                  [0,1,1,1,1],
                  [0,1,1,1,0],
                  [0,1,1,0,0]))
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.distance_transform_edt(a)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])

With a sampling of 2 units along x, 1 along y:

&gt;&gt;&gt; ndimage.distance_transform_edt(a, sampling=[2,1])
array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],
       [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],
       [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])

Asking for indices as well:

&gt;&gt;&gt; edt, inds = ndimage.distance_transform_edt(a, return_indices=True)
&gt;&gt;&gt; inds
array([[[0, 0, 1, 1, 3],
        [1, 1, 1, 1, 3],
        [2, 2, 1, 3, 3],
        [3, 3, 4, 4, 3],
        [4, 4, 4, 4, 4]],
       [[0, 0, 1, 1, 4],
        [0, 1, 1, 1, 4],
        [0, 0, 1, 4, 4],
        [0, 0, 3, 3, 4],
        [0, 0, 3, 3, 4]]])

With arrays provided for inplace outputs:

&gt;&gt;&gt; indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32)
&gt;&gt;&gt; ndimage.distance_transform_edt(a, return_indices=True, indices=indices)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])
&gt;&gt;&gt; indices
array([[[0, 0, 1, 1, 3],
        [1, 1, 1, 1, 3],
        [2, 2, 1, 3, 3],
        [3, 3, 4, 4, 3],
        [4, 4, 4, 4, 4]],
       [[0, 0, 1, 1, 4],
        [0, 1, 1, 1, 4],
        [0, 0, 1, 4, 4],
        [0, 0, 3, 3, 4],
        [0, 0, 3, 3, 4]]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input data to transform. Can be any type but will be converted
into binary: 1 wherever input equates to True, 0 elsewhere.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sampling" name="samplingScalar" port_type="basic:Float">
      <docstring>Spacing of elements along each dimension. If a sequence, must be of
length equal to the input rank; if a single number, this is used for
all axes. If not specified, a grid spacing of unity is implied.</docstring>
      <alternateSpec arg="sampling" name="samplingSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="return_distances" name="return_distances" port_type="basic:Boolean">
      <docstring>Whether to return distance matrix. At least one of
return_distances/return_indices must be True. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_indices" name="return_indices" port_type="basic:Boolean">
      <docstring>Whether to return indices matrix. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="distances" name="distances" port_type="basic:List">
      <docstring>Used for output of distance array, must be of type float64.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="indices" name="indices" port_type="basic:List">
      <docstring>Used for output of indices, must be of type int32.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="distance_transform_edt" name="distance_transform_edt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Either distance matrix, index matrix, or a list of the two,
depending on `return_x` flags and `distance` and `indices`
input parameters.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.extrema" module_name="extrema" namespace="'ndimage'" output_type="list">
    <docstring>Calculate the minimums and maximums of the values of an array
at labels, along with their positions.

Parameters
----------
input : ndarray
    Nd-image data to process.
labels : ndarray, optional
    Labels of features in input.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    Labels to include in output.  If None (default), all values where
    non-zero `labels` are used.

Returns
-------
minimums, maximums : int or ndarray
    Values of minimums and maximums in each feature.
min_positions, max_positions : tuple or list of tuples
    Each tuple gives the n-D coordinates of the corresponding minimum
    or maximum.

See Also
--------
maximum, minimum, maximum_position, minimum_position, center_of_mass

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.extrema(a)
(0, 9, (0, 2), (3, 0))

Features to process can be specified using `labels` and `index`:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.extrema(a, lbl, index=np.arange(1, nlbl+1))
(array([1, 4, 3]),
 array([5, 7, 9]),
 [(0, 0), (1, 3), (3, 1)],
 [(1, 0), (2, 3), (3, 0)])

If no index is given, non-zero `labels` are processed:

&gt;&gt;&gt; ndimage.extrema(a, lbl)
(1, 9, (0, 0), (3, 0))</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Nd-image data to process.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>Labels of features in input.
If not None, must be same shape as `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="indexScalar" port_type="basic:Integer">
      <docstring>Labels to include in output.  If None (default), all values where
non-zero `labels` are used.</docstring>
      <alternateSpec arg="index" depth="1" name="indexSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="minimums" name="minimums" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Values of minimums and maximums in each feature.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="maximums" name="maximums" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Values of minimums and maximums in each feature.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="min_positions" name="min_positions" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Each tuple gives the n-D coordinates of the corresponding minimum
or maximum.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="max_positions" name="max_positions" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Each tuple gives the n-D coordinates of the corresponding minimum
or maximum.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.find_objects" module_name="find_objects" namespace="'ndimage'">
    <docstring>Find objects in a labeled array.

Parameters
----------
input : ndarray of ints
    Array containing objects defined by different labels. Labels with
    value 0 are ignored.
max_label : int, optional
    Maximum label to be searched for in `input`. If max_label is not
    given, the positions of all objects are returned.

Returns
-------
object_slices : list of tuples
    A list of tuples, with each tuple containing N slices (with N the
    dimension of the input array).  Slices correspond to the minimal
    parallelepiped that contains the object. If a number is missing,
    None is returned instead of a slice.

See Also
--------
label, center_of_mass

Notes
-----
This function is very useful for isolating a volume of interest inside
a 3-D array, that cannot be "seen through".

Examples
--------
&gt;&gt;&gt; a = np.zeros((6,6), dtype=np.int)
&gt;&gt;&gt; a[2:4, 2:4] = 1
&gt;&gt;&gt; a[4, 4] = 1
&gt;&gt;&gt; a[:2, :3] = 2
&gt;&gt;&gt; a[0, 5] = 3
&gt;&gt;&gt; a
array([[2, 2, 2, 0, 0, 3],
       [2, 2, 2, 0, 0, 0],
       [0, 0, 1, 1, 0, 0],
       [0, 0, 1, 1, 0, 0],
       [0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.find_objects(a)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None)), (slice(0, 1, None), slice(5, 6, None))]
&gt;&gt;&gt; ndimage.find_objects(a, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None))]
&gt;&gt;&gt; ndimage.find_objects(a == 1, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), None]

&gt;&gt;&gt; loc = ndimage.find_objects(a)[0]
&gt;&gt;&gt; a[loc]
array([[1, 1, 0]
       [1, 1, 0]
       [0, 0, 1]])</docstring>
    <inputPortSpec arg="input" depth="1" name="input" port_type="basic:Integer" show_port="True">
      <docstring>Array containing objects defined by different labels. Labels with
value 0 are ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max_label" name="max_label" port_type="basic:Integer">
      <docstring>Maximum label to be searched for in `input`. If max_label is not
given, the positions of all objects are returned.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="object_slices" name="object_slices" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A list of tuples, with each tuple containing N slices (with N the
dimension of the input array).  Slices correspond to the minimal
parallelepiped that contains the object. If a number is missing,
None is returned instead of a slice.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.fourier_ellipsoid" module_name="fourier_ellipsoid" namespace="'ndimage'">
    <docstring>Multi-dimensional ellipsoid fourier filter.

The array is multiplied with the fourier transform of a ellipsoid of
given sizes.

Parameters
----------
input : array_like
    The input array.
size : float or sequence
    The size of the box used for filtering.
    If a float, `size` is the same for all axes. If a sequence, `size` has
    to contain one value for each axis.
n : int, optional
    If `n` is negative (default), then the input is assumed to be the
    result of a complex fft.
    If `n` is larger than or equal to zero, the input is assumed to be the
    result of a real fft, and `n` gives the length of the array before
    transformation along the real transform direction.
axis : int, optional
    The axis of the real transform.
output : ndarray, optional
    If given, the result of filtering the input is placed in this array.
    None is returned in this case.

Returns
-------
fourier_ellipsoid : ndarray or None
    The filtered input. If `output` is given as a parameter, None is
    returned.

Notes
-----
This function is implemented for arrays of rank 1, 2, or 3.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float" show_port="True">
      <docstring>The size of the box used for filtering.
If a float, `size` is the same for all axes. If a sequence, `size` has
to contain one value for each axis.</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>If `n` is negative (default), then the input is assumed to be the
result of a complex fft.
If `n` is larger than or equal to zero, the input is assumed to be the
result of a real fft, and `n` gives the length of the array before
transformation along the real transform direction.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the real transform.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>If given, the result of filtering the input is placed in this array.
None is returned in this case.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fourier_ellipsoid" name="fourier_ellipsoid" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.fourier_gaussian" module_name="fourier_gaussian" namespace="'ndimage'">
    <docstring>Multi-dimensional Gaussian fourier filter.

The array is multiplied with the fourier transform of a Gaussian
kernel.

Parameters
----------
input : array_like
    The input array.
sigma : float or sequence
    The sigma of the Gaussian kernel. If a float, `sigma` is the same for
    all axes. If a sequence, `sigma` has to contain one value for each
    axis.
n : int, optional
    If `n` is negative (default), then the input is assumed to be the
    result of a complex fft.
    If `n` is larger than or equal to zero, the input is assumed to be the
    result of a real fft, and `n` gives the length of the array before
    transformation along the real transform direction.
axis : int, optional
    The axis of the real transform.
output : ndarray, optional
    If given, the result of filtering the input is placed in this array.
    None is returned in this case.

Returns
-------
fourier_gaussian : ndarray or None
    The filtered input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigmaScalar" port_type="basic:Float" show_port="True">
      <docstring>The sigma of the Gaussian kernel. If a float, `sigma` is the same for
all axes. If a sequence, `sigma` has to contain one value for each
axis.</docstring>
      <alternateSpec arg="sigma" name="sigmaSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>If `n` is negative (default), then the input is assumed to be the
result of a complex fft.
If `n` is larger than or equal to zero, the input is assumed to be the
result of a real fft, and `n` gives the length of the array before
transformation along the real transform direction.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the real transform.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>If given, the result of filtering the input is placed in this array.
None is returned in this case.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fourier_gaussian" name="fourier_gaussian" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.fourier_shift" module_name="fourier_shift" namespace="'ndimage'">
    <docstring>Multi-dimensional fourier shift filter.

The array is multiplied with the fourier transform of a shift operation.

Parameters
----------
input : array_like
    The input array.
shift : float or sequence
    The size of the box used for filtering.
    If a float, `shift` is the same for all axes. If a sequence, `shift`
    has to contain one value for each axis.
n : int, optional
    If `n` is negative (default), then the input is assumed to be the
    result of a complex fft.
    If `n` is larger than or equal to zero, the input is assumed to be the
    result of a real fft, and `n` gives the length of the array before
    transformation along the real transform direction.
axis : int, optional
    The axis of the real transform.
output : ndarray, optional
    If given, the result of shifting the input is placed in this array.
    None is returned in this case.

Returns
-------
fourier_shift : ndarray or None
    The shifted input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shift" name="shiftScalar" port_type="basic:Float" show_port="True">
      <docstring>The size of the box used for filtering.
If a float, `shift` is the same for all axes. If a sequence, `shift`
has to contain one value for each axis.</docstring>
      <alternateSpec arg="shift" name="shiftSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>If `n` is negative (default), then the input is assumed to be the
result of a complex fft.
If `n` is larger than or equal to zero, the input is assumed to be the
result of a real fft, and `n` gives the length of the array before
transformation along the real transform direction.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the real transform.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>If given, the result of shifting the input is placed in this array.
None is returned in this case.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fourier_shift" name="fourier_shift" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shifted input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.fourier_uniform" module_name="fourier_uniform" namespace="'ndimage'">
    <docstring>Multi-dimensional uniform fourier filter.

The array is multiplied with the fourier transform of a box of given
size.

Parameters
----------
input : array_like
    The input array.
size : float or sequence
    The size of the box used for filtering.
    If a float, `size` is the same for all axes. If a sequence, `size` has
    to contain one value for each axis.
n : int, optional
    If `n` is negative (default), then the input is assumed to be the
    result of a complex fft.
    If `n` is larger than or equal to zero, the input is assumed to be the
    result of a real fft, and `n` gives the length of the array before
    transformation along the real transform direction.
axis : int, optional
    The axis of the real transform.
output : ndarray, optional
    If given, the result of filtering the input is placed in this array.
    None is returned in this case.

Returns
-------
fourier_uniform : ndarray or None
    The filtered input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float" show_port="True">
      <docstring>The size of the box used for filtering.
If a float, `size` is the same for all axes. If a sequence, `size` has
to contain one value for each axis.</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>If `n` is negative (default), then the input is assumed to be the
result of a complex fft.
If `n` is larger than or equal to zero, the input is assumed to be the
result of a real fft, and `n` gives the length of the array before
transformation along the real transform direction.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the real transform.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>If given, the result of filtering the input is placed in this array.
None is returned in this case.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fourier_uniform" name="fourier_uniform" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.gaussian_filter" module_name="gaussian_filter" namespace="'ndimage'">
    <docstring>Multidimensional Gaussian filter.

Parameters
----------
input : array_like
    Input array to filter.
sigma : scalar or sequence of scalars
    Standard deviation for Gaussian kernel. The standard
    deviations of the Gaussian filter are given for each axis as a
    sequence, or as a single number, in which case it is equal for
    all axes.
order : {0, 1, 2, 3} or sequence from same set, optional
    The order of the filter along each axis is given as a sequence
    of integers, or as a single number.  An order of 0 corresponds
    to convolution with a Gaussian kernel. An order of 1, 2, or 3
    corresponds to convolution with the first, second or third
    derivatives of a Gaussian. Higher order derivatives are not
    implemented
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
truncate : float
    Truncate the filter at this many standard deviations.
    Default is 4.0.

Returns
-------
gaussian_filter : ndarray
    Returned array of same shape as `input`.

Notes
-----
The multidimensional filter is implemented as a sequence of
one-dimensional convolution filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a limited precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigmaScalar" port_type="basic:Float" show_port="True">
      <docstring>Standard deviation for Gaussian kernel. The standard
deviations of the Gaussian filter are given for each axis as a
sequence, or as a single number, in which case it is equal for
all axes.</docstring>
      <alternateSpec arg="sigma" name="sigmaSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="orderScalar" port_type="basic:Integer">
      <docstring>The order of the filter along each axis is given as a sequence
of integers, or as a single number.  An order of 0 corresponds
to convolution with a Gaussian kernel. An order of 1, 2, or 3
corresponds to convolution with the first, second or third
derivatives of a Gaussian. Higher order derivatives are not
implemented</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1, 2, 3]]</values>
      <defaults>[0]</defaults>
      <alternateSpec arg="order" name="orderSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="truncate" name="truncate" port_type="basic:Float">
      <docstring>Truncate the filter at this many standard deviations.
Default is 4.0.</docstring>
      <defaults>[4.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="gaussian_filter" name="gaussian_filter" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returned array of same shape as `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.gaussian_filter1d" module_name="gaussian_filter1d" namespace="'ndimage'">
    <docstring>One-dimensional Gaussian filter.

Parameters
----------
input : array_like
    Input array to filter.
sigma : scalar
    standard deviation for Gaussian kernel
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
order : {0, 1, 2, 3}, optional
    An order of 0 corresponds to convolution with a Gaussian
    kernel. An order of 1, 2, or 3 corresponds to convolution with
    the first, second or third derivatives of a Gaussian. Higher
    order derivatives are not implemented
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
truncate : float, optional
    Truncate the filter at this many standard deviations.
    Default is 4.0.

Returns
-------
gaussian_filter1d : ndarray</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigma" port_type="basic:Float" show_port="True">
      <docstring>standard deviation for Gaussian kernel</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>An order of 0 corresponds to convolution with a Gaussian
kernel. An order of 1, 2, or 3 corresponds to convolution with
the first, second or third derivatives of a Gaussian. Higher
order derivatives are not implemented</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1, 2, 3]]</values>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="truncate" name="truncate" port_type="basic:Float">
      <docstring>Truncate the filter at this many standard deviations.
Default is 4.0.</docstring>
      <defaults>[4.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="gaussian_filter1d" name="gaussian_filter1d" port_type="basic:List" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.gaussian_gradient_magnitude" module_name="gaussian_gradient_magnitude" namespace="'ndimage'">
    <docstring>Multidimensional gradient magnitude using Gaussian derivatives.

Parameters
----------
input : array_like
    Input array to filter.
sigma : scalar or sequence of scalars
    The standard deviations of the Gaussian filter are given for
    each axis as a sequence, or as a single number, in which case
    it is equal for all axes..
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
Extra keyword arguments will be passed to gaussian_filter().</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigmaScalar" port_type="basic:Float" show_port="True">
      <docstring>The standard deviations of the Gaussian filter are given for
each axis as a sequence, or as a single number, in which case
it is equal for all axes..</docstring>
      <alternateSpec arg="sigma" name="sigmaSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.gaussian_laplace" module_name="gaussian_laplace" namespace="'ndimage'">
    <docstring>Multidimensional Laplace filter using gaussian second derivatives.

Parameters
----------
input : array_like
    Input array to filter.
sigma : scalar or sequence of scalars
    The standard deviations of the Gaussian filter are given for
    each axis as a sequence, or as a single number, in which case
    it is equal for all axes.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
Extra keyword arguments will be passed to gaussian_filter().</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigmaScalar" port_type="basic:Float" show_port="True">
      <docstring>The standard deviations of the Gaussian filter are given for
each axis as a sequence, or as a single number, in which case
it is equal for all axes.</docstring>
      <alternateSpec arg="sigma" name="sigmaSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.generate_binary_structure" module_name="generate_binary_structure" namespace="'ndimage'">
    <docstring>Generate a binary structure for binary morphological operations.

Parameters
----------
rank : int
     Number of dimensions of the array to which the structuring element
     will be applied, as returned by `np.ndim`.
connectivity : int
     `connectivity` determines which elements of the output array belong
     to the structure, i.e. are considered as neighbors of the central
     element. Elements up to a squared distance of `connectivity` from
     the center are considered neighbors. `connectivity` may range from 1
     (no diagonal elements are neighbors) to `rank` (all elements are
     neighbors).

Returns
-------
output : ndarray of bools
     Structuring element which may be used for binary morphological
     operations, with `rank` dimensions and all dimensions equal to 3.

See also
--------
iterate_structure, binary_dilation, binary_erosion

Notes
-----
`generate_binary_structure` can only create structuring elements with
dimensions equal to 3, i.e. minimal dimensions. For larger structuring
elements, that are useful e.g. for eroding large objects, one may either
use   `iterate_structure`, or create directly custom arrays with
numpy functions such as `numpy.ones`.

Examples
--------
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; struct
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; a = np.zeros((5,5))
&gt;&gt;&gt; a[2, 2] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)
&gt;&gt;&gt; b
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(b, structure=struct).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.]])
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 2)
&gt;&gt;&gt; struct
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(3, 1)
&gt;&gt;&gt; struct # no diagonal elements
array([[[False, False, False],
        [False,  True, False],
        [False, False, False]],
       [[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
       [[False, False, False],
        [False,  True, False],
        [False, False, False]]], dtype=bool)</docstring>
    <inputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True">
      <docstring>Number of dimensions of the array to which the structuring element
will be applied, as returned by `np.ndim`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="connectivity" name="connectivity" port_type="basic:Integer" show_port="True">
      <docstring>`connectivity` determines which elements of the output array belong
to the structure, i.e. are considered as neighbors of the central
element. Elements up to a squared distance of `connectivity` from
the center are considered neighbors. `connectivity` may range from 1
(no diagonal elements are neighbors) to `rank` (all elements are
neighbors).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" depth="1" name="output" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>Structuring element which may be used for binary morphological
operations, with `rank` dimensions and all dimensions equal to 3.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.generic_filter" module_name="generic_filter" namespace="'ndimage'">
    <docstring>Calculates a multi-dimensional filter using the given function.

At each element the provided function is called. The input values
within the filter footprint at that element are passed to the function
as a 1D array of double values.

Parameters
----------
input : array_like
    Input array to filter.
function : callable
    Function to apply at each element.
size : scalar or tuple, optional
    See footprint, below
footprint : array, optional
    Either `size` or `footprint` must be defined.  `size` gives
    the shape that is taken from the input array, at every element
    position, to define the input to the filter function.
    `footprint` is a boolean array that specifies (implicitly) a
    shape, but also which of the elements within this shape will get
    passed to the filter function.  Thus ``size=(n,m)`` is equivalent
    to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
    of dimensions of the input array, so that, if the input array is
    shape (10,10,10), and `size` is 2, then the actual size used is
    (2,2,2).
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.
extra_arguments : sequence, optional
    Sequence of extra positional arguments to pass to passed function
extra_keywords : dict, optional
    dict of extra keyword arguments to pass to passed function</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="function" name="function" port_type="basic:Variant" show_port="True">
      <docstring>Function to apply at each element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float">
      <docstring>See footprint, below</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprint" port_type="basic:List">
      <docstring>Either `size` or `footprint` must be defined.  `size` gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
`footprint` is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus ``size=(n,m)`` is equivalent
to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and `size` is 2, then the actual size used is
(2,2,2).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_arguments" name="extra_arguments" port_type="basic:List">
      <docstring>Sequence of extra positional arguments to pass to passed function</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_keywords" name="extra_keywords" port_type="basic:Dictionary">
      <docstring>dict of extra keyword arguments to pass to passed function</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.generic_filter1d" module_name="generic_filter1d" namespace="'ndimage'">
    <docstring>Calculate a one-dimensional filter along the given axis.

`generic_filter1d` iterates over the lines of the array, calling the
given function at each line. The arguments of the line are the
input line, and the output line. The input and output lines are 1D
double arrays.  The input line is extended appropriately according
to the filter size and origin. The output line must be modified
in-place with the result.

Parameters
----------
input : array_like
    Input array to filter.
function : callable
    Function to apply along given axis.
filter_size : scalar
    Length of the filter.
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.
extra_arguments : sequence, optional
    Sequence of extra positional arguments to pass to passed function
extra_keywords : dict, optional
    dict of extra keyword arguments to pass to passed function</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="function" name="function" port_type="basic:Variant" show_port="True">
      <docstring>Function to apply along given axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="filter_size" name="filter_size" port_type="basic:Float" show_port="True">
      <docstring>Length of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_arguments" name="extra_arguments" port_type="basic:List">
      <docstring>Sequence of extra positional arguments to pass to passed function</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_keywords" name="extra_keywords" port_type="basic:Dictionary">
      <docstring>dict of extra keyword arguments to pass to passed function</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.generic_gradient_magnitude" module_name="generic_gradient_magnitude" namespace="'ndimage'">
    <docstring>Gradient magnitude using a provided gradient function.

Parameters
----------
input : array_like
    Input array to filter.
derivative : callable
    Callable with the following signature::

        derivative(input, axis, output, mode, cval,
                   *extra_arguments, **extra_keywords)

    See `extra_arguments`, `extra_keywords` below.
    `derivative` can assume that `input` and `output` are ndarrays.
    Note that the output from `derivative` is modified inplace;
    be careful to copy important inputs before returning them.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
extra_keywords : dict, optional
    dict of extra keyword arguments to pass to passed function
extra_arguments : sequence, optional
    Sequence of extra positional arguments to pass to passed function</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="derivative" name="derivative" port_type="basic:Variant" show_port="True">
      <docstring>Callable with the following signature::

    derivative(input, axis, output, mode, cval,
               *extra_arguments, **extra_keywords)

See `extra_arguments`, `extra_keywords` below.
`derivative` can assume that `input` and `output` are ndarrays.
Note that the output from `derivative` is modified inplace;
be careful to copy important inputs before returning them.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_keywords" name="extra_keywords" port_type="basic:Dictionary">
      <docstring>dict of extra keyword arguments to pass to passed function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extra_arguments" name="extra_arguments" port_type="basic:List">
      <docstring>Sequence of extra positional arguments to pass to passed function</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.generic_laplace" module_name="generic_laplace" namespace="'ndimage'">
    <docstring>N-dimensional Laplace filter using a provided second derivative function

Parameters
----------
input : array_like
    Input array to filter.
derivative2 : callable
    Callable with the following signature::

        derivative2(input, axis, output, mode, cval,
                    *extra_arguments, **extra_keywords)

    See `extra_arguments`, `extra_keywords` below.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
extra_keywords : dict, optional
    dict of extra keyword arguments to pass to passed function
extra_arguments : sequence, optional
    Sequence of extra positional arguments to pass to passed function</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="derivative2" name="derivative2" port_type="basic:Variant" show_port="True">
      <docstring>Callable with the following signature::

    derivative2(input, axis, output, mode, cval,
                *extra_arguments, **extra_keywords)

See `extra_arguments`, `extra_keywords` below.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_keywords" name="extra_keywords" port_type="basic:Dictionary">
      <docstring>dict of extra keyword arguments to pass to passed function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extra_arguments" name="extra_arguments" port_type="basic:List">
      <docstring>Sequence of extra positional arguments to pass to passed function</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.geometric_transform" module_name="geometric_transform" namespace="'ndimage'">
    <docstring>Apply an arbritrary geometric transform.

The given mapping function is used to find, for each point in the
output, the corresponding coordinates in the input. The value of the
input at those coordinates is determined by spline interpolation of
the requested order.

Parameters
----------
input : array_like
    The input array.
mapping : callable
    A callable object that accepts a tuple of length equal to the output
    array rank, and returns the corresponding input coordinates as a tuple
    of length equal to the input array rank.
output_shape : tuple of ints, optional
    Shape tuple.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array.
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
mode : str, optional
    Points outside the boundaries of the input are filled according
    to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
    Default is 'constant'.
cval : scalar, optional
    Value used for points outside the boundaries of the input if
    ``mode='constant'``. Default is 0.0
prefilter : bool, optional
    The parameter prefilter determines if the input is pre-filtered with
    `spline_filter` before interpolation (necessary for spline
    interpolation of order &gt; 1).  If False, it is assumed that the input is
    already filtered. Default is True.
extra_arguments : tuple, optional
    Extra arguments passed to `mapping`.
extra_keywords : dict, optional
    Extra keywords passed to `mapping`.

Returns
-------
return_value : ndarray or None
    The filtered input. If `output` is given as a parameter, None is
    returned.

See Also
--------
map_coordinates, affine_transform, spline_filter1d

Examples
--------
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; a = np.arange(12.).reshape((4, 3))
&gt;&gt;&gt; def shift_func(output_coords):
...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)
...
&gt;&gt;&gt; ndimage.geometric_transform(a, shift_func)
array([[ 0.   ,  0.   ,  0.   ],
       [ 0.   ,  1.362,  2.738],
       [ 0.   ,  4.812,  6.187],
       [ 0.   ,  8.263,  9.637]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mapping" name="mapping" port_type="basic:Variant" show_port="True">
      <docstring>A callable object that accepts a tuple of length equal to the output
array rank, and returns the corresponding input coordinates as a tuple
of length equal to the input array rank.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output_shape" depth="1" name="output_shape" port_type="basic:Integer">
      <docstring>Shape tuple.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Points outside the boundaries of the input are filled according
to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
Default is 'constant'.</docstring>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value used for points outside the boundaries of the input if
``mode='constant'``. Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefilter" name="prefilter" port_type="basic:Boolean">
      <docstring>The parameter prefilter determines if the input is pre-filtered with
`spline_filter` before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_arguments" name="extra_arguments" port_type="basic:List">
      <docstring>Extra arguments passed to `mapping`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extra_keywords" name="extra_keywords">
      <docstring>Extra keywords passed to `mapping`.</docstring>
      <defaults>[{}]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="return_value" name="return_value" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.grey_closing" module_name="grey_closing" namespace="'ndimage'">
    <docstring>Multi-dimensional greyscale closing.

A greyscale closing consists in the succession of a greyscale dilation,
and a greyscale erosion.

Parameters
----------
input : array_like
    Array over which the grayscale closing is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    closing. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale closing.
structure : array of ints, optional
    Structuring element used for the grayscale closing. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the closing may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_closing : ndarray
    Result of the grayscale closing of `input` with `structure`.

See also
--------
binary_closing, grey_dilation, grey_erosion, grey_opening,
generate_binary_structure

Notes
-----
The action of a grayscale closing with a flat structuring element amounts
to smoothen deep local minima, whereas binary closing fills small holes.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.arange(36).reshape((6,6))
&gt;&gt;&gt; a[3,3] = 0
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20,  0, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
&gt;&gt;&gt; ndimage.grey_closing(a, size=(3,3))
array([[ 7,  7,  8,  9, 10, 11],
       [ 7,  7,  8,  9, 10, 11],
       [13, 13, 14, 15, 16, 17],
       [19, 19, 20, 20, 22, 23],
       [25, 25, 26, 27, 28, 29],
       [31, 31, 32, 33, 34, 35]])
&gt;&gt;&gt; # Note that the local minimum a[3,3] has disappeared</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array over which the grayscale closing is to be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Shape of a flat and full structuring element used for the grayscale
closing. Optional if `footprint` or `structure` is provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of non-infinite elements of a flat structuring element
used for the grayscale closing.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the grayscale closing. `structure`
may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the ouput of the closing may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="grey_closing" name="grey_closing" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result of the grayscale closing of `input` with `structure`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.grey_dilation" module_name="grey_dilation" namespace="'ndimage'">
    <docstring>Calculate a greyscale dilation, using either a structuring element,
or a footprint corresponding to a flat structuring element.

Grayscale dilation is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a maximum filter over a sliding window.

Parameters
----------
input : array_like
    Array over which the grayscale dilation is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    dilation. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale dilation. Non-zero values give the set of
    neighbors of the center over which the maximum is chosen.
structure : array of ints, optional
    Structuring element used for the grayscale dilation. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the dilation may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_dilation : ndarray
    Grayscale dilation of `input`.

See also
--------
binary_dilation, grey_erosion, grey_closing, grey_opening
generate_binary_structure, ndimage.maximum_filter

Notes
-----
The grayscale dilation of an image input by a structuring element s defined
over a domain E is given by:

(input+s)(x) = max {input(y) + s(x-y), for y in E}

In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale dilation computes the maximum of the
input image inside a sliding window defined by E.

Grayscale dilation [1]_ is a *mathematical morphology* operation [2]_.

References
----------
.. [1] http://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1
&gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_dilation(a, footprint=np.ones((3,3)))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; s = ndimage.generate_binary_structure(2,1)
&gt;&gt;&gt; s
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; ndimage.grey_dilation(a, footprint=s)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 1, 3, 2, 1, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))
array([[1, 1, 1, 1, 1, 1, 1],
       [1, 2, 4, 4, 4, 2, 1],
       [1, 2, 4, 4, 4, 2, 1],
       [1, 2, 4, 4, 4, 3, 1],
       [1, 2, 2, 3, 3, 3, 1],
       [1, 2, 2, 3, 3, 3, 1],
       [1, 1, 1, 1, 1, 1, 1]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array over which the grayscale dilation is to be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Shape of a flat and full structuring element used for the grayscale
dilation. Optional if `footprint` or `structure` is provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of non-infinite elements of a flat structuring element
used for the grayscale dilation. Non-zero values give the set of
neighbors of the center over which the maximum is chosen.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the grayscale dilation. `structure`
may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the ouput of the dilation may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="grey_dilation" name="grey_dilation" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Grayscale dilation of `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.grey_erosion" module_name="grey_erosion" namespace="'ndimage'">
    <docstring>Calculate a greyscale erosion, using either a structuring element,
or a footprint corresponding to a flat structuring element.

Grayscale erosion is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a minimum filter over a sliding window.

Parameters
----------
input : array_like
    Array over which the grayscale erosion is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    erosion. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale erosion. Non-zero values give the set of
    neighbors of the center over which the minimum is chosen.
structure : array of ints, optional
    Structuring element used for the grayscale erosion. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the erosion may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
output : ndarray
    Grayscale erosion of `input`.

See also
--------
binary_erosion, grey_dilation, grey_opening, grey_closing
generate_binary_structure, ndimage.minimum_filter

Notes
-----
The grayscale erosion of an image input by a structuring element s defined
over a domain E is given by:

(input+s)(x) = min {input(y) - s(x-y), for y in E}

In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale erosion computes the minimum of the
input image inside a sliding window defined by E.

Grayscale erosion [1]_ is a *mathematical morphology* operation [2]_.

References
----------
.. [1] http://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1:6, 1:6] = 3
&gt;&gt;&gt; a[4,4] = 2; a[2,3] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 3, 3, 1, 3, 3, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 3, 3, 3, 2, 3, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 3, 2, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; footprint = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; footprint
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; # Diagonally-connected elements are not considered neighbors
&gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3), footprint=footprint)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 3, 1, 2, 0, 0],
       [0, 0, 3, 2, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array over which the grayscale erosion is to be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Shape of a flat and full structuring element used for the grayscale
erosion. Optional if `footprint` or `structure` is provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of non-infinite elements of a flat structuring element
used for the grayscale erosion. Non-zero values give the set of
neighbors of the center over which the minimum is chosen.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the grayscale erosion. `structure`
may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the ouput of the erosion may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Grayscale erosion of `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.grey_opening" module_name="grey_opening" namespace="'ndimage'">
    <docstring>Multi-dimensional greyscale opening.

A greyscale opening consists in the succession of a greyscale erosion,
and a greyscale dilation.

Parameters
----------
input : array_like
    Array over which the grayscale opening is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    opening. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale opening.
structure : array of ints, optional
    Structuring element used for the grayscale opening. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the opening may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_opening : ndarray
    Result of the grayscale opening of `input` with `structure`.

See also
--------
binary_opening, grey_dilation, grey_erosion, grey_closing
generate_binary_structure

Notes
-----
The action of a grayscale opening with a flat structuring element amounts
to smoothen high local maxima, whereas binary opening erases small objects.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.arange(36).reshape((6,6))
&gt;&gt;&gt; a[3, 3] = 50
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 50, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
&gt;&gt;&gt; ndimage.grey_opening(a, size=(3,3))
array([[ 0,  1,  2,  3,  4,  4],
       [ 6,  7,  8,  9, 10, 10],
       [12, 13, 14, 15, 16, 16],
       [18, 19, 20, 22, 22, 22],
       [24, 25, 26, 27, 28, 28],
       [24, 25, 26, 27, 28, 28]])
&gt;&gt;&gt; # Note that the local maximum a[3,3] has disappeared</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array over which the grayscale opening is to be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Shape of a flat and full structuring element used for the grayscale
opening. Optional if `footprint` or `structure` is provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of non-infinite elements of a flat structuring element
used for the grayscale opening.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the grayscale opening. `structure`
may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the ouput of the opening may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="grey_opening" name="grey_opening" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result of the grayscale opening of `input` with `structure`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.histogram" module_name="histogram" namespace="'ndimage'">
    <docstring>Calculate the histogram of the values of an array, optionally at labels.

Histogram calculates the frequency of values in an array within bins
determined by `min`, `max`, and `bins`. The `labels` and `index`
keywords can limit the scope of the histogram to specified sub-regions
within the array.

Parameters
----------
input : array_like
    Data for which to calculate histogram.
min, max : int
    Minimum and maximum values of range of histogram bins.
bins : int
    Number of bins.
labels : array_like, optional
    Labels for objects in `input`.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    Label or labels for which to calculate histogram. If None, all values
    where label is greater than zero are used

Returns
-------
hist : ndarray
    Histogram counts.

Examples
--------
&gt;&gt;&gt; a = np.array([[ 0.    ,  0.2146,  0.5962,  0.    ],
                  [ 0.    ,  0.7778,  0.    ,  0.    ],
                  [ 0.    ,  0.    ,  0.    ,  0.    ],
                  [ 0.    ,  0.    ,  0.7181,  0.2787],
                  [ 0.    ,  0.    ,  0.6573,  0.3094]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.measurements.histogram(a, 0, 1, 10)
array([13,  0,  2,  1,  0,  1,  1,  2,  0,  0])

With labels and no indices, non-zero elements are counted:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.measurements.histogram(a, 0, 1, 10, lbl)
array([0, 0, 2, 1, 0, 1, 1, 2, 0, 0])

Indices can be used to count only certain objects:

&gt;&gt;&gt; ndimage.measurements.histogram(a, 0, 1, 10, lbl, 2)
array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Data for which to calculate histogram.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="min" name="min" port_type="basic:Integer" show_port="True">
      <docstring>Minimum and maximum values of range of histogram bins.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max" name="max" port_type="basic:Integer" show_port="True">
      <docstring>Minimum and maximum values of range of histogram bins.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="bins" port_type="basic:Integer" show_port="True">
      <docstring>Number of bins.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>Labels for objects in `input`.
If not None, must be same shape as `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="indexScalar" port_type="basic:Integer">
      <docstring>Label or labels for which to calculate histogram. If None, all values
where label is greater than zero are used</docstring>
      <alternateSpec arg="index" depth="1" name="indexSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="hist" name="hist" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Histogram counts.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.imread" module_name="imread" namespace="'ndimage'">
    <docstring>Read an image from a file as an array.

Parameters
----------
fname : str
    Image file name, e.g. ``test.jpg``, or a file object.
flatten : bool, optional
    If true, convert the output to grey-scale. Default is False.
mode : str, optional
    mode to convert image to, e.g. ``RGB``.


Returns
-------
img_array : ndarray
    The different colour bands/channels are stored in the
    third dimension, such that a grey-image is MxN, an
    RGB-image MxNx3 and an RGBA-image MxNx4.

Raises
------
ImportError
    If the Python Imaging Library (PIL) can not be imported.</docstring>
    <inputPortSpec arg="fname" name="fname" show_port="True">
      <docstring>Image file name, e.g. ``test.jpg``, or a file object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="flatten" name="flatten" port_type="basic:Boolean">
      <docstring>If true, convert the output to grey-scale. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>mode to convert image to, e.g. ``RGB``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="img_array" name="img_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The different colour bands/channels are stored in the
third dimension, such that a grey-image is MxN, an
RGB-image MxNx3 and an RGBA-image MxNx4.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.iterate_structure" module_name="iterate_structure" namespace="'ndimage'">
    <docstring>Iterate a structure by dilating it with itself.

Parameters
----------
structure : array_like
   Structuring element (an array of bools, for example), to be dilated with
   itself.
iterations : int
   number of dilations performed on the structure with itself
origin : optional
    If origin is None, only the iterated structure is returned. If
    not, a tuple of the iterated structure and the modified origin is
    returned.

Returns
-------
iterate_structure : ndarray of bools
    A new structuring element obtained by dilating `structure`
    (`iterations` - 1) times with itself.

See also
--------
generate_binary_structure

Examples
--------
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; struct.astype(int)
array([[0, 1, 0],
       [1, 1, 1],
       [0, 1, 0]])
&gt;&gt;&gt; ndimage.iterate_structure(struct, 2).astype(int)
array([[0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [1, 1, 1, 1, 1],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0]])
&gt;&gt;&gt; ndimage.iterate_structure(struct, 3).astype(int)
array([[0, 0, 0, 1, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0, 0]])</docstring>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List" show_port="True">
      <docstring>Structuring element (an array of bools, for example), to be dilated with
itself.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iterations" name="iterations" port_type="basic:Integer" show_port="True">
      <docstring>number of dilations performed on the structure with itself</docstring>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Variant">
      <docstring>If origin is None, only the iterated structure is returned. If
not, a tuple of the iterated structure and the modified origin is
returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="iterate_structure" depth="1" name="iterate_structure" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>A new structuring element obtained by dilating `structure`
(`iterations` - 1) times with itself.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.label" module_name="label" namespace="'ndimage'" output_type="list">
    <docstring>Label features in an array.

Parameters
----------
input : array_like
    An array-like object to be labeled.  Any non-zero values in `input` are
    counted as features and zero values are considered the background.
structure : array_like, optional
    A structuring element that defines feature connections.
    `structure` must be symmetric.  If no structuring element is provided,
    one is automatically generated with a squared connectivity equal to
    one.  That is, for a 2-D `input` array, the default structuring element
    is::

        [[0,1,0],
         [1,1,1],
         [0,1,0]]

output : (None, data-type, array_like), optional
    If `output` is a data type, it specifies the type of the resulting
    labeled feature array
    If `output` is an array-like object, then `output` will be updated
    with the labeled features from this function.  This function can
    operate in-place, by passing output=input.
    Note that the output must be able to store the largest label, or this
    function will raise an Exception.

Returns
-------
label : ndarray or int
    An integer ndarray where each unique feature in `input` has a unique
    label in the returned array.
num_features : int
    How many objects were found.

    If `output` is None, this function returns a tuple of
    (`labeled_array`, `num_features`).

    If `output` is a ndarray, then it will be updated with values in
    `labeled_array` and only `num_features` will be returned by this
    function.

See Also
--------
find_objects : generate a list of slices for the labeled features (or
               objects); useful for finding features' position or
               dimensions

Examples
--------
Create an image with some features, then label it using the default
(cross-shaped) structuring element:

&gt;&gt;&gt; a = np.array([[0,0,1,1,0,0],
...               [0,0,0,1,0,0],
...               [1,1,0,0,1,0],
...               [0,0,0,1,0,0]])
&gt;&gt;&gt; labeled_array, num_features = label(a)

Each of the 4 features are labeled with a different integer:

&gt;&gt;&gt; print(num_features)
4
&gt;&gt;&gt; print(labeled_array)
array([[0, 0, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [2, 2, 0, 0, 3, 0],
       [0, 0, 0, 4, 0, 0]])

Generate a structuring element that will consider features connected even
if they touch diagonally:

&gt;&gt;&gt; s = generate_binary_structure(2,2)

or,

&gt;&gt;&gt; s = [[1,1,1],
         [1,1,1],
         [1,1,1]]

Label the image using the new structuring element:

&gt;&gt;&gt; labeled_array, num_features = label(a, structure=s)

Show the 2 labeled features (note that features 1, 3, and 4 from above are
now considered a single feature):

&gt;&gt;&gt; print(num_features)
2
&gt;&gt;&gt; print(labeled_array)
array([[0, 0, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [2, 2, 0, 0, 1, 0],
       [0, 0, 0, 1, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>An array-like object to be labeled.  Any non-zero values in `input` are
counted as features and zero values are considered the background.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure" port_type="basic:List">
      <docstring>A structuring element that defines feature connections.
`structure` must be symmetric.  If no structuring element is provided,
one is automatically generated with a squared connectivity equal to
one.  That is, for a 2-D `input` array, the default structuring element
is::

    [[0,1,0],
     [1,1,1],
     [0,1,0]]
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>If `output` is a data type, it specifies the type of the resulting
labeled feature array
If `output` is an array-like object, then `output` will be updated
with the labeled features from this function.  This function can
operate in-place, by passing output=input.
Note that the output must be able to store the largest label, or this
function will raise an Exception.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="label" name="label" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>An integer ndarray where each unique feature in `input` has a unique
label in the returned array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="num_features" name="num_features" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>How many objects were found.

If `output` is None, this function returns a tuple of
(`labeled_array`, `num_features`).

If `output` is a ndarray, then it will be updated with values in
`labeled_array` and only `num_features` will be returned by this
function.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.labeled_comprehension" module_name="labeled_comprehension" namespace="'ndimage'">
    <docstring>Roughly equivalent to [func(input[labels == i]) for i in index].

Sequentially applies an arbitrary function (that works on array_like input)
to subsets of an n-D image array specified by `labels` and `index`.
The option exists to provide the function with positional parameters as the
second argument.

Parameters
----------
input : array_like
    Data from which to select `labels` to process.
labels : array_like or None
    Labels to objects in `input`.
    If not None, array must be same shape as `input`.
    If None, `func` is applied to raveled `input`.
index : int, sequence of ints or None
    Subset of `labels` to which to apply `func`.
    If a scalar, a single value is returned.
    If None, `func` is applied to all non-zero values of `labels`.
func : callable
    Python function to apply to `labels` from `input`.
out_dtype : dtype
    Dtype to use for `result`.
default : int, float or None
    Default return value when a element of `index` does not exist
    in `labels`.
pass_positions : bool, optional
    If True, pass linear indices to `func` as a second argument.
    Default is False.

Returns
-------
result : ndarray
    Result of applying `func` to each of `labels` to `input` in `index`.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; lbls = np.arange(1, nlbl+1)
&gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, 0)
array([ 2.75,  5.5 ,  6.  ])

Falling back to `default`:

&gt;&gt;&gt; lbls = np.arange(1, nlbl+2)
&gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, -1)
array([ 2.75,  5.5 ,  6.  , -1.  ])

Passing positions:

&gt;&gt;&gt; def fn(val, pos):
...     print("fn says: %s : %s" % (val, pos))
...     return (val.sum()) if (pos.sum() % 2 == 0) else (-val.sum())
...
&gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, fn, float, 0, True)
fn says: [1 2 5 3] : [0 1 4 5]
fn says: [4 7] : [7 11]
fn says: [9 3] : [12 13]
array([ 11.,  11., -12.])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Data from which to select `labels` to process.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List" show_port="True">
      <docstring>Labels to objects in `input`.
If not None, array must be same shape as `input`.
If None, `func` is applied to raveled `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" depth="1" name="index" port_type="basic:Integer" show_port="True">
      <docstring>Subset of `labels` to which to apply `func`.
If a scalar, a single value is returned.
If None, `func` is applied to all non-zero values of `labels`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Python function to apply to `labels` from `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out_dtype" name="out_dtype" port_type="basic:Variant" show_port="True">
      <docstring>Dtype to use for `result`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="default" name="default" port_type="basic:Float" show_port="True">
      <docstring>Default return value when a element of `index` does not exist
in `labels`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pass_positions" name="pass_positions" port_type="basic:Boolean">
      <docstring>If True, pass linear indices to `func` as a second argument.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="result" name="result" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result of applying `func` to each of `labels` to `input` in `index`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.laplace" module_name="laplace" namespace="'ndimage'">
    <docstring>N-dimensional Laplace filter based on approximate second derivatives.

Parameters
----------
input : array_like
    Input array to filter.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.map_coordinates" module_name="map_coordinates" namespace="'ndimage'">
    <docstring>Map the input array to new coordinates by interpolation.

The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.

The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.

Parameters
----------
input : ndarray
    The input array.
coordinates : array_like
    The coordinates at which `input` is evaluated.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array.
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
mode : str, optional
    Points outside the boundaries of the input are filled according
    to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
    Default is 'constant'.
cval : scalar, optional
    Value used for points outside the boundaries of the input if
    ``mode='constant'``. Default is 0.0
prefilter : bool, optional
    The parameter prefilter determines if the input is pre-filtered with
    `spline_filter` before interpolation (necessary for spline
    interpolation of order &gt; 1).  If False, it is assumed that the input is
    already filtered. Default is True.

Returns
-------
map_coordinates : ndarray
    The result of transforming the input. The shape of the output is
    derived from that of `coordinates` by dropping the first axis.

See Also
--------
spline_filter, geometric_transform, scipy.interpolate

Examples
--------
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; a = np.arange(12.).reshape((4, 3))
&gt;&gt;&gt; a
array([[  0.,   1.,   2.],
       [  3.,   4.,   5.],
       [  6.,   7.,   8.],
       [  9.,  10.,  11.]])
&gt;&gt;&gt; ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)
[ 2.  7.]

Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].

&gt;&gt;&gt; inds = np.array([[0.5, 2], [0.5, 4]])
&gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=-33.3)
array([  2. , -33.3])
&gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, mode='nearest')
array([ 2.,  8.])
&gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool)
array([ True, False], dtype=bool</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coordinates" name="coordinates" port_type="basic:List" show_port="True">
      <docstring>The coordinates at which `input` is evaluated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Points outside the boundaries of the input are filled according
to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
Default is 'constant'.</docstring>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value used for points outside the boundaries of the input if
``mode='constant'``. Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefilter" name="prefilter" port_type="basic:Boolean">
      <docstring>The parameter prefilter determines if the input is pre-filtered with
`spline_filter` before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="map_coordinates" name="map_coordinates" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of transforming the input. The shape of the output is
derived from that of `coordinates` by dropping the first axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.maximum" module_name="maximum" namespace="'ndimage'">
    <docstring>Calculate the maximum of the values of an array over labeled regions.

Parameters
----------
input : array_like
    Array_like of values. For each region specified by `labels`, the
    maximal values of `input` over the region is computed.
labels : array_like, optional
    An array of integers marking different regions over which the
    maximum value of `input` is to be computed. `labels` must have the
    same shape as `input`. If `labels` is not specified, the maximum
    over the whole array is returned.
index : array_like, optional
    A list of region labels that are taken into account for computing the
    maxima. If index is None, the maximum over all elements where `labels`
    is non-zero is returned.

Returns
-------
output : float or list of floats
    List of maxima of `input` over the regions determined by `labels` and
    whose index is in `index`. If `index` or `labels` are not specified, a
    float is returned: the maximal value of `input` if `labels` is None,
    and the maximal value of elements where `labels` is greater than zero
    if `index` is None.

See also
--------
label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation

Notes
-----
The function returns a Python list and not a Numpy array, use
`np.array` to convert the list to an array.

Examples
--------
&gt;&gt;&gt; a = np.arange(16).reshape((4,4))
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
&gt;&gt;&gt; labels = np.zeros_like(a)
&gt;&gt;&gt; labels[:2,:2] = 1
&gt;&gt;&gt; labels[2:, 1:3] = 2
&gt;&gt;&gt; labels
array([[1, 1, 0, 0],
       [1, 1, 0, 0],
       [0, 2, 2, 0],
       [0, 2, 2, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.maximum(a)
15.0
&gt;&gt;&gt; ndimage.maximum(a, labels=labels, index=[1,2])
[5.0, 14.0]
&gt;&gt;&gt; ndimage.maximum(a, labels=labels)
14.0

&gt;&gt;&gt; b = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; labels, labels_nb = ndimage.label(b)
&gt;&gt;&gt; labels
array([[1, 1, 0, 0],
       [1, 1, 0, 2],
       [0, 0, 0, 2],
       [3, 3, 0, 0]])
&gt;&gt;&gt; ndimage.maximum(b, labels=labels, index=np.arange(1, labels_nb + 1))
[5.0, 7.0, 9.0]</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array_like of values. For each region specified by `labels`, the
maximal values of `input` over the region is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>An array of integers marking different regions over which the
maximum value of `input` is to be computed. `labels` must have the
same shape as `input`. If `labels` is not specified, the maximum
over the whole array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="index" port_type="basic:List">
      <docstring>A list of region labels that are taken into account for computing the
maxima. If index is None, the maximum over all elements where `labels`
is non-zero is returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>List of maxima of `input` over the regions determined by `labels` and
whose index is in `index`. If `index` or `labels` are not specified, a
float is returned: the maximal value of `input` if `labels` is None,
and the maximal value of elements where `labels` is greater than zero
if `index` is None.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.maximum_filter" module_name="maximum_filter" namespace="'ndimage'">
    <docstring>Calculates a multi-dimensional maximum filter.

Parameters
----------
input : array_like
    Input array to filter.
size : scalar or tuple, optional
    See footprint, below
footprint : array, optional
    Either `size` or `footprint` must be defined.  `size` gives
    the shape that is taken from the input array, at every element
    position, to define the input to the filter function.
    `footprint` is a boolean array that specifies (implicitly) a
    shape, but also which of the elements within this shape will get
    passed to the filter function.  Thus ``size=(n,m)`` is equivalent
    to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
    of dimensions of the input array, so that, if the input array is
    shape (10,10,10), and `size` is 2, then the actual size used is
    (2,2,2).
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float">
      <docstring>See footprint, below</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprint" port_type="basic:List">
      <docstring>Either `size` or `footprint` must be defined.  `size` gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
`footprint` is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus ``size=(n,m)`` is equivalent
to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and `size` is 2, then the actual size used is
(2,2,2).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.maximum_filter1d" module_name="maximum_filter1d" namespace="'ndimage'">
    <docstring>Calculate a one-dimensional maximum filter along the given axis.

The lines of the array along the given axis are filtered with a
maximum filter of given size.

Parameters
----------
input : array_like
    Input array to filter.
size : int
    Length along which to calculate the 1-D maximum.
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.

Returns
-------
maximum1d : ndarray, None
    Maximum-filtered array with same shape as input.
    None if `output` is not None

Notes
-----
This function implements the MAXLIST algorithm [1]_, as described by
Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being
the `input` length, regardless of filter size.

References
----------
.. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
.. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Length along which to calculate the 1-D maximum.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="maximum1d" name="maximum1d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Maximum-filtered array with same shape as input.
None if `output` is not None</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.maximum_position" module_name="maximum_position" namespace="'ndimage'">
    <docstring>Find the positions of the maximums of the values of an array at labels.

For each region specified by `labels`, the position of the maximum
value of `input` within the region is returned.

Parameters
----------
input : array_like
    Array_like of values.
labels : array_like, optional
    An array of integers marking different regions over which the
    position of the maximum value of `input` is to be computed.
    `labels` must have the same shape as `input`. If `labels` is not
    specified, the location of the first maximum over the whole
    array is returned.

    The `labels` argument only works when `index` is specified.
index : array_like, optional
    A list of region labels that are taken into account for finding the
    location of the maxima.  If `index` is None, the first maximum
    over all elements where `labels` is non-zero is returned.

    The `index` argument only works when `labels` is specified.

Returns
-------
output : list of tuples of ints
    List of tuples of ints that specify the location of maxima of
    `input` over the regions determined by `labels` and whose index
    is in `index`.

    If `index` or `labels` are not specified, a tuple of ints is
    returned specifying the location of the ``first`` maximal value
    of `input`.

See also
--------
label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array_like of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>An array of integers marking different regions over which the
position of the maximum value of `input` is to be computed.
`labels` must have the same shape as `input`. If `labels` is not
specified, the location of the first maximum over the whole
array is returned.

The `labels` argument only works when `index` is specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="index" port_type="basic:List">
      <docstring>A list of region labels that are taken into account for finding the
location of the maxima.  If `index` is None, the first maximum
over all elements where `labels` is non-zero is returned.

The `index` argument only works when `labels` is specified.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" depth="1" name="output" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>List of tuples of ints that specify the location of maxima of
`input` over the regions determined by `labels` and whose index
is in `index`.

If `index` or `labels` are not specified, a tuple of ints is
returned specifying the location of the ``first`` maximal value
of `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.mean" module_name="mean" namespace="'ndimage'">
    <docstring>Calculate the mean of the values of an array at labels.

Parameters
----------
input : array_like
    Array on which to compute the mean of elements over distinct
    regions.
labels : array_like, optional
    Array of labels of same shape, or broadcastable to the same shape as
    `input`. All elements sharing the same label form one region over
    which the mean of the elements is computed.
index : int or sequence of ints, optional
    Labels of the objects over which the mean is to be computed.
    Default is None, in which case the mean for all values where label is
    greater than 0 is calculated.

Returns
-------
out : list
    Sequence of same length as `index`, with the mean of the different
    regions labeled by the labels in `index`.

See also
--------
ndimage.variance, ndimage.standard_deviation, ndimage.minimum,
ndimage.maximum, ndimage.sum
ndimage.label

Examples
--------
&gt;&gt;&gt; a = np.arange(25).reshape((5,5))
&gt;&gt;&gt; labels = np.zeros_like(a)
&gt;&gt;&gt; labels[3:5,3:5] = 1
&gt;&gt;&gt; index = np.unique(labels)
&gt;&gt;&gt; labels
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1],
       [0, 0, 0, 1, 1]])
&gt;&gt;&gt; index
array([0, 1])
&gt;&gt;&gt; ndimage.mean(a, labels=labels, index=index)
[10.285714285714286, 21.0]</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array on which to compute the mean of elements over distinct
regions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>Array of labels of same shape, or broadcastable to the same shape as
`input`. All elements sharing the same label form one region over
which the mean of the elements is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="indexScalar" port_type="basic:Integer">
      <docstring>Labels of the objects over which the mean is to be computed.
Default is None, in which case the mean for all values where label is
greater than 0 is calculated.</docstring>
      <alternateSpec arg="index" depth="1" name="indexSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sequence of same length as `index`, with the mean of the different
regions labeled by the labels in `index`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.median" module_name="median" namespace="'ndimage'">
    <docstring>Calculate the median of the values of an array over labeled regions.

Parameters
----------
input : array_like
    Array_like of values. For each region specified by `labels`, the
    median value of `input` over the region is computed.
labels : array_like, optional
    An array_like of integers marking different regions over which the
    median value of `input` is to be computed. `labels` must have the
    same shape as `input`. If `labels` is not specified, the median
    over the whole array is returned.
index : array_like, optional
    A list of region labels that are taken into account for computing the
    medians. If index is None, the median over all elements where `labels`
    is non-zero is returned.

Returns
-------
median : float or list of floats
    List of medians of `input` over the regions determined by `labels` and
    whose index is in `index`. If `index` or `labels` are not specified, a
    float is returned: the median value of `input` if `labels` is None,
    and the median value of elements where `labels` is greater than zero
    if `index` is None.

See also
--------
label, minimum, maximum, extrema, sum, mean, variance, standard_deviation

Notes
-----
The function returns a Python list and not a Numpy array, use
`np.array` to convert the list to an array.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 1],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
&gt;&gt;&gt; labels, labels_nb = ndimage.label(a)
&gt;&gt;&gt; labels
array([[1, 1, 0, 2],
       [1, 1, 0, 2],
       [0, 0, 0, 2],
       [3, 3, 0, 0]])
&gt;&gt;&gt; ndimage.median(a, labels=labels, index=np.arange(1, labels_nb + 1))
[2.5, 4.0, 6.0]
&gt;&gt;&gt; ndimage.median(a)
1.0
&gt;&gt;&gt; ndimage.median(a, labels=labels)
3.0</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array_like of values. For each region specified by `labels`, the
median value of `input` over the region is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>An array_like of integers marking different regions over which the
median value of `input` is to be computed. `labels` must have the
same shape as `input`. If `labels` is not specified, the median
over the whole array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="index" port_type="basic:List">
      <docstring>A list of region labels that are taken into account for computing the
medians. If index is None, the median over all elements where `labels`
is non-zero is returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="median" name="median" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>List of medians of `input` over the regions determined by `labels` and
whose index is in `index`. If `index` or `labels` are not specified, a
float is returned: the median value of `input` if `labels` is None,
and the median value of elements where `labels` is greater than zero
if `index` is None.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.median_filter" module_name="median_filter" namespace="'ndimage'">
    <docstring>Calculates a multidimensional median filter.

Parameters
----------
input : array_like
    Input array to filter.
size : scalar or tuple, optional
    See footprint, below
footprint : array, optional
    Either `size` or `footprint` must be defined.  `size` gives
    the shape that is taken from the input array, at every element
    position, to define the input to the filter function.
    `footprint` is a boolean array that specifies (implicitly) a
    shape, but also which of the elements within this shape will get
    passed to the filter function.  Thus ``size=(n,m)`` is equivalent
    to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
    of dimensions of the input array, so that, if the input array is
    shape (10,10,10), and `size` is 2, then the actual size used is
    (2,2,2).
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.

Returns
-------
median_filter : ndarray
    Return of same shape as `input`.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float">
      <docstring>See footprint, below</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprint" port_type="basic:List">
      <docstring>Either `size` or `footprint` must be defined.  `size` gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
`footprint` is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus ``size=(n,m)`` is equivalent
to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and `size` is 2, then the actual size used is
(2,2,2).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="median_filter" name="median_filter" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Return of same shape as `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.minimum" module_name="minimum" namespace="'ndimage'">
    <docstring>Calculate the minimum of the values of an array over labeled regions.

Parameters
----------
input : array_like
    Array_like of values. For each region specified by `labels`, the
    minimal values of `input` over the region is computed.
labels : array_like, optional
    An array_like of integers marking different regions over which the
    minimum value of `input` is to be computed. `labels` must have the
    same shape as `input`. If `labels` is not specified, the minimum
    over the whole array is returned.
index : array_like, optional
    A list of region labels that are taken into account for computing the
    minima. If index is None, the minimum over all elements where `labels`
    is non-zero is returned.

Returns
-------
minimum : float or list of floats
    List of minima of `input` over the regions determined by `labels` and
    whose index is in `index`. If `index` or `labels` are not specified, a
    float is returned: the minimal value of `input` if `labels` is None,
    and the minimal value of elements where `labels` is greater than zero
    if `index` is None.

See also
--------
label, maximum, median, minimum_position, extrema, sum, mean, variance,
standard_deviation

Notes
-----
The function returns a Python list and not a Numpy array, use
`np.array` to convert the list to an array.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
&gt;&gt;&gt; labels, labels_nb = ndimage.label(a)
&gt;&gt;&gt; labels
array([[1, 1, 0, 0],
       [1, 1, 0, 2],
       [0, 0, 0, 2],
       [3, 3, 0, 0]])
&gt;&gt;&gt; ndimage.minimum(a, labels=labels, index=np.arange(1, labels_nb + 1))
[1.0, 4.0, 3.0]
&gt;&gt;&gt; ndimage.minimum(a)
0.0
&gt;&gt;&gt; ndimage.minimum(a, labels=labels)
1.0</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array_like of values. For each region specified by `labels`, the
minimal values of `input` over the region is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>An array_like of integers marking different regions over which the
minimum value of `input` is to be computed. `labels` must have the
same shape as `input`. If `labels` is not specified, the minimum
over the whole array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="index" port_type="basic:List">
      <docstring>A list of region labels that are taken into account for computing the
minima. If index is None, the minimum over all elements where `labels`
is non-zero is returned.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="minimum" name="minimum" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>List of minima of `input` over the regions determined by `labels` and
whose index is in `index`. If `index` or `labels` are not specified, a
float is returned: the minimal value of `input` if `labels` is None,
and the minimal value of elements where `labels` is greater than zero
if `index` is None.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.minimum_filter" module_name="minimum_filter" namespace="'ndimage'">
    <docstring>Calculates a multi-dimensional minimum filter.

Parameters
----------
input : array_like
    Input array to filter.
size : scalar or tuple, optional
    See footprint, below
footprint : array, optional
    Either `size` or `footprint` must be defined.  `size` gives
    the shape that is taken from the input array, at every element
    position, to define the input to the filter function.
    `footprint` is a boolean array that specifies (implicitly) a
    shape, but also which of the elements within this shape will get
    passed to the filter function.  Thus ``size=(n,m)`` is equivalent
    to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
    of dimensions of the input array, so that, if the input array is
    shape (10,10,10), and `size` is 2, then the actual size used is
    (2,2,2).
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float">
      <docstring>See footprint, below</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprint" port_type="basic:List">
      <docstring>Either `size` or `footprint` must be defined.  `size` gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
`footprint` is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus ``size=(n,m)`` is equivalent
to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and `size` is 2, then the actual size used is
(2,2,2).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.minimum_filter1d" module_name="minimum_filter1d" namespace="'ndimage'">
    <docstring>Calculate a one-dimensional minimum filter along the given axis.

The lines of the array along the given axis are filtered with a
minimum filter of given size.

Parameters
----------
input : array_like
    Input array to filter.
size : int
    length along which to calculate 1D minimum
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.

Notes
-----
This function implements the MINLIST algorithm [1]_, as described by
Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being
the `input` length, regardless of filter size.

References
----------
.. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
.. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="size" port_type="basic:Integer" show_port="True">
      <docstring>length along which to calculate 1D minimum</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.minimum_position" module_name="minimum_position" namespace="'ndimage'">
    <docstring>Find the positions of the minimums of the values of an array at labels.

Parameters
----------
input : array_like
    Array_like of values.
labels : array_like, optional
    An array of integers marking different regions over which the
    position of the minimum value of `input` is to be computed.
    `labels` must have the same shape as `input`. If `labels` is not
    specified, the location of the first minimum over the whole
    array is returned.

    The `labels` argument only works when `index` is specified.
index : array_like, optional
    A list of region labels that are taken into account for finding the
    location of the minima. If `index` is None, the ``first`` minimum
    over all elements where `labels` is non-zero is returned.

    The `index` argument only works when `labels` is specified.

Returns
-------
output : list of tuples of ints
    Tuple of ints or list of tuples of ints that specify the location
    of minima of `input` over the regions determined by `labels` and
    whose index is in `index`.

    If `index` or `labels` are not specified, a tuple of ints is
    returned specifying the location of the first minimal value of `input`.

See also
--------
label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array_like of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>An array of integers marking different regions over which the
position of the minimum value of `input` is to be computed.
`labels` must have the same shape as `input`. If `labels` is not
specified, the location of the first minimum over the whole
array is returned.

The `labels` argument only works when `index` is specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="index" port_type="basic:List">
      <docstring>A list of region labels that are taken into account for finding the
location of the minima. If `index` is None, the ``first`` minimum
over all elements where `labels` is non-zero is returned.

The `index` argument only works when `labels` is specified.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" depth="1" name="output" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Tuple of ints or list of tuples of ints that specify the location
of minima of `input` over the regions determined by `labels` and
whose index is in `index`.

If `index` or `labels` are not specified, a tuple of ints is
returned specifying the location of the first minimal value of `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.morphological_gradient" module_name="morphological_gradient" namespace="'ndimage'">
    <docstring>Multi-dimensional morphological gradient.

The morphological gradient is calculated as the difference between a
dilation and an erosion of the input with a given structuring element.

Parameters
----------
input : array_like
    Array over which to compute the morphlogical gradient.
size : tuple of ints
    Shape of a flat and full structuring element used for the mathematical
    morphology operations. Optional if `footprint` or `structure` is
    provided. A larger `size` yields a more blurred gradient.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the morphology operations. Larger footprints
    give a more blurred morphological gradient.
structure : array of ints, optional
    Structuring element used for the morphology operations.
    `structure` may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the morphological gradient
    may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
morphological_gradient : ndarray
    Morphological gradient of `input`.

See also
--------
grey_dilation, grey_erosion, ndimage.gaussian_gradient_magnitude

Notes
-----
For a flat structuring element, the morphological gradient
computed at a given point corresponds to the maximal difference
between elements of the input among the elements covered by the
structuring element centered on the point.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1
&gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; # The morphological gradient is computed as the difference
&gt;&gt;&gt; # between a dilation and an erosion
&gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3)) -\
...  ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1
&gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 2, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Array over which to compute the morphlogical gradient.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Shape of a flat and full structuring element used for the mathematical
morphology operations. Optional if `footprint` or `structure` is
provided. A larger `size` yields a more blurred gradient.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of non-infinite elements of a flat structuring element
used for the morphology operations. Larger footprints
give a more blurred morphological gradient.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the morphology operations.
`structure` may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the ouput of the morphological gradient
may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="morphological_gradient" name="morphological_gradient" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Morphological gradient of `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.morphological_laplace" module_name="morphological_laplace" namespace="'ndimage'">
    <docstring>Multi-dimensional morphological laplace.

Parameters
----------
input : array_like
    Input.
size : int or sequence of ints, optional
    See `structure`.
footprint : bool or ndarray, optional
    See `structure`.
structure : structure, optional
    Either `size`, `footprint`, or the `structure` must be provided.
output : ndarray, optional
    An output array can optionally be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The mode parameter determines how the array borders are handled.
    For 'constant' mode, values beyond borders are set to be `cval`.
    Default is 'reflect'.
cval : scalar, optional
    Value to fill past edges of input if mode is 'constant'.
    Default is 0.0
origin : origin, optional
    The origin parameter controls the placement of the filter.

Returns
-------
morphological_laplace : ndarray
    Output</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>See `structure`.</docstring>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprintSequence" port_type="basic:List">
      <docstring>See `structure`.</docstring>
      <alternateSpec arg="footprint" name="footprintBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure">
      <docstring>Either `size`, `footprint`, or the `structure` must be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An output array can optionally be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The mode parameter determines how the array borders are handled.
For 'constant' mode, values beyond borders are set to be `cval`.
Default is 'reflect'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if mode is 'constant'.
Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Integer">
      <docstring>The origin parameter controls the placement of the filter.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="morphological_laplace" name="morphological_laplace" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.percentile_filter" module_name="percentile_filter" namespace="'ndimage'">
    <docstring>Calculates a multi-dimensional percentile filter.

Parameters
----------
input : array_like
    Input array to filter.
percentile : scalar
    The percentile parameter may be less then zero, i.e.,
    percentile = -20 equals percentile = 80
size : scalar or tuple, optional
    See footprint, below
footprint : array, optional
    Either `size` or `footprint` must be defined.  `size` gives
    the shape that is taken from the input array, at every element
    position, to define the input to the filter function.
    `footprint` is a boolean array that specifies (implicitly) a
    shape, but also which of the elements within this shape will get
    passed to the filter function.  Thus ``size=(n,m)`` is equivalent
    to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
    of dimensions of the input array, so that, if the input array is
    shape (10,10,10), and `size` is 2, then the actual size used is
    (2,2,2).
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="percentile" name="percentile" port_type="basic:Float" show_port="True">
      <docstring>The percentile parameter may be less then zero, i.e.,
percentile = -20 equals percentile = 80</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float">
      <docstring>See footprint, below</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprint" port_type="basic:List">
      <docstring>Either `size` or `footprint` must be defined.  `size` gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
`footprint` is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus ``size=(n,m)`` is equivalent
to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and `size` is 2, then the actual size used is
(2,2,2).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.prewitt" module_name="prewitt" namespace="'ndimage'">
    <docstring>Calculate a Prewitt filter.

Parameters
----------
input : array_like
    Input array to filter.
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.rank_filter" module_name="rank_filter" namespace="'ndimage'">
    <docstring>Calculates a multi-dimensional rank filter.

Parameters
----------
input : array_like
    Input array to filter.
rank : int
    The rank parameter may be less then zero, i.e., rank = -1
    indicates the largest element.
size : scalar or tuple, optional
    See footprint, below
footprint : array, optional
    Either `size` or `footprint` must be defined.  `size` gives
    the shape that is taken from the input array, at every element
    position, to define the input to the filter function.
    `footprint` is a boolean array that specifies (implicitly) a
    shape, but also which of the elements within this shape will get
    passed to the filter function.  Thus ``size=(n,m)`` is equivalent
    to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
    of dimensions of the input array, so that, if the input array is
    shape (10,10,10), and `size` is 2, then the actual size used is
    (2,2,2).
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True">
      <docstring>The rank parameter may be less then zero, i.e., rank = -1
indicates the largest element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Float">
      <docstring>See footprint, below</docstring>
      <alternateSpec arg="size" name="sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="footprint" name="footprint" port_type="basic:List">
      <docstring>Either `size` or `footprint` must be defined.  `size` gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
`footprint` is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus ``size=(n,m)`` is equivalent
to ``footprint=np.ones((n,m))``.  We adjust `size` to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and `size` is 2, then the actual size used is
(2,2,2).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.rotate" module_name="rotate" namespace="'ndimage'">
    <docstring>Rotate an array.

The array is rotated in the plane defined by the two axes given by the
`axes` parameter using spline interpolation of the requested order.

Parameters
----------
input : ndarray
    The input array.
angle : float
    The rotation angle in degrees.
axes : tuple of 2 ints, optional
    The two axes that define the plane of rotation. Default is the first
    two axes.
reshape : bool, optional
    If `reshape` is true, the output shape is adapted so that the input
    array is contained completely in the output. Default is True.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array.
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
mode : str, optional
    Points outside the boundaries of the input are filled according
    to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
    Default is 'constant'.
cval : scalar, optional
    Value used for points outside the boundaries of the input if
    ``mode='constant'``. Default is 0.0
prefilter : bool, optional
    The parameter prefilter determines if the input is pre-filtered with
    `spline_filter` before interpolation (necessary for spline
    interpolation of order &gt; 1).  If False, it is assumed that the input is
    already filtered. Default is True.

Returns
-------
rotate : ndarray or None
    The rotated input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="angle" name="angle" port_type="basic:Float" show_port="True">
      <docstring>The rotation angle in degrees.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" name="axes" port_type="basic:List">
      <docstring>The two axes that define the plane of rotation. Default is the first
two axes.</docstring>
      <defaults>[(1, 0)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="reshape" name="reshape" port_type="basic:Boolean">
      <docstring>If `reshape` is true, the output shape is adapted so that the input
array is contained completely in the output. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Points outside the boundaries of the input are filled according
to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
Default is 'constant'.</docstring>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value used for points outside the boundaries of the input if
``mode='constant'``. Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefilter" name="prefilter" port_type="basic:Boolean">
      <docstring>The parameter prefilter determines if the input is pre-filtered with
`spline_filter` before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="rotate" name="rotate" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The rotated input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.shift" module_name="shift" namespace="'ndimage'">
    <docstring>Shift an array.

The array is shifted using spline interpolation of the requested order.
Points outside the boundaries of the input are filled according to the
given mode.

Parameters
----------
input : ndarray
    The input array.
shift : float or sequence, optional
    The shift along the axes. If a float, `shift` is the same for each
    axis. If a sequence, `shift` should contain one value for each axis.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array.
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
mode : str, optional
    Points outside the boundaries of the input are filled according
    to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
    Default is 'constant'.
cval : scalar, optional
    Value used for points outside the boundaries of the input if
    ``mode='constant'``. Default is 0.0
prefilter : bool, optional
    The parameter prefilter determines if the input is pre-filtered with
    `spline_filter` before interpolation (necessary for spline
    interpolation of order &gt; 1).  If False, it is assumed that the input is
    already filtered. Default is True.

Returns
-------
shift : ndarray or None
    The shifted input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shift" name="shiftScalar" port_type="basic:Float">
      <docstring>The shift along the axes. If a float, `shift` is the same for each
axis. If a sequence, `shift` should contain one value for each axis.</docstring>
      <alternateSpec arg="shift" name="shiftSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Points outside the boundaries of the input are filled according
to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
Default is 'constant'.</docstring>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value used for points outside the boundaries of the input if
``mode='constant'``. Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefilter" name="prefilter" port_type="basic:Boolean">
      <docstring>The parameter prefilter determines if the input is pre-filtered with
`spline_filter` before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="shift" name="shift" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shifted input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.sobel" module_name="sobel" namespace="'ndimage'">
    <docstring>Calculate a Sobel filter.

Parameters
----------
input : array_like
    Input array to filter.
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.spline_filter" module_name="spline_filter" namespace="'ndimage'">
    <docstring>Multi-dimensional spline filter.

For more details, see `spline_filter1d`.

See Also
--------
spline_filter1d

Notes
-----
The multi-dimensional filter is implemented as a sequence of
one-dimensional spline filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.spline_filter1d" module_name="spline_filter1d" namespace="'ndimage'">
    <docstring>Calculates a one-dimensional spline filter along the given axis.

The lines of the array along the given axis are filtered by a
spline filter. The order of the spline must be &gt;= 2 and &lt;= 5.

Parameters
----------
input : array_like
    The input array.
order : int, optional
    The order of the spline, default is 3.
axis : int, optional
    The axis along which the spline filter is applied. Default is the last
    axis.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array. Default is `numpy.float64`.

Returns
-------
spline_filter1d : ndarray or None
    The filtered input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline, default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the spline filter is applied. Default is the last
axis.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array. Default is `numpy.float64`.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="spline_filter1d" name="spline_filter1d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.standard_deviation" module_name="standard_deviation" namespace="'ndimage'">
    <docstring>Calculate the standard deviation of the values of an n-D image array,
optionally at specified sub-regions.

Parameters
----------
input : array_like
    Nd-image data to process.
labels : array_like, optional
    Labels to identify sub-regions in `input`.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    `labels` to include in output.  If None (default), all values where
    `labels` is non-zero are used.

Returns
-------
standard_deviation : float or ndarray
    Values of standard deviation, for each sub-region if `labels` and
    `index` are specified.

See Also
--------
label, variance, maximum, minimum, extrema

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.standard_deviation(a)
2.7585095613392387

Features to process can be specified using `labels` and `index`:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.standard_deviation(a, lbl, index=np.arange(1, nlbl+1))
array([ 1.479,  1.5  ,  3.   ])

If no index is given, non-zero `labels` are processed:

&gt;&gt;&gt; ndimage.standard_deviation(a, lbl)
2.4874685927665499</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Nd-image data to process.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>Labels to identify sub-regions in `input`.
If not None, must be same shape as `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="indexScalar" port_type="basic:Integer">
      <docstring>`labels` to include in output.  If None (default), all values where
`labels` is non-zero are used.</docstring>
      <alternateSpec arg="index" depth="1" name="indexSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="standard_deviation" name="standard_deviation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Values of standard deviation, for each sub-region if `labels` and
`index` are specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.sum" module_name="sum" namespace="'ndimage'">
    <docstring>Calculate the sum of the values of the array.

Parameters
----------
input : array_like
    Values of `input` inside the regions defined by `labels`
    are summed together.
labels : array_like of ints, optional
    Assign labels to the values of the array. Has to have the same shape as
    `input`.
index : array_like, optional
    A single label number or a sequence of label numbers of
    the objects to be measured.

Returns
-------
sum : ndarray or scalar
    An array of the sums of values of `input` inside the regions defined
    by `labels` with the same shape as `index`. If 'index' is None or scalar,
    a scalar is returned.

See also
--------
mean, median

Examples
--------
&gt;&gt;&gt; input =  [0,1,2,3]
&gt;&gt;&gt; labels = [1,1,2,2]
&gt;&gt;&gt; sum(input, labels, index=[1,2])
[1.0, 5.0]
&gt;&gt;&gt; sum(input, labels, index=1)
1
&gt;&gt;&gt; sum(input, labels)
6</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Values of `input` inside the regions defined by `labels`
are summed together.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" depth="1" name="labels" port_type="basic:Integer">
      <docstring>Assign labels to the values of the array. Has to have the same shape as
`input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="index" port_type="basic:List">
      <docstring>A single label number or a sequence of label numbers of
the objects to be measured.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sum" name="sum" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>An array of the sums of values of `input` inside the regions defined
by `labels` with the same shape as `index`. If 'index' is None or scalar,
a scalar is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.uniform_filter" module_name="uniform_filter" namespace="'ndimage'">
    <docstring>Multi-dimensional uniform filter.

Parameters
----------
input : array_like
    Input array to filter.
size : int or sequence of ints, optional
    The sizes of the uniform filter are given for each axis as a
    sequence, or as a single number, in which case the size is
    equal for all axes.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.

Notes
-----
The multi-dimensional filter is implemented as a sequence of
one-dimensional uniform filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="sizeScalar" port_type="basic:Integer">
      <docstring>The sizes of the uniform filter are given for each axis as a
sequence, or as a single number, in which case the size is
equal for all axes.</docstring>
      <defaults>[3]</defaults>
      <alternateSpec arg="size" depth="1" name="sizeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.uniform_filter1d" module_name="uniform_filter1d" namespace="'ndimage'">
    <docstring>Calculate a one-dimensional uniform filter along the given axis.

The lines of the array along the given axis are filtered with a
uniform filter of given size.

Parameters
----------
input : array_like
    Input array to filter.
size : int
    length of uniform filter
axis : int, optional
    The axis of `input` along which to calculate. Default is -1.
output : array, optional
    The `output` parameter passes an array in which to store the
    filter output.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0.0.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input array to filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" name="size" port_type="basic:Integer" show_port="True">
      <docstring>length of uniform filter</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `input` along which to calculate. Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>The `output` parameter passes an array in which to store the
filter output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'. Default
is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default 0.0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.variance" module_name="variance" namespace="'ndimage'">
    <docstring>Calculate the variance of the values of an n-D image array, optionally at
specified sub-regions.

Parameters
----------
input : array_like
    Nd-image data to process.
labels : array_like, optional
    Labels defining sub-regions in `input`.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    `labels` to include in output.  If None (default), all values where
    `labels` is non-zero are used.

Returns
-------
variance : float or ndarray
    Values of variance, for each sub-region if `labels` and `index` are
    specified.

See Also
--------
label, standard_deviation, maximum, minimum, extrema

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.variance(a)
7.609375

Features to process can be specified using `labels` and `index`:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.variance(a, lbl, index=np.arange(1, nlbl+1))
array([ 2.1875,  2.25  ,  9.    ])

If no index is given, all non-zero `labels` are processed:

&gt;&gt;&gt; ndimage.variance(a, lbl)
6.1875</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Nd-image data to process.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labels" name="labels" port_type="basic:List">
      <docstring>Labels defining sub-regions in `input`.
If not None, must be same shape as `input`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="index" name="indexScalar" port_type="basic:Integer">
      <docstring>`labels` to include in output.  If None (default), all values where
`labels` is non-zero are used.</docstring>
      <alternateSpec arg="index" depth="1" name="indexSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="variance" name="variance" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Values of variance, for each sub-region if `labels` and `index` are
specified.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.watershed_ift" module_name="watershed_ift" namespace="'ndimage'">
    <docstring>Apply watershed from markers using image foresting transform algorithm.

Parameters
----------
input : array_like
    Input.
markers : array_like
    Markers are points within each watershed that form the beginning
    of the process.  Negative markers are considered background markers
    which are processed after the other markers.
structure : structure element, optional
    A structuring element defining the connectivity of the object can be
    provided. If None, an element is generated with a squared
    connectivity equal to one.
output : ndarray, optional
    An output array can optionally be provided.  The same shape as input.

Returns
-------
watershed_ift : ndarray
    Output.  Same shape as `input`.

References
----------
.. [1] A.X. Falcao, J. Stolfi and R. de Alencar Lotufo, "The image
       foresting transform: theory, algorithms, and applications",
       Pattern Analysis and Machine Intelligence, vol. 26, pp. 19-29, 2004.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="markers" name="markers" port_type="basic:List" show_port="True">
      <docstring>Markers are points within each watershed that form the beginning
of the process.  Negative markers are considered background markers
which are processed after the other markers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" name="structure">
      <docstring>A structuring element defining the connectivity of the object can be
provided. If None, an element is generated with a squared
connectivity equal to one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An output array can optionally be provided.  The same shape as input.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="watershed_ift" name="watershed_ift" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output.  Same shape as `input`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.white_tophat" module_name="white_tophat" namespace="'ndimage'">
    <docstring>Multi-dimensional white tophat filter.

Parameters
----------
input : array_like
    Input.
size : tuple of ints
    Shape of a flat and full structuring element used for the filter.
    Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of elements of a flat structuring element
    used for the white tophat filter.
structure : array of ints, optional
    Structuring element used for the filter. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'.
    Default is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default is 0.

Returns
-------
output : ndarray
    Result of the filter of `input` with `structure`.

See also
--------
black_tophat</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>Input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="size" depth="1" name="size" port_type="basic:Integer" show_port="True">
      <docstring>Shape of a flat and full structuring element used for the filter.
Optional if `footprint` or `structure` is provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="footprint" depth="1" name="footprint" port_type="basic:Integer">
      <docstring>Positions of elements of a flat structuring element
used for the white tophat filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="structure" depth="1" name="structure" port_type="basic:Integer">
      <docstring>Structuring element used for the filter. `structure`
may be a non-flat structuring element.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output" port_type="basic:List">
      <docstring>An array used for storing the output of the filter may be provided.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>The `mode` parameter determines how the array borders are
handled, where `cval` is the value when mode is equal to
'constant'. Default is 'reflect'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['reflect', 'constant', 'nearest', 'mirror', 'wrap']]</values>
      <defaults>['reflect']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past edges of input if `mode` is 'constant'.
Default is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="origin" name="origin" port_type="basic:Float">
      <docstring>The `origin` parameter controls the placement of the filter.
Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Result of the filter of `input` with `structure`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.ndimage.zoom" module_name="zoom" namespace="'ndimage'">
    <docstring>Zoom an array.

The array is zoomed using spline interpolation of the requested order.

Parameters
----------
input : ndarray
    The input array.
zoom : float or sequence, optional
    The zoom factor along the axes. If a float, `zoom` is the same for each
    axis. If a sequence, `zoom` should contain one value for each axis.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array.
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
mode : str, optional
    Points outside the boundaries of the input are filled according
    to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
    Default is 'constant'.
cval : scalar, optional
    Value used for points outside the boundaries of the input if
    ``mode='constant'``. Default is 0.0
prefilter : bool, optional
    The parameter prefilter determines if the input is pre-filtered with
    `spline_filter` before interpolation (necessary for spline
    interpolation of order &gt; 1).  If False, it is assumed that the input is
    already filtered. Default is True.

Returns
-------
zoom : ndarray or None
    The zoomed input. If `output` is given as a parameter, None is
    returned.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="zoom" name="zoomScalar" port_type="basic:Float">
      <docstring>The zoom factor along the axes. If a float, `zoom` is the same for each
axis. If a sequence, `zoom` should contain one value for each axis.</docstring>
      <alternateSpec arg="zoom" name="zoomSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="output" name="outputScalar">
      <docstring>The array in which to place the output, or the dtype of the returned
array.</docstring>
      <alternateSpec arg="output" name="outputSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Points outside the boundaries of the input are filled according
to the given mode ('constant', 'nearest', 'reflect' or 'wrap').
Default is 'constant'.</docstring>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value used for points outside the boundaries of the input if
``mode='constant'``. Default is 0.0</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="prefilter" name="prefilter" port_type="basic:Boolean">
      <docstring>The parameter prefilter determines if the input is pre-filtered with
`spline_filter` before interpolation (necessary for spline
interpolation of order &gt; 1).  If False, it is assumed that the input is
already filtered. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="zoom" name="zoom" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The zoomed input. If `output` is given as a parameter, None is
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.odr" module_name="odr" namespace="'odr'">
    <docstring>odr(fcn, beta0, y, x, we=None, wd=None, fjacb=None, fjacd=None, extra_args=None, ifixx=None, ifixb=None, job=0, iprint=0, errfile=None, rptfile=None, ndigit=0, taufac=0.0, sstol=-1.0, partol=-1.0, maxit=-1, stpb=None, stpd=None, sclb=None, scld=None, work=None, iwork=None, full_output=0)

Low-level function for ODR.

See Also
--------
ODR
Model
Data
RealData

Notes
-----
This is a function performing the same operation as the `ODR`,
`Model` and `Data` classes together. The parameters of this
function are explained in the class documentation.</docstring>
    <inputPortSpec arg="iwork" name="iwork" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="errfile" name="errfile" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="stpb" name="stpb" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="maxit" name="maxit" port_type="basic:Integer">
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fjacd" name="fjacd" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="fjacb" name="fjacb" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="beta0" name="beta0" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="sstol" name="sstol" port_type="basic:Float">
      <defaults>[-1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rptfile" name="rptfile" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="we" name="we" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="wd" name="wd" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="stpd" name="stpd" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="job" name="job" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="fcn" name="fcn" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="sclb" name="sclb" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ifixb" name="ifixb" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ifixx" name="ifixx" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="scld" name="scld" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="taufac" name="taufac" port_type="basic:Float" show_port="True" />
    <inputPortSpec arg="iprint" name="iprint" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="work" name="work" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="extra_args" name="extra_args" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="y" name="y" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="partol" name="partol" port_type="basic:Float">
      <defaults>[-1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndigit" name="ndigit" port_type="basic:Integer" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.polynomial" module_name="polynomial" namespace="'odr'">
    <docstring>Factory function for a general polynomial model.

Parameters
----------
order : int or sequence
    If an integer, it becomes the order of the polynomial to fit. If
    a sequence of numbers, then these are the explicit powers in the
    polynomial.
    A constant term (power 0) is always included, so don't include 0.
    Thus, polynomial(n) is equivalent to polynomial(range(1, n+1)).

Returns
-------
polynomial : Model instance
    Model instance.</docstring>
    <inputPortSpec arg="order" name="orderScalar" port_type="basic:Integer" show_port="True">
      <docstring>If an integer, it becomes the order of the polynomial to fit. If
a sequence of numbers, then these are the explicit powers in the
polynomial.
A constant term (power 0) is always included, so don't include 0.
Thus, polynomial(n) is equivalent to polynomial(range(1, n+1)).</docstring>
      <alternateSpec arg="order" name="orderSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="polynomial" name="polynomial" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Model instance.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.anderson" module_name="anderson" namespace="'optimize'">
    <docstring>Find a root of a function, using (extended) Anderson mixing.

The Jacobian is formed by for a 'best' solution in the space
spanned by last `M` vectors. As a result, only a MxM matrix
inversions and MxN multiplications are required. [Ey]_

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
alpha : float, optional
    Initial guess for the Jacobian is (-1/alpha).
M : float, optional
    Number of previous vectors to retain. Defaults to 5.
w0 : float, optional
    Regularization parameter for numerical stability.
    Compared to unity, good values of the order of 0.01.
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.

References
----------
.. [Ey] V. Eyert, J. Comp. Phys., 124, 271 (1996).</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Initial guess for the Jacobian is (-1/alpha).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" port_type="basic:Float">
      <docstring>Number of previous vectors to retain. Defaults to 5.</docstring>
      <defaults>[5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w0" name="w0" port_type="basic:Float">
      <docstring>Regularization parameter for numerical stability.
Compared to unity, good values of the order of 0.01.</docstring>
      <defaults>[0.01]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.approx_fprime" module_name="approx_fprime" namespace="'optimize'">
    <docstring>Finite-difference approximation of the gradient of a scalar function.

Parameters
----------
xk : array_like
    The coordinate vector at which to determine the gradient of `f`.
f : callable
    The function of which to determine the gradient (partial derivatives).
    Should take `xk` as first argument, other arguments to `f` can be
    supplied in ``*args``.  Should return a scalar, the value of the
    function at `xk`.
epsilon : array_like
    Increment to `xk` to use for determining the function gradient.
    If a scalar, uses the same finite difference delta for all partial
    derivatives.  If an array, should contain one value per element of
    `xk`.
\*args : args, optional
    Any other arguments that are to be passed to `f`.

Returns
-------
grad : ndarray
    The partial derivatives of `f` to `xk`.

See Also
--------
check_grad : Check correctness of gradient function against approx_fprime.

Notes
-----
The function gradient is determined by the forward finite difference
formula::

             f(xk[i] + epsilon[i]) - f(xk[i])
    f'[i] = ---------------------------------
                        epsilon[i]

The main use of `approx_fprime` is in scalar function optimizers like
`fmin_bfgs`, to determine numerically the Jacobian of a function.

Examples
--------
&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; def func(x, c0, c1):
...     "Coordinate vector `x` should be an array of size two."
...     return c0 * x[0]**2 + c1*x[1]**2

&gt;&gt;&gt; x = np.ones(2)
&gt;&gt;&gt; c0, c1 = (1, 200)
&gt;&gt;&gt; eps = np.sqrt(np.finfo(np.float).eps)
&gt;&gt;&gt; optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)
array([   2.        ,  400.00004198])</docstring>
    <inputPortSpec arg="xk" name="xk" port_type="basic:List" show_port="True">
      <docstring>The coordinate vector at which to determine the gradient of `f`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>The function of which to determine the gradient (partial derivatives).
Should take `xk` as first argument, other arguments to `f` can be
supplied in ``*args``.  Should return a scalar, the value of the
function at `xk`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilon" port_type="basic:List" show_port="True">
      <docstring>Increment to `xk` to use for determining the function gradient.
If a scalar, uses the same finite difference delta for all partial
derivatives.  If an array, should contain one value per element of
`xk`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="\*args" name="\*args" port_type="basic:Variant">
      <docstring>Any other arguments that are to be passed to `f`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="grad" name="grad" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The partial derivatives of `f` to `xk`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.basinhopping" module_name="basinhopping" namespace="'optimize'">
    <docstring>Find the global minimum of a function using the basin-hopping algorithm

Parameters
----------
func : callable ``f(x, *args)``
    Function to be optimized.  ``args`` can be passed as an optional item
    in the dict ``minimizer_kwargs``
x0 : ndarray
    Initial guess.
niter : integer, optional
    The number of basin hopping iterations
T : float, optional
    The "temperature" parameter for the accept or reject criterion.  Higher
    "temperatures" mean that larger jumps in function value will be
    accepted.  For best results ``T`` should be comparable to the
    separation
    (in function value) between local minima.
stepsize : float, optional
    initial step size for use in the random displacement.
minimizer_kwargs : dict, optional
    Extra keyword arguments to be passed to the minimizer
    ``scipy.optimize.minimize()`` Some important options could be:

        method : str
            The minimization method (e.g. ``"L-BFGS-B"``)
        args : tuple
            Extra arguments passed to the objective function (``func``) and
            its derivatives (Jacobian, Hessian).

take_step : callable ``take_step(x)``, optional
    Replace the default step taking routine with this routine.  The default
    step taking routine is a random displacement of the coordinates, but
    other step taking algorithms may be better for some systems.
    ``take_step`` can optionally have the attribute ``take_step.stepsize``.
    If this attribute exists, then ``basinhopping`` will adjust
    ``take_step.stepsize`` in order to try to optimize the global minimum
    search.
accept_test : callable, ``accept_test(f_new=f_new, x_new=x_new, f_old=fold, x_old=x_old)``, optional
    Define a test which will be used to judge whether or not to accept the
    step.  This will be used in addition to the Metropolis test based on
    "temperature" ``T``.  The acceptable return values are True,
    False, or ``"force accept"``.  If the latter, then this will
    override any other tests in order to accept the step.  This can be
    used, for example, to forcefully escape from a local minimum that
    ``basinhopping`` is trapped in.
callback : callable, ``callback(x, f, accept)``, optional
    A callback function which will be called for all minima found.  ``x``
    and ``f`` are the coordinates and function value of the trial minimum,
    and ``accept`` is whether or not that minimum was accepted.  This can be
    used, for example, to save the lowest N minima found.  Also,
    ``callback`` can be used to specify a user defined stop criterion by
    optionally returning True to stop the ``basinhopping`` routine.
interval : integer, optional
    interval for how often to update the ``stepsize``
disp : bool, optional
    Set to True to print status messages
niter_success : integer, optional
    Stop the run if the global minimum candidate remains the same for this
    number of iterations.


Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.  Important
    attributes are: ``x`` the solution array, ``fun`` the value of the
    function at the solution, and ``message`` which describes the cause of
    the termination. See `OptimizeResult` for a description of other attributes.

See Also
--------
minimize :
    The local minimization function called once for each basinhopping step.
    ``minimizer_kwargs`` is passed to this routine.

Notes
-----
Basin-hopping is a stochastic algorithm which attempts to find the global
minimum of a smooth scalar function of one or more variables [1]_ [2]_ [3]_
[4]_.  The algorithm in its current form was described by David Wales and
Jonathan Doye [2]_ http://www-wales.ch.cam.ac.uk/.

The algorithm is iterative with each cycle composed of the following
features

1) random perturbation of the coordinates

2) local minimization

3) accept or reject the new coordinates based on the minimized function
   value

The acceptance test used here is the Metropolis criterion of standard Monte
Carlo algorithms, although there are many other possibilities [3]_.

This global minimization method has been shown to be extremely efficient
for a wide variety of problems in physics and chemistry.  It is
particularly useful when the function has many minima separated by large
barriers. See the Cambridge Cluster Database
http://www-wales.ch.cam.ac.uk/CCD.html for databases of molecular systems
that have been optimized primarily using basin-hopping.  This database
includes minimization problems exceeding 300 degrees of freedom.

See the free software program GMIN (http://www-wales.ch.cam.ac.uk/GMIN) for
a Fortran implementation of basin-hopping.  This implementation has many
different variations of the procedure described above, including more
advanced step taking algorithms and alternate acceptance criterion.

For stochastic global optimization there is no way to determine if the true
global minimum has actually been found. Instead, as a consistency check,
the algorithm can be run from a number of different random starting points
to ensure the lowest minimum found in each example has converged to the
global minimum.  For this reason ``basinhopping`` will by default simply
run for the number of iterations ``niter`` and return the lowest minimum
found.  It is left to the user to ensure that this is in fact the global
minimum.

Choosing ``stepsize``:  This is a crucial parameter in ``basinhopping`` and
depends on the problem being solved.  Ideally it should be comparable to
the typical separation between local minima of the function being
optimized.  ``basinhopping`` will, by default, adjust ``stepsize`` to find
an optimal value, but this may take many iterations.  You will get quicker
results if you set a sensible value for ``stepsize``.

Choosing ``T``: The parameter ``T`` is the temperature used in the
metropolis criterion.  Basinhopping steps are accepted with probability
``1`` if ``func(xnew) &lt; func(xold)``, or otherwise with probability::

    exp( -(func(xnew) - func(xold)) / T )

So, for best results, ``T`` should to be comparable to the typical
difference in function values between local minima.

.. versionadded:: 0.12.0

References
----------
.. [1] Wales, David J. 2003, Energy Landscapes, Cambridge University Press,
    Cambridge, UK.
.. [2] Wales, D J, and Doye J P K, Global Optimization by Basin-Hopping and
    the Lowest Energy Structures of Lennard-Jones Clusters Containing up to
    110 Atoms.  Journal of Physical Chemistry A, 1997, 101, 5111.
.. [3] Li, Z. and Scheraga, H. A., Monte Carlo-minimization approach to the
    multiple-minima problem in protein folding, Proc. Natl. Acad. Sci. USA,
    1987, 84, 6611.
.. [4] Wales, D. J. and Scheraga, H. A., Global optimization of clusters,
    crystals, and biomolecules, Science, 1999, 285, 1368.

Examples
--------
The following example is a one-dimensional minimization problem,  with many
local minima superimposed on a parabola.

&gt;&gt;&gt; from scipy.optimize import basinhopping
&gt;&gt;&gt; func = lambda x: np.cos(14.5 * x - 0.3) + (x + 0.2) * x
&gt;&gt;&gt; x0=[1.]

Basinhopping, internally, uses a local minimization algorithm.  We will use
the parameter ``minimizer_kwargs`` to tell basinhopping which algorithm to
use and how to set up that minimizer.  This parameter will be passed to
``scipy.optimize.minimize()``.

&gt;&gt;&gt; minimizer_kwargs = {"method": "BFGS"}
&gt;&gt;&gt; ret = basinhopping(func, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200)
&gt;&gt;&gt; print("global minimum: x = %.4f, f(x0) = %.4f" % (ret.x, ret.fun))
global minimum: x = -0.1951, f(x0) = -1.0009

Next consider a two-dimensional minimization problem. Also, this time we
will use gradient information to significantly speed up the search.

&gt;&gt;&gt; def func2d(x):
...     f = np.cos(14.5 * x[0] - 0.3) + (x[1] + 0.2) * x[1] + (x[0] +
...                                                            0.2) * x[0]
...     df = np.zeros(2)
...     df[0] = -14.5 * np.sin(14.5 * x[0] - 0.3) + 2. * x[0] + 0.2
...     df[1] = 2. * x[1] + 0.2
...     return f, df

We'll also use a different local minimization algorithm.  Also we must tell
the minimizer that our function returns both energy and gradient (jacobian)

&gt;&gt;&gt; minimizer_kwargs = {"method":"L-BFGS-B", "jac":True}
&gt;&gt;&gt; x0 = [1.0, 1.0]
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200)
&gt;&gt;&gt; print("global minimum: x = [%.4f, %.4f], f(x0) = %.4f" % (ret.x[0],
...                                                           ret.x[1],
...                                                           ret.fun))
global minimum: x = [-0.1951, -0.1000], f(x0) = -1.0109


Here is an example using a custom step taking routine.  Imagine you want
the first coordinate to take larger steps then the rest of the coordinates.
This can be implemented like so:

&gt;&gt;&gt; class MyTakeStep(object):
...    def __init__(self, stepsize=0.5):
...        self.stepsize = stepsize
...    def __call__(self, x):
...        s = self.stepsize
...        x[0] += np.random.uniform(-2.*s, 2.*s)
...        x[1:] += np.random.uniform(-s, s, x[1:].shape)
...        return x

Since ``MyTakeStep.stepsize`` exists basinhopping will adjust the magnitude
of ``stepsize`` to optimize the search.  We'll use the same 2-D function as
before

&gt;&gt;&gt; mytakestep = MyTakeStep()
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200, take_step=mytakestep)
&gt;&gt;&gt; print("global minimum: x = [%.4f, %.4f], f(x0) = %.4f" % (ret.x[0],
...                                                           ret.x[1],
...                                                           ret.fun))
global minimum: x = [-0.1951, -0.1000], f(x0) = -1.0109


Now let's do an example using a custom callback function which prints the
value of every minimum found

&gt;&gt;&gt; def print_fun(x, f, accepted):
...         print("at minimum %.4f accepted %d" % (f, int(accepted)))

We'll run it for only 10 basinhopping steps this time.

&gt;&gt;&gt; np.random.seed(1)
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=10, callback=print_fun)
at minimum 0.4159 accepted 1
at minimum -0.9073 accepted 1
at minimum -0.1021 accepted 1
at minimum -0.1021 accepted 1
at minimum 0.9102 accepted 1
at minimum 0.9102 accepted 1
at minimum 2.2945 accepted 0
at minimum -0.1021 accepted 1
at minimum -1.0109 accepted 1
at minimum -1.0109 accepted 1


The minimum at -1.0109 is actually the global minimum, found already on the
8th iteration.

Now let's implement bounds on the problem using a custom ``accept_test``:

&gt;&gt;&gt; class MyBounds(object):
...     def __init__(self, xmax=[1.1,1.1], xmin=[-1.1,-1.1] ):
...         self.xmax = np.array(xmax)
...         self.xmin = np.array(xmin)
...     def __call__(self, **kwargs):
...         x = kwargs["x_new"]
...         tmax = bool(np.all(x &lt;= self.xmax))
...         tmin = bool(np.all(x &gt;= self.xmin))
...         return tmax and tmin

&gt;&gt;&gt; mybounds = MyBounds()
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=10, accept_test=mybounds)</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Function to be optimized.  ``args`` can be passed as an optional item
in the dict ``minimizer_kwargs``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="niter" name="niter" port_type="basic:Integer">
      <docstring>The number of basin hopping iterations</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:Float">
      <docstring>The "temperature" parameter for the accept or reject criterion.  Higher
"temperatures" mean that larger jumps in function value will be
accepted.  For best results ``T`` should be comparable to the
separation
(in function value) between local minima.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="stepsize" name="stepsize" port_type="basic:Float">
      <docstring>initial step size for use in the random displacement.</docstring>
      <defaults>[0.5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="minimizer_kwargs" name="minimizer_kwargs" port_type="basic:Dictionary">
      <docstring>Extra keyword arguments to be passed to the minimizer
``scipy.optimize.minimize()`` Some important options could be:

    method : str
        The minimization method (e.g. ``"L-BFGS-B"``)
    args : tuple
        Extra arguments passed to the objective function (``func``) and
        its derivatives (Jacobian, Hessian).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="take_step" name="take_step" port_type="basic:Variant">
      <docstring>Replace the default step taking routine with this routine.  The default
step taking routine is a random displacement of the coordinates, but
other step taking algorithms may be better for some systems.
``take_step`` can optionally have the attribute ``take_step.stepsize``.
If this attribute exists, then ``basinhopping`` will adjust
``take_step.stepsize`` in order to try to optimize the global minimum
search.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="accept_test" name="accept_test" port_type="basic:Variant">
      <docstring>Define a test which will be used to judge whether or not to accept the
step.  This will be used in addition to the Metropolis test based on
"temperature" ``T``.  The acceptable return values are True,
False, or ``"force accept"``.  If the latter, then this will
override any other tests in order to accept the step.  This can be
used, for example, to forcefully escape from a local minimum that
``basinhopping`` is trapped in.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>A callback function which will be called for all minima found.  ``x``
and ``f`` are the coordinates and function value of the trial minimum,
and ``accept`` is whether or not that minimum was accepted.  This can be
used, for example, to save the lowest N minima found.  Also,
``callback`` can be used to specify a user defined stop criterion by
optionally returning True to stop the ``basinhopping`` routine.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="interval" name="interval" port_type="basic:Integer">
      <docstring>interval for how often to update the ``stepsize``</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Set to True to print status messages</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="niter_success" name="niter_success" port_type="basic:Integer">
      <docstring>Stop the run if the global minimum candidate remains the same for this
number of iterations.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The optimization result represented as a ``OptimizeResult`` object.  Important
attributes are: ``x`` the solution array, ``fun`` the value of the
function at the solution, and ``message`` which describes the cause of
the termination. See `OptimizeResult` for a description of other attributes.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.bisect" module_name="bisect" namespace="'optimize'" output_type="list">
    <docstring>Find root of a function within an interval.

Basic bisection routine to find a zero of the function `f` between the
arguments `a` and `b`. `f(a)` and `f(b)` cannot have the same signs.
Slow but sure.

Parameters
----------
f : function
    Python function returning a number.  `f` must be continuous, and
    f(a) and f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within `xtol` of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in `maxiter` iterations, an error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where x is the root, and r is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.  In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, bisect, newton
fixed_point : scalar fixed-point finder
fsolve : n-dimensional root-finding</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Python function returning a number.  `f` must be continuous, and
f(a) and f(b) must have opposite signs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>One end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True">
      <docstring>The other end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within `xtol` of the
value return. Should be &gt;= 0.  The routine modifies this to take into
account the relative precision of doubles.</docstring>
      <defaults>[1e-12]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within `rtol` times
the value returned of the value returned. Should be &gt;= 0. Defaults to
``np.finfo(float).eps * 2``.</docstring>
      <defaults>[4.440892098500626e-16]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>if convergence is not achieved in `maxiter` iterations, an error is
raised.  Must be &gt;= 0.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>containing extra arguments for the function `f`.
`f` is called by ``apply(f, (x)+args)``.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Boolean">
      <docstring>If `full_output` is False, the root is returned.  If `full_output` is
True, the return value is ``(x, r)``, where x is the root, and r is
a `RootResults` object.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>If True, raise RuntimeError if the algorithm didn't converge.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x0" name="x0" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Zero of `f` between `a` and `b`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r" name="r" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Object containing information about the convergence.  In particular,
``r.converged`` is True if the routine converged.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.bracket" module_name="bracket" namespace="'optimize'" output_type="list">
    <docstring>Bracket the minimum of the function.

Given a function and distinct initial points, search in the
downhill direction (as defined by the initital points) and return
new points xa, xb, xc that bracket the minimum of the function
f(xa) &gt; f(xb) &lt; f(xc). It doesn't always mean that obtained
solution will satisfy xa&lt;=x&lt;=xb

Parameters
----------
func : callable f(x,*args)
    Objective function to minimize.
xa, xb : float, optional
    Bracketing interval. Defaults `xa` to 0.0, and `xb` to 1.0.
args : tuple, optional
    Additional arguments (if present), passed to `func`.
grow_limit : float, optional
    Maximum grow limit.  Defaults to 110.0
maxiter : int, optional
    Maximum number of iterations to perform. Defaults to 1000.

Returns
-------
xa, xb, xc : float
    Bracket.
fa, fb, fc : float
    Objective function values in bracket.
funcalls : int
    Number of function evaluations made.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to minimize.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xa" name="xa" port_type="basic:Float">
      <docstring>Bracketing interval. Defaults `xa` to 0.0, and `xb` to 1.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xb" name="xb" port_type="basic:Float">
      <docstring>Bracketing interval. Defaults `xa` to 0.0, and `xb` to 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Additional arguments (if present), passed to `func`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="grow_limit" name="grow_limit" port_type="basic:Float">
      <docstring>Maximum grow limit.  Defaults to 110.0</docstring>
      <defaults>[110.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to perform. Defaults to 1000.</docstring>
      <defaults>[1000]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="xa" name="xa" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Bracket.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xb" name="xb" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Bracket.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xc" name="xc" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Bracket.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fa" name="fa" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Objective function values in bracket.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fb" name="fb" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Objective function values in bracket.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fc" name="fc" port_type="basic:Float" show_port="True" sort_key="5">
      <docstring>Objective function values in bracket.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="funcalls" name="funcalls" port_type="basic:Integer" show_port="True" sort_key="6">
      <docstring>Number of function evaluations made.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.brent" module_name="brent" namespace="'optimize'" output_type="list">
    <docstring>Given a function of one-variable and a possible bracketing interval,
return the minimum of the function isolated to a fractional precision of
tol.

Parameters
----------
func : callable f(x,*args)
    Objective function.
args : tuple, optional
    Additional arguments (if present).
brack : tuple, optional
    Triple (a,b,c) where (a&lt;b&lt;c) and func(b) &lt;
    func(a),func(c).  If bracket consists of two numbers (a,c)
    then they are assumed to be a starting interval for a
    downhill bracket search (see `bracket`); it doesn't always
    mean that the obtained solution will satisfy a&lt;=x&lt;=c.
tol : float, optional
    Stop if between iteration change is less than `tol`.
full_output : bool, optional
    If True, return all output args (xmin, fval, iter,
    funcalls).
maxiter : int, optional
    Maximum number of iterations in solution.

Returns
-------
xmin : ndarray
    Optimum point.
fval : float
    Optimum value.
iter : int
    Number of iterations.
funcalls : int
    Number of objective function evaluations made.

See also
--------
minimize_scalar: Interface to minimization algorithms for scalar
    univariate functions. See the 'Brent' `method` in particular.

Notes
-----
Uses inverse parabolic interpolation when possible to speed up
convergence of golden section method.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Objective function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Additional arguments (if present).</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="brack" name="brack" port_type="basic:List">
      <docstring>Triple (a,b,c) where (a&lt;b&lt;c) and func(b) &lt;
func(a),func(c).  If bracket consists of two numbers (a,c)
then they are assumed to be a starting interval for a
downhill bracket search (see `bracket`); it doesn't always
mean that the obtained solution will satisfy a&lt;=x&lt;=c.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Stop if between iteration change is less than `tol`.</docstring>
      <defaults>[1.48e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return all output args (xmin, fval, iter,
funcalls).</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations in solution.</docstring>
      <defaults>[500]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="xmin" name="xmin" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Optimum point.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fval" name="fval" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Optimum value.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="iter" name="iter" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Number of iterations.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="funcalls" name="funcalls" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>Number of objective function evaluations made.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.brenth" module_name="brenth" namespace="'optimize'" output_type="list">
    <docstring>Find root of f in [a,b].

A variation on the classic Brent routine to find a zero of the function f
between the arguments a and b that uses hyperbolic extrapolation instead of
inverse quadratic extrapolation. There was a paper back in the 1980's ...
f(a) and f(b) cannot have the same signs. Generally on a par with the
brent routine, but not as heavily tested.  It is a safe version of the
secant method that uses hyperbolic extrapolation. The version here is by
Chuck Harris.

Parameters
----------
f : function
    Python function returning a number.  f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within xtol of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in maxiter iterations, an error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a RootResults object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.  In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
fmin, fmin_powell, fmin_cg,
       fmin_bfgs, fmin_ncg : multivariate local optimizers

leastsq : nonlinear least squares minimizer

fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers

basinhopping, differential_evolution, brute : global optimizers

fminbound, brent, golden, bracket : local scalar minimizers

fsolve : n-dimensional root-finding

brentq, brenth, ridder, bisect, newton : one-dimensional root-finding

fixed_point : scalar fixed-point finder</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>One end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True">
      <docstring>The other end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within xtol of the
value return. Should be &gt;= 0.  The routine modifies this to take into
account the relative precision of doubles.</docstring>
      <defaults>[1e-12]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within `rtol` times
the value returned of the value returned. Should be &gt;= 0. Defaults to
``np.finfo(float).eps * 2``.</docstring>
      <defaults>[4.440892098500626e-16]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>if convergence is not achieved in maxiter iterations, an error is
raised.  Must be &gt;= 0.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>containing extra arguments for the function `f`.
`f` is called by ``apply(f, (x)+args)``.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Boolean">
      <docstring>If `full_output` is False, the root is returned.  If `full_output` is
True, the return value is ``(x, r)``, where `x` is the root, and `r` is
a RootResults object.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>If True, raise RuntimeError if the algorithm didn't converge.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x0" name="x0" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Zero of `f` between `a` and `b`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r" name="r" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Object containing information about the convergence.  In particular,
``r.converged`` is True if the routine converged.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.brentq" module_name="brentq" namespace="'optimize'" output_type="list">
    <docstring>Find a root of a function in given interval.

Return float, a zero of `f` between `a` and `b`.  `f` must be a continuous
function, and [a,b] must be a sign changing interval.

Description:
Uses the classic Brent (1973) method to find a zero of the function `f` on
the sign changing interval [a , b].  Generally considered the best of the
rootfinding routines here.  It is a safe version of the secant method that
uses inverse quadratic extrapolation.  Brent's method combines root
bracketing, interval bisection, and inverse quadratic interpolation.  It is
sometimes known as the van Wijngaarden-Dekker-Brent method.  Brent (1973)
claims convergence is guaranteed for functions computable within [a,b].

[Brent1973]_ provides the classic description of the algorithm.  Another
description can be found in a recent edition of Numerical Recipes, including
[PressEtal1992]_.  Another description is at
http://mathworld.wolfram.com/BrentsMethod.html.  It should be easy to
understand the algorithm just by reading our code.  Our code diverges a bit
from standard presentations: we choose a different formula for the
extrapolation step.

Parameters
----------
f : function
    Python function returning a number.  f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within xtol of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in maxiter iterations, an error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a RootResults object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.  In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
multivariate local optimizers
  `fmin`, `fmin_powell`, `fmin_cg`, `fmin_bfgs`, `fmin_ncg`
nonlinear least squares minimizer
  `leastsq`
constrained multivariate optimizers
  `fmin_l_bfgs_b`, `fmin_tnc`, `fmin_cobyla`
global optimizers
  `basinhopping`, `brute`, `differential_evolution`
local scalar minimizers
  `fminbound`, `brent`, `golden`, `bracket`
n-dimensional root-finding
  `fsolve`
one-dimensional root-finding
  `brentq`, `brenth`, `ridder`, `bisect`, `newton`
scalar fixed-point finder
  `fixed_point`

Notes
-----
`f` must be continuous.  f(a) and f(b) must have opposite signs.


References
----------
.. [Brent1973]
   Brent, R. P.,
   *Algorithms for Minimization Without Derivatives*.
   Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.

.. [PressEtal1992]
   Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.
   *Numerical Recipes in FORTRAN: The Art of Scientific Computing*, 2nd ed.
   Cambridge, England: Cambridge University Press, pp. 352-355, 1992.
   Section 9.3:  "Van Wijngaarden-Dekker-Brent Method."</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>One end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True">
      <docstring>The other end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within xtol of the
value return. Should be &gt;= 0.  The routine modifies this to take into
account the relative precision of doubles.</docstring>
      <defaults>[1e-12]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within `rtol` times
the value returned of the value returned. Should be &gt;= 0. Defaults to
``np.finfo(float).eps * 2``.</docstring>
      <defaults>[4.440892098500626e-16]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>if convergence is not achieved in maxiter iterations, an error is
raised.  Must be &gt;= 0.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>containing extra arguments for the function `f`.
`f` is called by ``apply(f, (x)+args)``.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Boolean">
      <docstring>If `full_output` is False, the root is returned.  If `full_output` is
True, the return value is ``(x, r)``, where `x` is the root, and `r` is
a RootResults object.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>If True, raise RuntimeError if the algorithm didn't converge.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x0" name="x0" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Zero of `f` between `a` and `b`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r" name="r" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Object containing information about the convergence.  In particular,
``r.converged`` is True if the routine converged.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.broyden1" module_name="broyden1" namespace="'optimize'">
    <docstring>Find a root of a function, using Broyden's first Jacobian approximation.

This method is also known as \"Broyden's good method\".

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
alpha : float, optional
    Initial guess for the Jacobian is ``(-1/alpha)``.
reduction_method : str or tuple, optional
    Method used in ensuring that the rank of the Broyden matrix
    stays low. Can either be a string giving the name of the method,
    or a tuple of the form ``(method, param1, param2, ...)``
    that gives the name of the method and values for additional parameters.

    Methods available:

        - ``restart``: drop all matrix columns. Has no extra parameters.
        - ``simple``: drop oldest matrix column. Has no extra parameters.
        - ``svd``: keep only the most significant SVD components.
          Takes an extra parameter, ``to_retain``, which determines the
          number of SVD components to retain when rank reduction is done.
          Default is ``max_rank - 2``.

max_rank : int, optional
    Maximum rank for the Broyden matrix.
    Default is infinity (ie., no rank reduction).
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.

Notes
-----
This algorithm implements the inverse Jacobian Quasi-Newton update

.. math:: H_+ = H + (dx - H df) dx^\dagger H / ( dx^\dagger H df)

which corresponds to Broyden's first Jacobian update

.. math:: J_+ = J + (df - J dx) dx^\dagger / dx^\dagger dx


References
----------
.. [1] B.A. van der Rotten, PhD thesis,
   \"A limited memory Broyden method to solve high-dimensional
   systems of nonlinear equations\". Mathematisch Instituut,
   Universiteit Leiden, The Netherlands (2003).

   http://www.math.leidenuniv.nl/scripties/Rotten.pdf</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Initial guess for the Jacobian is ``(-1/alpha)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="reduction_method" name="reduction_methodScalar">
      <docstring>Method used in ensuring that the rank of the Broyden matrix
stays low. Can either be a string giving the name of the method,
or a tuple of the form ``(method, param1, param2, ...)``
that gives the name of the method and values for additional parameters.

Methods available:

    - ``restart``: drop all matrix columns. Has no extra parameters.
    - ``simple``: drop oldest matrix column. Has no extra parameters.
    - ``svd``: keep only the most significant SVD components.
      Takes an extra parameter, ``to_retain``, which determines the
      number of SVD components to retain when rank reduction is done.
      Default is ``max_rank - 2``.
</docstring>
      <defaults>['restart']</defaults>
      <alternateSpec arg="reduction_method" name="reduction_methodSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="max_rank" name="max_rank" port_type="basic:Integer">
      <docstring>Maximum rank for the Broyden matrix.
Default is infinity (ie., no rank reduction).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.broyden2" module_name="broyden2" namespace="'optimize'">
    <docstring>Find a root of a function, using Broyden's second Jacobian approximation.

This method is also known as "Broyden's bad method".

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
alpha : float, optional
    Initial guess for the Jacobian is ``(-1/alpha)``.
reduction_method : str or tuple, optional
    Method used in ensuring that the rank of the Broyden matrix
    stays low. Can either be a string giving the name of the method,
    or a tuple of the form ``(method, param1, param2, ...)``
    that gives the name of the method and values for additional parameters.

    Methods available:

        - ``restart``: drop all matrix columns. Has no extra parameters.
        - ``simple``: drop oldest matrix column. Has no extra parameters.
        - ``svd``: keep only the most significant SVD components.
          Takes an extra parameter, ``to_retain``, which determines the
          number of SVD components to retain when rank reduction is done.
          Default is ``max_rank - 2``.

max_rank : int, optional
    Maximum rank for the Broyden matrix.
    Default is infinity (ie., no rank reduction).
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.

Notes
-----
This algorithm implements the inverse Jacobian Quasi-Newton update

.. math:: H_+ = H + (dx - H df) df^\dagger / ( df^\dagger df)

corresponding to Broyden's second method.

References
----------
.. [1] B.A. van der Rotten, PhD thesis,
   "A limited memory Broyden method to solve high-dimensional
   systems of nonlinear equations". Mathematisch Instituut,
   Universiteit Leiden, The Netherlands (2003).

   http://www.math.leidenuniv.nl/scripties/Rotten.pdf</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Initial guess for the Jacobian is ``(-1/alpha)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="reduction_method" name="reduction_methodScalar">
      <docstring>Method used in ensuring that the rank of the Broyden matrix
stays low. Can either be a string giving the name of the method,
or a tuple of the form ``(method, param1, param2, ...)``
that gives the name of the method and values for additional parameters.

Methods available:

    - ``restart``: drop all matrix columns. Has no extra parameters.
    - ``simple``: drop oldest matrix column. Has no extra parameters.
    - ``svd``: keep only the most significant SVD components.
      Takes an extra parameter, ``to_retain``, which determines the
      number of SVD components to retain when rank reduction is done.
      Default is ``max_rank - 2``.
</docstring>
      <defaults>['restart']</defaults>
      <alternateSpec arg="reduction_method" name="reduction_methodSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="max_rank" name="max_rank" port_type="basic:Integer">
      <docstring>Maximum rank for the Broyden matrix.
Default is infinity (ie., no rank reduction).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.brute" module_name="brute" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function over a given range by brute force.

Uses the "brute force" method, i.e. computes the function's value
at each point of a multidimensional grid of points, to find the global
minimum of the function.

The function is evaluated everywhere in the range with the datatype of the
first call to the function, as enforced by the ``vectorize`` NumPy
function.  The value and type of the function evaluation returned when
``full_output=True`` are affected in addition by the ``finish`` argument
(see Notes).

Parameters
----------
func : callable
    The objective function to be minimized. Must be in the
    form ``f(x, *args)``, where ``x`` is the argument in
    the form of a 1-D array and ``args`` is a tuple of any
    additional fixed parameters needed to completely specify
    the function.
ranges : tuple
    Each component of the `ranges` tuple must be either a
    "slice object" or a range tuple of the form ``(low, high)``.
    The program uses these to create the grid of points on which
    the objective function will be computed. See `Note 2` for
    more detail.
args : tuple, optional
    Any additional fixed parameters needed to completely specify
    the function.
Ns : int, optional
    Number of grid points along the axes, if not otherwise
    specified. See `Note2`.
full_output : bool, optional
    If True, return the evaluation grid and the objective function's
    values on it.
finish : callable, optional
    An optimization function that is called with the result of brute force
    minimization as initial guess.  `finish` should take `func` and
    the initial guess as positional arguments, and take `args` as
    keyword arguments.  It may additionally take `full_output`
    and/or `disp` as keyword arguments.  Use None if no "polishing"
    function is to be used. See Notes for more details.
disp : bool, optional
    Set to True to print convergence messages.

Returns
-------
x0 : ndarray
    A 1-D array containing the coordinates of a point at which the
    objective function had its minimum value. (See `Note 1` for
    which point is returned.)
fval : float
    Function value at the point `x0`. (Returned when `full_output` is
    True.)
grid : tuple
    Representation of the evaluation grid.  It has the same
    length as `x0`. (Returned when `full_output` is True.)
Jout : ndarray
    Function values at each point of the evaluation
    grid, `i.e.`, ``Jout = func(*grid)``. (Returned
    when `full_output` is True.)

See Also
--------
basinhopping, differential_evolution

Notes
-----
*Note 1*: The program finds the gridpoint at which the lowest value
of the objective function occurs.  If `finish` is None, that is the
point returned.  When the global minimum occurs within (or not very far
outside) the grid's boundaries, and the grid is fine enough, that
point will be in the neighborhood of the gobal minimum.

However, users often employ some other optimization program to
"polish" the gridpoint values, `i.e.`, to seek a more precise
(local) minimum near `brute's` best gridpoint.
The `brute` function's `finish` option provides a convenient way to do
that.  Any polishing program used must take `brute's` output as its
initial guess as a positional argument, and take `brute's` input values
for `args` as keyword arguments, otherwise an error will be raised.
It may additionally take `full_output` and/or `disp` as keyword arguments.

`brute` assumes that the `finish` function returns either an
`OptimizeResult` object or a tuple in the form:
``(xmin, Jmin, ... , statuscode)``, where ``xmin`` is the minimizing
value of the argument, ``Jmin`` is the minimum value of the objective
function, "..." may be some other returned values (which are not used
by `brute`), and ``statuscode`` is the status code of the `finish` program.

Note that when `finish` is not None, the values returned are those
of the `finish` program, *not* the gridpoint ones.  Consequently,
while `brute` confines its search to the input grid points,
the `finish` program's results usually will not coincide with any
gridpoint, and may fall outside the grid's boundary.

*Note 2*: The grid of points is a `numpy.mgrid` object.
For `brute` the `ranges` and `Ns` inputs have the following effect.
Each component of the `ranges` tuple can be either a slice object or a
two-tuple giving a range of values, such as (0, 5).  If the component is a
slice object, `brute` uses it directly.  If the component is a two-tuple
range, `brute` internally converts it to a slice object that interpolates
`Ns` points from its low-value to its high-value, inclusive.

Examples
--------
We illustrate the use of `brute` to seek the global minimum of a function
of two variables that is given as the sum of a positive-definite
quadratic and two deep "Gaussian-shaped" craters.  Specifically, define
the objective function `f` as the sum of three other functions,
``f = f1 + f2 + f3``.  We suppose each of these has a signature
``(z, *params)``, where ``z = (x, y)``,  and ``params`` and the functions
are as defined below.

&gt;&gt;&gt; params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)
&gt;&gt;&gt; def f1(z, *params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)

&gt;&gt;&gt; def f2(z, *params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale))

&gt;&gt;&gt; def f3(z, *params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale))

&gt;&gt;&gt; def f(z, *params):
...     return f1(z, *params) + f2(z, *params) + f3(z, *params)

Thus, the objective function may have local minima near the minimum
of each of the three functions of which it is composed.  To
use `fmin` to polish its gridpoint result, we may then continue as
follows:

&gt;&gt;&gt; rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))
&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; resbrute = optimize.brute(f, rranges, args=params, full_output=True,
...                           finish=optimize.fmin)
&gt;&gt;&gt; resbrute[0]  # global minimum
array([-1.05665192,  1.80834843])
&gt;&gt;&gt; resbrute[1]  # function value at global minimum
-3.4085818767

Note that if `finish` had been set to None, we would have gotten the
gridpoint [-1.0 1.75] where the rounded function value is -2.892.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>The objective function to be minimized. Must be in the
form ``f(x, *args)``, where ``x`` is the argument in
the form of a 1-D array and ``args`` is a tuple of any
additional fixed parameters needed to completely specify
the function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ranges" name="ranges" port_type="basic:List" show_port="True">
      <docstring>Each component of the `ranges` tuple must be either a
"slice object" or a range tuple of the form ``(low, high)``.
The program uses these to create the grid of points on which
the objective function will be computed. See `Note 2` for
more detail.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Any additional fixed parameters needed to completely specify
the function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Ns" name="Ns" port_type="basic:Integer">
      <docstring>Number of grid points along the axes, if not otherwise
specified. See `Note2`.</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return the evaluation grid and the objective function's
values on it.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="finish" name="finish" port_type="basic:Variant">
      <docstring>An optimization function that is called with the result of brute force
minimization as initial guess.  `finish` should take `func` and
the initial guess as positional arguments, and take `args` as
keyword arguments.  It may additionally take `full_output`
and/or `disp` as keyword arguments.  Use None if no "polishing"
function is to be used. See Notes for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Set to True to print convergence messages.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 1-D array containing the coordinates of a point at which the
objective function had its minimum value. (See `Note 1` for
which point is returned.)</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fval" name="fval" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Function value at the point `x0`. (Returned when `full_output` is
True.)</docstring>
    </outputPortSpec>
    <outputPortSpec arg="grid" name="grid" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Representation of the evaluation grid.  It has the same
length as `x0`. (Returned when `full_output` is True.)</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Jout" name="Jout" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Function values at each point of the evaluation
grid, `i.e.`, ``Jout = func(*grid)``. (Returned
when `full_output` is True.)</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.check_grad" module_name="check_grad" namespace="'optimize'">
    <docstring>Check the correctness of a gradient function by comparing it against a
(forward) finite-difference approximation of the gradient.

Parameters
----------
func : callable ``func(x0, *args)``
    Function whose derivative is to be checked.
grad : callable ``grad(x0, *args)``
    Gradient of `func`.
x0 : ndarray
    Points to check `grad` against forward difference approximation of grad
    using `func`.
args : \*args, optional
    Extra arguments passed to `func` and `grad`.
epsilon : float, optional
    Step size used for the finite difference approximation. It defaults to
    ``sqrt(numpy.finfo(float).eps)``, which is approximately 1.49e-08.

Returns
-------
err : float
    The square root of the sum of squares (i.e. the 2-norm) of the
    difference between ``grad(x0, *args)`` and the finite difference
    approximation of `grad` using func at the points `x0`.

See Also
--------
approx_fprime

Examples
--------
&gt;&gt;&gt; def func(x):
...     return x[0]**2 - 0.5 * x[1]**3
&gt;&gt;&gt; def grad(x):
...     return [2 * x[0], -1.5 * x[1]**2]
&gt;&gt;&gt; from scipy.optimize import check_grad
&gt;&gt;&gt; check_grad(func, grad, [1.5, -1.5])
2.9802322387695312e-08</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Function whose derivative is to be checked.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="grad" name="grad" port_type="basic:Variant" show_port="True">
      <docstring>Gradient of `func`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Points to check `grad` against forward difference approximation of grad
using `func`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:Variant">
      <docstring>Extra arguments passed to `func` and `grad`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilon" port_type="basic:Float">
      <docstring>Step size used for the finite difference approximation. It defaults to
``sqrt(numpy.finfo(float).eps)``, which is approximately 1.49e-08.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="err" name="err" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The square root of the sum of squares (i.e. the 2-norm) of the
difference between ``grad(x0, *args)`` and the finite difference
approximation of `grad` using func at the points `x0`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.curve_fit" module_name="curve_fit" namespace="'optimize'" output_type="list">
    <docstring>Use non-linear least squares to fit a function, f, to data.

Assumes ``ydata = f(xdata, *params) + eps``

Parameters
----------
f : callable
    The model function, f(x, ...).  It must take the independent
    variable as the first argument and the parameters to fit as
    separate remaining arguments.
xdata : An M-length sequence or an (k,M)-shaped array
    for functions with k predictors.
    The independent variable where the data is measured.
ydata : M-length sequence
    The dependent data --- nominally f(xdata, ...)
p0 : None, scalar, or N-length sequence, optional
    Initial guess for the parameters.  If None, then the initial
    values will all be 1 (if the number of parameters for the function
    can be determined using introspection, otherwise a ValueError
    is raised).
sigma : None or M-length sequence, optional
    If not None, the uncertainties in the ydata array. These are used as
    weights in the least-squares problem
    i.e. minimising ``np.sum( ((f(xdata, *popt) - ydata) / sigma)**2 )``
    If None, the uncertainties are assumed to be 1.
absolute_sigma : bool, optional
    If False, `sigma` denotes relative weights of the data points.
    The returned covariance matrix `pcov` is based on *estimated*
    errors in the data, and is not affected by the overall
    magnitude of the values in `sigma`. Only the relative
    magnitudes of the `sigma` values matter.

    If True, `sigma` describes one standard deviation errors of
    the input data points. The estimated covariance in `pcov` is
    based on these values.
check_finite : bool, optional
    If True, check that the input arrays do not contain nans of infs,
    and raise a ValueError if they do. Setting this parameter to
    False may silently produce nonsensical results if the input arrays
    do contain nans.
    Default is True.

Returns
-------
popt : array
    Optimal values for the parameters so that the sum of the squared error
    of ``f(xdata, *popt) - ydata`` is minimized
pcov : 2d array
    The estimated covariance of popt. The diagonals provide the variance
    of the parameter estimate. To compute one standard deviation errors
    on the parameters use ``perr = np.sqrt(np.diag(pcov))``.

    How the `sigma` parameter affects the estimated covariance
    depends on `absolute_sigma` argument, as described above.

Raises
------
OptimizeWarning
    if covariance of the parameters can not be estimated.

ValueError
    if ydata and xdata contain NaNs.

See Also
--------
leastsq

Notes
-----
The algorithm uses the Levenberg-Marquardt algorithm through `leastsq`.
Additional keyword arguments are passed directly to that algorithm.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.optimize import curve_fit
&gt;&gt;&gt; def func(x, a, b, c):
...     return a * np.exp(-b * x) + c

&gt;&gt;&gt; xdata = np.linspace(0, 4, 50)
&gt;&gt;&gt; y = func(xdata, 2.5, 1.3, 0.5)
&gt;&gt;&gt; ydata = y + 0.2 * np.random.normal(size=len(xdata))

&gt;&gt;&gt; popt, pcov = curve_fit(func, xdata, ydata)</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>The model function, f(x, ...).  It must take the independent
variable as the first argument and the parameters to fit as
separate remaining arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xdata" name="xdata" port_type="basic:List" show_port="True">
      <docstring>for functions with k predictors.
The independent variable where the data is measured.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ydata" name="ydata" port_type="basic:List" show_port="True">
      <docstring>The dependent data --- nominally f(xdata, ...)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p0" name="p0Scalar" port_type="basic:Float">
      <docstring>Initial guess for the parameters.  If None, then the initial
values will all be 1 (if the number of parameters for the function
can be determined using introspection, otherwise a ValueError
is raised).</docstring>
      <alternateSpec arg="p0" name="p0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigma" port_type="basic:List">
      <docstring>If not None, the uncertainties in the ydata array. These are used as
weights in the least-squares problem
i.e. minimising ``np.sum( ((f(xdata, *popt) - ydata) / sigma)**2 )``
If None, the uncertainties are assumed to be 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="absolute_sigma" name="absolute_sigma" port_type="basic:Boolean">
      <docstring>If False, `sigma` denotes relative weights of the data points.
The returned covariance matrix `pcov` is based on *estimated*
errors in the data, and is not affected by the overall
magnitude of the values in `sigma`. Only the relative
magnitudes of the `sigma` values matter.

If True, `sigma` describes one standard deviation errors of
the input data points. The estimated covariance in `pcov` is
based on these values.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" name="check_finite" port_type="basic:Boolean">
      <docstring>If True, check that the input arrays do not contain nans of infs,
and raise a ValueError if they do. Setting this parameter to
False may silently produce nonsensical results if the input arrays
do contain nans.
Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="popt" name="popt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Optimal values for the parameters so that the sum of the squared error
of ``f(xdata, *popt) - ydata`` is minimized</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pcov" name="pcov" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The estimated covariance of popt. The diagonals provide the variance
of the parameter estimate. To compute one standard deviation errors
on the parameters use ``perr = np.sqrt(np.diag(pcov))``.

How the `sigma` parameter affects the estimated covariance
depends on `absolute_sigma` argument, as described above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.diagbroyden" module_name="diagbroyden" namespace="'optimize'">
    <docstring>Find a root of a function, using diagonal Broyden Jacobian approximation.

The Jacobian approximation is derived from previous iterations, by
retaining only the diagonal of Broyden matrices.

.. warning::

   This algorithm may be useful for specific problems, but whether
   it will work may depend strongly on the problem.

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
alpha : float, optional
    Initial guess for the Jacobian is (-1/alpha).
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Initial guess for the Jacobian is (-1/alpha).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.differential_evolution" module_name="differential_evolution" namespace="'optimize'">
    <docstring>Finds the global minimum of a multivariate function.
Differential Evolution is stochastic in nature (does not use gradient
methods) to find the minimium, and can search large areas of candidate
space, but often requires larger numbers of function evaluations than
conventional gradient based techniques.

The algorithm is due to Storn and Price [1]_.

Parameters
----------
func : callable
    The objective function to be minimized.  Must be in the form
    ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array
    and ``args`` is a  tuple of any additional fixed parameters needed to
    completely specify the function.
bounds : sequence
    Bounds for variables.  ``(min, max)`` pairs for each element in ``x``,
    defining the lower and upper bounds for the optimizing argument of
    `func`. It is required to have ``len(bounds) == len(x)``.
    ``len(bounds)`` is used to determine the number of parameters in ``x``.
args : tuple, optional
    Any additional fixed parameters needed to
    completely specify the objective function.
strategy : str, optional
    The differential evolution strategy to use. Should be one of:

        - 'best1bin'
        - 'best1exp'
        - 'rand1exp'
        - 'randtobest1exp'
        - 'best2exp'
        - 'rand2exp'
        - 'randtobest1bin'
        - 'best2bin'
        - 'rand2bin'
        - 'rand1bin'

    The default is 'best1bin'.
maxiter : int, optional
    The maximum number of times the entire population is evolved.
    The maximum number of function evaluations is:
    ``maxiter * popsize * len(x)``
popsize : int, optional
    A multiplier for setting the total population size.  The population has
    ``popsize * len(x)`` individuals.
tol : float, optional
    When the mean of the population energies, multiplied by tol,
    divided by the standard deviation of the population energies
    is greater than 1 the solving process terminates:
    ``convergence = mean(pop) * tol / stdev(pop) &gt; 1``
mutation : float or tuple(float, float), optional
    The mutation constant.
    If specified as a float it should be in the range [0, 2].
    If specified as a tuple ``(min, max)`` dithering is employed. Dithering
    randomly changes the mutation constant on a generation by generation
    basis. The mutation constant for that generation is taken from
    ``U[min, max)``. Dithering can help speed convergence significantly.
    Increasing the mutation constant increases the search radius, but will
    slow down convergence.
recombination : float, optional
    The recombination constant, should be in the range [0, 1]. Increasing
    this value allows a larger number of mutants to progress into the next
    generation, but at the risk of population stability.
seed : int or `np.random.RandomState`, optional
    If `seed` is not specified the `np.RandomState` singleton is used.
    If `seed` is an int, a new `np.random.RandomState` instance is used,
    seeded with seed.
    If `seed` is already a `np.random.RandomState instance`, then that
    `np.random.RandomState` instance is used.
    Specify `seed` for repeatable minimizations.
disp : bool, optional
    Display status messages
callback : callable, `callback(xk, convergence=val)`, optional
    A function to follow the progress of the minimization. ``xk`` is
    the current value of ``x0``. ``val`` represents the fractional
    value of the population convergence.  When ``val`` is greater than one
    the function halts. If callback returns `True`, then the minimization
    is halted (any polishing is still carried out).
polish : bool, optional
    If True (default), then `scipy.optimize.minimize` with the `L-BFGS-B`
    method is used to polish the best population member at the end, which
    can improve the minimization slightly.
init : string, optional
    Specify how the population initialization is performed. Should be
    one of:

        - 'latinhypercube'
        - 'random'

    The default is 'latinhypercube'. Latin Hypercube sampling tries to
    maximize coverage of the available parameter space. 'random' initializes
    the population randomly - this has the drawback that clustering can
    occur, preventing the whole of parameter space being covered.

Returns
-------
res : OptimizeResult
    The optimization result represented as a `OptimizeResult` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes. If `polish`
    was employed, then OptimizeResult also contains the `jac` attribute.

Notes
-----
Differential evolution is a stochastic population based method that is
useful for global optimization problems. At each pass through the population
the algorithm mutates each candidate solution by mixing with other candidate
solutions to create a trial candidate. There are several strategies [2]_ for
creating trial candidates, which suit some problems more than others. The
'best1bin' strategy is a good starting point for many systems. In this
strategy two members of the population are randomly chosen. Their difference
is used to mutate the best member (the `best` in `best1bin`), :math:`b_0`,
so far:

.. math::

    b' = b_0 + mutation * (population[rand0] - population[rand1])

A trial vector is then constructed. Starting with a randomly chosen 'i'th
parameter the trial is sequentially filled (in modulo) with parameters from
`b'` or the original candidate. The choice of whether to use `b'` or the
original candidate is made with a binomial distribution (the 'bin' in
'best1bin') - a random number in [0, 1) is generated.  If this number is
less than the `recombination` constant then the parameter is loaded from
`b'`, otherwise it is loaded from the original candidate.  The final
parameter is always loaded from `b'`.  Once the trial candidate is built
its fitness is assessed. If the trial is better than the original candidate
then it takes its place. If it is also better than the best overall
candidate it also replaces that.
To improve your chances of finding a global minimum use higher `popsize`
values, with higher `mutation` and (dithering), but lower `recombination`
values. This has the effect of widening the search radius, but slowing
convergence.

.. versionadded:: 0.15.0

Examples
--------
Let us consider the problem of minimizing the Rosenbrock function. This
function is implemented in `rosen` in `scipy.optimize`.

&gt;&gt;&gt; from scipy.optimize import rosen, differential_evolution
&gt;&gt;&gt; bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]
&gt;&gt;&gt; result = differential_evolution(rosen, bounds)
&gt;&gt;&gt; result.x, result.fun
(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)

Next find the minimum of the Ackley function
(http://en.wikipedia.org/wiki/Test_functions_for_optimization).

&gt;&gt;&gt; from scipy.optimize import differential_evolution
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; def ackley(x):
...     arg1 = -0.2 * np.sqrt(0.5 * (x[0] ** 2 + x[1] ** 2))
...     arg2 = 0.5 * (np.cos(2. * np.pi * x[0]) + np.cos(2. * np.pi * x[1]))
...     return -20. * np.exp(arg1) - np.exp(arg2) + 20. + np.e
&gt;&gt;&gt; bounds = [(-5, 5), (-5, 5)]
&gt;&gt;&gt; result = differential_evolution(ackley, bounds)
&gt;&gt;&gt; result.x, result.fun
(array([ 0.,  0.]), 4.4408920985006262e-16)

References
----------
.. [1] Storn, R and Price, K, Differential Evolution - a Simple and
       Efficient Heuristic for Global Optimization over Continuous Spaces,
       Journal of Global Optimization, 1997, 11, 341 - 359.
.. [2] http://www1.icsi.berkeley.edu/~storn/code.html
.. [3] http://en.wikipedia.org/wiki/Differential_evolution</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>The objective function to be minimized.  Must be in the form
``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array
and ``args`` is a  tuple of any additional fixed parameters needed to
completely specify the function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List" show_port="True">
      <docstring>Bounds for variables.  ``(min, max)`` pairs for each element in ``x``,
defining the lower and upper bounds for the optimizing argument of
`func`. It is required to have ``len(bounds) == len(x)``.
``len(bounds)`` is used to determine the number of parameters in ``x``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Any additional fixed parameters needed to
completely specify the objective function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="strategy" name="strategy">
      <docstring>The differential evolution strategy to use. Should be one of:

    - 'best1bin'
    - 'best1exp'
    - 'rand1exp'
    - 'randtobest1exp'
    - 'best2exp'
    - 'rand2exp'
    - 'randtobest1bin'
    - 'best2bin'
    - 'rand2bin'
    - 'rand1bin'

The default is 'best1bin'.</docstring>
      <defaults>['best1bin']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>The maximum number of times the entire population is evolved.
The maximum number of function evaluations is:
``maxiter * popsize * len(x)``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="popsize" name="popsize" port_type="basic:Integer">
      <docstring>A multiplier for setting the total population size.  The population has
``popsize * len(x)`` individuals.</docstring>
      <defaults>[15]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>When the mean of the population energies, multiplied by tol,
divided by the standard deviation of the population energies
is greater than 1 the solving process terminates:
``convergence = mean(pop) * tol / stdev(pop) &gt; 1``</docstring>
      <defaults>[0.01]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mutation" name="mutationSequence" port_type="basic:List">
      <docstring>The mutation constant.
If specified as a float it should be in the range [0, 2].
If specified as a tuple ``(min, max)`` dithering is employed. Dithering
randomly changes the mutation constant on a generation by generation
basis. The mutation constant for that generation is taken from
``U[min, max)``. Dithering can help speed convergence significantly.
Increasing the mutation constant increases the search radius, but will
slow down convergence.</docstring>
      <defaults>[(0.5, 1)]</defaults>
      <alternateSpec arg="mutation" name="mutationScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="recombination" name="recombination" port_type="basic:Float">
      <docstring>The recombination constant, should be in the range [0, 1]. Increasing
this value allows a larger number of mutants to progress into the next
generation, but at the risk of population stability.</docstring>
      <defaults>[0.7]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="seed" name="seed" port_type="basic:Integer">
      <docstring>If `seed` is not specified the `np.RandomState` singleton is used.
If `seed` is an int, a new `np.random.RandomState` instance is used,
seeded with seed.
If `seed` is already a `np.random.RandomState instance`, then that
`np.random.RandomState` instance is used.
Specify `seed` for repeatable minimizations.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Display status messages</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>A function to follow the progress of the minimization. ``xk`` is
the current value of ``x0``. ``val`` represents the fractional
value of the population convergence.  When ``val`` is greater than one
the function halts. If callback returns `True`, then the minimization
is halted (any polishing is still carried out).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="polish" name="polish" port_type="basic:Boolean">
      <docstring>If True (default), then `scipy.optimize.minimize` with the `L-BFGS-B`
method is used to polish the best population member at the end, which
can improve the minimization slightly.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="init" name="init">
      <docstring>Specify how the population initialization is performed. Should be
one of:

    - 'latinhypercube'
    - 'random'

The default is 'latinhypercube'. Latin Hypercube sampling tries to
maximize coverage of the available parameter space. 'random' initializes
the population randomly - this has the drawback that clustering can
occur, preventing the whole of parameter space being covered.</docstring>
      <defaults>['latinhypercube']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The optimization result represented as a `OptimizeResult` object.
Important attributes are: ``x`` the solution array, ``success`` a
Boolean flag indicating if the optimizer exited successfully and
``message`` which describes the cause of the termination. See
`OptimizeResult` for a description of other attributes. If `polish`
was employed, then OptimizeResult also contains the `jac` attribute.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.excitingmixing" module_name="excitingmixing" namespace="'optimize'">
    <docstring>Find a root of a function, using a tuned diagonal Jacobian approximation.

The Jacobian matrix is diagonal and is tuned on each iteration.

.. warning::

   This algorithm may be useful for specific problems, but whether
   it will work may depend strongly on the problem.

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
alpha : float, optional
    Initial Jacobian approximation is (-1/alpha).
alphamax : float, optional
    The entries of the diagonal Jacobian are kept in the range
    ``[alpha, alphamax]``.
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Initial Jacobian approximation is (-1/alpha).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alphamax" name="alphamax" port_type="basic:Float">
      <docstring>The entries of the diagonal Jacobian are kept in the range
``[alpha, alphamax]``.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fixed_point" module_name="fixed_point" namespace="'optimize'">
    <docstring>Find a fixed point of the function.

Given a function of one or more variables and a starting point, find a
fixed-point of the function: i.e. where ``func(x0) == x0``.

Parameters
----------
func : function
    Function to evaluate.
x0 : array_like
    Fixed point of function.
args : tuple, optional
    Extra arguments to `func`.
xtol : float, optional
    Convergence tolerance, defaults to 1e-08.
maxiter : int, optional
    Maximum number of iterations, defaults to 500.

Notes
-----
Uses Steffensen's Method using Aitken's ``Del^2`` convergence acceleration.
See Burden, Faires, "Numerical Analysis", 5th edition, pg. 80

Examples
--------
&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; def func(x, c1, c2):
...    return np.sqrt(c1/(x+c2))
&gt;&gt;&gt; c1 = np.array([10,12.])
&gt;&gt;&gt; c2 = np.array([3, 5.])
&gt;&gt;&gt; optimize.fixed_point(func, [1.2, 1.3], args=(c1,c2))
array([ 1.4920333 ,  1.37228132])</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Function to evaluate.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Fixed point of function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to `func`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>Convergence tolerance, defaults to 1e-08.</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations, defaults to 500.</docstring>
      <defaults>[500]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin" module_name="fmin" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function using the downhill simplex algorithm.

This algorithm only uses function values, not derivatives or second
derivatives.

Parameters
----------
func : callable func(x,*args)
    The objective function to be minimized.
x0 : ndarray
    Initial guess.
args : tuple, optional
    Extra arguments passed to func, i.e. ``f(x,*args)``.
callback : callable, optional
    Called after each iteration, as callback(xk), where xk is the
    current parameter vector.
xtol : float, optional
    Relative error in xopt acceptable for convergence.
ftol : number, optional
    Relative error in func(xopt) acceptable for convergence.
maxiter : int, optional
    Maximum number of iterations to perform.
maxfun : number, optional
    Maximum number of function evaluations to make.
full_output : bool, optional
    Set to True if fopt and warnflag outputs are desired.
disp : bool, optional
    Set to True to print convergence messages.
retall : bool, optional
    Set to True to return list of solutions at each iteration.

Returns
-------
xopt : ndarray
    Parameter that minimizes function.
fopt : float
    Value of function at minimum: ``fopt = func(xopt)``.
iter : int
    Number of iterations performed.
funcalls : int
    Number of function calls made.
warnflag : int
    1 : Maximum number of function evaluations made.
    2 : Maximum number of iterations reached.
allvecs : list
    Solution at each iteration.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'Nelder-Mead' `method` in particular.

Notes
-----
Uses a Nelder-Mead simplex algorithm to find the minimum of function of
one or more variables.

This algorithm has a long history of successful use in applications.
But it will usually be slower than an algorithm that uses first or
second derivative information. In practice it can have poor
performance in high-dimensional problems and is not robust to
minimizing complicated functions. Additionally, there currently is no
complete theory describing when the algorithm will successfully
converge to the minimum, or how fast it will if it does.

References
----------
.. [1] Nelder, J.A. and Mead, R. (1965), "A simplex method for function
       minimization", The Computer Journal, 7, pp. 308-313

.. [2] Wright, M.H. (1996), "Direct Search Methods: Once Scorned, Now
       Respectable", in Numerical Analysis 1995, Proceedings of the
       1995 Dundee Biennial Conference in Numerical Analysis, D.F.
       Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,
       Harlow, UK, pp. 191-208.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>The objective function to be minimized.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to func, i.e. ``f(x,*args)``.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Called after each iteration, as callback(xk), where xk is the
current parameter vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>Relative error in xopt acceptable for convergence.</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ftol" name="ftol" port_type="basic:Float">
      <docstring>Relative error in func(xopt) acceptable for convergence.</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to perform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxfun" name="maxfun" port_type="basic:Variant">
      <docstring>Maximum number of function evaluations to make.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>Set to True if fopt and warnflag outputs are desired.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="disp" name="dispScalar" port_type="basic:Integer">
      <docstring>Set to True to print convergence messages.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="disp" name="dispBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="retall" name="retallScalar" port_type="basic:Integer">
      <docstring>Set to True to return list of solutions at each iteration.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="retall" name="retallBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="xopt" name="xopt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Parameter that minimizes function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fopt" name="fopt" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Value of function at minimum: ``fopt = func(xopt)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="iter" name="iter" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Number of iterations performed.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="funcalls" name="funcalls" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>Number of function calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="warnflag" name="warnflag" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>1 : Maximum number of function evaluations made.
2 : Maximum number of iterations reached.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="allvecs" name="allvecs" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Solution at each iteration.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_bfgs" module_name="fmin_bfgs" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function using the BFGS algorithm.

Parameters
----------
f : callable f(x,*args)
    Objective function to be minimized.
x0 : ndarray
    Initial guess.
fprime : callable f'(x,*args), optional
    Gradient of f.
args : tuple, optional
    Extra arguments passed to f and fprime.
gtol : float, optional
    Gradient norm must be less than gtol before successful termination.
norm : float, optional
    Order of norm (Inf is max, -Inf is min)
epsilon : int or ndarray, optional
    If fprime is approximated, use this value for the step size.
callback : callable, optional
    An optional user-supplied function to call after each
    iteration.  Called as callback(xk), where xk is the
    current parameter vector.
maxiter : int, optional
    Maximum number of iterations to perform.
full_output : bool, optional
    If True,return fopt, func_calls, grad_calls, and warnflag
    in addition to xopt.
disp : bool, optional
    Print convergence message if True.
retall : bool, optional
    Return a list of results at each iteration if True.

Returns
-------
xopt : ndarray
    Parameters which minimize f, i.e. f(xopt) == fopt.
fopt : float
    Minimum value.
gopt : ndarray
    Value of gradient at minimum, f'(xopt), which should be near 0.
Bopt : ndarray
    Value of 1/f''(xopt), i.e. the inverse hessian matrix.
func_calls : int
    Number of function_calls made.
grad_calls : int
    Number of gradient calls made.
warnflag : integer
    1 : Maximum number of iterations exceeded.
    2 : Gradient and/or function calls not changing.
allvecs  :  list
    `OptimizeResult` at each iteration.  Only returned if retall is True.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'BFGS' `method` in particular.

Notes
-----
Optimize the function, f, whose gradient is given by fprime
using the quasi-Newton method of Broyden, Fletcher, Goldfarb,
and Shanno (BFGS)

References
----------
Wright, and Nocedal 'Numerical Optimization', 1999, pg. 198.</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to be minimized.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>Gradient of f.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to f and fprime.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="gtol" name="gtol" port_type="basic:Float">
      <docstring>Gradient norm must be less than gtol before successful termination.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm" port_type="basic:Float">
      <docstring>Order of norm (Inf is max, -Inf is min)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilonScalar" port_type="basic:Float">
      <docstring>If fprime is approximated, use this value for the step size.</docstring>
      <defaults>[1.4901161193847656e-08]</defaults>
      <alternateSpec arg="epsilon" name="epsilonSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>An optional user-supplied function to call after each
iteration.  Called as callback(xk), where xk is the
current parameter vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to perform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True,return fopt, func_calls, grad_calls, and warnflag
in addition to xopt.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="disp" name="dispScalar" port_type="basic:Integer">
      <docstring>Print convergence message if True.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="disp" name="dispBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="retall" name="retallScalar" port_type="basic:Integer">
      <docstring>Return a list of results at each iteration if True.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="retall" name="retallBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="xopt" name="xopt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Parameters which minimize f, i.e. f(xopt) == fopt.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fopt" name="fopt" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Minimum value.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="gopt" name="gopt" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Value of gradient at minimum, f'(xopt), which should be near 0.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Bopt" name="Bopt" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Value of 1/f''(xopt), i.e. the inverse hessian matrix.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="func_calls" name="func_calls" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>Number of function_calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="grad_calls" name="grad_calls" port_type="basic:Integer" show_port="True" sort_key="5">
      <docstring>Number of gradient calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="warnflag" name="warnflag" port_type="basic:Integer" show_port="True" sort_key="6">
      <docstring>1 : Maximum number of iterations exceeded.
2 : Gradient and/or function calls not changing.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="allvecs" name="allvecs" port_type="basic:List" show_port="True" sort_key="7">
      <docstring>`OptimizeResult` at each iteration.  Only returned if retall is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_cg" module_name="fmin_cg" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function using a nonlinear conjugate gradient algorithm.

Parameters
----------
f : callable, ``f(x, *args)``
    Objective function to be minimized.  Here `x` must be a 1-D array of
    the variables that are to be changed in the search for a minimum, and
    `args` are the other (fixed) parameters of `f`.
x0 : ndarray
    A user-supplied initial estimate of `xopt`, the optimal value of `x`.
    It must be a 1-D array of values.
fprime : callable, ``fprime(x, *args)``, optional
    A function that returns the gradient of `f` at `x`. Here `x` and `args`
    are as described above for `f`. The returned value must be a 1-D array.
    Defaults to None, in which case the gradient is approximated
    numerically (see `epsilon`, below).
args : tuple, optional
    Parameter values passed to `f` and `fprime`. Must be supplied whenever
    additional fixed parameters are needed to completely specify the
    functions `f` and `fprime`.
gtol : float, optional
    Stop when the norm of the gradient is less than `gtol`.
norm : float, optional
    Order to use for the norm of the gradient
    (``-np.Inf`` is min, ``np.Inf`` is max).
epsilon : float or ndarray, optional
    Step size(s) to use when `fprime` is approximated numerically. Can be a
    scalar or a 1-D array.  Defaults to ``sqrt(eps)``, with eps the
    floating point machine precision.  Usually ``sqrt(eps)`` is about
    1.5e-8.
maxiter : int, optional
    Maximum number of iterations to perform. Default is ``200 * len(x0)``.
full_output : bool, optional
    If True, return `fopt`, `func_calls`, `grad_calls`, and `warnflag` in
    addition to `xopt`.  See the Returns section below for additional
    information on optional return values.
disp : bool, optional
    If True, return a convergence message, followed by `xopt`.
retall : bool, optional
    If True, add to the returned values the results of each iteration.
callback : callable, optional
    An optional user-supplied function, called after each iteration.
    Called as ``callback(xk)``, where ``xk`` is the current value of `x0`.

Returns
-------
xopt : ndarray
    Parameters which minimize f, i.e. ``f(xopt) == fopt``.
fopt : float, optional
    Minimum value found, f(xopt).  Only returned if `full_output` is True.
func_calls : int, optional
    The number of function_calls made.  Only returned if `full_output`
    is True.
grad_calls : int, optional
    The number of gradient calls made. Only returned if `full_output` is
    True.
warnflag : int, optional
    Integer value with warning status, only returned if `full_output` is
    True.

    0 : Success.

    1 : The maximum number of iterations was exceeded.

    2 : Gradient and/or function calls were not changing.  May indicate
        that precision was lost, i.e., the routine did not converge.

allvecs : list of ndarray, optional
    List of arrays, containing the results at each iteration.
    Only returned if `retall` is True.

See Also
--------
minimize : common interface to all `scipy.optimize` algorithms for
           unconstrained and constrained minimization of multivariate
           functions.  It provides an alternative way to call
           ``fmin_cg``, by specifying ``method='CG'``.

Notes
-----
This conjugate gradient algorithm is based on that of Polak and Ribiere
[1]_.

Conjugate gradient methods tend to work better when:

1. `f` has a unique global minimizing point, and no local minima or
   other stationary points,
2. `f` is, at least locally, reasonably well approximated by a
   quadratic function of the variables,
3. `f` is continuous and has a continuous gradient,
4. `fprime` is not too large, e.g., has a norm less than 1000,
5. The initial guess, `x0`, is reasonably close to `f` 's global
   minimizing point, `xopt`.

References
----------
.. [1] Wright &amp; Nocedal, "Numerical Optimization", 1999, pp. 120-122.

Examples
--------
Example 1: seek the minimum value of the expression
``a*u**2 + b*u*v + c*v**2 + d*u + e*v + f`` for given values
of the parameters and an initial guess ``(u, v) = (0, 0)``.

&gt;&gt;&gt; args = (2, 3, 7, 8, 9, 10)  # parameter values
&gt;&gt;&gt; def f(x, *args):
...     u, v = x
...     a, b, c, d, e, f = args
...     return a*u**2 + b*u*v + c*v**2 + d*u + e*v + f
&gt;&gt;&gt; def gradf(x, *args):
...     u, v = x
...     a, b, c, d, e, f = args
...     gu = 2*a*u + b*v + d     # u-component of the gradient
...     gv = b*u + 2*c*v + e     # v-component of the gradient
...     return np.asarray((gu, gv))
&gt;&gt;&gt; x0 = np.asarray((0, 0))  # Initial guess.
&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)
&gt;&gt;&gt; print('res1 = ', res1)
Optimization terminated successfully.
         Current function value: 1.617021
         Iterations: 2
         Function evaluations: 5
         Gradient evaluations: 5
res1 =  [-1.80851064 -0.25531915]

Example 2: solve the same problem using the `minimize` function.
(This `myopts` dictionary shows all of the available options,
although in practice only non-default values would be needed.
The returned value will be a dictionary.)

&gt;&gt;&gt; opts = {'maxiter' : None,    # default value.
...         'disp' : True,    # non-default value.
...         'gtol' : 1e-5,    # default value.
...         'norm' : np.inf,  # default value.
...         'eps' : 1.4901161193847656e-08}  # default value.
&gt;&gt;&gt; res2 = optimize.minimize(f, x0, jac=gradf, args=args,
...                          method='CG', options=opts)
Optimization terminated successfully.
        Current function value: 1.617021
        Iterations: 2
        Function evaluations: 5
        Gradient evaluations: 5
&gt;&gt;&gt; res2.x  # minimum found
array([-1.80851064 -0.25531915])</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to be minimized.  Here `x` must be a 1-D array of
the variables that are to be changed in the search for a minimum, and
`args` are the other (fixed) parameters of `f`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>A user-supplied initial estimate of `xopt`, the optimal value of `x`.
It must be a 1-D array of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>A function that returns the gradient of `f` at `x`. Here `x` and `args`
are as described above for `f`. The returned value must be a 1-D array.
Defaults to None, in which case the gradient is approximated
numerically (see `epsilon`, below).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Parameter values passed to `f` and `fprime`. Must be supplied whenever
additional fixed parameters are needed to completely specify the
functions `f` and `fprime`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="gtol" name="gtol" port_type="basic:Float">
      <docstring>Stop when the norm of the gradient is less than `gtol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="norm" port_type="basic:Float">
      <docstring>Order to use for the norm of the gradient
(``-np.Inf`` is min, ``np.Inf`` is max).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilonScalar" port_type="basic:Float">
      <docstring>Step size(s) to use when `fprime` is approximated numerically. Can be a
scalar or a 1-D array.  Defaults to ``sqrt(eps)``, with eps the
floating point machine precision.  Usually ``sqrt(eps)`` is about
1.5e-8.</docstring>
      <defaults>[1.4901161193847656e-08]</defaults>
      <alternateSpec arg="epsilon" name="epsilonSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to perform. Default is ``200 * len(x0)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return `fopt`, `func_calls`, `grad_calls`, and `warnflag` in
addition to `xopt`.  See the Returns section below for additional
information on optional return values.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="disp" name="dispScalar" port_type="basic:Integer">
      <docstring>If True, return a convergence message, followed by `xopt`.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="disp" name="dispBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="retall" name="retallScalar" port_type="basic:Integer">
      <docstring>If True, add to the returned values the results of each iteration.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="retall" name="retallBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>An optional user-supplied function, called after each iteration.
Called as ``callback(xk)``, where ``xk`` is the current value of `x0`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="xopt" name="xopt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Parameters which minimize f, i.e. ``f(xopt) == fopt``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fopt" name="fopt" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Minimum value found, f(xopt).  Only returned if `full_output` is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="func_calls" name="func_calls" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>The number of function_calls made.  Only returned if `full_output`
is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="grad_calls" name="grad_calls" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>The number of gradient calls made. Only returned if `full_output` is
True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="warnflag" name="warnflag" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>Integer value with warning status, only returned if `full_output` is
True.

0 : Success.

1 : The maximum number of iterations was exceeded.

2 : Gradient and/or function calls were not changing.  May indicate
    that precision was lost, i.e., the routine did not converge.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="allvecs" name="allvecs" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>List of arrays, containing the results at each iteration.
Only returned if `retall` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_cobyla" module_name="fmin_cobyla" namespace="'optimize'">
    <docstring>Minimize a function using the Constrained Optimization BY Linear
Approximation (COBYLA) method. This method wraps a FORTRAN
implentation of the algorithm.

Parameters
----------
func : callable
    Function to minimize. In the form func(x, \*args).
x0 : ndarray
    Initial guess.
cons : sequence
    Constraint functions; must all be ``&gt;=0`` (a single function
    if only 1 constraint). Each function takes the parameters `x`
    as its first argument, and it can return either a single number or
    an array or list of numbers.
args : tuple, optional
    Extra arguments to pass to function.
consargs : tuple, optional
    Extra arguments to pass to constraint functions (default of None means
    use same extra arguments as those passed to func).
    Use ``()`` for no extra arguments.
rhobeg : float, optional
    Reasonable initial changes to the variables.
rhoend : float, optional
    Final accuracy in the optimization (not precisely guaranteed). This
    is a lower bound on the size of the trust region.
iprint : {0, 1, 2, 3}, optional
    Controls the frequency of output; 0 implies no output.  Deprecated.
disp : {0, 1, 2, 3}, optional
    Over-rides the iprint interface.  Preferred.
maxfun : int, optional
    Maximum number of function evaluations.
catol : float, optional
    Absolute tolerance for constraint violations.

Returns
-------
x : ndarray
    The argument that minimises `f`.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'COBYLA' `method` in particular.

Notes
-----
This algorithm is based on linear approximations to the objective
function and each constraint. We briefly describe the algorithm.

Suppose the function is being minimized over k variables. At the
jth iteration the algorithm has k+1 points v_1, ..., v_(k+1),
an approximate solution x_j, and a radius RHO_j.
(i.e. linear plus a constant) approximations to the objective
function and constraint functions such that their function values
agree with the linear approximation on the k+1 points v_1,.., v_(k+1).
This gives a linear program to solve (where the linear approximations
of the constraint functions are constrained to be non-negative).

However the linear approximations are likely only good
approximations near the current simplex, so the linear program is
given the further requirement that the solution, which
will become x_(j+1), must be within RHO_j from x_j. RHO_j only
decreases, never increases. The initial RHO_j is rhobeg and the
final RHO_j is rhoend. In this way COBYLA's iterations behave
like a trust region algorithm.

Additionally, the linear program may be inconsistent, or the
approximation may give poor improvement. For details about
how these issues are resolved, as well as how the points v_i are
updated, refer to the source code or the references below.


References
----------
Powell M.J.D. (1994), "A direct search optimization method that models
the objective and constraint functions by linear interpolation.", in
Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J-P Hennart, Kluwer Academic (Dordrecht), pp. 51-67

Powell M.J.D. (1998), "Direct search algorithms for optimization
calculations", Acta Numerica 7, 287-336

Powell M.J.D. (2007), "A view of algorithms for optimization without
derivatives", Cambridge University Technical Report DAMTP 2007/NA03


Examples
--------
Minimize the objective function f(x,y) = x*y subject
to the constraints x**2 + y**2 &lt; 1 and y &gt; 0::

    &gt;&gt;&gt; def objective(x):
    ...     return x[0]*x[1]
    ...
    &gt;&gt;&gt; def constr1(x):
    ...     return 1 - (x[0]**2 + x[1]**2)
    ...
    &gt;&gt;&gt; def constr2(x):
    ...     return x[1]
    ...
    &gt;&gt;&gt; from scipy.optimize import fmin_cobyla
    &gt;&gt;&gt; fmin_cobyla(objective, [0.0, 0.1], [constr1, constr2], rhoend=1e-7)

       Normal return from subroutine COBYLA

       NFVALS =   64   F =-5.000000E-01    MAXCV = 1.998401E-14
       X =-7.071069E-01   7.071067E-01
    array([-0.70710685,  0.70710671])

The exact solution is (-sqrt(2)/2, sqrt(2)/2).</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Function to minimize. In the form func(x, \*args).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cons" name="cons" port_type="basic:List" show_port="True">
      <docstring>Constraint functions; must all be ``&gt;=0`` (a single function
if only 1 constraint). Each function takes the parameters `x`
as its first argument, and it can return either a single number or
an array or list of numbers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to pass to function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="consargs" name="consargs" port_type="basic:List">
      <docstring>Extra arguments to pass to constraint functions (default of None means
use same extra arguments as those passed to func).
Use ``()`` for no extra arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rhobeg" name="rhobeg" port_type="basic:Float">
      <docstring>Reasonable initial changes to the variables.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rhoend" name="rhoend" port_type="basic:Float">
      <docstring>Final accuracy in the optimization (not precisely guaranteed). This
is a lower bound on the size of the trust region.</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iprint" name="iprint" port_type="basic:Integer">
      <docstring>Controls the frequency of output; 0 implies no output.  Deprecated.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1, 2, 3]]</values>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Integer">
      <docstring>Over-rides the iprint interface.  Preferred.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1, 2, 3]]</values>
    </inputPortSpec>
    <inputPortSpec arg="maxfun" name="maxfun" port_type="basic:Integer">
      <docstring>Maximum number of function evaluations.</docstring>
      <defaults>[1000]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="catol" name="catol" port_type="basic:Float">
      <docstring>Absolute tolerance for constraint violations.</docstring>
      <defaults>[0.0002]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The argument that minimises `f`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_l_bfgs_b" module_name="fmin_l_bfgs_b" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function func using the L-BFGS-B algorithm.

Parameters
----------
func : callable f(x,*args)
    Function to minimise.
x0 : ndarray
    Initial guess.
fprime : callable fprime(x,*args), optional
    The gradient of `func`.  If None, then `func` returns the function
    value and the gradient (``f, g = func(x, *args)``), unless
    `approx_grad` is True in which case `func` returns only ``f``.
args : sequence, optional
    Arguments to pass to `func` and `fprime`.
approx_grad : bool, optional
    Whether to approximate the gradient numerically (in which case
    `func` returns only the function value).
bounds : list, optional
    ``(min, max)`` pairs for each element in ``x``, defining
    the bounds on that parameter. Use None or +-inf for one of ``min`` or
    ``max`` when there is no bound in that direction.
m : int, optional
    The maximum number of variable metric corrections
    used to define the limited memory matrix. (The limited memory BFGS
    method does not store the full hessian but uses this many terms in an
    approximation to it.)
factr : float, optional
    The iteration stops when
    ``(f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} &lt;= factr * eps``,
    where ``eps`` is the machine precision, which is automatically
    generated by the code. Typical values for `factr` are: 1e12 for
    low accuracy; 1e7 for moderate accuracy; 10.0 for extremely
    high accuracy.
pgtol : float, optional
    The iteration will stop when
    ``max{|proj g_i | i = 1, ..., n} &lt;= pgtol``
    where ``pg_i`` is the i-th component of the projected gradient.
epsilon : float, optional
    Step size used when `approx_grad` is True, for numerically
    calculating the gradient
iprint : int, optional
    Controls the frequency of output. ``iprint &lt; 0`` means no output;
    ``iprint == 0`` means write messages to stdout; ``iprint &gt; 1`` in
    addition means write logging information to a file named
    ``iterate.dat`` in the current working directory.
disp : int, optional
    If zero, then no output.  If a positive number, then this over-rides
    `iprint` (i.e., `iprint` gets the value of `disp`).
maxfun : int, optional
    Maximum number of function evaluations.
maxiter : int, optional
    Maximum number of iterations.
callback : callable, optional
    Called after each iteration, as ``callback(xk)``, where ``xk`` is the
    current parameter vector.

Returns
-------
x : array_like
    Estimated position of the minimum.
f : float
    Value of `func` at the minimum.
d : dict
    Information dictionary.

    * d['warnflag'] is

      - 0 if converged,
      - 1 if too many function evaluations or too many iterations,
      - 2 if stopped for another reason, given in d['task']

    * d['grad'] is the gradient at the minimum (should be 0 ish)
    * d['funcalls'] is the number of function calls made.
    * d['nit'] is the number of iterations.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'L-BFGS-B' `method` in particular.

Notes
-----
License of L-BFGS-B (FORTRAN code):

The version included here (in fortran code) is 3.0
(released April 25, 2011).  It was written by Ciyou Zhu, Richard Byrd,
and Jorge Nocedal &lt;nocedal@ece.nwu.edu&gt;. It carries the following
condition for use:

This software is freely available, but we expect that all publications
describing work using this software, or all commercial products using it,
quote at least one of the references given below. This software is released
under the BSD License.

References
----------
* R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound
  Constrained Optimization, (1995), SIAM Journal on Scientific and
  Statistical Computing, 16, 5, pp. 1190-1208.
* C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,
  FORTRAN routines for large scale bound constrained optimization (1997),
  ACM Transactions on Mathematical Software, 23, 4, pp. 550 - 560.
* J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B,
  FORTRAN routines for large scale bound constrained optimization (2011),
  ACM Transactions on Mathematical Software, 38, 1.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Function to minimise.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>The gradient of `func`.  If None, then `func` returns the function
value and the gradient (``f, g = func(x, *args)``), unless
`approx_grad` is True in which case `func` returns only ``f``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Arguments to pass to `func` and `fprime`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="approx_grad" name="approx_gradScalar" port_type="basic:Integer">
      <docstring>Whether to approximate the gradient numerically (in which case
`func` returns only the function value).</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="approx_grad" name="approx_gradBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List">
      <docstring>``(min, max)`` pairs for each element in ``x``, defining
the bounds on that parameter. Use None or +-inf for one of ``min`` or
``max`` when there is no bound in that direction.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>The maximum number of variable metric corrections
used to define the limited memory matrix. (The limited memory BFGS
method does not store the full hessian but uses this many terms in an
approximation to it.)</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="factr" name="factr" port_type="basic:Float">
      <docstring>The iteration stops when
``(f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} &lt;= factr * eps``,
where ``eps`` is the machine precision, which is automatically
generated by the code. Typical values for `factr` are: 1e12 for
low accuracy; 1e7 for moderate accuracy; 10.0 for extremely
high accuracy.</docstring>
      <defaults>[10000000.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pgtol" name="pgtol" port_type="basic:Float">
      <docstring>The iteration will stop when
``max{|proj g_i | i = 1, ..., n} &lt;= pgtol``
where ``pg_i`` is the i-th component of the projected gradient.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilon" port_type="basic:Float">
      <docstring>Step size used when `approx_grad` is True, for numerically
calculating the gradient</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iprint" name="iprint" port_type="basic:Integer">
      <docstring>Controls the frequency of output. ``iprint &lt; 0`` means no output;
``iprint == 0`` means write messages to stdout; ``iprint &gt; 1`` in
addition means write logging information to a file named
``iterate.dat`` in the current working directory.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Integer">
      <docstring>If zero, then no output.  If a positive number, then this over-rides
`iprint` (i.e., `iprint` gets the value of `disp`).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxfun" name="maxfun" port_type="basic:Integer">
      <docstring>Maximum number of function evaluations.</docstring>
      <defaults>[15000]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations.</docstring>
      <defaults>[15000]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Called after each iteration, as ``callback(xk)``, where ``xk`` is the
current parameter vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Estimated position of the minimum.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Value of `func` at the minimum.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="d" name="d" port_type="basic:Dictionary" show_port="True" sort_key="2">
      <docstring>Information dictionary.

* d['warnflag'] is

  - 0 if converged,
  - 1 if too many function evaluations or too many iterations,
  - 2 if stopped for another reason, given in d['task']

* d['grad'] is the gradient at the minimum (should be 0 ish)
* d['funcalls'] is the number of function calls made.
* d['nit'] is the number of iterations.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_ncg" module_name="fmin_ncg" namespace="'optimize'" output_type="list">
    <docstring>Unconstrained minimization of a function using the Newton-CG method.

Parameters
----------
f : callable ``f(x, *args)``
    Objective function to be minimized.
x0 : ndarray
    Initial guess.
fprime : callable ``f'(x, *args)``
    Gradient of f.
fhess_p : callable ``fhess_p(x, p, *args)``, optional
    Function which computes the Hessian of f times an
    arbitrary vector, p.
fhess : callable ``fhess(x, *args)``, optional
    Function to compute the Hessian matrix of f.
args : tuple, optional
    Extra arguments passed to f, fprime, fhess_p, and fhess
    (the same set of extra arguments is supplied to all of
    these functions).
epsilon : float or ndarray, optional
    If fhess is approximated, use this value for the step size.
callback : callable, optional
    An optional user-supplied function which is called after
    each iteration.  Called as callback(xk), where xk is the
    current parameter vector.
avextol : float, optional
    Convergence is assumed when the average relative error in
    the minimizer falls below this amount.
maxiter : int, optional
    Maximum number of iterations to perform.
full_output : bool, optional
    If True, return the optional outputs.
disp : bool, optional
    If True, print convergence message.
retall : bool, optional
    If True, return a list of results at each iteration.

Returns
-------
xopt : ndarray
    Parameters which minimize f, i.e. ``f(xopt) == fopt``.
fopt : float
    Value of the function at xopt, i.e. ``fopt = f(xopt)``.
fcalls : int
    Number of function calls made.
gcalls : int
    Number of gradient calls made.
hcalls : int
    Number of hessian calls made.
warnflag : int
    Warnings generated by the algorithm.
    1 : Maximum number of iterations exceeded.
allvecs : list
    The result at each iteration, if retall is True (see below).

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'Newton-CG' `method` in particular.

Notes
-----
Only one of `fhess_p` or `fhess` need to be given.  If `fhess`
is provided, then `fhess_p` will be ignored.  If neither `fhess`
nor `fhess_p` is provided, then the hessian product will be
approximated using finite differences on `fprime`. `fhess_p`
must compute the hessian times an arbitrary vector. If it is not
given, finite-differences on `fprime` are used to compute
it.

Newton-CG methods are also called truncated Newton methods. This
function differs from scipy.optimize.fmin_tnc because

1. scipy.optimize.fmin_ncg is written purely in python using numpy
    and scipy while scipy.optimize.fmin_tnc calls a C function.
2. scipy.optimize.fmin_ncg is only for unconstrained minimization
    while scipy.optimize.fmin_tnc is for unconstrained minimization
    or box constrained minimization. (Box constraints give
    lower and upper bounds for each variable separately.)

References
----------
Wright &amp; Nocedal, 'Numerical Optimization', 1999, pg. 140.</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to be minimized.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant" show_port="True">
      <docstring>Gradient of f.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fhess_p" name="fhess_p" port_type="basic:Variant">
      <docstring>Function which computes the Hessian of f times an
arbitrary vector, p.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fhess" name="fhess" port_type="basic:Variant">
      <docstring>Function to compute the Hessian matrix of f.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to f, fprime, fhess_p, and fhess
(the same set of extra arguments is supplied to all of
these functions).</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilonScalar" port_type="basic:Float">
      <docstring>If fhess is approximated, use this value for the step size.</docstring>
      <defaults>[1.4901161193847656e-08]</defaults>
      <alternateSpec arg="epsilon" name="epsilonSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>An optional user-supplied function which is called after
each iteration.  Called as callback(xk), where xk is the
current parameter vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="avextol" name="avextol" port_type="basic:Float">
      <docstring>Convergence is assumed when the average relative error in
the minimizer falls below this amount.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to perform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return the optional outputs.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="disp" name="dispScalar" port_type="basic:Integer">
      <docstring>If True, print convergence message.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="disp" name="dispBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="retall" name="retallScalar" port_type="basic:Integer">
      <docstring>If True, return a list of results at each iteration.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="retall" name="retallBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="xopt" name="xopt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Parameters which minimize f, i.e. ``f(xopt) == fopt``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fopt" name="fopt" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Value of the function at xopt, i.e. ``fopt = f(xopt)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fcalls" name="fcalls" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Number of function calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="gcalls" name="gcalls" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>Number of gradient calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="hcalls" name="hcalls" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>Number of hessian calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="warnflag" name="warnflag" port_type="basic:Integer" show_port="True" sort_key="5">
      <docstring>Warnings generated by the algorithm.
1 : Maximum number of iterations exceeded.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="allvecs" name="allvecs" port_type="basic:List" show_port="True" sort_key="6">
      <docstring>The result at each iteration, if retall is True (see below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_powell" module_name="fmin_powell" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function using modified Powell's method. This method
only uses function values, not derivatives.

Parameters
----------
func : callable f(x,*args)
    Objective function to be minimized.
x0 : ndarray
    Initial guess.
args : tuple, optional
    Extra arguments passed to func.
callback : callable, optional
    An optional user-supplied function, called after each
    iteration.  Called as ``callback(xk)``, where ``xk`` is the
    current parameter vector.
direc : ndarray, optional
    Initial direction set.
xtol : float, optional
    Line-search error tolerance.
ftol : float, optional
    Relative error in ``func(xopt)`` acceptable for convergence.
maxiter : int, optional
    Maximum number of iterations to perform.
maxfun : int, optional
    Maximum number of function evaluations to make.
full_output : bool, optional
    If True, fopt, xi, direc, iter, funcalls, and
    warnflag are returned.
disp : bool, optional
    If True, print convergence messages.
retall : bool, optional
    If True, return a list of the solution at each iteration.

Returns
-------
xopt : ndarray
    Parameter which minimizes `func`.
fopt : number
    Value of function at minimum: ``fopt = func(xopt)``.
direc : ndarray
    Current direction set.
iter : int
    Number of iterations.
funcalls : int
    Number of function calls made.
warnflag : int
    Integer warning flag:
        1 : Maximum number of function evaluations.
        2 : Maximum number of iterations.
allvecs : list
    List of solutions at each iteration.

See also
--------
minimize: Interface to unconstrained minimization algorithms for
    multivariate functions. See the 'Powell' `method` in particular.

Notes
-----
Uses a modification of Powell's method to find the minimum of
a function of N variables. Powell's method is a conjugate
direction method.

The algorithm has two loops. The outer loop
merely iterates over the inner loop. The inner loop minimizes
over each current direction in the direction set. At the end
of the inner loop, if certain conditions are met, the direction
that gave the largest decrease is dropped and replaced with
the difference between the current estiamted x and the estimated
x from the beginning of the inner-loop.

The technical conditions for replacing the direction of greatest
increase amount to checking that

1. No further gain can be made along the direction of greatest increase
   from that iteration.
2. The direction of greatest increase accounted for a large sufficient
   fraction of the decrease in the function value from that iteration of
   the inner loop.

References
----------
Powell M.J.D. (1964) An efficient method for finding the minimum of a
function of several variables without calculating derivatives,
Computer Journal, 7 (2):155-162.

Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.:
Numerical Recipes (any edition), Cambridge University Press</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to be minimized.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to func.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>An optional user-supplied function, called after each
iteration.  Called as ``callback(xk)``, where ``xk`` is the
current parameter vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="direc" name="direc" port_type="basic:List">
      <docstring>Initial direction set.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>Line-search error tolerance.</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ftol" name="ftol" port_type="basic:Float">
      <docstring>Relative error in ``func(xopt)`` acceptable for convergence.</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to perform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxfun" name="maxfun" port_type="basic:Integer">
      <docstring>Maximum number of function evaluations to make.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, fopt, xi, direc, iter, funcalls, and
warnflag are returned.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="disp" name="dispScalar" port_type="basic:Integer">
      <docstring>If True, print convergence messages.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="disp" name="dispBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="retall" name="retallScalar" port_type="basic:Integer">
      <docstring>If True, return a list of the solution at each iteration.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="retall" name="retallBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="xopt" name="xopt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Parameter which minimizes `func`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fopt" name="fopt" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Value of function at minimum: ``fopt = func(xopt)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="direc" name="direc" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Current direction set.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="iter" name="iter" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>Number of iterations.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="funcalls" name="funcalls" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>Number of function calls made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="warnflag" name="warnflag" port_type="basic:Integer" show_port="True" sort_key="5">
      <docstring>Integer warning flag:
    1 : Maximum number of function evaluations.
    2 : Maximum number of iterations.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="allvecs" name="allvecs" port_type="basic:List" show_port="True" sort_key="6">
      <docstring>List of solutions at each iteration.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_slsqp" module_name="fmin_slsqp" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function using Sequential Least SQuares Programming

Python interface function for the SLSQP Optimization subroutine
originally implemented by Dieter Kraft.

Parameters
----------
func : callable f(x,*args)
    Objective function.
x0 : 1-D ndarray of float
    Initial guess for the independent variable(s).
eqcons : list, optional
    A list of functions of length n such that
    eqcons[j](x,*args) == 0.0 in a successfully optimized
    problem.
f_eqcons : callable f(x,*args), optional
    Returns a 1-D array in which each element must equal 0.0 in a
    successfully optimized problem.  If f_eqcons is specified,
    eqcons is ignored.
ieqcons : list, optional
    A list of functions of length n such that
    ieqcons[j](x,*args) &gt;= 0.0 in a successfully optimized
    problem.
f_ieqcons : callable f(x,*args), optional
    Returns a 1-D ndarray in which each element must be greater or
    equal to 0.0 in a successfully optimized problem.  If
    f_ieqcons is specified, ieqcons is ignored.
bounds : list, optional
    A list of tuples specifying the lower and upper bound
    for each independent variable [(xl0, xu0),(xl1, xu1),...]
    Infinite values will be interpreted as large floating values.
fprime : callable `f(x,*args)`, optional
    A function that evaluates the partial derivatives of func.
fprime_eqcons : callable `f(x,*args)`, optional
    A function of the form `f(x, *args)` that returns the m by n
    array of equality constraint normals.  If not provided,
    the normals will be approximated. The array returned by
    fprime_eqcons should be sized as ( len(eqcons), len(x0) ).
fprime_ieqcons : callable `f(x,*args)`, optional
    A function of the form `f(x, *args)` that returns the m by n
    array of inequality constraint normals.  If not provided,
    the normals will be approximated. The array returned by
    fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ).
args : sequence, optional
    Additional arguments passed to func and fprime.
iter : int, optional
    The maximum number of iterations.
acc : float, optional
    Requested accuracy.
iprint : int, optional
    The verbosity of fmin_slsqp :

    * iprint &lt;= 0 : Silent operation
    * iprint == 1 : Print summary upon completion (default)
    * iprint &gt;= 2 : Print status of each iterate and summary
disp : int, optional
    Over-rides the iprint interface (preferred).
full_output : bool, optional
    If False, return only the minimizer of func (default).
    Otherwise, output final objective function and summary
    information.
epsilon : float, optional
    The step size for finite-difference derivative estimates.
callback : callable, optional
    Called after each iteration, as ``callback(x)``, where ``x`` is the
    current parameter vector.

Returns
-------
out : ndarray of float
    The final minimizer of func.
fx : ndarray of float, if full_output is true
    The final value of the objective function.
its : int, if full_output is true
    The number of iterations.
imode : int, if full_output is true
    The exit mode from the optimizer (see below).
smode : string, if full_output is true
    Message describing the exit mode from the optimizer.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'SLSQP' `method` in particular.

Notes
-----
Exit modes are defined as follows ::

    -1 : Gradient evaluation required (g &amp; a)
     0 : Optimization terminated successfully.
     1 : Function evaluation required (f &amp; c)
     2 : More equality constraints than independent variables
     3 : More than 3*n iterations in LSQ subproblem
     4 : Inequality constraints incompatible
     5 : Singular matrix E in LSQ subproblem
     6 : Singular matrix C in LSQ subproblem
     7 : Rank-deficient equality constraint subproblem HFTI
     8 : Positive directional derivative for linesearch
     9 : Iteration limit exceeded

Examples
--------
Examples are given :ref:`in the tutorial &lt;tutorial-sqlsp&gt;`.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Objective function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" depth="1" name="x0" port_type="basic:Float" show_port="True">
      <docstring>Initial guess for the independent variable(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="eqcons" name="eqcons" port_type="basic:List">
      <docstring>A list of functions of length n such that
eqcons[j](x,*args) == 0.0 in a successfully optimized
problem.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_eqcons" name="f_eqcons" port_type="basic:Variant">
      <docstring>Returns a 1-D array in which each element must equal 0.0 in a
successfully optimized problem.  If f_eqcons is specified,
eqcons is ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ieqcons" name="ieqcons" port_type="basic:List">
      <docstring>A list of functions of length n such that
ieqcons[j](x,*args) &gt;= 0.0 in a successfully optimized
problem.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_ieqcons" name="f_ieqcons" port_type="basic:Variant">
      <docstring>Returns a 1-D ndarray in which each element must be greater or
equal to 0.0 in a successfully optimized problem.  If
f_ieqcons is specified, ieqcons is ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List">
      <docstring>A list of tuples specifying the lower and upper bound
for each independent variable [(xl0, xu0),(xl1, xu1),...]
Infinite values will be interpreted as large floating values.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>A function that evaluates the partial derivatives of func.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime_eqcons" name="fprime_eqcons" port_type="basic:Variant">
      <docstring>A function of the form `f(x, *args)` that returns the m by n
array of equality constraint normals.  If not provided,
the normals will be approximated. The array returned by
fprime_eqcons should be sized as ( len(eqcons), len(x0) ).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime_ieqcons" name="fprime_ieqcons" port_type="basic:Variant">
      <docstring>A function of the form `f(x, *args)` that returns the m by n
array of inequality constraint normals.  If not provided,
the normals will be approximated. The array returned by
fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Additional arguments passed to func and fprime.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>The maximum number of iterations.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="acc" name="acc" port_type="basic:Float">
      <docstring>Requested accuracy.</docstring>
      <defaults>[1e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iprint" name="iprint" port_type="basic:Integer">
      <docstring>The verbosity of fmin_slsqp :

* iprint &lt;= 0 : Silent operation
* iprint == 1 : Print summary upon completion (default)
* iprint &gt;= 2 : Print status of each iterate and summary</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Integer">
      <docstring>Over-rides the iprint interface (preferred).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If False, return only the minimizer of func (default).
Otherwise, output final objective function and summary
information.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilon" port_type="basic:Float">
      <docstring>The step size for finite-difference derivative estimates.</docstring>
      <defaults>[1.4901161193847656e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Called after each iteration, as ``callback(x)``, where ``x`` is the
current parameter vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" depth="1" name="out" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The final minimizer of func.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fx" depth="1" name="fx" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The final value of the objective function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="its" name="its" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>The number of iterations.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="imode" name="imode" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>The exit mode from the optimizer (see below).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="smode" name="smode" show_port="True" sort_key="4">
      <docstring>Message describing the exit mode from the optimizer.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fmin_tnc" module_name="fmin_tnc" namespace="'optimize'" output_type="list">
    <docstring>Minimize a function with variables subject to bounds, using
gradient information in a truncated Newton algorithm. This
method wraps a C implementation of the algorithm.

Parameters
----------
func : callable ``func(x, *args)``
    Function to minimize.  Must do one of:

    1. Return f and g, where f is the value of the function and g its
       gradient (a list of floats).

    2. Return the function value but supply gradient function
       separately as `fprime`.

    3. Return the function value and set ``approx_grad=True``.

    If the function returns None, the minimization
    is aborted.
x0 : array_like
    Initial estimate of minimum.
fprime : callable ``fprime(x, *args)``, optional
    Gradient of `func`. If None, then either `func` must return the
    function value and the gradient (``f,g = func(x, *args)``)
    or `approx_grad` must be True.
args : tuple, optional
    Arguments to pass to function.
approx_grad : bool, optional
    If true, approximate the gradient numerically.
bounds : list, optional
    (min, max) pairs for each element in x0, defining the
    bounds on that parameter. Use None or +/-inf for one of
    min or max when there is no bound in that direction.
epsilon : float, optional
    Used if approx_grad is True. The stepsize in a finite
    difference approximation for fprime.
scale : array_like, optional
    Scaling factors to apply to each variable.  If None, the
    factors are up-low for interval bounded variables and
    1+|x| for the others.  Defaults to None.
offset : array_like, optional
    Value to subtract from each variable.  If None, the
    offsets are (up+low)/2 for interval bounded variables
    and x for the others.
messages : int, optional
    Bit mask used to select messages display during
    minimization values defined in the MSGS dict.  Defaults to
    MGS_ALL.
disp : int, optional
    Integer interface to messages.  0 = no message, 5 = all messages
maxCGit : int, optional
    Maximum number of hessian*vector evaluations per main
    iteration.  If maxCGit == 0, the direction chosen is
    -gradient if maxCGit &lt; 0, maxCGit is set to
    max(1,min(50,n/2)).  Defaults to -1.
maxfun : int, optional
    Maximum number of function evaluation.  if None, maxfun is
    set to max(100, 10*len(x0)).  Defaults to None.
eta : float, optional
    Severity of the line search. if &lt; 0 or &gt; 1, set to 0.25.
    Defaults to -1.
stepmx : float, optional
    Maximum step for the line search.  May be increased during
    call.  If too small, it will be set to 10.0.  Defaults to 0.
accuracy : float, optional
    Relative precision for finite difference calculations.  If
    &lt;= machine_precision, set to sqrt(machine_precision).
    Defaults to 0.
fmin : float, optional
    Minimum function value estimate.  Defaults to 0.
ftol : float, optional
    Precision goal for the value of f in the stoping criterion.
    If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1.
xtol : float, optional
    Precision goal for the value of x in the stopping
    criterion (after applying x scaling factors).  If xtol &lt;
    0.0, xtol is set to sqrt(machine_precision).  Defaults to
    -1.
pgtol : float, optional
    Precision goal for the value of the projected gradient in
    the stopping criterion (after applying x scaling factors).
    If pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy).
    Setting it to 0.0 is not recommended.  Defaults to -1.
rescale : float, optional
    Scaling factor (in log10) used to trigger f value
    rescaling.  If 0, rescale at each iteration.  If a large
    value, never rescale.  If &lt; 0, rescale is set to 1.3.
callback : callable, optional
    Called after each iteration, as callback(xk), where xk is the
    current parameter vector.

Returns
-------
x : ndarray
    The solution.
nfeval : int
    The number of function evaluations.
rc : int
    Return code, see below

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'TNC' `method` in particular.

Notes
-----
The underlying algorithm is truncated Newton, also called
Newton Conjugate-Gradient. This method differs from
scipy.optimize.fmin_ncg in that

1. It wraps a C implementation of the algorithm
2. It allows each variable to be given an upper and lower bound.

The algorithm incoporates the bound constraints by determining
the descent direction as in an unconstrained truncated Newton,
but never taking a step-size large enough to leave the space
of feasible x's. The algorithm keeps track of a set of
currently active constraints, and ignores them when computing
the minimum allowable step size. (The x's associated with the
active constraint are kept fixed.) If the maximum allowable
step size is zero then a new constraint is added. At the end
of each iteration one of the constraints may be deemed no
longer active and removed. A constraint is considered
no longer active is if it is currently active
but the gradient for that variable points inward from the
constraint. The specific constraint removed is the one
associated with the variable of largest index whose
constraint is no longer active.

Return codes are defined as follows::

    -1 : Infeasible (lower bound &gt; upper bound)
     0 : Local minimum reached (|pg| ~= 0)
     1 : Converged (|f_n-f_(n-1)| ~= 0)
     2 : Converged (|x_n-x_(n-1)| ~= 0)
     3 : Max. number of function evaluations reached
     4 : Linear search failed
     5 : All lower bounds are equal to the upper bounds
     6 : Unable to progress
     7 : User requested end of minimization

References
----------
Wright S., Nocedal J. (2006), 'Numerical Optimization'

Nash S.G. (1984), "Newton-Type Minimization Via the Lanczos Method",
SIAM Journal of Numerical Analysis 21, pp. 770-778</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Function to minimize.  Must do one of:

1. Return f and g, where f is the value of the function and g its
   gradient (a list of floats).

2. Return the function value but supply gradient function
   separately as `fprime`.

3. Return the function value and set ``approx_grad=True``.

If the function returns None, the minimization
is aborted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial estimate of minimum.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>Gradient of `func`. If None, then either `func` must return the
function value and the gradient (``f,g = func(x, *args)``)
or `approx_grad` must be True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Arguments to pass to function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="approx_grad" name="approx_gradScalar" port_type="basic:Integer">
      <docstring>If true, approximate the gradient numerically.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="approx_grad" name="approx_gradBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List">
      <docstring>(min, max) pairs for each element in x0, defining the
bounds on that parameter. Use None or +/-inf for one of
min or max when there is no bound in that direction.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" name="epsilon" port_type="basic:Float">
      <docstring>Used if approx_grad is True. The stepsize in a finite
difference approximation for fprime.</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:List">
      <docstring>Scaling factors to apply to each variable.  If None, the
factors are up-low for interval bounded variables and
1+|x| for the others.  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="offset" name="offset" port_type="basic:List">
      <docstring>Value to subtract from each variable.  If None, the
offsets are (up+low)/2 for interval bounded variables
and x for the others.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="messages" name="messages" port_type="basic:Integer">
      <docstring>Bit mask used to select messages display during
minimization values defined in the MSGS dict.  Defaults to
MGS_ALL.</docstring>
      <defaults>[15]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Integer">
      <docstring>Integer interface to messages.  0 = no message, 5 = all messages</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxCGit" name="maxCGit" port_type="basic:Integer">
      <docstring>Maximum number of hessian*vector evaluations per main
iteration.  If maxCGit == 0, the direction chosen is
-gradient if maxCGit &lt; 0, maxCGit is set to
max(1,min(50,n/2)).  Defaults to -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxfun" name="maxfun" port_type="basic:Integer">
      <docstring>Maximum number of function evaluation.  if None, maxfun is
set to max(100, 10*len(x0)).  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="eta" name="eta" port_type="basic:Float">
      <docstring>Severity of the line search. if &lt; 0 or &gt; 1, set to 0.25.
Defaults to -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="stepmx" name="stepmx" port_type="basic:Float">
      <docstring>Maximum step for the line search.  May be increased during
call.  If too small, it will be set to 10.0.  Defaults to 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="accuracy" name="accuracy" port_type="basic:Float">
      <docstring>Relative precision for finite difference calculations.  If
&lt;= machine_precision, set to sqrt(machine_precision).
Defaults to 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fmin" name="fmin" port_type="basic:Float">
      <docstring>Minimum function value estimate.  Defaults to 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ftol" name="ftol" port_type="basic:Float">
      <docstring>Precision goal for the value of f in the stoping criterion.
If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>Precision goal for the value of x in the stopping
criterion (after applying x scaling factors).  If xtol &lt;
0.0, xtol is set to sqrt(machine_precision).  Defaults to
-1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pgtol" name="pgtol" port_type="basic:Float">
      <docstring>Precision goal for the value of the projected gradient in
the stopping criterion (after applying x scaling factors).
If pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy).
Setting it to 0.0 is not recommended.  Defaults to -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rescale" name="rescale" port_type="basic:Float">
      <docstring>Scaling factor (in log10) used to trigger f value
rescaling.  If 0, rescale at each iteration.  If a large
value, never rescale.  If &lt; 0, rescale is set to 1.3.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Called after each iteration, as callback(xk), where xk is the
current parameter vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="nfeval" name="nfeval" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>The number of function evaluations.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rc" name="rc" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Return code, see below</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fminbound" module_name="fminbound" namespace="'optimize'" output_type="list">
    <docstring>Bounded minimization for scalar functions.

Parameters
----------
func : callable f(x,*args)
    Objective function to be minimized (must accept and return scalars).
x1, x2 : float or array scalar
    The optimization bounds.
args : tuple, optional
    Extra arguments passed to function.
xtol : float, optional
    The convergence tolerance.
maxfun : int, optional
    Maximum number of function evaluations allowed.
full_output : bool, optional
    If True, return optional outputs.
disp : int, optional
    If non-zero, print messages.
        0 : no message printing.
        1 : non-convergence notification messages only.
        2 : print a message on convergence too.
        3 : print iteration results.


Returns
-------
xopt : ndarray
    Parameters (over given interval) which minimize the
    objective function.
fval : number
    The function value at the minimum point.
ierr : int
    An error flag (0 if converged, 1 if maximum number of
    function calls reached).
numfunc : int
  The number of function calls made.

See also
--------
minimize_scalar: Interface to minimization algorithms for scalar
    univariate functions. See the 'Bounded' `method` in particular.

Notes
-----
Finds a local minimizer of the scalar function `func` in the
interval x1 &lt; xopt &lt; x2 using Brent's method.  (See `brent`
for auto-bracketing).</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to be minimized (must accept and return scalars).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x1" name="x1Scalar" port_type="basic:Float" show_port="True">
      <docstring>The optimization bounds.</docstring>
      <alternateSpec arg="x1" name="x1Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x2" name="x2Scalar" port_type="basic:Float" show_port="True">
      <docstring>The optimization bounds.</docstring>
      <alternateSpec arg="x2" name="x2Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>The convergence tolerance.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxfun" name="maxfun" port_type="basic:Integer">
      <docstring>Maximum number of function evaluations allowed.</docstring>
      <defaults>[500]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return optional outputs.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Integer">
      <docstring>If non-zero, print messages.
    0 : no message printing.
    1 : non-convergence notification messages only.
    2 : print a message on convergence too.
    3 : print iteration results.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="xopt" name="xopt" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Parameters (over given interval) which minimize the
objective function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fval" name="fval" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>The function value at the minimum point.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ierr" name="ierr" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>An error flag (0 if converged, 1 if maximum number of
function calls reached).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="numfunc" name="numfunc" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>The number of function calls made.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.fsolve" module_name="fsolve" namespace="'optimize'" output_type="list">
    <docstring>Find the roots of a function.

Return the roots of the (non-linear) equations defined by
``func(x) = 0`` given a starting estimate.

Parameters
----------
func : callable ``f(x, *args)``
    A function that takes at least one (possibly vector) argument.
x0 : ndarray
    The starting estimate for the roots of ``func(x) = 0``.
args : tuple, optional
    Any extra arguments to `func`.
fprime : callable(x), optional
    A function to compute the Jacobian of `func` with derivatives
    across the rows. By default, the Jacobian will be estimated.
full_output : bool, optional
    If True, return optional outputs.
col_deriv : bool, optional
    Specify whether the Jacobian function computes derivatives down
    the columns (faster, because there is no transpose operation).
xtol : float, optional
    The calculation will terminate if the relative error between two
    consecutive iterates is at most `xtol`.
maxfev : int, optional
    The maximum number of calls to the function. If zero, then
    ``100*(N+1)`` is the maximum where N is the number of elements
    in `x0`.
band : tuple, optional
    If set to a two-sequence containing the number of sub- and
    super-diagonals within the band of the Jacobi matrix, the
    Jacobi matrix is considered banded (only for ``fprime=None``).
epsfcn : float, optional
    A suitable step length for the forward-difference
    approximation of the Jacobian (for ``fprime=None``). If
    `epsfcn` is less than the machine precision, it is assumed
    that the relative errors in the functions are of the order of
    the machine precision.
factor : float, optional
    A parameter determining the initial step bound
    (``factor * || diag * x||``).  Should be in the interval
    ``(0.1, 100)``.
diag : sequence, optional
    N positive entries that serve as a scale factors for the
    variables.

Returns
-------
x : ndarray
    The solution (or the result of the last iteration for
    an unsuccessful call).
infodict : dict
    A dictionary of optional outputs with the keys:

    ``nfev``
        number of function calls
    ``njev``
        number of Jacobian calls
    ``fvec``
        function evaluated at the output
    ``fjac``
        the orthogonal matrix, q, produced by the QR
        factorization of the final approximate Jacobian
        matrix, stored column wise
    ``r``
        upper triangular matrix produced by QR factorization
        of the same matrix
    ``qtf``
        the vector ``(transpose(q) * fvec)``

ier : int
    An integer flag.  Set to 1 if a solution was found, otherwise refer
    to `mesg` for more information.
mesg : str
    If no solution is found, `mesg` details the cause of failure.

See Also
--------
root : Interface to root finding algorithms for multivariate
functions. See the 'hybr' `method` in particular.

Notes
-----
``fsolve`` is a wrapper around MINPACK's hybrd and hybrj algorithms.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>A function that takes at least one (possibly vector) argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>The starting estimate for the roots of ``func(x) = 0``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Any extra arguments to `func`.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>A function to compute the Jacobian of `func` with derivatives
across the rows. By default, the Jacobian will be estimated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return optional outputs.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="col_deriv" name="col_derivScalar" port_type="basic:Integer">
      <docstring>Specify whether the Jacobian function computes derivatives down
the columns (faster, because there is no transpose operation).</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="col_deriv" name="col_derivBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>The calculation will terminate if the relative error between two
consecutive iterates is at most `xtol`.</docstring>
      <defaults>[1.49012e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxfev" name="maxfev" port_type="basic:Integer">
      <docstring>The maximum number of calls to the function. If zero, then
``100*(N+1)`` is the maximum where N is the number of elements
in `x0`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="band" name="band" port_type="basic:List">
      <docstring>If set to a two-sequence containing the number of sub- and
super-diagonals within the band of the Jacobi matrix, the
Jacobi matrix is considered banded (only for ``fprime=None``).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="epsfcn" name="epsfcn" port_type="basic:Float">
      <docstring>A suitable step length for the forward-difference
approximation of the Jacobian (for ``fprime=None``). If
`epsfcn` is less than the machine precision, it is assumed
that the relative errors in the functions are of the order of
the machine precision.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="factor" name="factor" port_type="basic:Float">
      <docstring>A parameter determining the initial step bound
(``factor * || diag * x||``).  Should be in the interval
``(0.1, 100)``.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="diag" name="diag" port_type="basic:List">
      <docstring>N positive entries that serve as a scale factors for the
variables.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The solution (or the result of the last iteration for
an unsuccessful call).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="infodict" name="infodict" port_type="basic:Dictionary" show_port="True" sort_key="1">
      <docstring>A dictionary of optional outputs with the keys:

``nfev``
    number of function calls
``njev``
    number of Jacobian calls
``fvec``
    function evaluated at the output
``fjac``
    the orthogonal matrix, q, produced by the QR
    factorization of the final approximate Jacobian
    matrix, stored column wise
``r``
    upper triangular matrix produced by QR factorization
    of the same matrix
``qtf``
    the vector ``(transpose(q) * fvec)``
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ier" name="ier" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>An integer flag.  Set to 1 if a solution was found, otherwise refer
to `mesg` for more information.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mesg" name="mesg" show_port="True" sort_key="3">
      <docstring>If no solution is found, `mesg` details the cause of failure.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.golden" module_name="golden" namespace="'optimize'">
    <docstring>Return the minimum of a function of one variable.

Given a function of one variable and a possible bracketing interval,
return the minimum of the function isolated to a fractional precision of
tol.

Parameters
----------
func : callable func(x,*args)
    Objective function to minimize.
args : tuple, optional
    Additional arguments (if present), passed to func.
brack : tuple, optional
    Triple (a,b,c), where (a&lt;b&lt;c) and func(b) &lt;
    func(a),func(c).  If bracket consists of two numbers (a,
    c), then they are assumed to be a starting interval for a
    downhill bracket search (see `bracket`); it doesn't always
    mean that obtained solution will satisfy a&lt;=x&lt;=c.
tol : float, optional
    x tolerance stop criterion
full_output : bool, optional
    If True, return optional outputs.

See also
--------
minimize_scalar: Interface to minimization algorithms for scalar
    univariate functions. See the 'Golden' `method` in particular.

Notes
-----
Uses analog of bisection method to decrease the bracketed
interval.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>Objective function to minimize.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Additional arguments (if present), passed to func.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="brack" name="brack" port_type="basic:List">
      <docstring>Triple (a,b,c), where (a&lt;b&lt;c) and func(b) &lt;
func(a),func(c).  If bracket consists of two numbers (a,
c), then they are assumed to be a starting interval for a
downhill bracket search (see `bracket`); it doesn't always
mean that obtained solution will satisfy a&lt;=x&lt;=c.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>x tolerance stop criterion</docstring>
      <defaults>[1.4901161193847656e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>If True, return optional outputs.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.leastsq" module_name="leastsq" namespace="'optimize'" output_type="list">
    <docstring>Minimize the sum of squares of a set of equations.

::

    x = arg min(sum(func(y)**2,axis=0))
             y

Parameters
----------
func : callable
    should take at least one (possibly length N vector) argument and
    returns M floating point numbers. It must not return NaNs or
    fitting might fail.
x0 : ndarray
    The starting estimate for the minimization.
args : tuple, optional
    Any extra arguments to func are placed in this tuple.
Dfun : callable, optional
    A function or method to compute the Jacobian of func with derivatives
    across the rows. If this is None, the Jacobian will be estimated.
full_output : bool, optional
    non-zero to return all optional outputs.
col_deriv : bool, optional
    non-zero to specify that the Jacobian function computes derivatives
    down the columns (faster, because there is no transpose operation).
ftol : float, optional
    Relative error desired in the sum of squares.
xtol : float, optional
    Relative error desired in the approximate solution.
gtol : float, optional
    Orthogonality desired between the function vector and the columns of
    the Jacobian.
maxfev : int, optional
    The maximum number of calls to the function. If `Dfun` is provided
    then the default `maxfev` is 100*(N+1) where N is the number of elements
    in x0, otherwise the default `maxfev` is 200*(N+1).
epsfcn : float, optional
    A variable used in determining a suitable step length for the forward-
    difference approximation of the Jacobian (for Dfun=None). 
    Normally the actual step length will be sqrt(epsfcn)*x
    If epsfcn is less than the machine precision, it is assumed that the 
    relative errors are of the order of the machine precision.
factor : float, optional
    A parameter determining the initial step bound
    (``factor * || diag * x||``). Should be in interval ``(0.1, 100)``.
diag : sequence, optional
    N positive entries that serve as a scale factors for the variables.

Returns
-------
x : ndarray
    The solution (or the result of the last iteration for an unsuccessful
    call).
cov_x : ndarray
    Uses the fjac and ipvt optional outputs to construct an
    estimate of the jacobian around the solution. None if a
    singular matrix encountered (indicates very flat curvature in
    some direction).  This matrix must be multiplied by the
    residual variance to get the covariance of the
    parameter estimates -- see curve_fit.
infodict : dict
    a dictionary of optional outputs with the key s:

    ``nfev``
        The number of function calls
    ``fvec``
        The function evaluated at the output
    ``fjac``
        A permutation of the R matrix of a QR
        factorization of the final approximate
        Jacobian matrix, stored column wise.
        Together with ipvt, the covariance of the
        estimate can be approximated.
    ``ipvt``
        An integer array of length N which defines
        a permutation matrix, p, such that
        fjac*p = q*r, where r is upper triangular
        with diagonal elements of nonincreasing
        magnitude. Column j of p is column ipvt(j)
        of the identity matrix.
    ``qtf``
        The vector (transpose(q) * fvec).

mesg : str
    A string message giving information about the cause of failure.
ier : int
    An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was
    found.  Otherwise, the solution was not found. In either case, the
    optional output variable 'mesg' gives more information.

Notes
-----
"leastsq" is a wrapper around MINPACK's lmdif and lmder algorithms.

cov_x is a Jacobian approximation to the Hessian of the least squares
objective function.
This approximation assumes that the objective function is based on the
difference between some observed target data (ydata) and a (non-linear)
function of the parameters `f(xdata, params)` ::

       func(params) = ydata - f(xdata, params)

so that the objective function is ::

       min   sum((ydata - f(xdata, params))**2, axis=0)
     params</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>should take at least one (possibly length N vector) argument and
returns M floating point numbers. It must not return NaNs or
fitting might fail.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>The starting estimate for the minimization.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Any extra arguments to func are placed in this tuple.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Dfun" name="Dfun" port_type="basic:Variant">
      <docstring>A function or method to compute the Jacobian of func with derivatives
across the rows. If this is None, the Jacobian will be estimated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_outputScalar" port_type="basic:Integer">
      <docstring>non-zero to return all optional outputs.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="full_output" name="full_outputBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="col_deriv" name="col_derivScalar" port_type="basic:Integer">
      <docstring>non-zero to specify that the Jacobian function computes derivatives
down the columns (faster, because there is no transpose operation).</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="col_deriv" name="col_derivBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="ftol" name="ftol" port_type="basic:Float">
      <docstring>Relative error desired in the sum of squares.</docstring>
      <defaults>[1.49012e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>Relative error desired in the approximate solution.</docstring>
      <defaults>[1.49012e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="gtol" name="gtol" port_type="basic:Float">
      <docstring>Orthogonality desired between the function vector and the columns of
the Jacobian.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxfev" name="maxfev" port_type="basic:Integer">
      <docstring>The maximum number of calls to the function. If `Dfun` is provided
then the default `maxfev` is 100*(N+1) where N is the number of elements
in x0, otherwise the default `maxfev` is 200*(N+1).</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsfcn" name="epsfcn" port_type="basic:Float">
      <docstring>A variable used in determining a suitable step length for the forward-
difference approximation of the Jacobian (for Dfun=None). 
Normally the actual step length will be sqrt(epsfcn)*x
If epsfcn is less than the machine precision, it is assumed that the 
relative errors are of the order of the machine precision.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="factor" name="factor" port_type="basic:Float">
      <docstring>A parameter determining the initial step bound
(``factor * || diag * x||``). Should be in interval ``(0.1, 100)``.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="diag" name="diag" port_type="basic:List">
      <docstring>N positive entries that serve as a scale factors for the variables.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The solution (or the result of the last iteration for an unsuccessful
call).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="cov_x" name="cov_x" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Uses the fjac and ipvt optional outputs to construct an
estimate of the jacobian around the solution. None if a
singular matrix encountered (indicates very flat curvature in
some direction).  This matrix must be multiplied by the
residual variance to get the covariance of the
parameter estimates -- see curve_fit.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="infodict" name="infodict" port_type="basic:Dictionary" show_port="True" sort_key="2">
      <docstring>a dictionary of optional outputs with the key s:

``nfev``
    The number of function calls
``fvec``
    The function evaluated at the output
``fjac``
    A permutation of the R matrix of a QR
    factorization of the final approximate
    Jacobian matrix, stored column wise.
    Together with ipvt, the covariance of the
    estimate can be approximated.
``ipvt``
    An integer array of length N which defines
    a permutation matrix, p, such that
    fjac*p = q*r, where r is upper triangular
    with diagonal elements of nonincreasing
    magnitude. Column j of p is column ipvt(j)
    of the identity matrix.
``qtf``
    The vector (transpose(q) * fvec).
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mesg" name="mesg" show_port="True" sort_key="3">
      <docstring>A string message giving information about the cause of failure.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ier" name="ier" port_type="basic:Integer" show_port="True" sort_key="4">
      <docstring>An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was
found.  Otherwise, the solution was not found. In either case, the
optional output variable 'mesg' gives more information.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.line_search" module_name="line_search" namespace="'optimize'" output_type="list">
    <docstring>Find alpha that satisfies strong Wolfe conditions.

Parameters
----------
f : callable f(x,*args)
    Objective function.
myfprime : callable f'(x,*args)
    Objective function gradient.
xk : ndarray
    Starting point.
pk : ndarray
    Search direction.
gfk : ndarray, optional
    Gradient value for x=xk (xk being the current parameter
    estimate). Will be recomputed if omitted.
old_fval : float, optional
    Function value for x=xk. Will be recomputed if omitted.
old_old_fval : float, optional
    Function value for the point preceding x=xk
args : tuple, optional
    Additional arguments passed to objective function.
c1 : float, optional
    Parameter for Armijo condition rule.
c2 : float, optional
    Parameter for curvature condition rule.
amax : float, optional
    Maximum step size

Returns
-------
alpha : float or None
    Alpha for which ``x_new = x0 + alpha * pk``,
    or None if the line search algorithm did not converge.
fc : int
    Number of function evaluations made.
gc : int
    Number of gradient evaluations made.
new_fval : float or None
    New function value ``f(x_new)=f(x0+alpha*pk)``,
    or None if the line search algorithm did not converge.
old_fval : float
    Old function value ``f(x0)``.
new_slope : float or None
    The local slope along the search direction at the
    new value ``&lt;myfprime(x_new), pk&gt;``,
    or None if the line search algorithm did not converge.


Notes
-----
Uses the line search algorithm to enforce strong Wolfe
conditions.  See Wright and Nocedal, 'Numerical Optimization',
1999, pg. 59-60.

For the zoom phase it uses an algorithm by [...].</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Objective function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="myfprime" name="myfprime" port_type="basic:Variant" show_port="True">
      <docstring>Objective function gradient.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xk" name="xk" port_type="basic:List" show_port="True">
      <docstring>Starting point.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pk" name="pk" port_type="basic:List" show_port="True">
      <docstring>Search direction.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gfk" name="gfk" port_type="basic:List">
      <docstring>Gradient value for x=xk (xk being the current parameter
estimate). Will be recomputed if omitted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="old_fval" name="old_fval" port_type="basic:Float">
      <docstring>Function value for x=xk. Will be recomputed if omitted.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="old_old_fval" name="old_old_fval" port_type="basic:Float">
      <docstring>Function value for the point preceding x=xk</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Additional arguments passed to objective function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="c1" name="c1" port_type="basic:Float">
      <docstring>Parameter for Armijo condition rule.</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="c2" name="c2" port_type="basic:Float">
      <docstring>Parameter for curvature condition rule.</docstring>
      <defaults>[0.9]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="amax" name="amax" port_type="basic:Float">
      <docstring>Maximum step size</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="alpha" name="alpha" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Alpha for which ``x_new = x0 + alpha * pk``,
or None if the line search algorithm did not converge.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="fc" name="fc" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Number of function evaluations made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="gc" name="gc" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Number of gradient evaluations made.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="new_fval" name="new_fval" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>New function value ``f(x_new)=f(x0+alpha*pk)``,
or None if the line search algorithm did not converge.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="old_fval" name="old_fval" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Old function value ``f(x0)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="new_slope" name="new_slope" port_type="basic:Float" show_port="True" sort_key="5">
      <docstring>The local slope along the search direction at the
new value ``&lt;myfprime(x_new), pk&gt;``,
or None if the line search algorithm did not converge.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.linearmixing" module_name="linearmixing" namespace="'optimize'">
    <docstring>Find a root of a function, using a scalar Jacobian approximation.

.. warning::

   This algorithm may be useful for specific problems, but whether
   it will work may depend strongly on the problem.

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
alpha : float, optional
    The Jacobian approximation is (-1/alpha).
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>The Jacobian approximation is (-1/alpha).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.linprog" module_name="linprog" namespace="'optimize'">
    <docstring>Minimize a linear objective function subject to linear
equality and inequality constraints.

Linear Programming is intended to solve the following problem form:

Minimize:     c^T * x

Subject to:   A_ub * x &lt;= b_ub
              A_eq * x == b_eq

Parameters
----------
c : array_like
    Coefficients of the linear objective function to be minimized.
A_ub : array_like, optional
    2-D array which, when matrix-multiplied by x, gives the values of the
    upper-bound inequality constraints at x.
b_ub : array_like, optional
    1-D array of values representing the upper-bound of each inequality
    constraint (row) in A_ub.
A_eq : array_like, optional
    2-D array which, when matrix-multiplied by x, gives the values of the
    equality constraints at x.
b_eq : array_like, optional
    1-D array of values representing the RHS of each equality constraint
    (row) in A_eq.
bounds : sequence, optional
    ``(min, max)`` pairs for each element in ``x``, defining
    the bounds on that parameter. Use None for one of ``min`` or
    ``max`` when there is no bound in that direction. By default
    bounds are ``(0, None)`` (non-negative)
    If a sequence containing a single tuple is provided, then ``min`` and
    ``max`` will be applied to all variables in the problem.
method : str, optional
    Type of solver.  At this time only 'simplex' is supported
    :ref:`(see here) &lt;optimize.linprog-simplex&gt;`.
callback : callable, optional
    If a callback function is provide, it will be called within each
    iteration of the simplex algorithm. The callback must have the signature
    `callback(xk, **kwargs)` where xk is the current solution vector
    and kwargs is a dictionary containing the following::

        "tableau" : The current Simplex algorithm tableau
        "nit" : The current iteration.
        "pivot" : The pivot (row, column) used for the next iteration.
        "phase" : Whether the algorithm is in Phase 1 or Phase 2.
        "basis" : The indices of the columns of the basic variables.

options : dict, optional
    A dictionary of solver options. All methods accept the following
    generic options:

        maxiter : int
            Maximum number of iterations to perform.
        disp : bool
            Set to True to print convergence messages.

    For method-specific options, see `show_options('linprog')`.

Returns
-------
A `scipy.optimize.OptimizeResult` consisting of the following fields:

    x : ndarray
        The independent variable vector which optimizes the linear
        programming problem.
    slack : ndarray
        The values of the slack variables.  Each slack variable corresponds
        to an inequality constraint.  If the slack is zero, then the
        corresponding constraint is active.
    success : bool
        Returns True if the algorithm succeeded in finding an optimal
        solution.
    status : int
        An integer representing the exit status of the optimization::

             0 : Optimization terminated successfully
             1 : Iteration limit reached
             2 : Problem appears to be infeasible
             3 : Problem appears to be unbounded

    nit : int
        The number of iterations performed.
    message : str
        A string descriptor of the exit status of the optimization.

See Also
--------
show_options : Additional options accepted by the solvers

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is :ref:`Simplex &lt;optimize.linprog-simplex&gt;`.

Method *Simplex* uses the Simplex algorithm (as it relates to Linear
Programming, NOT the Nelder-Mead Simplex) [1]_, [2]_. This algorithm
should be reasonably reliable and fast.

.. versionadded:: 0.15.0

References
----------
.. [1] Dantzig, George B., Linear programming and extensions. Rand
       Corporation Research Study Princeton Univ. Press, Princeton, NJ, 1963
.. [2] Hillier, S.H. and Lieberman, G.J. (1995), "Introduction to
       Mathematical Programming", McGraw-Hill, Chapter 4.
.. [3] Bland, Robert G. New finite pivoting rules for the simplex method.
       Mathematics of Operations Research (2), 1977: pp. 103-107.

Examples
--------
Consider the following problem:

Minimize: f = -1*x[0] + 4*x[1]

Subject to: -3*x[0] + 1*x[1] &lt;= 6
             1*x[0] + 2*x[1] &lt;= 4
                        x[1] &gt;= -3

where:  -inf &lt;= x[0] &lt;= inf

This problem deviates from the standard linear programming problem.
In standard form, linear programming problems assume the variables x are
non-negative.  Since the variables don't have standard bounds where
0 &lt;= x &lt;= inf, the bounds of the variables must be explicitly set.

There are two upper-bound constraints, which can be expressed as

dot(A_ub, x) &lt;= b_ub

The input for this problem is as follows:

&gt;&gt;&gt; c = [-1, 4]
&gt;&gt;&gt; A = [[-3, 1], [1, 2]]
&gt;&gt;&gt; b = [6, 4]
&gt;&gt;&gt; x0_bounds = (None, None)
&gt;&gt;&gt; x1_bounds = (-3, None)
&gt;&gt;&gt; from scipy.optimize import linprog
&gt;&gt;&gt; res = linprog(c, A_ub=A, b_ub=b, bounds=(x0_bounds, x1_bounds),
...               options={"disp": True})
&gt;&gt;&gt; print(res)
Optimization terminated successfully.
     Current function value: -11.428571
     Iterations: 2
status: 0
success: True
fun: -11.428571428571429
x: array([-1.14285714,  2.57142857])
message: 'Optimization terminated successfully.'
nit: 2

Note the actual objective value is 11.428571.  In this case we minimized
the negative of the objective function.</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:List" show_port="True">
      <docstring>Coefficients of the linear objective function to be minimized.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="A_ub" name="A_ub" port_type="basic:List">
      <docstring>2-D array which, when matrix-multiplied by x, gives the values of the
upper-bound inequality constraints at x.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b_ub" name="b_ub" port_type="basic:List">
      <docstring>1-D array of values representing the upper-bound of each inequality
constraint (row) in A_ub.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="A_eq" name="A_eq" port_type="basic:List">
      <docstring>2-D array which, when matrix-multiplied by x, gives the values of the
equality constraints at x.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b_eq" name="b_eq" port_type="basic:List">
      <docstring>1-D array of values representing the RHS of each equality constraint
(row) in A_eq.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List">
      <docstring>``(min, max)`` pairs for each element in ``x``, defining
the bounds on that parameter. Use None for one of ``min`` or
``max`` when there is no bound in that direction. By default
bounds are ``(0, None)`` (non-negative)
If a sequence containing a single tuple is provided, then ``min`` and
``max`` will be applied to all variables in the problem.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Type of solver.  At this time only 'simplex' is supported
:ref:`(see here) &lt;optimize.linprog-simplex&gt;`.</docstring>
      <defaults>['simplex']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>If a callback function is provide, it will be called within each
iteration of the simplex algorithm. The callback must have the signature
`callback(xk, **kwargs)` where xk is the current solution vector
and kwargs is a dictionary containing the following::

    "tableau" : The current Simplex algorithm tableau
    "nit" : The current iteration.
    "pivot" : The pivot (row, column) used for the next iteration.
    "phase" : Whether the algorithm is in Phase 1 or Phase 2.
    "basis" : The indices of the columns of the basic variables.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="options" name="options" port_type="basic:Dictionary">
      <docstring>A dictionary of solver options. All methods accept the following
generic options:

    maxiter : int
        Maximum number of iterations to perform.
    disp : bool
        Set to True to print convergence messages.

For method-specific options, see `show_options('linprog')`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>
x : ndarray
    The independent variable vector which optimizes the linear
    programming problem.
slack : ndarray
    The values of the slack variables.  Each slack variable corresponds
    to an inequality constraint.  If the slack is zero, then the
    corresponding constraint is active.
success : bool
    Returns True if the algorithm succeeded in finding an optimal
    solution.
status : int
    An integer representing the exit status of the optimization::

         0 : Optimization terminated successfully
         1 : Iteration limit reached
         2 : Problem appears to be infeasible
         3 : Problem appears to be unbounded

nit : int
    The number of iterations performed.
message : str
    A string descriptor of the exit status of the optimization.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.linprog_verbose_callback" module_name="linprog_verbose_callback" namespace="'optimize'">
    <docstring>A sample callback function demonstrating the linprog callback interface.
This callback produces detailed output to sys.stdout before each iteration
and after the final iteration of the simplex algorithm.

Parameters
----------
xk : array_like
    The current solution vector.
**kwargs : dict
    A dictionary containing the following parameters:

    tableau : array_like
        The current tableau of the simplex algorithm.
        Its structure is defined in _solve_simplex.
    phase : int
        The current Phase of the simplex algorithm (1 or 2)
    nit : int
        The current iteration number.
    pivot : tuple(int, int)
        The index of the tableau selected as the next pivot,
        or nan if no pivot exists
    basis : array(int)
        A list of the current basic variables.
        Each element contains the name of a basic variable and its value.
    complete : bool
        True if the simplex algorithm has completed
        (and this is the final call to callback), otherwise False.</docstring>
    <inputPortSpec arg="xk" name="xk" port_type="basic:List" show_port="True">
      <docstring>The current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="**kwargs" name="**kwargs" port_type="basic:Dictionary" show_port="True">
      <docstring>A dictionary containing the following parameters:

tableau : array_like
    The current tableau of the simplex algorithm.
    Its structure is defined in _solve_simplex.
phase : int
    The current Phase of the simplex algorithm (1 or 2)
nit : int
    The current iteration number.
pivot : tuple(int, int)
    The index of the tableau selected as the next pivot,
    or nan if no pivot exists
basis : array(int)
    A list of the current basic variables.
    Each element contains the name of a basic variable and its value.
complete : bool
    True if the simplex algorithm has completed
    (and this is the final call to callback), otherwise False.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.minimize" module_name="minimize" namespace="'optimize'">
    <docstring>Minimization of scalar function of one or more variables.

In general, the optimization problems are of the form:

minimize f(x)

subject to:

    ``g_i(x) &gt;= 0``, i = 1,...,m
    ``h_j(x)  = 0``, j = 1,...,p

Where x is a vector of one or more variables.
``g_i(x)`` are the inequality constraints.
``h_j(x)`` are the equality constrains.

Optionally, the lower and upper bounds for each element in x can also be specified 
using the `bounds` argument.

Parameters
----------
fun : callable
    Objective function.
x0 : ndarray
    Initial guess.
args : tuple, optional
    Extra arguments passed to the objective function and its
    derivatives (Jacobian, Hessian).
method : str or callable, optional
    Type of solver.  Should be one of

        - 'Nelder-Mead' :ref:`(see here) &lt;optimize.minimize-neldermead&gt;`
        - 'Powell'      :ref:`(see here) &lt;optimize.minimize-powell&gt;`
        - 'CG'          :ref:`(see here) &lt;optimize.minimize-cg&gt;`
        - 'BFGS'        :ref:`(see here) &lt;optimize.minimize-bfgs&gt;`
        - 'Newton-CG'   :ref:`(see here) &lt;optimize.minimize-newtoncg&gt;`
        - 'L-BFGS-B'    :ref:`(see here) &lt;optimize.minimize-lbfgsb&gt;`
        - 'TNC'         :ref:`(see here) &lt;optimize.minimize-tnc&gt;`
        - 'COBYLA'      :ref:`(see here) &lt;optimize.minimize-cobyla&gt;`
        - 'SLSQP'       :ref:`(see here) &lt;optimize.minimize-slsqp&gt;`
        - 'dogleg'      :ref:`(see here) &lt;optimize.minimize-dogleg&gt;`
        - 'trust-ncg'   :ref:`(see here) &lt;optimize.minimize-trustncg&gt;`
        - custom - a callable object (added in version 0.14.0),
          see below for description.

    If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,
    depending if the problem has constraints or bounds.
jac : bool or callable, optional
    Jacobian (gradient) of objective function. Only for CG, BFGS,
    Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg.
    If `jac` is a Boolean and is True, `fun` is assumed to return the
    gradient along with the objective function. If False, the
    gradient will be estimated numerically.
    `jac` can also be a callable returning the gradient of the
    objective. In this case, it must accept the same arguments as `fun`.
hess, hessp : callable, optional
    Hessian (matrix of second-order derivatives) of objective function or
    Hessian of objective function times an arbitrary vector p.  Only for
    Newton-CG, dogleg, trust-ncg.
    Only one of `hessp` or `hess` needs to be given.  If `hess` is
    provided, then `hessp` will be ignored.  If neither `hess` nor
    `hessp` is provided, then the Hessian product will be approximated
    using finite differences on `jac`. `hessp` must compute the Hessian
    times an arbitrary vector.
bounds : sequence, optional
    Bounds for variables (only for L-BFGS-B, TNC and SLSQP).
    ``(min, max)`` pairs for each element in ``x``, defining
    the bounds on that parameter. Use None for one of ``min`` or
    ``max`` when there is no bound in that direction.
constraints : dict or sequence of dict, optional
    Constraints definition (only for COBYLA and SLSQP).
    Each constraint is defined in a dictionary with fields:
        type : str
            Constraint type: 'eq' for equality, 'ineq' for inequality.
        fun : callable
            The function defining the constraint.
        jac : callable, optional
            The Jacobian of `fun` (only for SLSQP).
        args : sequence, optional
            Extra arguments to be passed to the function and Jacobian.
    Equality constraint means that the constraint function result is to
    be zero whereas inequality means that it is to be non-negative.
    Note that COBYLA only supports inequality constraints.
tol : float, optional
    Tolerance for termination. For detailed control, use solver-specific
    options.
options : dict, optional
    A dictionary of solver options. All methods accept the following
    generic options:
        maxiter : int
            Maximum number of iterations to perform.
        disp : bool
            Set to True to print convergence messages.
    For method-specific options, see :func:`show_options()`.
callback : callable, optional
    Called after each iteration, as ``callback(xk)``, where ``xk`` is the
    current parameter vector.

Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.


See also
--------
minimize_scalar : Interface to minimization algorithms for scalar
    univariate functions
show_options : Additional options accepted by the solvers

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *BFGS*.

**Unconstrained minimization**

Method :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;` uses the
Simplex algorithm [1]_, [2]_. This algorithm has been successful
in many applications but other algorithms using the first and/or
second derivatives information might be preferred for their better
performances and robustness in general.

Method :ref:`Powell &lt;optimize.minimize-powell&gt;` is a modification
of Powell's method [3]_, [4]_ which is a conjugate direction
method. It performs sequential one-dimensional minimizations along
each vector of the directions set (`direc` field in `options` and
`info`), which is updated at each iteration of the main
minimization loop. The function need not be differentiable, and no
derivatives are taken.

Method :ref:`CG &lt;optimize.minimize-cg&gt;` uses a nonlinear conjugate
gradient algorithm by Polak and Ribiere, a variant of the
Fletcher-Reeves method described in [5]_ pp.  120-122. Only the
first derivatives are used.

Method :ref:`BFGS &lt;optimize.minimize-bfgs&gt;` uses the quasi-Newton
method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_
pp. 136. It uses the first derivatives only. BFGS has proven good
performance even for non-smooth optimizations. This method also
returns an approximation of the Hessian inverse, stored as
`hess_inv` in the OptimizeResult object.

Method :ref:`Newton-CG &lt;optimize.minimize-newtoncg&gt;` uses a
Newton-CG algorithm [5]_ pp. 168 (also known as the truncated
Newton method). It uses a CG method to the compute the search
direction. See also *TNC* method for a box-constrained
minimization with a similar algorithm.

Method :ref:`dogleg &lt;optimize.minimize-dogleg&gt;` uses the dog-leg
trust-region algorithm [5]_ for unconstrained minimization. This
algorithm requires the gradient and Hessian; furthermore the
Hessian is required to be positive definite.

Method :ref:`trust-ncg &lt;optimize.minimize-trustncg&gt;` uses the
Newton conjugate gradient trust-region algorithm [5]_ for
unconstrained minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector.

**Constrained minimization**

Method :ref:`L-BFGS-B &lt;optimize.minimize-lbfgsb&gt;` uses the L-BFGS-B
algorithm [6]_, [7]_ for bound constrained minimization.

Method :ref:`TNC &lt;optimize.minimize-tnc&gt;` uses a truncated Newton
algorithm [5]_, [8]_ to minimize a function with variables subject
to bounds. This algorithm uses gradient information; it is also
called Newton Conjugate-Gradient. It differs from the *Newton-CG*
method described above as it wraps a C implementation and allows
each variable to be given upper and lower bounds.

Method :ref:`COBYLA &lt;optimize.minimize-cobyla&gt;` uses the
Constrained Optimization BY Linear Approximation (COBYLA) method
[9]_, [10]_, [11]_. The algorithm is based on linear
approximations to the objective function and each constraint. The
method wraps a FORTRAN implementation of the algorithm. The
constraints functions 'fun' may return either a single number
or an array or list of numbers.

Method :ref:`SLSQP &lt;optimize.minimize-slsqp&gt;` uses Sequential
Least SQuares Programming to minimize a function of several
variables with any combination of bounds, equality and inequality
constraints. The method wraps the SLSQP Optimization subroutine
originally implemented by Dieter Kraft [12]_. Note that the
wrapper handles infinite values in bounds by converting them into
large floating values.

**Custom minimizers**

It may be useful to pass a custom minimization method, for example
when using a frontend to this method such as `scipy.optimize.basinhopping`
or a different library.  You can simply pass a callable as the ``method``
parameter.

The callable is called as ``method(fun, x0, args, **kwargs, **options)``
where ``kwargs`` corresponds to any other parameters passed to `minimize`
(such as `callback`, `hess`, etc.), except the `options` dict, which has
its contents also passed as `method` parameters pair by pair.  Also, if
`jac` has been passed as a bool type, `jac` and `fun` are mangled so that
`fun` returns just the function values and `jac` is converted to a function
returning the Jacobian.  The method shall return an ``OptimizeResult``
object.

The provided `method` callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by `minimize` may
expand in future versions and then these parameters will be passed to
the method.  You can find an example in the scipy.optimize tutorial.

.. versionadded:: 0.11.0

References
----------
.. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function
    Minimization. The Computer Journal 7: 308-13.
.. [2] Wright M H. 1996. Direct search methods: Once scorned, now
    respectable, in Numerical Analysis 1995: Proceedings of the 1995
    Dundee Biennial Conference in Numerical Analysis (Eds. D F
    Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.
    191-208.
.. [3] Powell, M J D. 1964. An efficient method for finding the minimum of
   a function of several variables without calculating derivatives. The
   Computer Journal 7: 155-162.
.. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.
   Numerical Recipes (any edition), Cambridge University Press.
.. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.
   Springer New York.
.. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory
   Algorithm for Bound Constrained Optimization. SIAM Journal on
   Scientific and Statistical Computing 16 (5): 1190-1208.
.. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm
   778: L-BFGS-B, FORTRAN routines for large scale bound constrained
   optimization. ACM Transactions on Mathematical Software 23 (4):
   550-560.
.. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.
   1984. SIAM Journal of Numerical Analysis 21: 770-778.
.. [9] Powell, M J D. A direct search optimization method that models
   the objective and constraint functions by linear interpolation.
   1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez
   and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.
.. [10] Powell M J D. Direct search algorithms for optimization
   calculations. 1998. Acta Numerica 7: 287-336.
.. [11] Powell M J D. A view of algorithms for optimization without
   derivatives. 2007.Cambridge University Technical Report DAMTP
   2007/NA03
.. [12] Kraft, D. A software package for sequential quadratic
   programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace
   Center -- Institute for Flight Mechanics, Koln, Germany.

Examples
--------
Let us consider the problem of minimizing the Rosenbrock function. This
function (and its respective derivatives) is implemented in `rosen`
(resp. `rosen_der`, `rosen_hess`) in the `scipy.optimize`.

&gt;&gt;&gt; from scipy.optimize import minimize, rosen, rosen_der

A simple application of the *Nelder-Mead* method is:

&gt;&gt;&gt; x0 = [1.3, 0.7, 0.8, 1.9, 1.2]
&gt;&gt;&gt; res = minimize(rosen, x0, method='Nelder-Mead')
&gt;&gt;&gt; res.x
[ 1.  1.  1.  1.  1.]

Now using the *BFGS* algorithm, using the first derivative and a few
options:

&gt;&gt;&gt; res = minimize(rosen, x0, method='BFGS', jac=rosen_der,
...                options={'gtol': 1e-6, 'disp': True})
Optimization terminated successfully.
         Current function value: 0.000000
         Iterations: 52
         Function evaluations: 64
         Gradient evaluations: 64
&gt;&gt;&gt; res.x
array([ 1.  1.  1.  1.  1.])
&gt;&gt;&gt; print(res.message)
Optimization terminated successfully.
&gt;&gt;&gt; res.hess_inv
[[ 0.00749589  0.01255155  0.02396251  0.04750988  0.09495377]
 [ 0.01255155  0.02510441  0.04794055  0.09502834  0.18996269]
 [ 0.02396251  0.04794055  0.09631614  0.19092151  0.38165151]
 [ 0.04750988  0.09502834  0.19092151  0.38341252  0.7664427 ]
 [ 0.09495377  0.18996269  0.38165151  0.7664427   1.53713523]]


Next, consider a minimization problem with several constraints (namely
Example 16.4 from [5]_). The objective function is:

&gt;&gt;&gt; fun = lambda x: (x[0] - 1)**2 + (x[1] - 2.5)**2

There are three constraints defined as:

&gt;&gt;&gt; cons = ({'type': 'ineq', 'fun': lambda x:  x[0] - 2 * x[1] + 2},
...         {'type': 'ineq', 'fun': lambda x: -x[0] - 2 * x[1] + 6},
...         {'type': 'ineq', 'fun': lambda x: -x[0] + 2 * x[1] + 2})

And variables must be positive, hence the following bounds:

&gt;&gt;&gt; bnds = ((0, None), (0, None))

The optimization problem is solved using the SLSQP method as:

&gt;&gt;&gt; res = minimize(fun, (2, 0), method='SLSQP', bounds=bnds,
...                constraints=cons)

It should converge to the theoretical solution (1.4 ,1.7).</docstring>
    <inputPortSpec arg="fun" name="fun" port_type="basic:Variant" show_port="True">
      <docstring>Objective function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to the objective function and its
derivatives (Jacobian, Hessian).</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Type of solver.  Should be one of

    - 'Nelder-Mead' :ref:`(see here) &lt;optimize.minimize-neldermead&gt;`
    - 'Powell'      :ref:`(see here) &lt;optimize.minimize-powell&gt;`
    - 'CG'          :ref:`(see here) &lt;optimize.minimize-cg&gt;`
    - 'BFGS'        :ref:`(see here) &lt;optimize.minimize-bfgs&gt;`
    - 'Newton-CG'   :ref:`(see here) &lt;optimize.minimize-newtoncg&gt;`
    - 'L-BFGS-B'    :ref:`(see here) &lt;optimize.minimize-lbfgsb&gt;`
    - 'TNC'         :ref:`(see here) &lt;optimize.minimize-tnc&gt;`
    - 'COBYLA'      :ref:`(see here) &lt;optimize.minimize-cobyla&gt;`
    - 'SLSQP'       :ref:`(see here) &lt;optimize.minimize-slsqp&gt;`
    - 'dogleg'      :ref:`(see here) &lt;optimize.minimize-dogleg&gt;`
    - 'trust-ncg'   :ref:`(see here) &lt;optimize.minimize-trustncg&gt;`
    - custom - a callable object (added in version 0.14.0),
      see below for description.

If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,
depending if the problem has constraints or bounds.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="jac" name="jacScalar">
      <docstring>Jacobian (gradient) of objective function. Only for CG, BFGS,
Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg.
If `jac` is a Boolean and is True, `fun` is assumed to return the
gradient along with the objective function. If False, the
gradient will be estimated numerically.
`jac` can also be a callable returning the gradient of the
objective. In this case, it must accept the same arguments as `fun`.</docstring>
      <alternateSpec arg="jac" name="jacBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="hess" name="hess" port_type="basic:Variant">
      <docstring>Hessian (matrix of second-order derivatives) of objective function or
Hessian of objective function times an arbitrary vector p.  Only for
Newton-CG, dogleg, trust-ncg.
Only one of `hessp` or `hess` needs to be given.  If `hess` is
provided, then `hessp` will be ignored.  If neither `hess` nor
`hessp` is provided, then the Hessian product will be approximated
using finite differences on `jac`. `hessp` must compute the Hessian
times an arbitrary vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hessp" name="hessp" port_type="basic:Variant">
      <docstring>Hessian (matrix of second-order derivatives) of objective function or
Hessian of objective function times an arbitrary vector p.  Only for
Newton-CG, dogleg, trust-ncg.
Only one of `hessp` or `hess` needs to be given.  If `hess` is
provided, then `hessp` will be ignored.  If neither `hess` nor
`hessp` is provided, then the Hessian product will be approximated
using finite differences on `jac`. `hessp` must compute the Hessian
times an arbitrary vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List">
      <docstring>Bounds for variables (only for L-BFGS-B, TNC and SLSQP).
``(min, max)`` pairs for each element in ``x``, defining
the bounds on that parameter. Use None for one of ``min`` or
``max`` when there is no bound in that direction.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="constraints" name="constraints" port_type="basic:Dictionary">
      <docstring>Constraints definition (only for COBYLA and SLSQP).
Each constraint is defined in a dictionary with fields:
    type : str
        Constraint type: 'eq' for equality, 'ineq' for inequality.
    fun : callable
        The function defining the constraint.
    jac : callable, optional
        The Jacobian of `fun` (only for SLSQP).
    args : sequence, optional
        Extra arguments to be passed to the function and Jacobian.
Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</docstring>
      <defaults>[()]</defaults>
      <alternateSpec arg="constraints" name="constraintsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance for termination. For detailed control, use solver-specific
options.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="options" name="options" port_type="basic:Dictionary">
      <docstring>A dictionary of solver options. All methods accept the following
generic options:
    maxiter : int
        Maximum number of iterations to perform.
    disp : bool
        Set to True to print convergence messages.
For method-specific options, see :func:`show_options()`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Called after each iteration, as ``callback(xk)``, where ``xk`` is the
current parameter vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The optimization result represented as a ``OptimizeResult`` object.
Important attributes are: ``x`` the solution array, ``success`` a
Boolean flag indicating if the optimizer exited successfully and
``message`` which describes the cause of the termination. See
`OptimizeResult` for a description of other attributes.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.minimize_scalar" module_name="minimize_scalar" namespace="'optimize'">
    <docstring>Minimization of scalar function of one variable.

Parameters
----------
fun : callable
    Objective function.
    Scalar function, must return a scalar.
bracket : sequence, optional
    For methods 'brent' and 'golden', `bracket` defines the bracketing
    interval and can either have three items `(a, b, c)` so that `a &lt; b
    &lt; c` and `fun(b) &lt; fun(a), fun(c)` or two items `a` and `c` which
    are assumed to be a starting interval for a downhill bracket search
    (see `bracket`); it doesn't always mean that the obtained solution
    will satisfy `a &lt;= x &lt;= c`.
bounds : sequence, optional
    For method 'bounded', `bounds` is mandatory and must have two items
    corresponding to the optimization bounds.
args : tuple, optional
    Extra arguments passed to the objective function.
method : str or callable, optional
    Type of solver.  Should be one of

        - 'Brent'     :ref:`(see here) &lt;optimize.minimize_scalar-brent&gt;`
        - 'Bounded'   :ref:`(see here) &lt;optimize.minimize_scalar-bounded&gt;`
        - 'Golden'    :ref:`(see here) &lt;optimize.minimize_scalar-golden&gt;`
        - custom - a callable object (added in version 0.14.0),
          see below
tol : float, optional
    Tolerance for termination. For detailed control, use solver-specific
    options.
options : dict, optional
    A dictionary of solver options.
        maxiter : int
            Maximum number of iterations to perform.
        disp : bool
            Set to True to print convergence messages.

    See :func:`show_options()` for solver-specific options.

Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.

See also
--------
minimize : Interface to minimization algorithms for scalar multivariate
    functions
show_options : Additional options accepted by the solvers

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *Brent*.

Method :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;` uses Brent's
algorithm to find a local minimum.  The algorithm uses inverse
parabolic interpolation when possible to speed up convergence of
the golden section method.

Method :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;` uses the
golden section search technique. It uses analog of the bisection
method to decrease the bracketed interval. It is usually
preferable to use the *Brent* method.

Method :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;` can
perform bounded minimization. It uses the Brent method to find a
local minimum in the interval x1 &lt; xopt &lt; x2.

**Custom minimizers**

It may be useful to pass a custom minimization method, for example
when using some library frontend to minimize_scalar.  You can simply
pass a callable as the ``method`` parameter.

The callable is called as ``method(fun, args, **kwargs, **options)``
where ``kwargs`` corresponds to any other parameters passed to `minimize`
(such as `bracket`, `tol`, etc.), except the `options` dict, which has
its contents also passed as `method` parameters pair by pair.  The method
shall return an ``OptimizeResult`` object.

The provided `method` callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by `minimize` may
expand in future versions and then these parameters will be passed to
the method.  You can find an example in the scipy.optimize tutorial.

.. versionadded:: 0.11.0

Examples
--------
Consider the problem of minimizing the following function.

&gt;&gt;&gt; def f(x):
...     return (x - 2) * x * (x + 2)**2

Using the *Brent* method, we find the local minimum as:

&gt;&gt;&gt; from scipy.optimize import minimize_scalar
&gt;&gt;&gt; res = minimize_scalar(f)
&gt;&gt;&gt; res.x
1.28077640403

Using the *Bounded* method, we find a local minimum with specified
bounds as:

&gt;&gt;&gt; res = minimize_scalar(f, bounds=(-3, -1), method='bounded')
&gt;&gt;&gt; res.x
-2.0000002026</docstring>
    <inputPortSpec arg="fun" name="fun" port_type="basic:Variant" show_port="True">
      <docstring>Objective function.
Scalar function, must return a scalar.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bracket" name="bracket" port_type="basic:List">
      <docstring>For methods 'brent' and 'golden', `bracket` defines the bracketing
interval and can either have three items `(a, b, c)` so that `a &lt; b
&lt; c` and `fun(b) &lt; fun(a), fun(c)` or two items `a` and `c` which
are assumed to be a starting interval for a downhill bracket search
(see `bracket`); it doesn't always mean that the obtained solution
will satisfy `a &lt;= x &lt;= c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bounds" name="bounds" port_type="basic:List">
      <docstring>For method 'bounded', `bounds` is mandatory and must have two items
corresponding to the optimization bounds.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to the objective function.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Type of solver.  Should be one of

    - 'Brent'     :ref:`(see here) &lt;optimize.minimize_scalar-brent&gt;`
    - 'Bounded'   :ref:`(see here) &lt;optimize.minimize_scalar-bounded&gt;`
    - 'Golden'    :ref:`(see here) &lt;optimize.minimize_scalar-golden&gt;`
    - custom - a callable object (added in version 0.14.0),
      see below</docstring>
      <defaults>['brent']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance for termination. For detailed control, use solver-specific
options.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="options" name="options" port_type="basic:Dictionary">
      <docstring>A dictionary of solver options.
    maxiter : int
        Maximum number of iterations to perform.
    disp : bool
        Set to True to print convergence messages.

See :func:`show_options()` for solver-specific options.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The optimization result represented as a ``OptimizeResult`` object.
Important attributes are: ``x`` the solution array, ``success`` a
Boolean flag indicating if the optimizer exited successfully and
``message`` which describes the cause of the termination. See
`OptimizeResult` for a description of other attributes.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.newton" module_name="newton" namespace="'optimize'">
    <docstring>Find a zero using the Newton-Raphson or secant method.

Find a zero of the function `func` given a nearby starting point `x0`.
The Newton-Raphson method is used if the derivative `fprime` of `func`
is provided, otherwise the secant method is used.  If the second order
derivate `fprime2` of `func` is provided, parabolic Halley's method
is used.

Parameters
----------
func : function
    The function whose zero is wanted. It must be a function of a
    single variable of the form f(x,a,b,c...), where a,b,c... are extra
    arguments that can be passed in the `args` parameter.
x0 : float
    An initial estimate of the zero that should be somewhere near the
    actual zero.
fprime : function, optional
    The derivative of the function when available and convenient. If it
    is None (default), then the secant method is used.
args : tuple, optional
    Extra arguments to be used in the function call.
tol : float, optional
    The allowable error of the zero value.
maxiter : int, optional
    Maximum number of iterations.
fprime2 : function, optional
    The second order derivative of the function when available and
    convenient. If it is None (default), then the normal Newton-Raphson
    or the secant method is used. If it is given, parabolic Halley's
    method is used.

Returns
-------
zero : float
    Estimated location where function is zero.

See Also
--------
brentq, brenth, ridder, bisect
fsolve : find zeroes in n dimensions.

Notes
-----
The convergence rate of the Newton-Raphson method is quadratic,
the Halley method is cubic, and the secant method is
sub-quadratic.  This means that if the function is well behaved
the actual error in the estimated zero is approximately the square
(cube for Halley) of the requested tolerance up to roundoff
error. However, the stopping criterion used here is the step size
and there is no guarantee that a zero has been found. Consequently
the result should be verified. Safer algorithms are brentq,
brenth, ridder, and bisect, but they all require that the root
first be bracketed in an interval where the function changes
sign. The brentq algorithm is recommended for general use in one
dimensional problems when such an interval has been found.</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>The function whose zero is wanted. It must be a function of a
single variable of the form f(x,a,b,c...), where a,b,c... are extra
arguments that can be passed in the `args` parameter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:Float" show_port="True">
      <docstring>An initial estimate of the zero that should be somewhere near the
actual zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fprime" name="fprime" port_type="basic:Variant">
      <docstring>The derivative of the function when available and convenient. If it
is None (default), then the secant method is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments to be used in the function call.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>The allowable error of the zero value.</docstring>
      <defaults>[1.48e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations.</docstring>
      <defaults>[50]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fprime2" name="fprime2" port_type="basic:Variant">
      <docstring>The second order derivative of the function when available and
convenient. If it is None (default), then the normal Newton-Raphson
or the secant method is used. If it is given, parabolic Halley's
method is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="zero" name="zero" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Estimated location where function is zero.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.newton_krylov" module_name="newton_krylov" namespace="'optimize'">
    <docstring>Find a root of a function, using Krylov approximation for inverse Jacobian.

This method is suitable for solving large-scale problems.

Parameters
----------
F : function(x) -&gt; f
    Function whose root to find; should take and return an array-like
    object.
x0 : array_like
    Initial guess for the solution
rdiff : float, optional
    Relative step size to use in numerical differentiation.
method : {'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function
    Krylov method to use to approximate the Jacobian.
    Can be a string, or a function implementing the same interface as
    the iterative solvers in `scipy.sparse.linalg`.

    The default is `scipy.sparse.linalg.lgmres`.
inner_M : LinearOperator or InverseJacobian
    Preconditioner for the inner Krylov iteration.
    Note that you can use also inverse Jacobians as (adaptive)
    preconditioners. For example,

    &gt;&gt;&gt; from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
    &gt;&gt;&gt; from scipy.optimize.nonlin import InverseJacobian
    &gt;&gt;&gt; jac = BroydenFirst()
    &gt;&gt;&gt; kjac = KrylovJacobian(inner_M=InverseJacobian(jac))

    If the preconditioner has a method named 'update', it will be called
    as ``update(x, f)`` after each nonlinear step, with ``x`` giving
    the current point, and ``f`` the current function value.
inner_tol, inner_maxiter, ...
    Parameters to pass on to the \"inner\" Krylov solver.
    See `scipy.sparse.linalg.gmres` for details.
outer_k : int, optional
    Size of the subspace kept across LGMRES nonlinear iterations.
    See `scipy.sparse.linalg.lgmres` for details.
iter : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
verbose : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
f_tol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
f_rtol : float, optional
    Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
x_rtol : float, optional
    Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in the
    direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual.

Returns
-------
sol : ndarray
    An array (of similar array type as `x0`) containing the final solution.

Raises
------
NoConvergence
    When a solution was not found.

See Also
--------
scipy.sparse.linalg.gmres
scipy.sparse.linalg.lgmres

Notes
-----
This function implements a Newton-Krylov solver. The basic idea is
to compute the inverse of the Jacobian with an iterative Krylov
method. These methods require only evaluating the Jacobian-vector
products, which are conveniently approximated by a finite difference:

.. math:: J v \approx (f(x + \omega*v/|v|) - f(x)) / \omega

Due to the use of iterative matrix inverses, these methods can
deal with large nonlinear problems.

Scipy's `scipy.sparse.linalg` module offers a selection of Krylov
solvers to choose from. The default here is `lgmres`, which is a
variant of restarted GMRES iteration that reuses some of the
information obtained in the previous Newton steps to invert
Jacobians in subsequent steps.

For a review on Newton-Krylov methods, see for example [1]_,
and for the LGMRES sparse inverse method, see [2]_.

References
----------
.. [1] D.A. Knoll and D.E. Keyes, J. Comp. Phys. 193, 357 (2003).
.. [2] A.H. Baker and E.R. Jessup and T. Manteuffel,
         SIAM J. Matrix Anal. Appl. 26, 962 (2005).</docstring>
    <inputPortSpec arg="F" name="F" port_type="basic:Variant" show_port="True">
      <docstring>Function whose root to find; should take and return an array-like
object.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess for the solution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rdiff" name="rdiff" port_type="basic:Float">
      <docstring>Relative step size to use in numerical differentiation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Krylov method to use to approximate the Jacobian.
Can be a string, or a function implementing the same interface as
the iterative solvers in `scipy.sparse.linalg`.

The default is `scipy.sparse.linalg.lgmres`.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lgmres', 'gmres', 'bicgstab', 'cgs', 'minres', 'function']]</values>
      <defaults>['lgmres']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inner_M" name="inner_M" show_port="True">
      <docstring>Preconditioner for the inner Krylov iteration.
Note that you can use also inverse Jacobians as (adaptive)
preconditioners. For example,

&gt;&gt;&gt; from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
&gt;&gt;&gt; from scipy.optimize.nonlin import InverseJacobian
&gt;&gt;&gt; jac = BroydenFirst()
&gt;&gt;&gt; kjac = KrylovJacobian(inner_M=InverseJacobian(jac))

If the preconditioner has a method named 'update', it will be called
as ``update(x, f)`` after each nonlinear step, with ``x`` giving
the current point, and ``f`` the current function value.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator', 'InverseJacobian']]</values>
    </inputPortSpec>
    <inputPortSpec arg="inner_tol" name="inner_tol" port_type="basic:Variant" show_port="True">
      <docstring>Parameters to pass on to the \"inner\" Krylov solver.
See `scipy.sparse.linalg.gmres` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inner_maxiter" name="inner_maxiter" port_type="basic:Integer">
      <docstring>Parameters to pass on to the \"inner\" Krylov solver.
See `scipy.sparse.linalg.gmres` for details.</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:Variant" show_port="True">
      <docstring>Parameters to pass on to the \"inner\" Krylov solver.
See `scipy.sparse.linalg.gmres` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="outer_k" name="outer_k" port_type="basic:Integer">
      <docstring>Size of the subspace kept across LGMRES nonlinear iterations.
See `scipy.sparse.linalg.lgmres` for details.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iter" name="iter" port_type="basic:Integer">
      <docstring>Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean">
      <docstring>Print status to stdout on every iteration.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations to make. If more are needed to
meet convergence, `NoConvergence` is raised.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_tol" name="f_tol" port_type="basic:Float">
      <docstring>Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.</docstring>
      <defaults>[6e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="f_rtol" name="f_rtol" port_type="basic:Float">
      <docstring>Relative tolerance for the residual. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_tol" name="x_tol" port_type="basic:Float">
      <docstring>Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x_rtol" name="x_rtol" port_type="basic:Float">
      <docstring>Relative minimum step size. If omitted, not used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol_norm" name="tol_norm" port_type="basic:List">
      <docstring>Norm to use in convergence check. Default is the maximum norm.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="line_search" name="line_search">
      <docstring>Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.</docstring>
      <defaults>['armijo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xin" name="xin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="sol" name="sol" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array (of similar array type as `x0`) containing the final solution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.nnls" module_name="nnls" namespace="'optimize'" output_type="list">
    <docstring>Solve ``argmin_x || Ax - b ||_2`` for ``x&gt;=0``. This is a wrapper
for a FORTAN non-negative least squares solver.

Parameters
----------
A : ndarray
    Matrix ``A`` as shown above.
b : ndarray
    Right-hand side vector.

Returns
-------
x : ndarray
    Solution vector.
rnorm : float
    The residual, ``|| Ax-b ||_2``.

Notes
-----
The FORTRAN code was published in the book below. The algorithm
is an active set method. It solves the KKT (Karush-Kuhn-Tucker)
conditions for the non-negative least squares problem.

References
----------
Lawson C., Hanson R.J., (1987) Solving Least Squares Problems, SIAM</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Matrix ``A`` as shown above.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand side vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Solution vector.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rnorm" name="rnorm" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The residual, ``|| Ax-b ||_2``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.ridder" module_name="ridder" namespace="'optimize'" output_type="list">
    <docstring>Find a root of a function in an interval.

Parameters
----------
f : function
    Python function returning a number.  f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within xtol of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in maxiter iterations, an error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a RootResults object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.
    In particular, ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, bisect, newton : one-dimensional root-finding
fixed_point : scalar fixed-point finder

Notes
-----
Uses [Ridders1979]_ method to find a zero of the function `f` between the
arguments `a` and `b`. Ridders' method is faster than bisection, but not
generally as fast as the Brent rountines. [Ridders1979]_ provides the
classic description and source of the algorithm. A description can also be
found in any recent edition of Numerical Recipes.

The routine used here diverges slightly from standard presentations in
order to be a bit more careful of tolerance.

References
----------
.. [Ridders1979]
   Ridders, C. F. J. "A New Algorithm for Computing a
   Single Root of a Real Continuous Function."
   IEEE Trans. Circuits Systems 26, 979-980, 1979.</docstring>
    <inputPortSpec arg="f" name="f" port_type="basic:Variant" show_port="True">
      <docstring>Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>One end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True">
      <docstring>The other end of the bracketing interval [a,b].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtol" name="xtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within xtol of the
value return. Should be &gt;= 0.  The routine modifies this to take into
account the relative precision of doubles.</docstring>
      <defaults>[1e-12]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <docstring>The routine converges when a root is known to lie within `rtol` times
the value returned of the value returned. Should be &gt;= 0. Defaults to
``np.finfo(float).eps * 2``.</docstring>
      <defaults>[4.440892098500626e-16]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>if convergence is not achieved in maxiter iterations, an error is
raised.  Must be &gt;= 0.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>containing extra arguments for the function `f`.
`f` is called by ``apply(f, (x)+args)``.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="full_output" name="full_output" port_type="basic:Boolean">
      <docstring>If `full_output` is False, the root is returned.  If `full_output` is
True, the return value is ``(x, r)``, where `x` is the root, and `r` is
a RootResults object.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>If True, raise RuntimeError if the algorithm didn't converge.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x0" name="x0" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Zero of `f` between `a` and `b`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r" name="r" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Object containing information about the convergence.
In particular, ``r.converged`` is True if the routine converged.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.root" module_name="root" namespace="'optimize'">
    <docstring>Find a root of a vector function.

Parameters
----------
fun : callable
    A vector function to find a root of.
x0 : ndarray
    Initial guess.
args : tuple, optional
    Extra arguments passed to the objective function and its Jacobian.
method : str, optional
    Type of solver.  Should be one of

        - 'hybr'             :ref:`(see here) &lt;optimize.root-hybr&gt;`
        - 'lm'               :ref:`(see here) &lt;optimize.root-lm&gt;`
        - 'broyden1'         :ref:`(see here) &lt;optimize.root-broyden1&gt;`
        - 'broyden2'         :ref:`(see here) &lt;optimize.root-broyden2&gt;`
        - 'anderson'         :ref:`(see here) &lt;optimize.root-anderson&gt;`
        - 'linearmixing'     :ref:`(see here) &lt;optimize.root-linearmixing&gt;`
        - 'diagbroyden'      :ref:`(see here) &lt;optimize.root-diagbroyden&gt;`
        - 'excitingmixing'   :ref:`(see here) &lt;optimize.root-excitingmixing&gt;`
        - 'krylov'           :ref:`(see here) &lt;optimize.root-krylov&gt;`
        - 'df-sane'          :ref:`(see here) &lt;optimize.root-dfsane&gt;`

jac : bool or callable, optional
    If `jac` is a Boolean and is True, `fun` is assumed to return the
    value of Jacobian along with the objective function. If False, the
    Jacobian will be estimated numerically.
    `jac` can also be a callable returning the Jacobian of `fun`. In
    this case, it must accept the same arguments as `fun`.
tol : float, optional
    Tolerance for termination. For detailed control, use solver-specific
    options.
callback : function, optional
    Optional callback function. It is called on every iteration as
    ``callback(x, f)`` where `x` is the current solution and `f`
    the corresponding residual. For all methods but 'hybr' and 'lm'.
options : dict, optional
    A dictionary of solver options. E.g. `xtol` or `maxiter`, see
    :obj:`show_options()` for details.

Returns
-------
sol : OptimizeResult
    The solution represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the algorithm exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.

See also
--------
show_options : Additional options accepted by the solvers

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *hybr*.

Method *hybr* uses a modification of the Powell hybrid method as
implemented in MINPACK [1]_.

Method *lm* solves the system of nonlinear equations in a least squares
sense using a modification of the Levenberg-Marquardt algorithm as
implemented in MINPACK [1]_.

Method *df-sane* is a derivative-free spectral method. [3]_

Methods *broyden1*, *broyden2*, *anderson*, *linearmixing*,
*diagbroyden*, *excitingmixing*, *krylov* are inexact Newton methods,
with backtracking or full line searches [2]_. Each method corresponds
to a particular Jacobian approximations. See `nonlin` for details.

- Method *broyden1* uses Broyden's first Jacobian approximation, it is
  known as Broyden's good method.
- Method *broyden2* uses Broyden's second Jacobian approximation, it
  is known as Broyden's bad method.
- Method *anderson* uses (extended) Anderson mixing.
- Method *Krylov* uses Krylov approximation for inverse Jacobian. It
  is suitable for large-scale problem.
- Method *diagbroyden* uses diagonal Broyden Jacobian approximation.
- Method *linearmixing* uses a scalar Jacobian approximation.
- Method *excitingmixing* uses a tuned diagonal Jacobian
  approximation.

.. warning::

    The algorithms implemented for methods *diagbroyden*,
    *linearmixing* and *excitingmixing* may be useful for specific
    problems, but whether they will work may depend strongly on the
    problem.

.. versionadded:: 0.11.0

References
----------
.. [1] More, Jorge J., Burton S. Garbow, and Kenneth E. Hillstrom.
   1980. User Guide for MINPACK-1.
.. [2] C. T. Kelley. 1995. Iterative Methods for Linear and Nonlinear
    Equations. Society for Industrial and Applied Mathematics.
    &lt;http://www.siam.org/books/kelley/&gt;
.. [3] W. La Cruz, J.M. Martinez, M. Raydan. Math. Comp. 75, 1429 (2006).

Examples
--------
The following functions define a system of nonlinear equations and its
jacobian.

&gt;&gt;&gt; def fun(x):
...     return [x[0]  + 0.5 * (x[0] - x[1])**3 - 1.0,
...             0.5 * (x[1] - x[0])**3 + x[1]]

&gt;&gt;&gt; def jac(x):
...     return np.array([[1 + 1.5 * (x[0] - x[1])**2,
...                       -1.5 * (x[0] - x[1])**2],
...                      [-1.5 * (x[1] - x[0])**2,
...                       1 + 1.5 * (x[1] - x[0])**2]])

A solution can be obtained as follows.

&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; sol = optimize.root(fun, [0, 0], jac=jac, method='hybr')
&gt;&gt;&gt; sol.x
array([ 0.8411639,  0.1588361])</docstring>
    <inputPortSpec arg="fun" name="fun" port_type="basic:Variant" show_port="True">
      <docstring>A vector function to find a root of.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List" show_port="True">
      <docstring>Initial guess.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Extra arguments passed to the objective function and its Jacobian.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Type of solver.  Should be one of

    - 'hybr'             :ref:`(see here) &lt;optimize.root-hybr&gt;`
    - 'lm'               :ref:`(see here) &lt;optimize.root-lm&gt;`
    - 'broyden1'         :ref:`(see here) &lt;optimize.root-broyden1&gt;`
    - 'broyden2'         :ref:`(see here) &lt;optimize.root-broyden2&gt;`
    - 'anderson'         :ref:`(see here) &lt;optimize.root-anderson&gt;`
    - 'linearmixing'     :ref:`(see here) &lt;optimize.root-linearmixing&gt;`
    - 'diagbroyden'      :ref:`(see here) &lt;optimize.root-diagbroyden&gt;`
    - 'excitingmixing'   :ref:`(see here) &lt;optimize.root-excitingmixing&gt;`
    - 'krylov'           :ref:`(see here) &lt;optimize.root-krylov&gt;`
    - 'df-sane'          :ref:`(see here) &lt;optimize.root-dfsane&gt;`
</docstring>
      <defaults>['hybr']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="jac" name="jacScalar">
      <docstring>If `jac` is a Boolean and is True, `fun` is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
`jac` can also be a callable returning the Jacobian of `fun`. In
this case, it must accept the same arguments as `fun`.</docstring>
      <alternateSpec arg="jac" name="jacBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance for termination. For detailed control, use solver-specific
options.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>Optional callback function. It is called on every iteration as
``callback(x, f)`` where `x` is the current solution and `f`
the corresponding residual. For all methods but 'hybr' and 'lm'.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="options" name="options" port_type="basic:Dictionary">
      <docstring>A dictionary of solver options. E.g. `xtol` or `maxiter`, see
:obj:`show_options()` for details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sol" name="sol" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The solution represented as a ``OptimizeResult`` object.
Important attributes are: ``x`` the solution array, ``success`` a
Boolean flag indicating if the algorithm exited successfully and
``message`` which describes the cause of the termination. See
`OptimizeResult` for a description of other attributes.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.rosen" module_name="rosen" namespace="'optimize'">
    <docstring>The Rosenbrock function.

The function computed is::

    sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0

Parameters
----------
x : array_like
    1-D array of points at which the Rosenbrock function is to be computed.

Returns
-------
f : float
    The value of the Rosenbrock function.

See Also
--------
rosen_der, rosen_hess, rosen_hess_prod</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D array of points at which the Rosenbrock function is to be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The value of the Rosenbrock function.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.rosen_der" module_name="rosen_der" namespace="'optimize'">
    <docstring>The derivative (i.e. gradient) of the Rosenbrock function.

Parameters
----------
x : array_like
    1-D array of points at which the derivative is to be computed.

Returns
-------
rosen_der : (N,) ndarray
    The gradient of the Rosenbrock function at `x`.

See Also
--------
rosen, rosen_hess, rosen_hess_prod</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D array of points at which the derivative is to be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="rosen_der" name="rosen_der" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The gradient of the Rosenbrock function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.rosen_hess" module_name="rosen_hess" namespace="'optimize'">
    <docstring>The Hessian matrix of the Rosenbrock function.

Parameters
----------
x : array_like
    1-D array of points at which the Hessian matrix is to be computed.

Returns
-------
rosen_hess : ndarray
    The Hessian matrix of the Rosenbrock function at `x`.

See Also
--------
rosen, rosen_der, rosen_hess_prod</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D array of points at which the Hessian matrix is to be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="rosen_hess" name="rosen_hess" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Hessian matrix of the Rosenbrock function at `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.rosen_hess_prod" module_name="rosen_hess_prod" namespace="'optimize'">
    <docstring>Product of the Hessian matrix of the Rosenbrock function with a vector.

Parameters
----------
x : array_like
    1-D array of points at which the Hessian matrix is to be computed.
p : array_like
    1-D array, the vector to be multiplied by the Hessian matrix.

Returns
-------
rosen_hess_prod : ndarray
    The Hessian matrix of the Rosenbrock function at `x` multiplied
    by the vector `p`.

See Also
--------
rosen, rosen_der, rosen_hess</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D array of points at which the Hessian matrix is to be computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>1-D array, the vector to be multiplied by the Hessian matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="rosen_hess_prod" name="rosen_hess_prod" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The Hessian matrix of the Rosenbrock function at `x` multiplied
by the vector `p`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.optimize.show_options" module_name="show_options" namespace="'optimize'">
    <docstring>Show documentation for additional options of optimization solvers.

These are method-specific options that can be supplied through the
``options`` dict.

Parameters
----------
solver : str
    Type of optimization solver. One of 'minimize', 'minimize_scalar',
    'root', or 'linprog'.
method : str, optional
    If not given, shows all methods of the specified solver. Otherwise,
    show only the options for the specified method. Valid values
    corresponds to methods' names of respective solver (e.g. 'BFGS' for
    'minimize').
disp : bool, optional
    Whether to print the result rather than returning it.

Returns
-------
text
    Either None (for disp=False) or the text string (disp=True)

Notes
-----
The solver-specific methods are:

`scipy.optimize.minimize`

- :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;`
- :ref:`Powell      &lt;optimize.minimize-powell&gt;`
- :ref:`CG          &lt;optimize.minimize-cg&gt;`
- :ref:`BFGS        &lt;optimize.minimize-bfgs&gt;`
- :ref:`Newton-CG   &lt;optimize.minimize-newtoncg&gt;`
- :ref:`L-BFGS-B    &lt;optimize.minimize-lbfgsb&gt;`
- :ref:`TNC         &lt;optimize.minimize-tnc&gt;`
- :ref:`COBYLA      &lt;optimize.minimize-cobyla&gt;`
- :ref:`SLSQP       &lt;optimize.minimize-slsqp&gt;`
- :ref:`dogleg      &lt;optimize.minimize-dogleg&gt;`
- :ref:`trust-ncg   &lt;optimize.minimize-trustncg&gt;`

`scipy.optimize.root`

- :ref:`hybr              &lt;optimize.root-hybr&gt;`
- :ref:`lm                &lt;optimize.root-lm&gt;`
- :ref:`broyden1          &lt;optimize.root-broyden1&gt;`
- :ref:`broyden2          &lt;optimize.root-broyden2&gt;`
- :ref:`anderson          &lt;optimize.root-anderson&gt;`
- :ref:`linearmixing      &lt;optimize.root-linearmixing&gt;`
- :ref:`diagbroyden       &lt;optimize.root-diagbroyden&gt;`
- :ref:`excitingmixing    &lt;optimize.root-excitingmixing&gt;`
- :ref:`krylov            &lt;optimize.root-krylov&gt;`
- :ref:`df-sane           &lt;optimize.root-dfsane&gt;`

`scipy.optimize.minimize_scalar`

- :ref:`brent       &lt;optimize.minimize_scalar-brent&gt;`
- :ref:`golden      &lt;optimize.minimize_scalar-golden&gt;`
- :ref:`bounded     &lt;optimize.minimize_scalar-bounded&gt;`

`scipy.optimize.linprog`

- :ref:`simplex     &lt;optimize.linprog-simplex&gt;`</docstring>
    <inputPortSpec arg="solver" name="solver" show_port="True">
      <docstring>Type of optimization solver. One of 'minimize', 'minimize_scalar',
'root', or 'linprog'.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>If not given, shows all methods of the specified solver. Otherwise,
show only the options for the specified method. Valid values
corresponds to methods' names of respective solver (e.g. 'BFGS' for
'minimize').</docstring>
    </inputPortSpec>
    <inputPortSpec arg="disp" name="disp" port_type="basic:Boolean">
      <docstring>Whether to print the result rather than returning it.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Either None (for disp=False) or the text string (disp=True)</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.abcd_normalize" module_name="abcd_normalize" namespace="'signal'" output_type="list">
    <docstring>Check state-space matrices and ensure they are two-dimensional.

If enough information on the system is provided, that is, enough
properly-shaped arrays are passed to the function, the missing ones
are built from this information, ensuring the correct number of
rows and columns. Otherwise a ValueError is raised.

Parameters
----------
A, B, C, D : array_like, optional
    State-space matrices. All of them are None (missing) by default.

Returns
-------
A, B, C, D : array
    Properly shaped state-space matrices.

Raises
------
ValueError
    If not enough information on the system was provided.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List">
      <docstring>State-space matrices. All of them are None (missing) by default.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List">
      <docstring>State-space matrices. All of them are None (missing) by default.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="C" name="C" port_type="basic:List">
      <docstring>State-space matrices. All of them are None (missing) by default.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="D" name="D" port_type="basic:List">
      <docstring>State-space matrices. All of them are None (missing) by default.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Properly shaped state-space matrices.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Properly shaped state-space matrices.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="C" name="C" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Properly shaped state-space matrices.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="D" name="D" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>Properly shaped state-space matrices.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.argrelextrema" module_name="argrelextrema" namespace="'signal'">
    <docstring>Calculate the relative extrema of `data`.

Parameters
----------
data : ndarray
    Array in which to find the relative extrema.
comparator : callable
    Function to use to compare two data points.
    Should take 2 numbers as arguments.
axis : int, optional
    Axis over which to select from `data`.  Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n, n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated.  'wrap' (wrap around) or
    'clip' (treat overflow as the same as the last (or first) element).
    Default is 'clip'.  See `numpy.take`.

Returns
-------
extrema : tuple of ndarrays
    Indices of the maxima in arrays of integers.  ``extrema[k]`` is
    the array of indices of axis `k` of `data`.  Note that the
    return value is a tuple even when `data` is one-dimensional.

See Also
--------
argrelmin, argrelmax

Notes
-----

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
&gt;&gt;&gt; argrelextrema(x, np.greater)
(array([3, 6]),)
&gt;&gt;&gt; y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
&gt;&gt;&gt; argrelextrema(y, np.less, axis=1)
(array([0, 2]), array([2, 1]))</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Array in which to find the relative extrema.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="comparator" name="comparator" port_type="basic:Variant" show_port="True">
      <docstring>Function to use to compare two data points.
Should take 2 numbers as arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to select from `data`.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>How many points on each side to use for the comparison
to consider ``comparator(n, n+x)`` to be True.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>How the edges of the vector are treated.  'wrap' (wrap around) or
'clip' (treat overflow as the same as the last (or first) element).
Default is 'clip'.  See `numpy.take`.</docstring>
      <defaults>['clip']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="extrema" name="extrema" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Indices of the maxima in arrays of integers.  ``extrema[k]`` is
the array of indices of axis `k` of `data`.  Note that the
return value is a tuple even when `data` is one-dimensional.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.argrelmax" module_name="argrelmax" namespace="'signal'">
    <docstring>Calculate the relative maxima of `data`.

Parameters
----------
data : ndarray
    Array in which to find the relative maxima.
axis : int, optional
    Axis over which to select from `data`.  Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n, n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated.
    Available options are 'wrap' (wrap around) or 'clip' (treat overflow
    as the same as the last (or first) element).
    Default 'clip'.  See `numpy.take`.

Returns
-------
extrema : tuple of ndarrays
    Indices of the maxima in arrays of integers.  ``extrema[k]`` is
    the array of indices of axis `k` of `data`.  Note that the
    return value is a tuple even when `data` is one-dimensional.

See Also
--------
argrelextrema, argrelmin

Notes
-----
This function uses `argrelextrema` with np.greater as comparator.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
&gt;&gt;&gt; argrelmax(x)
(array([3, 6]),)
&gt;&gt;&gt; y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
&gt;&gt;&gt; argrelmax(y, axis=1)
(array([0]), array([1]))</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Array in which to find the relative maxima.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to select from `data`.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>How many points on each side to use for the comparison
to consider ``comparator(n, n+x)`` to be True.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>How the edges of the vector are treated.
Available options are 'wrap' (wrap around) or 'clip' (treat overflow
as the same as the last (or first) element).
Default 'clip'.  See `numpy.take`.</docstring>
      <defaults>['clip']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="extrema" name="extrema" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Indices of the maxima in arrays of integers.  ``extrema[k]`` is
the array of indices of axis `k` of `data`.  Note that the
return value is a tuple even when `data` is one-dimensional.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.argrelmin" module_name="argrelmin" namespace="'signal'">
    <docstring>Calculate the relative minima of `data`.

Parameters
----------
data : ndarray
    Array in which to find the relative minima.
axis : int, optional
    Axis over which to select from `data`.  Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n, n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated.
    Available options are 'wrap' (wrap around) or 'clip' (treat overflow
    as the same as the last (or first) element).
    Default 'clip'. See numpy.take

Returns
-------
extrema : tuple of ndarrays
    Indices of the minima in arrays of integers.  ``extrema[k]`` is
    the array of indices of axis `k` of `data`.  Note that the
    return value is a tuple even when `data` is one-dimensional.

See Also
--------
argrelextrema, argrelmax

Notes
-----
This function uses `argrelextrema` with np.less as comparator.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
&gt;&gt;&gt; argrelmin(x)
(array([1, 5]),)
&gt;&gt;&gt; y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
&gt;&gt;&gt; argrelmin(y, axis=1)
(array([0, 2]), array([2, 1]))</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Array in which to find the relative minima.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis over which to select from `data`.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order" port_type="basic:Integer">
      <docstring>How many points on each side to use for the comparison
to consider ``comparator(n, n+x)`` to be True.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>How the edges of the vector are treated.
Available options are 'wrap' (wrap around) or 'clip' (treat overflow
as the same as the last (or first) element).
Default 'clip'. See numpy.take</docstring>
      <defaults>['clip']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="extrema" name="extrema" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Indices of the minima in arrays of integers.  ``extrema[k]`` is
the array of indices of axis `k` of `data`.  Note that the
return value is a tuple even when `data` is one-dimensional.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.band_stop_obj" module_name="band_stop_obj" namespace="'signal'">
    <docstring>Band Stop Objective Function for order minimization.

Returns the non-integer order for an analog band stop filter.

Parameters
----------
wp : scalar
    Edge of passband `passb`.
ind : int, {0, 1}
    Index specifying which `passb` edge to vary (0 or 1).
passb : ndarray
    Two element sequence of fixed passband edges.
stopb : ndarray
    Two element sequence of fixed stopband edges.
gstop : float
    Amount of attenuation in stopband in dB.
gpass : float
    Amount of ripple in the passband in dB.
type : {'butter', 'cheby', 'ellip'}
    Type of filter.

Returns
-------
n : scalar
    Filter order (possibly non-integer).</docstring>
    <inputPortSpec arg="wp" name="wp" port_type="basic:Float" show_port="True">
      <docstring>Edge of passband `passb`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ind" name="ind" port_type="basic:Integer" show_port="True">
      <docstring>Index specifying which `passb` edge to vary (0 or 1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1]]</values>
    </inputPortSpec>
    <inputPortSpec arg="passb" name="passb" port_type="basic:List" show_port="True">
      <docstring>Two element sequence of fixed passband edges.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="stopb" name="stopb" port_type="basic:List" show_port="True">
      <docstring>Two element sequence of fixed stopband edges.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gstop" name="gstop" port_type="basic:Float" show_port="True">
      <docstring>Amount of attenuation in stopband in dB.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gpass" name="gpass" port_type="basic:Float" show_port="True">
      <docstring>Amount of ripple in the passband in dB.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" show_port="True">
      <docstring>Type of filter.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['butter', 'cheby', 'ellip']]</values>
    </inputPortSpec>
    <outputPortSpec arg="n" name="n" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Filter order (possibly non-integer).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.barthann" module_name="barthann" namespace="'signal'">
    <docstring>Return a modified Bartlett-Hann window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.barthann(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Bartlett-Hann window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Bartlett-Hann window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.bartlett" module_name="bartlett" namespace="'signal'">
    <docstring>Return a Bartlett window.

The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The triangular window, with the first and last samples equal to zero
    and the maximum value normalized to 1 (though the value 1 does not
    appear if `M` is even and `sym` is True).

Notes
-----
The Bartlett window is defined as

.. math:: w(n) = \frac{2}{M-1} \left(
          \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
          \right)

Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means"removing the foot", i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The Fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich.

References
----------
.. [1] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
       Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
       Processing", Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, "Window function",
       http://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 429.

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.bartlett(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Bartlett window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Bartlett window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The triangular window, with the first and last samples equal to zero
and the maximum value normalized to 1 (though the value 1 does not
appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.bessel" module_name="bessel" namespace="'signal'" output_type="list">
    <docstring>Bessel/Thomson digital and analog filter design.

Design an Nth order digital or analog Bessel filter and return the
filter coefficients.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For a Bessel filter, this is defined as the point at which the
    asymptotes of the response are the same as a Butterworth filter of
    the same order.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

Notes
-----
Also known as a Thomson filter, the analog Bessel filter has maximally
flat group delay and maximally linear phase response, with very little
ringing in the step response.

As order increases, the Bessel filter approaches a Gaussian filter.

The digital Bessel filter is generated using the bilinear
transform, which does not preserve the phase response of the analog
filter. As such, it is only approximately correct at frequencies
below about fs/4.  To get maximally flat group delay at higher
frequencies, the analog Bessel filter must be transformed using
phase-preserving techniques.

For a given `Wn`, the lowpass and highpass filter have the same phase vs
frequency curves; they are "phase-matched".

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Plot the filter's frequency response, showing the flat group delay and
the relationship to the Butterworth's cutoff frequency:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; b, a = signal.butter(4, 100, 'low', analog=True)
&gt;&gt;&gt; w, h = signal.freqs(b, a)
&gt;&gt;&gt; plt.plot(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed')
&gt;&gt;&gt; b, a = signal.bessel(4, 100, 'low', analog=True)
&gt;&gt;&gt; w, h = signal.freqs(b, a)
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h)))
&gt;&gt;&gt; plt.title('Bessel filter frequency response (with Butterworth)')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.margins(0, 0.1)
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))
&gt;&gt;&gt; plt.title('Bessel filter group delay')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Group delay [seconds]')
&gt;&gt;&gt; plt.margins(0, 0.1)
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Wn" name="Wn" port_type="basic:List" show_port="True">
      <docstring>A scalar or length-2 sequence giving the critical frequencies.
For a Bessel filter, this is defined as the point at which the
asymptotes of the response are the same as a Butterworth filter of
the same order.
For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`Wn` is thus in
half-cycles / sample.)
For analog filters, `Wn` is an angular frequency (e.g. rad/s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="btype" name="btype">
      <docstring>The type of filter.  Default is 'lowpass'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lowpass', 'highpass', 'bandpass', 'bandstop']]</values>
      <defaults>['low']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.besselap" module_name="besselap" namespace="'signal'" output_type="list">
    <docstring>Return (z,p,k) for analog prototype of an Nth order Bessel filter.

The filter is normalized such that the filter asymptotes are the same as
a Butterworth filter of the same order with an angular (e.g. rad/s)
cutoff frequency of 1.

Parameters
----------
N : int
    The order of the Bessel filter to return zeros, poles and gain for.
    Values in the range 0-25 are supported.

Returns
-------
z : ndarray
    Zeros. Is always an empty array.
p : ndarray
    Poles.
k : scalar
    Gain. Always 1.</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the Bessel filter to return zeros, poles and gain for.
Values in the range 0-25 are supported.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Zeros. Is always an empty array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Poles.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Gain. Always 1.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.bilinear" module_name="bilinear" namespace="'signal'">
    <docstring>Return a digital filter from an analog one using a bilinear transform.

The bilinear transform substitutes ``(z-1) / (z+1)`` for ``s``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="fs" name="fs" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.blackman" module_name="blackman" namespace="'signal'">
    <docstring>Return a Blackman window.

The Blackman window is a taper formed by using the first three terms of
a summation of cosines. It was designed to have close to the minimal
leakage possible.  It is close to optimal, only slightly worse than a
Kaiser window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Blackman window is defined as

.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)

Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
"near optimal" tapering function, almost as good (by some measures)
as the Kaiser window.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
       Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.blackman(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Blackman window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Blackman window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.blackmanharris" module_name="blackmanharris" namespace="'signal'">
    <docstring>Return a minimum 4-term Blackman-Harris window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.blackmanharris(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Blackman-Harris window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Blackman-Harris window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.bode" module_name="bode" namespace="'signal'" output_type="list">
    <docstring>Calculate Bode magnitude and phase data of a continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

w : array_like, optional
    Array of frequencies (in rad/s). Magnitude and phase data is calculated
    for every value in this array. If not given a reasonable set will be
    calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
    Frequency array [rad/s]
mag : 1D ndarray
    Magnitude array [dB]
phase : 1D ndarray
    Phase array [deg]

Notes
-----

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; s1 = signal.lti([1], [1, 1])
&gt;&gt;&gt; w, mag, phase = signal.bode(s1)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>The following gives the number of elements in the tuple and
the interpretation:

    * 2 (num, den)
    * 3 (zeros, poles, gain)
    * 4 (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Array of frequencies (in rad/s). Magnitude and phase data is calculated
for every value in this array. If not given a reasonable set will be
calculated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Number of frequency points to compute if `w` is not given. The `n`
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</docstring>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Frequency array [rad/s]</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mag" name="mag" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Magnitude array [dB]</docstring>
    </outputPortSpec>
    <outputPortSpec arg="phase" name="phase" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Phase array [deg]</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.bohman" module_name="bohman" namespace="'signal'">
    <docstring>Return a Bohman window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.bohman(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Bohman window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Bohman window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.boxcar" module_name="boxcar" namespace="'signal'">
    <docstring>Return a boxcar or rectangular window.

Included for completeness, this is equivalent to no window at all.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    Whether the window is symmetric. (Has no effect for boxcar.)

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1.

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.boxcar(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Boxcar window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the boxcar window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>Whether the window is symmetric. (Has no effect for boxcar.)</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.bspline" module_name="bspline" namespace="'signal'">
    <docstring>B-spline basis function of order n.

Notes
-----
Uses numpy.piecewise and automatic function-generator.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.buttap" module_name="buttap" namespace="'signal'">
    <docstring>Return (z,p,k) for analog prototype of Nth order Butterworth filter.

The filter will have an angular (e.g. rad/s) cutoff frequency of 1.</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.butter" module_name="butter" namespace="'signal'" output_type="list">
    <docstring>Butterworth digital and analog filter design.

Design an Nth order digital or analog Butterworth filter and return
the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For a Butterworth filter, this is the point at which the gain
    drops to 1/sqrt(2) that of the passband (the "-3 dB point").
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

See Also
--------
buttord

Notes
-----
The Butterworth filter has maximally flat frequency response in the
passband.

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Plot the filter's frequency response, showing the critical points:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; b, a = signal.butter(4, 100, 'low', analog=True)
&gt;&gt;&gt; w, h = signal.freqs(b, a)
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Butterworth filter frequency response')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.margins(0, 0.1)
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Wn" name="Wn" port_type="basic:List" show_port="True">
      <docstring>A scalar or length-2 sequence giving the critical frequencies.
For a Butterworth filter, this is the point at which the gain
drops to 1/sqrt(2) that of the passband (the "-3 dB point").
For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`Wn` is thus in
half-cycles / sample.)
For analog filters, `Wn` is an angular frequency (e.g. rad/s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="btype" name="btype">
      <docstring>The type of filter.  Default is 'lowpass'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lowpass', 'highpass', 'bandpass', 'bandstop']]</values>
      <defaults>['low']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.buttord" module_name="buttord" namespace="'signal'" output_type="list">
    <docstring>Butterworth filter order selection.

Return the order of the lowest order digital or analog Butterworth filter
that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for a Butterworth filter which meets specs.
wn : ndarray or float
    The Butterworth natural frequency (i.e. the "3dB frequency").  Should
    be used with `butter` to give filter results.

See Also
--------
butter : Filter design using order and critical points
cheb1ord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design an analog bandpass filter with passband within 3 dB from 20 to
50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s.
Plot its frequency response, showing the passband and stopband
constraints in gray.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True)
&gt;&gt;&gt; b, a = signal.butter(N, Wn, 'band', True)
&gt;&gt;&gt; w, h = signal.freqs(b, a, np.logspace(1, 2, 500))
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Butterworth bandpass filter fit to constraints')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], '0.9', lw=0) # stop
&gt;&gt;&gt; plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], '0.9', lw=0) # pass
&gt;&gt;&gt; plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], '0.9', lw=0) # stop
&gt;&gt;&gt; plt.axis([10, 100, -60, 3])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="wp" name="wp" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ws" name="ws" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gpass" name="gpass" port_type="basic:Float" show_port="True">
      <docstring>The maximum loss in the passband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gstop" name="gstop" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation in the stopband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ord" name="ord" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The lowest order for a Butterworth filter which meets specs.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="wn" name="wn" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The Butterworth natural frequency (i.e. the "3dB frequency").  Should
be used with `butter` to give filter results.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cascade" module_name="cascade" namespace="'signal'" output_type="list">
    <docstring>Return (x, phi, psi) at dyadic points ``K/2**J`` from filter coefficients.

Parameters
----------
hk : array_like
    Coefficients of low-pass filter.
J : int, optional
    Values will be computed at grid points ``K/2**J``. Default is 7.

Returns
-------
x : ndarray
    The dyadic points ``K/2**J`` for ``K=0...N * (2**J)-1`` where
    ``len(hk) = len(gk) = N+1``.
phi : ndarray
    The scaling function ``phi(x)`` at `x`:
    ``phi(x) = sum(hk * phi(2x-k))``, where k is from 0 to N.
psi : ndarray, optional
    The wavelet function ``psi(x)`` at `x`:
    ``phi(x) = sum(gk * phi(2x-k))``, where k is from 0 to N.
    `psi` is only returned if `gk` is not None.

Notes
-----
The algorithm uses the vector cascade algorithm described by Strang and
Nguyen in "Wavelets and Filter Banks".  It builds a dictionary of values
and slices for quick reuse.  Then inserts vectors into final vector at the
end.</docstring>
    <inputPortSpec arg="hk" name="hk" port_type="basic:List" show_port="True">
      <docstring>Coefficients of low-pass filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="J" name="J" port_type="basic:Integer">
      <docstring>Values will be computed at grid points ``K/2**J``. Default is 7.</docstring>
      <defaults>[7]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The dyadic points ``K/2**J`` for ``K=0...N * (2**J)-1`` where
``len(hk) = len(gk) = N+1``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="phi" name="phi" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The scaling function ``phi(x)`` at `x`:
``phi(x) = sum(hk * phi(2x-k))``, where k is from 0 to N.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="psi" name="psi" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The wavelet function ``psi(x)`` at `x`:
``phi(x) = sum(gk * phi(2x-k))``, where k is from 0 to N.
`psi` is only returned if `gk` is not None.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cheb1ap" module_name="cheb1ap" namespace="'signal'">
    <docstring>Return (z,p,k) for Nth order Chebyshev type I analog lowpass filter.

The returned filter prototype has `rp` decibels of ripple in the passband.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below ``-rp``.</docstring>
    <inputPortSpec arg="rp" name="rp" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="N" name="N" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cheb1ord" module_name="cheb1ord" namespace="'signal'" output_type="list">
    <docstring>Chebyshev type I filter order selection.

Return the order of the lowest order digital or analog Chebyshev Type I
filter that loses no more than `gpass` dB in the passband and has at
least `gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for a Chebyshev type I filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `cheby1` to give filter results.

See Also
--------
cheby1 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design a digital lowpass filter such that the passband is within 3 dB up
to 0.2*(fs/2), while rejecting at least -40 dB above 0.3*(fs/2).  Plot its
frequency response, showing the passband and stopband constraints in gray.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40)
&gt;&gt;&gt; b, a = signal.cheby1(N, 3, Wn, 'low')
&gt;&gt;&gt; w, h = signal.freqz(b, a)
&gt;&gt;&gt; plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Chebyshev I lowpass filter fit to constraints')
&gt;&gt;&gt; plt.xlabel('Normalized frequency')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], '0.9', lw=0) # stop
&gt;&gt;&gt; plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], '0.9', lw=0) # pass
&gt;&gt;&gt; plt.axis([0.08, 1, -60, 3])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="wp" name="wp" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ws" name="ws" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gpass" name="gpass" port_type="basic:Float" show_port="True">
      <docstring>The maximum loss in the passband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gstop" name="gstop" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation in the stopband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ord" name="ord" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The lowest order for a Chebyshev type I filter that meets specs.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="wn" name="wn" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The Chebyshev natural frequency (the "3dB frequency") for use with
`cheby1` to give filter results.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cheb2ap" module_name="cheb2ap" namespace="'signal'">
    <docstring>Return (z,p,k) for Nth order Chebyshev type I analog lowpass filter.

The returned filter prototype has `rs` decibels of ripple in the stopband.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first reaches ``-rs``.</docstring>
    <inputPortSpec arg="rs" name="rs" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="N" name="N" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cheb2ord" module_name="cheb2ord" namespace="'signal'" output_type="list">
    <docstring>Chebyshev type II filter order selection.

Return the order of the lowest order digital or analog Chebyshev Type II
filter that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for a Chebyshev type II filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `cheby2` to give filter results.

See Also
--------
cheby2 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design a digital bandstop filter which rejects -60 dB from 0.2*(fs/2) to
0.5*(fs/2), while staying within 3 dB below 0.1*(fs/2) or above
0.6*(fs/2).  Plot its frequency response, showing the passband and
stopband constraints in gray.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60)
&gt;&gt;&gt; b, a = signal.cheby2(N, 60, Wn, 'stop')
&gt;&gt;&gt; w, h = signal.freqz(b, a)
&gt;&gt;&gt; plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Chebyshev II bandstop filter fit to constraints')
&gt;&gt;&gt; plt.xlabel('Normalized frequency')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], '0.9', lw=0) # stop
&gt;&gt;&gt; plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], '0.9', lw=0) # pass
&gt;&gt;&gt; plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], '0.9', lw=0) # stop
&gt;&gt;&gt; plt.axis([0.06, 1, -80, 3])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="wp" name="wp" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ws" name="ws" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gpass" name="gpass" port_type="basic:Float" show_port="True">
      <docstring>The maximum loss in the passband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gstop" name="gstop" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation in the stopband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ord" name="ord" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The lowest order for a Chebyshev type II filter that meets specs.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="wn" name="wn" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The Chebyshev natural frequency (the "3dB frequency") for use with
`cheby2` to give filter results.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.chebwin" module_name="chebwin" namespace="'signal'">
    <docstring>Return a Dolph-Chebyshev window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
at : float
    Attenuation (in dB).
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value always normalized to 1

Notes
-----
This window optimizes for the narrowest main lobe width for a given order
`M` and sidelobe equiripple attenuation `at`, using Chebyshev
polynomials.  It was originally developed by Dolph to optimize the
directionality of radio antenna arrays.

Unlike most windows, the Dolph-Chebyshev is defined in terms of its
frequency response:

.. math:: W(k) = \frac
          {\cos\{M \cos^{-1}[\beta \cos(\frac{\pi k}{M})]\}}
          {\cosh[M \cosh^{-1}(\beta)]}

where

.. math:: \beta = \cosh \left [\frac{1}{M}
          \cosh^{-1}(10^\frac{A}{20}) \right ]

and 0 &lt;= abs(k) &lt;= M-1. A is the attenuation in decibels (`at`).

The time domain window is then generated using the IFFT, so
power-of-two `M` are the fastest to generate, and prime number `M` are
the slowest.

The equiripple condition in the frequency domain creates impulses in the
time domain, which appear at the ends of the window.

References
----------
.. [1] C. Dolph, "A current distribution for broadside arrays which
       optimizes the relationship between beam width and side-lobe level",
       Proceedings of the IEEE, Vol. 34, Issue 6
.. [2] Peter Lynch, "The Dolph-Chebyshev Window: A Simple Optimal Filter",
       American Meteorological Society (April 1997)
       http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf
.. [3] F. J. Harris, "On the use of windows for harmonic analysis with the
       discrete Fourier transforms", Proceedings of the IEEE, Vol. 66,
       No. 1, January 1978

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.chebwin(51, at=100)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Dolph-Chebyshev window (100 dB)")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Dolph-Chebyshev window (100 dB)")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="at" name="at" port_type="basic:Float" show_port="True">
      <docstring>Attenuation (in dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value always normalized to 1</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cheby1" module_name="cheby1" namespace="'signal'" output_type="list">
    <docstring>Chebyshev type I digital and analog filter design.

Design an Nth order digital or analog Chebyshev type I filter and
return the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
rp : float
    The maximum ripple allowed below unity gain in the passband.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For Type I filters, this is the point in the transition band at which
    the gain first drops below -`rp`.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

See Also
--------
cheb1ord

Notes
-----
The Chebyshev type I filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the passband and increased ringing in the step response.

Type I filters roll off faster than Type II (`cheby2`), but Type II
filters do not have any ripple in the passband.

The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Plot the filter's frequency response, showing the critical points:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; b, a = signal.cheby1(4, 5, 100, 'low', analog=True)
&gt;&gt;&gt; w, h = signal.freqs(b, a)
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Chebyshev Type I frequency response (rp=5)')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.margins(0, 0.1)
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency
&gt;&gt;&gt; plt.axhline(-5, color='green') # rp
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rp" name="rp" port_type="basic:Float" show_port="True">
      <docstring>The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Wn" name="Wn" port_type="basic:List" show_port="True">
      <docstring>A scalar or length-2 sequence giving the critical frequencies.
For Type I filters, this is the point in the transition band at which
the gain first drops below -`rp`.
For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`Wn` is thus in
half-cycles / sample.)
For analog filters, `Wn` is an angular frequency (e.g. rad/s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="btype" name="btype">
      <docstring>The type of filter.  Default is 'lowpass'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lowpass', 'highpass', 'bandpass', 'bandstop']]</values>
      <defaults>['low']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cheby2" module_name="cheby2" namespace="'signal'" output_type="list">
    <docstring>Chebyshev type II digital and analog filter design.

Design an Nth order digital or analog Chebyshev type II filter and
return the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
rs : float
    The minimum attenuation required in the stop band.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For Type II filters, this is the point in the transition band at which
    the gain first reaches -`rs`.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

See Also
--------
cheb2ord

Notes
-----
The Chebyshev type II filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the stopband and increased ringing in the step response.

Type II filters do not roll off as fast as Type I (`cheby1`).

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Plot the filter's frequency response, showing the critical points:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; b, a = signal.cheby2(4, 40, 100, 'low', analog=True)
&gt;&gt;&gt; w, h = signal.freqs(b, a)
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Chebyshev Type II frequency response (rs=40)')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.margins(0, 0.1)
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency
&gt;&gt;&gt; plt.axhline(-40, color='green') # rs
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rs" name="rs" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation required in the stop band.
Specified in decibels, as a positive number.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Wn" name="Wn" port_type="basic:List" show_port="True">
      <docstring>A scalar or length-2 sequence giving the critical frequencies.
For Type II filters, this is the point in the transition band at which
the gain first reaches -`rs`.
For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`Wn` is thus in
half-cycles / sample.)
For analog filters, `Wn` is an angular frequency (e.g. rad/s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="btype" name="btype">
      <docstring>The type of filter.  Default is 'lowpass'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lowpass', 'highpass', 'bandpass', 'bandstop']]</values>
      <defaults>['low']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.chirp" module_name="chirp" namespace="'signal'">
    <docstring>Frequency-swept cosine generator.

In the following, 'Hz' should be interpreted as 'cycles per unit';
there is no requirement here that the unit is one second.  The
important distinction is that the units of rotation are cycles, not
radians. Likewise, `t` could be a measurement of space instead of time.

Parameters
----------
t : array_like
    Times at which to evaluate the waveform.
f0 : float
    Frequency (e.g. Hz) at time t=0.
t1 : float
    Time at which `f1` is specified.
f1 : float
    Frequency (e.g. Hz) of the waveform at time `t1`.
method : {'linear', 'quadratic', 'logarithmic', 'hyperbolic'}, optional
    Kind of frequency sweep.  If not given, `linear` is assumed.  See
    Notes below for more details.
phi : float, optional
    Phase offset, in degrees. Default is 0.
vertex_zero : bool, optional
    This parameter is only used when `method` is 'quadratic'.
    It determines whether the vertex of the parabola that is the graph
    of the frequency is at t=0 or t=t1.

Returns
-------
y : ndarray
    A numpy array containing the signal evaluated at `t` with the
    requested time-varying frequency.  More precisely, the function
    returns ``cos(phase + (pi/180)*phi)`` where `phase` is the integral
    (from 0 to `t`) of ``2*pi*f(t)``. ``f(t)`` is defined below.

See Also
--------
sweep_poly

Notes
-----
There are four options for the `method`.  The following formulas give
the instantaneous frequency (in Hz) of the signal generated by
`chirp()`.  For convenience, the shorter names shown below may also be
used.

linear, lin, li:

    ``f(t) = f0 + (f1 - f0) * t / t1``

quadratic, quad, q:

    The graph of the frequency f(t) is a parabola through (0, f0) and
    (t1, f1).  By default, the vertex of the parabola is at (0, f0).
    If `vertex_zero` is False, then the vertex is at (t1, f1).  The
    formula is:

    if vertex_zero is True:

        ``f(t) = f0 + (f1 - f0) * t**2 / t1**2``

    else:

        ``f(t) = f1 - (f1 - f0) * (t1 - t)**2 / t1**2``

    To use a more general quadratic function, or an arbitrary
    polynomial, use the function `scipy.signal.waveforms.sweep_poly`.

logarithmic, log, lo:

    ``f(t) = f0 * (f1/f0)**(t/t1)``

    f0 and f1 must be nonzero and have the same sign.

    This signal is also known as a geometric or exponential chirp.

hyperbolic, hyp:

    ``f(t) = f0*f1*t1 / ((f0 - f1)*t + f1*t1)``

    f0 and f1 must be nonzero.</docstring>
    <inputPortSpec arg="t" name="t" port_type="basic:List" show_port="True">
      <docstring>Times at which to evaluate the waveform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f0" name="f0" port_type="basic:Float" show_port="True">
      <docstring>Frequency (e.g. Hz) at time t=0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t1" name="t1" port_type="basic:Float" show_port="True">
      <docstring>Time at which `f1` is specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f1" name="f1" port_type="basic:Float" show_port="True">
      <docstring>Frequency (e.g. Hz) of the waveform at time `t1`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Kind of frequency sweep.  If not given, `linear` is assumed.  See
Notes below for more details.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'quadratic', 'logarithmic', 'hyperbolic']]</values>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="phi" name="phi" port_type="basic:Float">
      <docstring>Phase offset, in degrees. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vertex_zero" name="vertex_zero" port_type="basic:Boolean">
      <docstring>This parameter is only used when `method` is 'quadratic'.
It determines whether the vertex of the parabola that is the graph
of the frequency is at t=0 or t=t1.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A numpy array containing the signal evaluated at `t` with the
requested time-varying frequency.  More precisely, the function
returns ``cos(phase + (pi/180)*phi)`` where `phase` is the integral
(from 0 to `t`) of ``2*pi*f(t)``. ``f(t)`` is defined below.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cmplx_sort" module_name="cmplx_sort" namespace="'signal'" output_type="list">
    <docstring>Sort roots based on magnitude.

Parameters
----------
p : array_like
    The roots to sort, as a 1-D array.

Returns
-------
p_sorted : ndarray
    Sorted roots.
indx : ndarray
    Array of indices needed to sort the input `p`.</docstring>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>The roots to sort, as a 1-D array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="p_sorted" name="p_sorted" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sorted roots.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="indx" name="indx" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Array of indices needed to sort the input `p`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.coherence" module_name="coherence" namespace="'signal'" output_type="list">
    <docstring>Estimate the magnitude squared coherence estimate, Cxy, of discrete-time
signals X and Y using Welch's method.

Cxy = abs(Pxy)**2/(Pxx*Pyy), where Pxx and Pyy are power spectral density
estimates of X and Y, and Pxy is the cross spectral density estimate of X
and Y.

Parameters
----------
x : array_like
    Time series of measurement values
y : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` and `y` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length will be used for nperseg.
    Defaults to 'hanning'.
nperseg : int, optional
    Length of each segment.  Defaults to 256.
noverlap: int, optional
    Number of points to overlap between segments. If None,
    ``noverlap = nperseg // 2``.  Defaults to None.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired.  If None,
    the FFT length is `nperseg`. Defaults to None.
detrend : str or function or False, optional
    Specifies how to detrend each segment. If `detrend` is a string,
    it is passed as the ``type`` argument to `detrend`.  If it is a
    function, it takes a segment and returns a detrended segment.
    If `detrend` is False, no detrending is done.  Defaults to 'constant'.
axis : int, optional
    Axis along which the coherence is computed for both inputs; the default is
    over the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Cxy : ndarray
    Magnitude squared coherence of x and y.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.

Notes
--------
An appropriate amount of overlap will depend on the choice of window
and on your requirements.  For the default 'hanning' window an
overlap of 50\% is a reasonable trade off between accurately estimating
the signal power, while not over counting any of the data.  Narrower
windows may require a larger overlap.

.. versionadded:: 0.16.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Stoica, Petre, and Randolph Moses, "Spectral Analysis of Signals"
       Prentice Hall, 2005

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate two test signals with some common features.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 20
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low')
&gt;&gt;&gt; x = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; y = signal.lfilter(b, a, x)
&gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; y += np.random.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)

Compute and plot the coherence.

&gt;&gt;&gt; f, Cxy = signal.coherence(x, y, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, Cxy)
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Coherence')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fs" name="fs" port_type="basic:Float">
      <docstring>Sampling frequency of the `x` and `y` time series. Defaults to 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" name="windowScalar">
      <docstring>Desired window to use. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length will be used for nperseg.
Defaults to 'hanning'.</docstring>
      <defaults>['hanning']</defaults>
      <alternateSpec arg="window" name="windowSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nperseg" name="nperseg" port_type="basic:Integer">
      <docstring>Length of each segment.  Defaults to 256.</docstring>
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="optional" name="optional" port_type="basic:Variant" show_port="True">
      <docstring>Number of points to overlap between segments. If None,
``noverlap = nperseg // 2``.  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nfft" name="nfft" port_type="basic:Integer">
      <docstring>Length of the FFT used, if a zero padded FFT is desired.  If None,
the FFT length is `nperseg`. Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" name="detrend">
      <docstring>Specifies how to detrend each segment. If `detrend` is a string,
it is passed as the ``type`` argument to `detrend`.  If it is a
function, it takes a segment and returns a detrended segment.
If `detrend` is False, no detrending is done.  Defaults to 'constant'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['function']]</values>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the coherence is computed for both inputs; the default is
over the last axis (i.e. ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" name="noverlap" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of sample frequencies.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Cxy" name="Cxy" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Magnitude squared coherence of x and y.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cont2discrete" module_name="cont2discrete" namespace="'signal'">
    <docstring>Transform a continuous to a discrete state-space system.

Parameters
----------
sys : a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

       * 2: (num, den)
       * 3: (zeros, poles, gain)
       * 4: (A, B, C, D)

dt : float
    The discretization time step.
method : {"gbt", "bilinear", "euler", "backward_diff", "zoh"}, optional
    Which method to use:

       * gbt: generalized bilinear transformation
       * bilinear: Tustin's approximation ("gbt" with alpha=0.5)
       * euler: Euler (or forward differencing) method ("gbt" with alpha=0)
       * backward_diff: Backwards differencing ("gbt" with alpha=1.0)
       * zoh: zero-order hold (default)

alpha : float within [0, 1], optional
    The generalized bilinear transformation weighting parameter, which
    should only be specified with method="gbt", and is ignored otherwise

Returns
-------
sysd : tuple containing the discrete system
    Based on the input type, the output will be of the form

    * (num, den, dt)   for transfer function input
    * (zeros, poles, gain, dt)   for zeros-poles-gain input
    * (A, B, C, D, dt) for state-space system input

Notes
-----
By default, the routine uses a Zero-Order Hold (zoh) method to perform
the transformation.  Alternatively, a generalized bilinear transformation
may be used, which includes the common Tustin's bilinear approximation,
an Euler's method technique, or a backwards differencing technique.

The Zero-Order Hold (zoh) method is based on [1]_, the generalized bilinear
approximation is based on [2]_ and [3]_.

References
----------
.. [1] http://en.wikipedia.org/wiki/Discretization#Discretization_of_linear_state_space_models

.. [2] http://techteach.no/publications/discretetime_signals_systems/discrete.pdf

.. [3] G. Zhang, X. Chen, and T. Chen, Digital redesign via the generalized
    bilinear transformation, Int. J. Control, vol. 82, no. 4, pp. 741-754,
    2009.
    (http://www.ece.ualberta.ca/~gfzhang/research/ZCC07_preprint.pdf)</docstring>
    <inputPortSpec arg="sys" name="sys" port_type="basic:List" show_port="True">
      <docstring>The following gives the number of elements in the tuple and
the interpretation:

   * 2: (num, den)
   * 3: (zeros, poles, gain)
   * 4: (A, B, C, D)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dt" name="dt" port_type="basic:Float" show_port="True">
      <docstring>The discretization time step.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Which method to use:

   * gbt: generalized bilinear transformation
   * bilinear: Tustin's approximation ("gbt" with alpha=0.5)
   * euler: Euler (or forward differencing) method ("gbt" with alpha=0)
   * backward_diff: Backwards differencing ("gbt" with alpha=1.0)
   * zoh: zero-order hold (default)
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['gbt', 'bilinear', 'euler', 'backward_diff', 'zoh']]</values>
      <defaults>['zoh']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>The generalized bilinear transformation weighting parameter, which
should only be specified with method="gbt", and is ignored otherwise</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sysd" name="sysd" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Based on the input type, the output will be of the form

* (num, den, dt)   for transfer function input
* (zeros, poles, gain, dt)   for zeros-poles-gain input
* (A, B, C, D, dt) for state-space system input</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.convolve" module_name="convolve" namespace="'signal'">
    <docstring>Convolve two N-dimensional arrays.

Convolve `in1` and `in2`, with the output size determined by the
`mode` argument.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`;
    if sizes of `in1` and `in2` are not equal then `in1` has to be the
    larger array.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

Returns
-------
convolve : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

See also
--------
numpy.polymul : performs polynomial multiplication (same operation, but
                also accepts poly1d objects)

Examples
--------
Smooth a square pulse using a Hann window:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; sig = np.repeat([0., 1., 0.], 100)
&gt;&gt;&gt; win = signal.hann(50)
&gt;&gt;&gt; filtered = signal.convolve(sig, win, mode='same') / sum(win)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.set_title('Original pulse')
&gt;&gt;&gt; ax_orig.margins(0, 0.1)
&gt;&gt;&gt; ax_win.plot(win)
&gt;&gt;&gt; ax_win.set_title('Filter impulse response')
&gt;&gt;&gt; ax_win.margins(0, 0.1)
&gt;&gt;&gt; ax_filt.plot(filtered)
&gt;&gt;&gt; ax_filt.set_title('Filtered signal')
&gt;&gt;&gt; ax_filt.margins(0, 0.1)
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; fig.show()</docstring>
    <inputPortSpec arg="in1" name="in1" port_type="basic:List" show_port="True">
      <docstring>First input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="in2" name="in2" port_type="basic:List" show_port="True">
      <docstring>Second input. Should have the same number of dimensions as `in1`;
if sizes of `in1` and `in2` are not equal then `in1` has to be the
larger array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>A string indicating the size of the output:

``full``
   The output is the full discrete linear convolution
   of the inputs. (Default)
``valid``
   The output consists only of those elements that do not
   rely on the zero-padding.
``same``
   The output is the same size as `in1`, centered
   with respect to the 'full' output.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'valid', 'same']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="convolve" name="convolve" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An N-dimensional array containing a subset of the discrete linear
convolution of `in1` with `in2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.convolve2d" module_name="convolve2d" namespace="'signal'">
    <docstring>Convolve two 2-dimensional arrays.

Convolve `in1` and `in2` with output size determined by `mode`, and
boundary conditions determined by `boundary` and `fillvalue`.

Parameters
----------
in1, in2 : array_like
    Two-dimensional input arrays to be convolved.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

boundary : str {'fill', 'wrap', 'symm'}, optional
    A flag indicating how to handle boundaries:

    ``fill``
       pad input arrays with fillvalue. (default)
    ``wrap``
       circular boundary conditions.
    ``symm``
       symmetrical boundary conditions.

fillvalue : scalar, optional
    Value to fill pad input arrays with. Default is 0.

Returns
-------
out : ndarray
    A 2-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

Examples
--------
Compute the gradient of an image by 2D convolution with a complex Scharr
operator.  (Horizontal operator is real, vertical is imaginary.)  Use
symmetric boundary condition to avoid creating edges at the image
boundaries.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; lena = misc.lena()
&gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],
...                    [-10+0j, 0+ 0j, +10 +0j],
...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy
&gt;&gt;&gt; grad = signal.convolve2d(lena, scharr, boundary='symm', mode='same')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(1, 3)
&gt;&gt;&gt; ax_orig.imshow(lena, cmap='gray')
&gt;&gt;&gt; ax_orig.set_title('Original')
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap='gray')
&gt;&gt;&gt; ax_mag.set_title('Gradient magnitude')
&gt;&gt;&gt; ax_mag.set_axis_off()
&gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap='hsv') # hsv is cyclic, like angles
&gt;&gt;&gt; ax_ang.set_title('Gradient orientation')
&gt;&gt;&gt; ax_ang.set_axis_off()
&gt;&gt;&gt; fig.show()</docstring>
    <inputPortSpec arg="in1" name="in1" port_type="basic:List" show_port="True">
      <docstring>Two-dimensional input arrays to be convolved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="in2" name="in2" port_type="basic:List" show_port="True">
      <docstring>Two-dimensional input arrays to be convolved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>A string indicating the size of the output:

``full``
   The output is the full discrete linear convolution
   of the inputs. (Default)
``valid``
   The output consists only of those elements that do not
   rely on the zero-padding.
``same``
   The output is the same size as `in1`, centered
   with respect to the 'full' output.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'valid', 'same']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="boundary" name="boundary">
      <docstring>A flag indicating how to handle boundaries:

``fill``
   pad input arrays with fillvalue. (default)
``wrap``
   circular boundary conditions.
``symm``
   symmetrical boundary conditions.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['fill', 'wrap', 'symm']]</values>
      <defaults>['fill']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fillvalue" name="fillvalue" port_type="basic:Float">
      <docstring>Value to fill pad input arrays with. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 2-dimensional array containing a subset of the discrete linear
convolution of `in1` with `in2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.correlate" module_name="correlate" namespace="'signal'">
    <docstring>Cross-correlate two N-dimensional arrays.

Cross-correlate `in1` and `in2`, with the output size determined by the
`mode` argument.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`;
    if sizes of `in1` and `in2` are not equal then `in1` has to be the
    larger array.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear cross-correlation
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

Returns
-------
correlate : array
    An N-dimensional array containing a subset of the discrete linear
    cross-correlation of `in1` with `in2`.

Notes
-----
The correlation z of two d-dimensional arrays x and y is defined as:

  z[...,k,...] = sum[..., i_l, ...]
                     x[..., i_l,...] * conj(y[..., i_l + k,...])

Examples
--------
Implement a matched filter using cross-correlation, to recover a signal
that has passed through a noisy channel.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)
&gt;&gt;&gt; sig_noise = sig + np.random.randn(len(sig))
&gt;&gt;&gt; corr = signal.correlate(sig_noise, np.ones(128), mode='same') / 128

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; clock = np.arange(64, len(sig), 128)
&gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.plot(clock, sig[clock], 'ro')
&gt;&gt;&gt; ax_orig.set_title('Original signal')
&gt;&gt;&gt; ax_noise.plot(sig_noise)
&gt;&gt;&gt; ax_noise.set_title('Signal with noise')
&gt;&gt;&gt; ax_corr.plot(corr)
&gt;&gt;&gt; ax_corr.plot(clock, corr[clock], 'ro')
&gt;&gt;&gt; ax_corr.axhline(0.5, ls=':')
&gt;&gt;&gt; ax_corr.set_title('Cross-correlated with rectangular pulse')
&gt;&gt;&gt; ax_orig.margins(0, 0.1)
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; fig.show()</docstring>
    <inputPortSpec arg="in1" name="in1" port_type="basic:List" show_port="True">
      <docstring>First input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="in2" name="in2" port_type="basic:List" show_port="True">
      <docstring>Second input. Should have the same number of dimensions as `in1`;
if sizes of `in1` and `in2` are not equal then `in1` has to be the
larger array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>A string indicating the size of the output:

``full``
   The output is the full discrete linear cross-correlation
   of the inputs. (Default)
``valid``
   The output consists only of those elements that do not
   rely on the zero-padding.
``same``
   The output is the same size as `in1`, centered
   with respect to the 'full' output.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'valid', 'same']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="correlate" name="correlate" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An N-dimensional array containing a subset of the discrete linear
cross-correlation of `in1` with `in2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.correlate2d" module_name="correlate2d" namespace="'signal'">
    <docstring>Cross-correlate two 2-dimensional arrays.

Cross correlate `in1` and `in2` with output size determined by `mode`, and
boundary conditions determined by `boundary` and `fillvalue`.

Parameters
----------
in1, in2 : array_like
    Two-dimensional input arrays to be convolved.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear cross-correlation
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

boundary : str {'fill', 'wrap', 'symm'}, optional
    A flag indicating how to handle boundaries:

    ``fill``
       pad input arrays with fillvalue. (default)
    ``wrap``
       circular boundary conditions.
    ``symm``
       symmetrical boundary conditions.

fillvalue : scalar, optional
    Value to fill pad input arrays with. Default is 0.

Returns
-------
correlate2d : ndarray
    A 2-dimensional array containing a subset of the discrete linear
    cross-correlation of `in1` with `in2`.

Examples
--------
Use 2D cross-correlation to find the location of a template in a noisy
image:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; lena = misc.lena() - misc.lena().mean()
&gt;&gt;&gt; template = np.copy(lena[235:295, 310:370]) # right eye
&gt;&gt;&gt; template -= template.mean()
&gt;&gt;&gt; lena = lena + np.random.randn(*lena.shape) * 50 # add noise
&gt;&gt;&gt; corr = signal.correlate2d(lena, template, boundary='symm', mode='same')
&gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape) # find the match

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(1, 3)
&gt;&gt;&gt; ax_orig.imshow(lena, cmap='gray')
&gt;&gt;&gt; ax_orig.set_title('Original')
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_template.imshow(template, cmap='gray')
&gt;&gt;&gt; ax_template.set_title('Template')
&gt;&gt;&gt; ax_template.set_axis_off()
&gt;&gt;&gt; ax_corr.imshow(corr, cmap='gray')
&gt;&gt;&gt; ax_corr.set_title('Cross-correlation')
&gt;&gt;&gt; ax_corr.set_axis_off()
&gt;&gt;&gt; ax_orig.plot(x, y, 'ro')
&gt;&gt;&gt; fig.show()</docstring>
    <inputPortSpec arg="in1" name="in1" port_type="basic:List" show_port="True">
      <docstring>Two-dimensional input arrays to be convolved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="in2" name="in2" port_type="basic:List" show_port="True">
      <docstring>Two-dimensional input arrays to be convolved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>A string indicating the size of the output:

``full``
   The output is the full discrete linear cross-correlation
   of the inputs. (Default)
``valid``
   The output consists only of those elements that do not
   rely on the zero-padding.
``same``
   The output is the same size as `in1`, centered
   with respect to the 'full' output.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'valid', 'same']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="boundary" name="boundary">
      <docstring>A flag indicating how to handle boundaries:

``fill``
   pad input arrays with fillvalue. (default)
``wrap``
   circular boundary conditions.
``symm``
   symmetrical boundary conditions.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['fill', 'wrap', 'symm']]</values>
      <defaults>['fill']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fillvalue" name="fillvalue" port_type="basic:Float">
      <docstring>Value to fill pad input arrays with. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="correlate2d" name="correlate2d" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 2-dimensional array containing a subset of the discrete linear
cross-correlation of `in1` with `in2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cosine" module_name="cosine" namespace="'signal'">
    <docstring>Return a window with a simple cosine shape.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----

.. versionadded:: 0.13.0

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.cosine(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Cosine window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the cosine window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.csd" module_name="csd" namespace="'signal'" output_type="list">
    <docstring>Estimate the cross power spectral density, Pxy, using Welch's method.

Parameters
----------
x : array_like
    Time series of measurement values
y : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` and `y` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length will be used for nperseg.
    Defaults to 'hanning'.
nperseg : int, optional
    Length of each segment.  Defaults to 256.
noverlap: int, optional
    Number of points to overlap between segments. If None,
    ``noverlap = nperseg // 2``.  Defaults to None.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired.  If None,
    the FFT length is `nperseg`. Defaults to None.
detrend : str or function or False, optional
    Specifies how to detrend each segment. If `detrend` is a string,
    it is passed as the ``type`` argument to `detrend`.  If it is a
    function, it takes a segment and returns a detrended segment.
    If `detrend` is False, no detrending is done.  Defaults to 'constant'.
return_onesided : bool, optional
    If True, return a one-sided spectrum for real data. If False return
    a two-sided spectrum. Note that for complex data, a two-sided
    spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the cross spectral density ('density')
    where `Pxy` has units of V**2/Hz and computing the cross spectrum
    ('spectrum') where `Pxy` has units of V**2, if `x` and `y` are
    measured in V and fs is measured in Hz.  Defaults to 'density'
axis : int, optional
    Axis along which the CSD is computed for both inputs; the default is
    over the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxy : ndarray
    Cross spectral density or cross power spectrum of x,y.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method. [Equivalent to csd(x,x)]
coherence: Magnitude squared coherence by Welch's method.

Notes
--------
By convention, Pxy is computed with the conjugate FFT of X multiplied by
the FFT of Y.

If the input series differ in length, the shorter series will be
zero-padded to match.

An appropriate amount of overlap will depend on the choice of window
and on your requirements.  For the default 'hanning' window an
overlap of 50\% is a reasonable trade off between accurately estimating
the signal power, while not over counting any of the data.  Narrower
windows may require a larger overlap.

.. versionadded:: 0.16.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Rabiner, Lawrence R., and B. Gold. "Theory and Application of
       Digital Signal Processing" Prentice-Hall, pp. 414-419, 1975

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate two test signals with some common features.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 20
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low')
&gt;&gt;&gt; x = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; y = signal.lfilter(b, a, x)
&gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; y += np.random.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)

Compute and plot the magnitude of the cross spectral density.

&gt;&gt;&gt; f, Pxy = signal.csd(x, y, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, np.abs(Pxy))
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('CSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fs" name="fs" port_type="basic:Float">
      <docstring>Sampling frequency of the `x` and `y` time series. Defaults to 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" name="windowScalar">
      <docstring>Desired window to use. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length will be used for nperseg.
Defaults to 'hanning'.</docstring>
      <defaults>['hanning']</defaults>
      <alternateSpec arg="window" name="windowSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nperseg" name="nperseg" port_type="basic:Integer">
      <docstring>Length of each segment.  Defaults to 256.</docstring>
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="optional" name="optional" port_type="basic:Variant" show_port="True">
      <docstring>Number of points to overlap between segments. If None,
``noverlap = nperseg // 2``.  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nfft" name="nfft" port_type="basic:Integer">
      <docstring>Length of the FFT used, if a zero padded FFT is desired.  If None,
the FFT length is `nperseg`. Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" name="detrend">
      <docstring>Specifies how to detrend each segment. If `detrend` is a string,
it is passed as the ``type`` argument to `detrend`.  If it is a
function, it takes a segment and returns a detrended segment.
If `detrend` is False, no detrending is done.  Defaults to 'constant'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['function']]</values>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_onesided" name="return_onesided" port_type="basic:Boolean">
      <docstring>If True, return a one-sided spectrum for real data. If False return
a two-sided spectrum. Note that for complex data, a two-sided
spectrum is always returned.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scaling" name="scaling">
      <docstring>Selects between computing the cross spectral density ('density')
where `Pxy` has units of V**2/Hz and computing the cross spectrum
('spectrum') where `Pxy` has units of V**2, if `x` and `y` are
measured in V and fs is measured in Hz.  Defaults to 'density'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['density', 'spectrum']]</values>
      <defaults>['density']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the CSD is computed for both inputs; the default is
over the last axis (i.e. ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" name="noverlap" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of sample frequencies.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Pxy" name="Pxy" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Cross spectral density or cross power spectrum of x,y.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cspline1d" module_name="cspline1d" namespace="'signal'">
    <docstring>Compute cubic spline coefficients for rank-1 array.

Find the cubic spline coefficients for a 1-D signal assuming
mirror-symmetric boundary conditions.   To obtain the signal back from the
spline representation mirror-symmetric-convolve these coefficients with a
length 3 FIR window [1.0, 4.0, 1.0]/ 6.0 .

Parameters
----------
signal : ndarray
    A rank-1 array representing samples of a signal.
lamb : float, optional
    Smoothing coefficient, default is 0.0.

Returns
-------
c : ndarray
    Cubic spline coefficients.</docstring>
    <inputPortSpec arg="signal" name="signal" port_type="basic:List" show_port="True">
      <docstring>A rank-1 array representing samples of a signal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lamb" name="lamb" port_type="basic:Float">
      <docstring>Smoothing coefficient, default is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Cubic spline coefficients.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cspline1d_eval" module_name="cspline1d_eval" namespace="'signal'">
    <docstring>Evaluate a spline at the new set of points.

`dx` is the old sample-spacing while `x0` was the old origin.  In
other-words the old-sample points (knot-points) for which the `cj`
represent spline coefficients were at equally-spaced points of:

  oldx = x0 + j*dx  j=0...N-1, with N=len(cj)

Edges are handled using mirror-symmetric boundary conditions.</docstring>
    <inputPortSpec arg="cj" name="cj" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="newx" name="newx" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="x0" name="x0" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cspline2d" module_name="cspline2d" namespace="'signal'">
    <docstring>cspline2d(input {, lambda, precision}) -&gt; ck

Description:

  Return the third-order B-spline coefficients over a regularly spacedi
  input grid for the two-dimensional input image.  The lambda argument
  specifies the amount of smoothing.  The precision argument allows specifying
  the precision used when computing the infinite sum needed to apply mirror-
  symmetric boundary conditions.</docstring>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cubic" module_name="cubic" namespace="'signal'">
    <docstring>A cubic B-spline.

This is a special case of `bspline`, and equivalent to ``bspline(x, 3)``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.cwt" module_name="cwt" namespace="'signal'" output_type="list">
    <docstring>Continuous wavelet transform.

Performs a continuous wavelet transform on `data`,
using the `wavelet` function. A CWT performs a convolution
with `data` using the `wavelet` function, which is characterized
by a width parameter and length parameter.

Parameters
----------
data : (N,) ndarray
    data on which to perform the transform.
wavelet : function
    Wavelet function, which should take 2 arguments.
    The first argument is the number of points that the returned vector
    will have (len(wavelet(width,length)) == length).
    The second is a width parameter, defining the size of the wavelet
    (e.g. standard deviation of a gaussian). See `ricker`, which
    satisfies these requirements.
widths : (M,) sequence
    Widths to use for transform.

Returns
-------
cwt: (M, N) ndarray
    Will have shape of (len(widths), len(data)).

Notes
-----
&gt;&gt;&gt; length = min(10 * width[ii], len(data))
&gt;&gt;&gt; cwt[ii,:] = scipy.signal.convolve(data, wavelet(length,
...                                       width[ii]), mode='same')

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.linspace(-1, 1, 200, endpoint=False)
&gt;&gt;&gt; sig  = np.cos(2 * np.pi * 7 * t) + signal.gausspulse(t - 0.4, fc=2)
&gt;&gt;&gt; widths = np.arange(1, 31)
&gt;&gt;&gt; cwtmatr = signal.cwt(sig, signal.ricker, widths)
&gt;&gt;&gt; plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',
...            vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>data on which to perform the transform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="wavelet" name="wavelet" port_type="basic:Variant" show_port="True">
      <docstring>Wavelet function, which should take 2 arguments.
The first argument is the number of points that the returned vector
will have (len(wavelet(width,length)) == length).
The second is a width parameter, defining the size of the wavelet
(e.g. standard deviation of a gaussian). See `ricker`, which
satisfies these requirements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="widths" name="widths" port_type="basic:List" show_port="True">
      <docstring>Widths to use for transform.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Will have shape of (len(widths), len(data)).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Will have shape of (len(widths), len(data)).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.daub" module_name="daub" namespace="'signal'">
    <docstring>The coefficients for the FIR low-pass filter producing Daubechies wavelets.

p&gt;=1 gives the order of the zero at f=1/2.
There are 2p filter coefficients.

Parameters
----------
p : int
    Order of the zero at f=1/2, can have values from 1 to 34.

Returns
-------
daub : ndarray
    Return</docstring>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer" show_port="True">
      <docstring>Order of the zero at f=1/2, can have values from 1 to 34.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="daub" name="daub" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Return</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.decimate" module_name="decimate" namespace="'signal'">
    <docstring>Downsample the signal by using a filter.

By default, an order 8 Chebyshev type I filter is used.  A 30 point FIR
filter with hamming window is used if `ftype` is 'fir'.

Parameters
----------
x : ndarray
    The signal to be downsampled, as an N-dimensional array.
q : int
    The downsampling factor.
n : int, optional
    The order of the filter (1 less than the length for 'fir').
ftype : str {'iir', 'fir'}, optional
    The type of the lowpass filter.
axis : int, optional
    The axis along which to decimate.

Returns
-------
y : ndarray
    The down-sampled signal.

See also
--------
resample</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The signal to be downsampled, as an N-dimensional array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q" name="q" port_type="basic:Integer" show_port="True">
      <docstring>The downsampling factor.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>The order of the filter (1 less than the length for 'fir').</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ftype" name="ftype">
      <docstring>The type of the lowpass filter.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['iir', 'fir']]</values>
      <defaults>['iir']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which to decimate.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The down-sampled signal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.deconvolve" module_name="deconvolve" namespace="'signal'" output_type="list">
    <docstring>Deconvolves ``divisor`` out of ``signal``.

Returns the quotient and remainder such that
``signal = convolve(divisor, quotient) + remainder``

Parameters
----------
signal : array_like
    Signal data, typically a recorded signal
divisor : array_like
    Divisor data, typically an impulse response or filter that was
    applied to the original signal

Returns
-------
quotient : ndarray
    Quotient, typically the recovered original signal
remainder : ndarray
    Remainder

Examples
--------
Deconvolve a signal that's been filtered:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; original = [0, 1, 0, 0, 1, 1, 0, 0]
&gt;&gt;&gt; impulse_response = [2, 1]
&gt;&gt;&gt; recorded = signal.convolve(impulse_response, original)
&gt;&gt;&gt; recorded
array([0, 2, 1, 0, 2, 3, 1, 0, 0])
&gt;&gt;&gt; recovered, remainder = signal.deconvolve(recorded, impulse_response)
&gt;&gt;&gt; recovered
array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])

See also
--------
numpy.polydiv : performs polynomial division (same operation, but
                also accepts poly1d objects)</docstring>
    <inputPortSpec arg="signal" name="signal" port_type="basic:List" show_port="True">
      <docstring>Signal data, typically a recorded signal</docstring>
    </inputPortSpec>
    <inputPortSpec arg="divisor" name="divisor" port_type="basic:List" show_port="True">
      <docstring>Divisor data, typically an impulse response or filter that was
applied to the original signal</docstring>
    </inputPortSpec>
    <outputPortSpec arg="quotient" name="quotient" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Quotient, typically the recovered original signal</docstring>
    </outputPortSpec>
    <outputPortSpec arg="remainder" name="remainder" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Remainder</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.detrend" module_name="detrend" namespace="'signal'">
    <docstring>Remove linear trend along axis from data.

Parameters
----------
data : array_like
    The input data.
axis : int, optional
    The axis along which to detrend the data. By default this is the
    last axis (-1).
type : {'linear', 'constant'}, optional
    The type of detrending. If ``type == 'linear'`` (default),
    the result of a linear least-squares fit to `data` is subtracted
    from `data`.
    If ``type == 'constant'``, only the mean of `data` is subtracted.
bp : array_like of ints, optional
    A sequence of break points. If given, an individual linear fit is
    performed for each part of `data` between two break points.
    Break points are specified as indices into `data`.

Returns
-------
ret : ndarray
    The detrended input data.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; randgen = np.random.RandomState(9)
&gt;&gt;&gt; npoints = 1e3
&gt;&gt;&gt; noise = randgen.randn(npoints)
&gt;&gt;&gt; x = 3 + 2*np.linspace(0, 1, npoints) + noise
&gt;&gt;&gt; (signal.detrend(x) - noise).max() &lt; 0.01
True</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>The input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which to detrend the data. By default this is the
last axis (-1).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type">
      <docstring>The type of detrending. If ``type == 'linear'`` (default),
the result of a linear least-squares fit to `data` is subtracted
from `data`.
If ``type == 'constant'``, only the mean of `data` is subtracted.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'constant']]</values>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bp" name="bpScalar" port_type="basic:Integer">
      <docstring>A sequence of break points. If given, an individual linear fit is
performed for each part of `data` between two break points.
Break points are specified as indices into `data`.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="bp" depth="1" name="bpSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="ret" name="ret" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The detrended input data.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.dimpulse" module_name="dimpulse" namespace="'signal'" output_type="list">
    <docstring>Impulse response of discrete-time system.

Parameters
----------
system : tuple of array_like
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

      * 3: (num, den, dt)
      * 4: (zeros, poles, gain, dt)
      * 5: (A, B, C, D, dt)

x0 : array_like, optional
    Initial state-vector.  Defaults to zero.
t : array_like, optional
    Time points.  Computed if not given.
n : int, optional
    The number of time points to compute (if `t` is not given).

Returns
-------
tout : ndarray
    Time values for the output, as a 1-D array.
yout : ndarray
    Impulse response of system.  Each element of the tuple represents
    the output of the system based on an impulse in each input.

See Also
--------
impulse, dstep, dlsim, cont2discrete</docstring>
    <inputPortSpec arg="system" name="system" port_type="basic:List" show_port="True">
      <docstring>A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:

  * 3: (num, den, dt)
  * 4: (zeros, poles, gain, dt)
  * 5: (A, B, C, D, dt)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List">
      <docstring>Initial state-vector.  Defaults to zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:List">
      <docstring>Time points.  Computed if not given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>The number of time points to compute (if `t` is not given).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tout" name="tout" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Time values for the output, as a 1-D array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Impulse response of system.  Each element of the tuple represents
the output of the system based on an impulse in each input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.dlsim" module_name="dlsim" namespace="'signal'" output_type="list">
    <docstring>Simulate output of a discrete-time linear system.

Parameters
----------
system : tuple of array_like
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

      - 3: (num, den, dt)
      - 4: (zeros, poles, gain, dt)
      - 5: (A, B, C, D, dt)

u : array_like
    An input array describing the input at each time `t` (interpolation is
    assumed between given times).  If there are multiple inputs, then each
    column of the rank-2 array represents an input.
t : array_like, optional
    The time steps at which the input is defined.  If `t` is given, it
    must be the same length as `u`, and the final value in `t` determines
    the number of steps returned in the output.
x0 : array_like, optional
    The initial conditions on the state vector (zero by default).

Returns
-------
tout : ndarray
    Time values for the output, as a 1-D array.
yout : ndarray
    System response, as a 1-D array.
xout : ndarray, optional
    Time-evolution of the state-vector.  Only generated if the input is a
    state-space systems.

See Also
--------
lsim, dstep, dimpulse, cont2discrete

Examples
--------
A simple integrator transfer function with a discrete time step of 1.0
could be implemented as:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; tf = ([1.0,], [1.0, -1.0], 1.0)
&gt;&gt;&gt; t_in = [0.0, 1.0, 2.0, 3.0]
&gt;&gt;&gt; u = np.asarray([0.0, 0.0, 1.0, 1.0])
&gt;&gt;&gt; t_out, y = signal.dlsim(tf, u, t=t_in)
&gt;&gt;&gt; y
array([ 0.,  0.,  0.,  1.])</docstring>
    <inputPortSpec arg="system" name="system" port_type="basic:List" show_port="True">
      <docstring>A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:

  - 3: (num, den, dt)
  - 4: (zeros, poles, gain, dt)
  - 5: (A, B, C, D, dt)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>An input array describing the input at each time `t` (interpolation is
assumed between given times).  If there are multiple inputs, then each
column of the rank-2 array represents an input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:List">
      <docstring>The time steps at which the input is defined.  If `t` is given, it
must be the same length as `u`, and the final value in `t` determines
the number of steps returned in the output.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List">
      <docstring>The initial conditions on the state vector (zero by default).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tout" name="tout" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Time values for the output, as a 1-D array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>System response, as a 1-D array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xout" name="xout" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Time-evolution of the state-vector.  Only generated if the input is a
state-space systems.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.dstep" module_name="dstep" namespace="'signal'" output_type="list">
    <docstring>Step response of discrete-time system.

Parameters
----------
system : tuple of array_like
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

      * 3: (num, den, dt)
      * 4: (zeros, poles, gain, dt)
      * 5: (A, B, C, D, dt)

x0 : array_like, optional
    Initial state-vector.  Defaults to zero.
t : array_like, optional
    Time points.  Computed if not given.
n : int, optional
    The number of time points to compute (if `t` is not given).

Returns
-------
tout : ndarray
    Output time points, as a 1-D array.
yout : ndarray
    Step response of system.  Each element of the tuple represents
    the output of the system based on a step response to each input.

See Also
--------
step, dimpulse, dlsim, cont2discrete</docstring>
    <inputPortSpec arg="system" name="system" port_type="basic:List" show_port="True">
      <docstring>A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:

  * 3: (num, den, dt)
  * 4: (zeros, poles, gain, dt)
  * 5: (A, B, C, D, dt)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0" port_type="basic:List">
      <docstring>Initial state-vector.  Defaults to zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:List">
      <docstring>Time points.  Computed if not given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>The number of time points to compute (if `t` is not given).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="tout" name="tout" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output time points, as a 1-D array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Step response of system.  Each element of the tuple represents
the output of the system based on a step response to each input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.ellip" module_name="ellip" namespace="'signal'" output_type="list">
    <docstring>Elliptic (Cauer) digital and analog filter design.

Design an Nth order digital or analog elliptic filter and return
the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
rp : float
    The maximum ripple allowed below unity gain in the passband.
    Specified in decibels, as a positive number.
rs : float
    The minimum attenuation required in the stop band.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For elliptic filters, this is the point in the transition band at
    which the gain first drops below -`rp`.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

See Also
--------
ellipord

Notes
-----
Also known as Cauer or Zolotarev filters, the elliptical filter maximizes
the rate of transition between the frequency response's passband and
stopband, at the expense of ripple in both, and increased ringing in the
step response.

As `rp` approaches 0, the elliptical filter becomes a Chebyshev
type II filter (`cheby2`).  As `rs` approaches 0, it becomes a Chebyshev
type I filter (`cheby1`).  As both approach 0, it becomes a Butterworth
filter (`butter`).

The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Plot the filter's frequency response, showing the critical points:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; b, a = signal.ellip(4, 5, 40, 100, 'low', analog=True)
&gt;&gt;&gt; w, h = signal.freqs(b, a)
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Elliptic filter frequency response (rp=5, rs=40)')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.margins(0, 0.1)
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency
&gt;&gt;&gt; plt.axhline(-40, color='green') # rs
&gt;&gt;&gt; plt.axhline(-5, color='green') # rp
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rp" name="rp" port_type="basic:Float" show_port="True">
      <docstring>The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rs" name="rs" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation required in the stop band.
Specified in decibels, as a positive number.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Wn" name="Wn" port_type="basic:List" show_port="True">
      <docstring>A scalar or length-2 sequence giving the critical frequencies.
For elliptic filters, this is the point in the transition band at
which the gain first drops below -`rp`.
For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`Wn` is thus in
half-cycles / sample.)
For analog filters, `Wn` is an angular frequency (e.g. rad/s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="btype" name="btype">
      <docstring>The type of filter.  Default is 'lowpass'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lowpass', 'highpass', 'bandpass', 'bandstop']]</values>
      <defaults>['low']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.ellipap" module_name="ellipap" namespace="'signal'">
    <docstring>Return (z,p,k) of Nth order elliptic analog lowpass filter.

The filter is a normalized prototype that has `rp` decibels of ripple
in the passband and a stopband `rs` decibels down.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below ``-rp``.

References
----------
Lutova, Tosic, and Evans, "Filter Design for Signal Processing", Chapters 5
and 12.</docstring>
    <inputPortSpec arg="rs" name="rs" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="rp" name="rp" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="N" name="N" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.ellipord" module_name="ellipord" namespace="'signal'" output_type="list">
    <docstring>Elliptic (Cauer) filter order selection.

Return the order of the lowest order digital or analog elliptic filter
that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for an Elliptic (Cauer) filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `ellip` to give filter results.

See Also
--------
ellip : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design an analog highpass filter such that the passband is within 3 dB
above 30 rad/s, while rejecting -60 dB at 10 rad/s.  Plot its
frequency response, showing the passband and stopband constraints in gray.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; N, Wn = signal.ellipord(30, 10, 3, 60, True)
&gt;&gt;&gt; b, a = signal.ellip(N, 3, 60, Wn, 'high', True)
&gt;&gt;&gt; w, h = signal.freqs(b, a, np.logspace(0, 3, 500))
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.title('Elliptical highpass filter fit to constraints')
&gt;&gt;&gt; plt.xlabel('Frequency [radians / second]')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]')
&gt;&gt;&gt; plt.grid(which='both', axis='both')
&gt;&gt;&gt; plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], '0.9', lw=0) # stop
&gt;&gt;&gt; plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], '0.9', lw=0) # pass
&gt;&gt;&gt; plt.axis([1, 300, -80, 3])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="wp" name="wp" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ws" name="ws" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gpass" name="gpass" port_type="basic:Float" show_port="True">
      <docstring>The maximum loss in the passband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gstop" name="gstop" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation in the stopband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ord" name="ord" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The lowest order for an Elliptic (Cauer) filter that meets specs.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="wn" name="wn" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The Chebyshev natural frequency (the "3dB frequency") for use with
`ellip` to give filter results.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.exponential" module_name="exponential" namespace="'signal'">
    <docstring>Return an exponential (or Poisson) window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
center : float, optional
    Parameter defining the center location of the window function.
    The default value if not given is ``center = (M-1) / 2``.  This
    parameter must take its default value for symmetric windows.
tau : float, optional
    Parameter defining the decay.  For ``center = 0`` use
    ``tau = -(M-1) / ln(x)`` if ``x`` is the fraction of the window
    remaining at the end.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Exponential window is defined as

.. math::  w(n) = e^{-|n-center| / \tau}

References
----------
S. Gade and H. Herlufsen, "Windows to FFT analysis (Part I)",
Technical Review 3, Bruel &amp; Kjaer, 1987.

Examples
--------
Plot the symmetric window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; M = 51
&gt;&gt;&gt; tau = 3.0
&gt;&gt;&gt; window = signal.exponential(M, tau=tau)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Exponential Window (tau=3.0)")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -35, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Exponential window (tau=3.0)")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")

This function can also generate non-symmetric windows:

&gt;&gt;&gt; tau2 = -(M-1) / np.log(0.01)
&gt;&gt;&gt; window2 = signal.exponential(M, 0, tau2, False)
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(window2)
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="center" name="center" port_type="basic:Float">
      <docstring>Parameter defining the center location of the window function.
The default value if not given is ``center = (M-1) / 2``.  This
parameter must take its default value for symmetric windows.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tau" name="tau" port_type="basic:Float">
      <docstring>Parameter defining the decay.  For ``center = 0`` use
``tau = -(M-1) / ln(x)`` if ``x`` is the fraction of the window
remaining at the end.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.fftconvolve" module_name="fftconvolve" namespace="'signal'">
    <docstring>Convolve two N-dimensional arrays using FFT.

Convolve `in1` and `in2` using the fast Fourier transform method, with
the output size determined by the `mode` argument.

This is generally much faster than `convolve` for large arrays (n &gt; ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`;
    if sizes of `in1` and `in2` are not equal then `in1` has to be the
    larger array.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

Returns
-------
out : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.

Examples
--------
Autocorrelation of white noise is an impulse.  (This is at least 100 times
as fast as `convolve`.)

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; sig = np.random.randn(1000)
&gt;&gt;&gt; autocorr = signal.fftconvolve(sig, sig[::-1], mode='full')

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
&gt;&gt;&gt; ax_orig.plot(sig)
&gt;&gt;&gt; ax_orig.set_title('White noise')
&gt;&gt;&gt; ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)
&gt;&gt;&gt; ax_mag.set_title('Autocorrelation')
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; fig.show()

Gaussian blur implemented using FFT convolution.  Notice the dark borders
around the image, due to the zero-padding beyond its boundaries.
The `convolve2d` function allows for other types of image boundaries,
but is far slower.

&gt;&gt;&gt; from scipy import misc
&gt;&gt;&gt; lena = misc.lena()
&gt;&gt;&gt; kernel = np.outer(signal.gaussian(70, 8), signal.gaussian(70, 8))
&gt;&gt;&gt; blurred = signal.fftconvolve(lena, kernel, mode='same')

&gt;&gt;&gt; fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(1, 3)
&gt;&gt;&gt; ax_orig.imshow(lena, cmap='gray')
&gt;&gt;&gt; ax_orig.set_title('Original')
&gt;&gt;&gt; ax_orig.set_axis_off()
&gt;&gt;&gt; ax_kernel.imshow(kernel, cmap='gray')
&gt;&gt;&gt; ax_kernel.set_title('Gaussian kernel')
&gt;&gt;&gt; ax_kernel.set_axis_off()
&gt;&gt;&gt; ax_blurred.imshow(blurred, cmap='gray')
&gt;&gt;&gt; ax_blurred.set_title('Blurred')
&gt;&gt;&gt; ax_blurred.set_axis_off()
&gt;&gt;&gt; fig.show()</docstring>
    <inputPortSpec arg="in1" name="in1" port_type="basic:List" show_port="True">
      <docstring>First input.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="in2" name="in2" port_type="basic:List" show_port="True">
      <docstring>Second input. Should have the same number of dimensions as `in1`;
if sizes of `in1` and `in2` are not equal then `in1` has to be the
larger array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>A string indicating the size of the output:

``full``
   The output is the full discrete linear convolution
   of the inputs. (Default)
``valid``
   The output consists only of those elements that do not
   rely on the zero-padding.
``same``
   The output is the same size as `in1`, centered
   with respect to the 'full' output.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['full', 'valid', 'same']]</values>
      <defaults>['full']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An N-dimensional array containing a subset of the discrete linear
convolution of `in1` with `in2`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.filtfilt" module_name="filtfilt" namespace="'signal'">
    <docstring>A forward-backward filter.

This function applies a linear filter twice, once forward and once
backwards.  The combined filter has linear phase.

The function provides options for handling the edges of the signal.

When `method` is "pad", the function pads the data along the given axis
in one of three ways: odd, even or constant.  The odd and even extensions
have the corresponding symmetry about the end point of the data.  The
constant extension extends the data with the values at the end points. On
both the forward and backward passes, the initial condition of the
filter is found by using `lfilter_zi` and scaling it by the end point of
the extended data.

When `method` is "gust", Gustafsson's method [1]_ is used.  Initial
conditions are chosen for the forward and backward passes so that the
forward-backward filter gives the same result as the backward-forward
filter.

Parameters
----------
b : (N,) array_like
    The numerator coefficient vector of the filter.
a : (N,) array_like
    The denominator coefficient vector of the filter.  If ``a[0]``
    is not 1, then both `a` and `b` are normalized by ``a[0]``.
x : array_like
    The array of data to be filtered.
axis : int, optional
    The axis of `x` to which the filter is applied.
    Default is -1.
padtype : str or None, optional
    Must be 'odd', 'even', 'constant', or None.  This determines the
    type of extension to use for the padded signal to which the filter
    is applied.  If `padtype` is None, no padding is used.  The default
    is 'odd'.
padlen : int or None, optional
    The number of elements by which to extend `x` at both ends of
    `axis` before applying the filter.  This value must be less than
    ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.
    The default value is ``3 * max(len(a), len(b))``.
method : str, optional
    Determines the method for handling the edges of the signal, either
    "pad" or "gust".  When `method` is "pad", the signal is padded; the
    type of padding is determined by `padtype` and `padlen`, and `irlen`
    is ignored.  When `method` is "gust", Gustafsson's method is used,
    and `padtype` and `padlen` are ignored.
irlen : int or None, optional
    When `method` is "gust", `irlen` specifies the length of the
    impulse response of the filter.  If `irlen` is None, no part
    of the impulse response is ignored.  For a long signal, specifying
    `irlen` can significantly improve the performance of the filter.

Returns
-------
y : ndarray
    The filtered output, an array of type numpy.float64 with the same
    shape as `x`.

See Also
--------
lfilter_zi, lfilter

Notes
-----
The option to use Gustaffson's method was added in scipy version 0.16.0.

References
----------
.. [1] F. Gustaffson, "Determining the initial states in forward-backward
       filtering", Transactions on Signal Processing, Vol. 46, pp. 988-992,
       1996.

Examples
--------
The examples will use several functions from `scipy.signal`.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

First we create a one second signal that is the sum of two pure sine
waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.

&gt;&gt;&gt; t = np.linspace(0, 1.0, 2001)
&gt;&gt;&gt; xlow = np.sin(2 * np.pi * 5 * t)
&gt;&gt;&gt; xhigh = np.sin(2 * np.pi * 250 * t)
&gt;&gt;&gt; x = xlow + xhigh

Now create a lowpass Butterworth filter with a cutoff of 0.125 times
the Nyquist rate, or 125 Hz, and apply it to ``x`` with `filtfilt`.
The result should be approximately ``xlow``, with no phase shift.

&gt;&gt;&gt; b, a = signal.butter(8, 0.125)
&gt;&gt;&gt; y = signal.filtfilt(b, a, x, padlen=150)
&gt;&gt;&gt; np.abs(y - xlow).max()
9.1086182074789912e-06

We get a fairly clean result for this artificial example because
the odd extension is exact, and with the moderately long padding,
the filter's transients have dissipated by the time the actual data
is reached.  In general, transient effects at the edges are
unavoidable.

The following example demonstrates the option ``method="gust"``.

First, create a filter.

&gt;&gt;&gt; b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.
&gt;&gt;&gt; np.random.seed(123456)

`sig` is a random input signal to be filtered.

&gt;&gt;&gt; n = 60
&gt;&gt;&gt; sig = np.random.randn(n)**3 + 3*np.random.randn(n).cumsum()

Apply `filtfilt` to `sig`, once using the Gustafsson method, and
once using padding, and plot the results for comparison.

&gt;&gt;&gt; fgust = signal.filtfilt(b, a, sig, method="gust")
&gt;&gt;&gt; fpad = signal.filtfilt(b, a, sig, padlen=50)
&gt;&gt;&gt; plt.plot(sig, 'k-', label='input')
&gt;&gt;&gt; plt.plot(fgust, 'b-', linewidth=4, label='gust')
&gt;&gt;&gt; plt.plot(fpad, 'c-', linewidth=1.5, label='pad')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()

The `irlen` argument can be used to improve the performance
of Gustafsson's method.

Estimate the impulse response length of the filter.

&gt;&gt;&gt; z, p, k = signal.tf2zpk(b, a)
&gt;&gt;&gt; eps = 1e-9
&gt;&gt;&gt; r = np.max(np.abs(p))
&gt;&gt;&gt; approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))
&gt;&gt;&gt; approx_impulse_len
137

Apply the filter to a longer signal, with and without the `irlen`
argument.  The difference between `y1` and `y2` is small.  For long
signals, using `irlen` gives a significant performance improvement.

&gt;&gt;&gt; x = np.random.randn(5000)
&gt;&gt;&gt; y1 = signal.filtfilt(b, a, x, method='gust')
&gt;&gt;&gt; y2 = signal.filtfilt(b, a, x, method='gust', irlen=approx_impulse_len)
&gt;&gt;&gt; print(np.max(np.abs(y1 - y2)))
1.80056858312e-10</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The numerator coefficient vector of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The denominator coefficient vector of the filter.  If ``a[0]``
is not 1, then both `a` and `b` are normalized by ``a[0]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The array of data to be filtered.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `x` to which the filter is applied.
Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="padtype" name="padtype">
      <docstring>Must be 'odd', 'even', 'constant', or None.  This determines the
type of extension to use for the padded signal to which the filter
is applied.  If `padtype` is None, no padding is used.  The default
is 'odd'.</docstring>
      <defaults>['odd']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="padlen" name="padlen">
      <docstring>The number of elements by which to extend `x` at both ends of
`axis` before applying the filter.  This value must be less than
``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.
The default value is ``3 * max(len(a), len(b))``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Determines the method for handling the edges of the signal, either
"pad" or "gust".  When `method` is "pad", the signal is padded; the
type of padding is determined by `padtype` and `padlen`, and `irlen`
is ignored.  When `method` is "gust", Gustafsson's method is used,
and `padtype` and `padlen` are ignored.</docstring>
      <defaults>['pad']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="irlen" name="irlen">
      <docstring>When `method` is "gust", `irlen` specifies the length of the
impulse response of the filter.  If `irlen` is None, no part
of the impulse response is ignored.  For a long signal, specifying
`irlen` can significantly improve the performance of the filter.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered output, an array of type numpy.float64 with the same
shape as `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.find_peaks_cwt" module_name="find_peaks_cwt" namespace="'signal'">
    <docstring>Attempt to find the peaks in a 1-D array.

The general approach is to smooth `vector` by convolving it with
`wavelet(width)` for each width in `widths`. Relative maxima which
appear at enough length scales, and with sufficiently high SNR, are
accepted.

Parameters
----------
vector : ndarray
    1-D array in which to find the peaks.
widths : sequence
    1-D array of widths to use for calculating the CWT matrix. In general,
    this range should cover the expected width of peaks of interest.
wavelet : callable, optional
    Should take a single variable and return a 1-D array to convolve
    with `vector`.  Should be normalized to unit area.
    Default is the ricker wavelet.
max_distances : ndarray, optional
    At each row, a ridge line is only connected if the relative max at
    row[n] is within ``max_distances[n]`` from the relative max at
    ``row[n+1]``.  Default value is ``widths/4``.
gap_thresh : float, optional
    If a relative maximum is not found within `max_distances`,
    there will be a gap. A ridge line is discontinued if there are more
    than `gap_thresh` points without connecting a new relative maximum.
    Default is 2.
min_length : int, optional
    Minimum length a ridge line needs to be acceptable.
    Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths.
min_snr : float, optional
    Minimum SNR ratio. Default 1. The signal is the value of
    the cwt matrix at the shortest length scale (``cwt[0, loc]``), the
    noise is the `noise_perc`th percentile of datapoints contained within a
    window of `window_size` around ``cwt[0, loc]``.
noise_perc : float, optional
    When calculating the noise floor, percentile of data points
    examined below which to consider noise. Calculated using
    `stats.scoreatpercentile`.  Default is 10.

Returns
-------
peaks_indices : list
    Indices of the locations in the `vector` where peaks were found.
    The list is sorted.

See Also
--------
cwt

Notes
-----
This approach was designed for finding sharp peaks among noisy data,
however with proper parameter selection it should function well for
different peak shapes.

The algorithm is as follows:
 1. Perform a continuous wavelet transform on `vector`, for the supplied
    `widths`. This is a convolution of `vector` with `wavelet(width)` for
    each width in `widths`. See `cwt`
 2. Identify "ridge lines" in the cwt matrix. These are relative maxima
    at each row, connected across adjacent rows. See identify_ridge_lines
 3. Filter the ridge_lines using filter_ridge_lines.

.. versionadded:: 0.11.0

References
----------
.. [1] Bioinformatics (2006) 22 (17): 2059-2065.
    doi: 10.1093/bioinformatics/btl355
    http://bioinformatics.oxfordjournals.org/content/22/17/2059.long

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; xs = np.arange(0, np.pi, 0.05)
&gt;&gt;&gt; data = np.sin(xs)
&gt;&gt;&gt; peakind = signal.find_peaks_cwt(data, np.arange(1,10))
&gt;&gt;&gt; peakind, xs[peakind], data[peakind]
([32], array([ 1.6]), array([ 0.9995736]))</docstring>
    <inputPortSpec arg="vector" name="vector" port_type="basic:List" show_port="True">
      <docstring>1-D array in which to find the peaks.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="widths" name="widths" port_type="basic:List" show_port="True">
      <docstring>1-D array of widths to use for calculating the CWT matrix. In general,
this range should cover the expected width of peaks of interest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="wavelet" name="wavelet" port_type="basic:Variant">
      <docstring>Should take a single variable and return a 1-D array to convolve
with `vector`.  Should be normalized to unit area.
Default is the ricker wavelet.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="max_distances" name="max_distances" port_type="basic:List">
      <docstring>At each row, a ridge line is only connected if the relative max at
row[n] is within ``max_distances[n]`` from the relative max at
``row[n+1]``.  Default value is ``widths/4``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gap_thresh" name="gap_thresh" port_type="basic:Float">
      <docstring>If a relative maximum is not found within `max_distances`,
there will be a gap. A ridge line is discontinued if there are more
than `gap_thresh` points without connecting a new relative maximum.
Default is 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="min_length" name="min_length" port_type="basic:Integer">
      <docstring>Minimum length a ridge line needs to be acceptable.
Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="min_snr" name="min_snr" port_type="basic:Float">
      <docstring>Minimum SNR ratio. Default 1. The signal is the value of
the cwt matrix at the shortest length scale (``cwt[0, loc]``), the
noise is the `noise_perc`th percentile of datapoints contained within a
window of `window_size` around ``cwt[0, loc]``.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noise_perc" name="noise_perc" port_type="basic:Float">
      <docstring>When calculating the noise floor, percentile of data points
examined below which to consider noise. Calculated using
`stats.scoreatpercentile`.  Default is 10.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="peaks_indices" name="peaks_indices" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Indices of the locations in the `vector` where peaks were found.
The list is sorted.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.findfreqs" module_name="findfreqs" namespace="'signal'">
    <docstring>Find an array of frequencies for computing the response of a filter.

Parameters
----------
num, den : array_like, 1-D
    The polynomial coefficients of the numerator and denominator of the
    transfer function of the filter or LTI system.  The coefficients are
    ordered from highest to lowest degree.
N : int
    The length of the array to be computed.

Returns
-------
w : (N,) ndarray
    A 1-D array of frequencies, logarithmically spaced.

Examples
--------
Find a set of nine frequencies that span the "interesting part" of the
frequency response for the filter with the transfer function

    H(s) = s / (s^2 + 8s + 25)

&gt;&gt;&gt; findfreqs([1, 0], [1, 8, 25], N=9)
array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,
         3.16227766e-01,   1.00000000e+00,   3.16227766e+00,
         1.00000000e+01,   3.16227766e+01,   1.00000000e+02])</docstring>
    <inputPortSpec arg="num" name="num" port_type="basic:List" show_port="True">
      <docstring>The polynomial coefficients of the numerator and denominator of the
transfer function of the filter or LTI system.  The coefficients are
ordered from highest to lowest degree.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="den" name="den" port_type="basic:List" show_port="True">
      <docstring>The polynomial coefficients of the numerator and denominator of the
transfer function of the filter or LTI system.  The coefficients are
ordered from highest to lowest degree.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The length of the array to be computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 1-D array of frequencies, logarithmically spaced.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.firwin" module_name="firwin" namespace="'signal'">
    <docstring>FIR filter design using the window method.

This function computes the coefficients of a finite impulse response
filter.  The filter will have linear phase; it will be Type I if
`numtaps` is odd and Type II if `numtaps` is even.

Type II filters always have zero response at the Nyquist rate, so a
ValueError exception is raised if firwin is called with `numtaps` even and
having a passband whose right end is at the Nyquist rate.

Parameters
----------
numtaps : int
    Length of the filter (number of coefficients, i.e. the filter
    order + 1).  `numtaps` must be even if a passband includes the
    Nyquist frequency.
cutoff : float or 1D array_like
    Cutoff frequency of filter (expressed in the same units as `nyq`)
    OR an array of cutoff frequencies (that is, band edges). In the
    latter case, the frequencies in `cutoff` should be positive and
    monotonically increasing between 0 and `nyq`.  The values 0 and
    `nyq` must not be included in `cutoff`.
width : float or None, optional
    If `width` is not None, then assume it is the approximate width
    of the transition region (expressed in the same units as `nyq`)
    for use in Kaiser FIR filter design.  In this case, the `window`
    argument is ignored.
window : string or tuple of string and parameter values, optional
    Desired window to use. See `scipy.signal.get_window` for a list
    of windows and required parameters.
pass_zero : bool, optional
    If True, the gain at the frequency 0 (i.e. the "DC gain") is 1.
    Otherwise the DC gain is 0.
scale : bool, optional
    Set to True to scale the coefficients so that the frequency
    response is exactly unity at a certain frequency.
    That frequency is either:

    - 0 (DC) if the first passband starts at 0 (i.e. pass_zero
      is True)
    - `nyq` (the Nyquist rate) if the first passband ends at
      `nyq` (i.e the filter is a single band highpass filter);
      center of first passband otherwise

nyq : float, optional
    Nyquist frequency.  Each frequency in `cutoff` must be between 0
    and `nyq`.

Returns
-------
h : (numtaps,) ndarray
    Coefficients of length `numtaps` FIR filter.

Raises
------
ValueError
    If any value in `cutoff` is less than or equal to 0 or greater
    than or equal to `nyq`, if the values in `cutoff` are not strictly
    monotonically increasing, or if `numtaps` is even but a passband
    includes the Nyquist frequency.

See also
--------
scipy.signal.firwin2

Examples
--------
Low-pass from 0 to f::

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; signal.firwin(numtaps, f)

Use a specific window function::

&gt;&gt;&gt; signal.firwin(numtaps, f, window='nuttall')

High-pass ('stop' from 0 to f)::

&gt;&gt;&gt; signal.firwin(numtaps, f, pass_zero=False)

Band-pass::

&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2], pass_zero=False)

Band-stop::

&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2])

Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1])::

&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4])

Multi-band (passbands are [f1, f2] and [f3,f4])::

&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)</docstring>
    <inputPortSpec arg="numtaps" name="numtaps" port_type="basic:Integer" show_port="True">
      <docstring>Length of the filter (number of coefficients, i.e. the filter
order + 1).  `numtaps` must be even if a passband includes the
Nyquist frequency.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cutoff" name="cutoffScalar" port_type="basic:Float" show_port="True">
      <docstring>Cutoff frequency of filter (expressed in the same units as `nyq`)
OR an array of cutoff frequencies (that is, band edges). In the
latter case, the frequencies in `cutoff` should be positive and
monotonically increasing between 0 and `nyq`.  The values 0 and
`nyq` must not be included in `cutoff`.</docstring>
      <alternateSpec arg="cutoff" name="cutoffSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="width" name="width">
      <docstring>If `width` is not None, then assume it is the approximate width
of the transition region (expressed in the same units as `nyq`)
for use in Kaiser FIR filter design.  In this case, the `window`
argument is ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="window" name="windowScalar">
      <docstring>Desired window to use. See `scipy.signal.get_window` for a list
of windows and required parameters.</docstring>
      <defaults>['hamming']</defaults>
      <alternateSpec arg="window" depth="1" name="windowSequence" />
    </inputPortSpec>
    <inputPortSpec arg="pass_zero" name="pass_zero" port_type="basic:Boolean">
      <docstring>If True, the gain at the frequency 0 (i.e. the "DC gain") is 1.
Otherwise the DC gain is 0.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:Boolean">
      <docstring>Set to True to scale the coefficients so that the frequency
response is exactly unity at a certain frequency.
That frequency is either:

- 0 (DC) if the first passband starts at 0 (i.e. pass_zero
  is True)
- `nyq` (the Nyquist rate) if the first passband ends at
  `nyq` (i.e the filter is a single band highpass filter);
  center of first passband otherwise
</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="nyq" name="nyq" port_type="basic:Float">
      <docstring>Nyquist frequency.  Each frequency in `cutoff` must be between 0
and `nyq`.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="h" name="h" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Coefficients of length `numtaps` FIR filter.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.firwin2" module_name="firwin2" namespace="'signal'">
    <docstring>FIR filter design using the window method.

From the given frequencies `freq` and corresponding gains `gain`,
this function constructs an FIR filter with linear phase and
(approximately) the given frequency response.

Parameters
----------
numtaps : int
    The number of taps in the FIR filter.  `numtaps` must be less than
    `nfreqs`.
freq : array_like, 1D
    The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
    Nyquist.  The Nyquist frequency can be redefined with the argument
    `nyq`.
    The values in `freq` must be nondecreasing.  A value can be repeated
    once to implement a discontinuity.  The first value in `freq` must
    be 0, and the last value must be `nyq`.
gain : array_like
    The filter gains at the frequency sampling points. Certain
    constraints to gain values, depending on the filter type, are applied,
    see Notes for details.
nfreqs : int, optional
    The size of the interpolation mesh used to construct the filter.
    For most efficient behavior, this should be a power of 2 plus 1
    (e.g, 129, 257, etc).  The default is one more than the smallest
    power of 2 that is not less than `numtaps`.  `nfreqs` must be greater
    than `numtaps`.
window : string or (string, float) or float, or None, optional
    Window function to use. Default is "hamming".  See
    `scipy.signal.get_window` for the complete list of possible values.
    If None, no window function is applied.
nyq : float, optional
    Nyquist frequency.  Each frequency in `freq` must be between 0 and
    `nyq` (inclusive).
antisymmetric : bool, optional
    Whether resulting impulse response is symmetric/antisymmetric.
    See Notes for more details.

Returns
-------
taps : ndarray
    The filter coefficients of the FIR filter, as a 1-D array of length
    `numtaps`.

See also
--------
scipy.signal.firwin

Notes
-----
From the given set of frequencies and gains, the desired response is
constructed in the frequency domain.  The inverse FFT is applied to the
desired response to create the associated convolution kernel, and the
first `numtaps` coefficients of this kernel, scaled by `window`, are
returned.

The FIR filter will have linear phase. The type of filter is determined by
the value of 'numtaps` and `antisymmetric` flag.
There are four possible combinations:

   - odd  `numtaps`, `antisymmetric` is False, type I filter is produced
   - even `numtaps`, `antisymmetric` is False, type II filter is produced
   - odd  `numtaps`, `antisymmetric` is True, type III filter is produced
   - even `numtaps`, `antisymmetric` is True, type IV filter is produced

Magnitude response of all but type I filters are subjects to following
constraints:

   - type II  -- zero at the Nyquist frequency
   - type III -- zero at zero and Nyquist frequencies
   - type IV  -- zero at zero frequency

.. versionadded:: 0.9.0

References
----------
.. [1] Oppenheim, A. V. and Schafer, R. W., "Discrete-Time Signal
   Processing", Prentice-Hall, Englewood Cliffs, New Jersey (1989).
   (See, for example, Section 7.4.)

.. [2] Smith, Steven W., "The Scientist and Engineer's Guide to Digital
   Signal Processing", Ch. 17. http://www.dspguide.com/ch17/1.htm

Examples
--------
A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and
that decreases linearly on [0.5, 1.0] from 1 to 0:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])
&gt;&gt;&gt; print(taps[72:78])
[-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</docstring>
    <inputPortSpec arg="numtaps" name="numtaps" port_type="basic:Integer" show_port="True">
      <docstring>The number of taps in the FIR filter.  `numtaps` must be less than
`nfreqs`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="freq" name="freq" port_type="basic:List" show_port="True">
      <docstring>The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
Nyquist.  The Nyquist frequency can be redefined with the argument
`nyq`.
The values in `freq` must be nondecreasing.  A value can be repeated
once to implement a discontinuity.  The first value in `freq` must
be 0, and the last value must be `nyq`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gain" name="gain" port_type="basic:List" show_port="True">
      <docstring>The filter gains at the frequency sampling points. Certain
constraints to gain values, depending on the filter type, are applied,
see Notes for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nfreqs" name="nfreqs" port_type="basic:Integer">
      <docstring>The size of the interpolation mesh used to construct the filter.
For most efficient behavior, this should be a power of 2 plus 1
(e.g, 129, 257, etc).  The default is one more than the smallest
power of 2 that is not less than `numtaps`.  `nfreqs` must be greater
than `numtaps`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="window" name="window">
      <docstring>Window function to use. Default is "hamming".  See
`scipy.signal.get_window` for the complete list of possible values.
If None, no window function is applied.</docstring>
      <defaults>['hamming']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="nyq" name="nyq" port_type="basic:Float">
      <docstring>Nyquist frequency.  Each frequency in `freq` must be between 0 and
`nyq` (inclusive).</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="antisymmetric" name="antisymmetric" port_type="basic:Boolean">
      <docstring>Whether resulting impulse response is symmetric/antisymmetric.
See Notes for more details.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="taps" name="taps" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filter coefficients of the FIR filter, as a 1-D array of length
`numtaps`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.flattop" module_name="flattop" namespace="'signal'">
    <docstring>Return a flat top window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.flattop(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Flat top window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the flat top window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.freqresp" module_name="freqresp" namespace="'signal'" output_type="list">
    <docstring>Calculate the frequency response of a continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

w : array_like, optional
    Array of frequencies (in rad/s). Magnitude and phase data is
    calculated for every value in this array. If not given a reasonable
    set will be calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
    Frequency array [rad/s]
H : 1D ndarray
    Array of complex magnitude values

Examples
--------
# Generating the Nyquist plot of a transfer function

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; s1 = signal.lti([], [1, 1, 1], [5])
# transfer function: H(s) = 5 / (s-1)^3

&gt;&gt;&gt; w, H = signal.freqresp(s1)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(H.real, H.imag, "b")
&gt;&gt;&gt; plt.plot(H.real, -H.imag, "r")
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>The following gives the number of elements in the tuple and
the interpretation:

    * 2 (num, den)
    * 3 (zeros, poles, gain)
    * 4 (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>Array of frequencies (in rad/s). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Number of frequency points to compute if `w` is not given. The `n`
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</docstring>
      <defaults>[10000]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Frequency array [rad/s]</docstring>
    </outputPortSpec>
    <outputPortSpec arg="H" name="H" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Array of complex magnitude values</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.freqs" module_name="freqs" namespace="'signal'" output_type="list">
    <docstring>Compute frequency response of analog filter.

Given the numerator `b` and denominator `a` of a filter, compute its
frequency response::

         b[0]*(jw)**(nb-1) + b[1]*(jw)**(nb-2) + ... + b[nb-1]
 H(w) = -------------------------------------------------------
         a[0]*(jw)**(na-1) + a[1]*(jw)**(na-2) + ... + a[na-1]

Parameters
----------
b : ndarray
    Numerator of a linear filter.
a : ndarray
    Denominator of a linear filter.
worN : {None, int}, optional
    If None, then compute at 200 frequencies around the interesting parts
    of the response curve (determined by pole-zero locations).  If a single
    integer, then compute at that many frequencies.  Otherwise, compute the
    response at the angular frequencies (e.g. rad/s) given in `worN`.
plot : callable, optional
    A callable that takes two arguments. If given, the return parameters
    `w` and `h` are passed to plot. Useful for plotting the frequency
    response inside `freqs`.

Returns
-------
w : ndarray
    The angular frequencies at which h was computed.
h : ndarray
    The frequency response.

See Also
--------
freqz : Compute the frequency response of a digital filter.

Notes
-----
Using Matplotlib's "plot" function as the callable for `plot` produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try ``lambda w, h: plot(w, abs(h))``.

Examples
--------
&gt;&gt;&gt; from scipy.signal import freqs, iirfilter

&gt;&gt;&gt; b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1')

&gt;&gt;&gt; w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; plt.xlabel('Frequency')
&gt;&gt;&gt; plt.ylabel('Amplitude response [dB]')
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Numerator of a linear filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Denominator of a linear filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="worN" name="worN" port_type="basic:Integer">
      <docstring>If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in `worN`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="plot" name="plot" port_type="basic:Variant">
      <docstring>A callable that takes two arguments. If given, the return parameters
`w` and `h` are passed to plot. Useful for plotting the frequency
response inside `freqs`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The angular frequencies at which h was computed.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="h" name="h" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The frequency response.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.freqz" module_name="freqz" namespace="'signal'" output_type="list">
    <docstring>Compute the frequency response of a digital filter.

Given the numerator `b` and denominator `a` of a digital filter,
compute its frequency response::

           jw               -jw            -jmw
    jw  B(e)    b[0] + b[1]e + .... + b[m]e
 H(e) = ---- = ------------------------------------
           jw               -jw            -jnw
        A(e)    a[0] + a[1]e + .... + a[n]e

Parameters
----------
b : ndarray
    numerator of a linear filter
a : ndarray
    denominator of a linear filter
worN : {None, int, array_like}, optional
    If None (default), then compute at 512 frequencies equally spaced
    around the unit circle.
    If a single integer, then compute at that many frequencies.
    If an array_like, compute the response at the frequencies given (in
    radians/sample).
whole : bool, optional
    Normally, frequencies are computed from 0 to the Nyquist frequency,
    pi radians/sample (upper-half of unit-circle).  If `whole` is True,
    compute frequencies from 0 to 2*pi radians/sample.
plot : callable
    A callable that takes two arguments. If given, the return parameters
    `w` and `h` are passed to plot. Useful for plotting the frequency
    response inside `freqz`.

Returns
-------
w : ndarray
    The normalized frequencies at which h was computed, in radians/sample.
h : ndarray
    The frequency response.

Notes
-----
Using Matplotlib's "plot" function as the callable for `plot` produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try ``lambda w, h: plot(w, abs(h))``.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; b = signal.firwin(80, 0.5, window=('kaiser', 8))
&gt;&gt;&gt; w, h = signal.freqz(b)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; plt.title('Digital filter frequency response')
&gt;&gt;&gt; ax1 = fig.add_subplot(111)

&gt;&gt;&gt; plt.plot(w, 20 * np.log10(abs(h)), 'b')
&gt;&gt;&gt; plt.ylabel('Amplitude [dB]', color='b')
&gt;&gt;&gt; plt.xlabel('Frequency [rad/sample]')

&gt;&gt;&gt; ax2 = ax1.twinx()
&gt;&gt;&gt; angles = np.unwrap(np.angle(h))
&gt;&gt;&gt; plt.plot(w, angles, 'g')
&gt;&gt;&gt; plt.ylabel('Angle (radians)', color='g')
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.axis('tight')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>numerator of a linear filter</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="aScalar" port_type="basic:Integer">
      <docstring>denominator of a linear filter</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="a" name="aSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="worN" name="worNScalar" port_type="basic:Integer">
      <docstring>If None (default), then compute at 512 frequencies equally spaced
around the unit circle.
If a single integer, then compute at that many frequencies.
If an array_like, compute the response at the frequencies given (in
radians/sample).</docstring>
      <alternateSpec arg="worN" name="worNSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="whole" name="wholeScalar" port_type="basic:Integer">
      <docstring>Normally, frequencies are computed from 0 to the Nyquist frequency,
pi radians/sample (upper-half of unit-circle).  If `whole` is True,
compute frequencies from 0 to 2*pi radians/sample.</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="whole" name="wholeBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="plot" name="plot" port_type="basic:Variant" show_port="True">
      <docstring>A callable that takes two arguments. If given, the return parameters
`w` and `h` are passed to plot. Useful for plotting the frequency
response inside `freqz`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The normalized frequencies at which h was computed, in radians/sample.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="h" name="h" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The frequency response.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.gauss_spline" module_name="gauss_spline" namespace="'signal'">
    <docstring>Gaussian approximation to B-spline basis function of order n.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.gaussian" module_name="gaussian" namespace="'signal'">
    <docstring>Return a Gaussian window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
std : float
    The standard deviation, sigma.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Gaussian window is defined as

.. math::  w(n) = e^{ -\frac{1}{2}\left(\frac{n}{\sigma}\right)^2 }

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.gaussian(51, std=7)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(r"Gaussian window ($\sigma$=7)")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title(r"Frequency response of the Gaussian window ($\sigma$=7)")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="std" name="std" port_type="basic:Float" show_port="True">
      <docstring>The standard deviation, sigma.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.gausspulse" module_name="gausspulse" namespace="'signal'" output_type="list">
    <docstring>Return a Gaussian modulated sinusoid:

    ``exp(-a t^2) exp(1j*2*pi*fc*t).``

If `retquad` is True, then return the real and imaginary parts
(in-phase and quadrature).
If `retenv` is True, then return the envelope (unmodulated signal).
Otherwise, return the real part of the modulated sinusoid.

Parameters
----------
t : ndarray or the string 'cutoff'
    Input array.
fc : int, optional
    Center frequency (e.g. Hz).  Default is 1000.
bw : float, optional
    Fractional bandwidth in frequency domain of pulse (e.g. Hz).
    Default is 0.5.
bwr : float, optional
    Reference level at which fractional bandwidth is calculated (dB).
    Default is -6.
tpr : float, optional
    If `t` is 'cutoff', then the function returns the cutoff
    time for when the pulse amplitude falls below `tpr` (in dB).
    Default is -60.
retquad : bool, optional
    If True, return the quadrature (imaginary) as well as the real part
    of the signal.  Default is False.
retenv : bool, optional
    If True, return the envelope of the signal.  Default is False.

Returns
-------
yI : ndarray
    Real part of signal.  Always returned.
yQ : ndarray
    Imaginary part of signal.  Only returned if `retquad` is True.
yenv : ndarray
    Envelope of signal.  Only returned if `retenv` is True.

See Also
--------
scipy.signal.morlet

Examples
--------
Plot real component, imaginary component, and envelope for a 5 Hz pulse,
sampled at 100 Hz for 2 seconds:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.linspace(-1, 1, 2 * 100, endpoint=False)
&gt;&gt;&gt; i, q, e = signal.gausspulse(t, fc=5, retquad=True, retenv=True)
&gt;&gt;&gt; plt.plot(t, i, t, q, t, e, '--')</docstring>
    <inputPortSpec arg="t" name="tScalar" show_port="True">
      <docstring>Input array.</docstring>
      <alternateSpec arg="t" name="tSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="fc" name="fc" port_type="basic:Integer">
      <docstring>Center frequency (e.g. Hz).  Default is 1000.</docstring>
      <defaults>[1000]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bw" name="bw" port_type="basic:Float">
      <docstring>Fractional bandwidth in frequency domain of pulse (e.g. Hz).
Default is 0.5.</docstring>
      <defaults>[0.5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bwr" name="bwr" port_type="basic:Float">
      <docstring>Reference level at which fractional bandwidth is calculated (dB).
Default is -6.</docstring>
      <defaults>[-6]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tpr" name="tpr" port_type="basic:Float">
      <docstring>If `t` is 'cutoff', then the function returns the cutoff
time for when the pulse amplitude falls below `tpr` (in dB).
Default is -60.</docstring>
      <defaults>[-60]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="retquad" name="retquad" port_type="basic:Boolean">
      <docstring>If True, return the quadrature (imaginary) as well as the real part
of the signal.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="retenv" name="retenv" port_type="basic:Boolean">
      <docstring>If True, return the envelope of the signal.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="yI" name="yI" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Real part of signal.  Always returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yQ" name="yQ" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Imaginary part of signal.  Only returned if `retquad` is True.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yenv" name="yenv" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Envelope of signal.  Only returned if `retenv` is True.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.general_gaussian" module_name="general_gaussian" namespace="'signal'">
    <docstring>Return a window with a generalized Gaussian shape.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
p : float
    Shape parameter.  p = 1 is identical to `gaussian`, p = 0.5 is
    the same shape as the Laplace distribution.
sig : float
    The standard deviation, sigma.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The generalized Gaussian window is defined as

.. math::  w(n) = e^{ -\frac{1}{2}\left|\frac{n}{\sigma}\right|^{2p} }

the half-power point is at

.. math::  (2 \log(2))^{1/(2 p)} \sigma

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.general_gaussian(51, p=1.5, sig=7)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(r"Generalized Gaussian window (p=1.5, $\sigma$=7)")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title(r"Freq. resp. of the gen. Gaussian window (p=1.5, $\sigma$=7)")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True">
      <docstring>Shape parameter.  p = 1 is identical to `gaussian`, p = 0.5 is
the same shape as the Laplace distribution.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sig" name="sig" port_type="basic:Float" show_port="True">
      <docstring>The standard deviation, sigma.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.get_window" module_name="get_window" namespace="'signal'">
    <docstring>Return a window.

Parameters
----------
window : string, float, or tuple
    The type of window to create. See below for more details.
Nx : int
    The number of samples in the window.
fftbins : bool, optional
    If True, create a "periodic" window ready to use with ifftshift
    and be multiplied by the result of an fft (SEE ALSO fftfreq).

Returns
-------
get_window : ndarray
    Returns a window of length `Nx` and type `window`

Notes
-----
Window types:

    boxcar, triang, blackman, hamming, hann, bartlett, flattop, parzen,
    bohman, blackmanharris, nuttall, barthann, kaiser (needs beta),
    gaussian (needs std), general_gaussian (needs power, width),
    slepian (needs width), chebwin (needs attenuation)
    exponential (needs decay scale), tukey (needs taper fraction)

If the window requires no parameters, then `window` can be a string.

If the window requires parameters, then `window` must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.

If `window` is a floating point number, it is interpreted as the beta
parameter of the kaiser window.

Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; signal.get_window('triang', 7)
array([ 0.25,  0.5 ,  0.75,  1.  ,  0.75,  0.5 ,  0.25])
&gt;&gt;&gt; signal.get_window(('kaiser', 4.0), 9)
array([ 0.08848053,  0.32578323,  0.63343178,  0.89640418,  1.        ,
        0.89640418,  0.63343178,  0.32578323,  0.08848053])
&gt;&gt;&gt; signal.get_window(4.0, 9)
array([ 0.08848053,  0.32578323,  0.63343178,  0.89640418,  1.        ,
        0.89640418,  0.63343178,  0.32578323,  0.08848053])</docstring>
    <inputPortSpec arg="window" name="windowScalar" port_type="basic:Float" show_port="True">
      <docstring>The type of window to create. See below for more details.</docstring>
      <alternateSpec arg="window" name="windowSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="Nx" name="Nx" port_type="basic:Integer" show_port="True">
      <docstring>The number of samples in the window.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fftbins" name="fftbins" port_type="basic:Boolean">
      <docstring>If True, create a "periodic" window ready to use with ifftshift
and be multiplied by the result of an fft (SEE ALSO fftfreq).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="get_window" name="get_window" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns a window of length `Nx` and type `window`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.group_delay" module_name="group_delay" namespace="'signal'" output_type="list">
    <docstring>Compute the group delay of a digital filter.

The group delay measures by how many samples amplitude envelopes of
various spectral components of a signal are delayed by a filter.
It is formally defined as the derivative of continuous (unwrapped) phase::

           d        jw
 D(w) = - -- arg H(e)
          dw

Parameters
----------
system : tuple of array_like (b, a)
    Numerator and denominator coefficients of a filter transfer function.
w : {None, int, array-like}, optional
    If None (default), then compute at 512 frequencies equally spaced
    around the unit circle.
    If a single integer, then compute at that many frequencies.
    If array, compute the delay at the frequencies given
    (in radians/sample).
whole : bool, optional
    Normally, frequencies are computed from 0 to the Nyquist frequency,
    pi radians/sample (upper-half of unit-circle).  If `whole` is True,
    compute frequencies from 0 to ``2*pi`` radians/sample.

Returns
-------
w : ndarray
    The normalized frequencies at which the group delay was computed,
    in radians/sample.
gd : ndarray
    The group delay.

Notes
-----
The similar function in MATLAB is called `grpdelay`.

If the transfer function :math:`H(z)` has zeros or poles on the unit
circle, the group delay at corresponding frequencies is undefined.
When such a case arises the warning is raised and the group delay
is set to 0 at those frequencies.

For the details of numerical computation of the group delay refer to [1]_.

.. versionadded: 0.16.0

See Also
--------
freqz : Frequency response of a digital filter

References
----------
.. [1] Richard G. Lyons, "Understanding Digital Signal Processing,
       3rd edition", p. 830.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; b, a = signal.iirdesign(0.1, 0.3, 5, 50, ftype='cheby1')
&gt;&gt;&gt; w, gd = signal.group_delay((b, a))

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.title('Digital filter group delay')
&gt;&gt;&gt; plt.plot(w, gd)
&gt;&gt;&gt; plt.ylabel('Group delay [samples]')
&gt;&gt;&gt; plt.xlabel('Frequency [rad/sample]')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="system" name="system" port_type="basic:List" show_port="True">
      <docstring>Numerator and denominator coefficients of a filter transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="wScalar" port_type="basic:Integer">
      <docstring>If None (default), then compute at 512 frequencies equally spaced
around the unit circle.
If a single integer, then compute at that many frequencies.
If array, compute the delay at the frequencies given
(in radians/sample).</docstring>
      <alternateSpec arg="w" name="wSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="whole" name="whole" port_type="basic:Boolean">
      <docstring>Normally, frequencies are computed from 0 to the Nyquist frequency,
pi radians/sample (upper-half of unit-circle).  If `whole` is True,
compute frequencies from 0 to ``2*pi`` radians/sample.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The normalized frequencies at which the group delay was computed,
in radians/sample.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="gd" name="gd" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The group delay.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.hamming" module_name="hamming" namespace="'signal'">
    <docstring>Return a Hamming window.

The Hamming window is a taper formed by using a raised cosine with
non-zero endpoints, optimized to minimize the nearest side lobe.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Hamming window is defined as

.. math::  w(n) = 0.54 - 0.46 \cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and
is described in Blackman and Tukey. It was recommended for smoothing the
truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
       University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, "Window function",
       http://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.hamming(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Hamming window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Hamming window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.hann" module_name="hann" namespace="'signal'">
    <docstring>Return a Hann window.

The Hann window is a taper formed by using a raised cosine or sine-squared
with ends that touch zero.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Hann window is defined as

.. math::  w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The window was named for Julius van Hann, an Austrian meteorologist. It is
also known as the Cosine Bell. It is sometimes erroneously referred to as
the "Hanning" window, from the use of "hann" as a verb in the original
paper and confusion with the very similar Hamming window.

Most references to the Hann window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, "Window function",
       http://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.hann(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Hann window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Hann window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.hanning" module_name="hanning" namespace="'signal'">
    <docstring>Return a Hann window.

The Hann window is a taper formed by using a raised cosine or sine-squared
with ends that touch zero.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Hann window is defined as

.. math::  w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The window was named for Julius van Hann, an Austrian meteorologist. It is
also known as the Cosine Bell. It is sometimes erroneously referred to as
the "Hanning" window, from the use of "hann" as a verb in the original
paper and confusion with the very similar Hamming window.

Most references to the Hann window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, "Window function",
       http://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.hann(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Hann window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Hann window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.hilbert" module_name="hilbert" namespace="'signal'">
    <docstring>Compute the analytic signal, using the Hilbert transform.

The transformation is done along the last axis by default.

Parameters
----------
x : array_like
    Signal data.  Must be real.
N : int, optional
    Number of Fourier components.  Default: ``x.shape[axis]``
axis : int, optional
    Axis along which to do the transformation.  Default: -1.

Returns
-------
xa : ndarray
    Analytic signal of `x`, of each 1-D array along `axis`

Notes
-----
The analytic signal ``x_a(t)`` of signal ``x(t)`` is:

.. math:: x_a = F^{-1}(F(x) 2U) = x + i y

where `F` is the Fourier transform, `U` the unit step function,
and `y` the Hilbert transform of `x`. [1]_

In other words, the negative half of the frequency spectrum is zeroed
out, turning the real-valued signal into a complex signal.  The Hilbert
transformed signal can be obtained from ``np.imag(hilbert(x))``, and the
original signal from ``np.real(hilbert(x))``.

References
----------
.. [1] Wikipedia, "Analytic signal".
       http://en.wikipedia.org/wiki/Analytic_signal</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Signal data.  Must be real.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of Fourier components.  Default: ``x.shape[axis]``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to do the transformation.  Default: -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="xa" name="xa" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Analytic signal of `x`, of each 1-D array along `axis`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.hilbert2" module_name="hilbert2" namespace="'signal'">
    <docstring>Compute the '2-D' analytic signal of `x`

Parameters
----------
x : array_like
    2-D signal data.
N : int or tuple of two ints, optional
    Number of Fourier components. Default is ``x.shape``

Returns
-------
xa : ndarray
    Analytic signal of `x` taken along axes (0,1).

References
----------
.. [1] Wikipedia, "Analytic signal",
    http://en.wikipedia.org/wiki/Analytic_signal</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>2-D signal data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="NScalar" port_type="basic:Integer">
      <docstring>Number of Fourier components. Default is ``x.shape``</docstring>
      <alternateSpec arg="N" depth="1" name="NSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <outputPortSpec arg="xa" name="xa" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Analytic signal of `x` taken along axes (0,1).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.iirdesign" module_name="iirdesign" namespace="'signal'" output_type="list">
    <docstring>Complete IIR digital and analog filter design.

Given passband and stopband frequencies and gains, construct an analog or
digital IIR filter of minimum order for a given basic type.  Return the
output in numerator, denominator ('ba'), pole-zero ('zpk') or second order
sections ('sos') form.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
ftype : str, optional
    The type of IIR filter to design:

        - Butterworth   : 'butter'
        - Chebyshev I   : 'cheby1'
        - Chebyshev II  : 'cheby2'
        - Cauer/elliptic: 'ellip'
        - Bessel/Thomson: 'bessel'

output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

See Also
--------
butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies

Notes
-----
The ``'sos'`` output parameter was added in 0.16.0.</docstring>
    <inputPortSpec arg="wp" name="wp" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ws" name="ws" port_type="basic:Float" show_port="True">
      <docstring>Passband and stopband edge frequencies.
For digital filters, these are normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
half-cycles / sample.)  For example:

    - Lowpass:   wp = 0.2,          ws = 0.3
    - Highpass:  wp = 0.3,          ws = 0.2
    - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
    - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gpass" name="gpass" port_type="basic:Float" show_port="True">
      <docstring>The maximum loss in the passband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="gstop" name="gstop" port_type="basic:Float" show_port="True">
      <docstring>The minimum attenuation in the stopband (dB).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ftype" name="ftype">
      <docstring>The type of IIR filter to design:

    - Butterworth   : 'butter'
    - Chebyshev I   : 'cheby1'
    - Chebyshev II  : 'cheby2'
    - Cauer/elliptic: 'ellip'
    - Bessel/Thomson: 'bessel'
</docstring>
      <defaults>['ellip']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.iirfilter" module_name="iirfilter" namespace="'signal'" output_type="list">
    <docstring>IIR digital and analog filter design given order and critical points.

Design an Nth order digital or analog filter and return the filter
coefficients.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
rp : float, optional
    For Chebyshev and elliptic filters, provides the maximum ripple
    in the passband. (dB)
rs : float, optional
    For Chebyshev and elliptic filters, provides the minimum attenuation
    in the stop band. (dB)
btype : {'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
    The type of filter.  Default is 'bandpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
ftype : str, optional
    The type of IIR filter to design:

        - Butterworth   : 'butter'
        - Chebyshev I   : 'cheby1'
        - Chebyshev II  : 'cheby2'
        - Cauer/elliptic: 'ellip'
        - Bessel/Thomson: 'bessel'

output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output=='sos'``.

See Also
--------
butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirdesign : General filter design using passband and stopband spec

Notes
-----
The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Generate a 17th-order Chebyshev II bandpass filter and plot the frequency
response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; b, a = signal.iirfilter(17, [50, 200], rs=60, btype='band',
...                         analog=True, ftype='cheby2')
&gt;&gt;&gt; w, h = signal.freqs(b, a, 1000)
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.semilogx(w, 20 * np.log10(abs(h)))
&gt;&gt;&gt; ax.set_title('Chebyshev Type II bandpass frequency response')
&gt;&gt;&gt; ax.set_xlabel('Frequency [radians / second]')
&gt;&gt;&gt; ax.set_ylabel('Amplitude [dB]')
&gt;&gt;&gt; ax.axis((10, 1000, -100, 10))
&gt;&gt;&gt; ax.grid(which='both', axis='both')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer" show_port="True">
      <docstring>The order of the filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Wn" name="Wn" port_type="basic:List" show_port="True">
      <docstring>A scalar or length-2 sequence giving the critical frequencies.
For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
Nyquist frequency, pi radians/sample.  (`Wn` is thus in
half-cycles / sample.)
For analog filters, `Wn` is an angular frequency (e.g. rad/s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rp" name="rp" port_type="basic:Float">
      <docstring>For Chebyshev and elliptic filters, provides the maximum ripple
in the passband. (dB)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rs" name="rs" port_type="basic:Float">
      <docstring>For Chebyshev and elliptic filters, provides the minimum attenuation
in the stop band. (dB)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="btype" name="btype">
      <docstring>The type of filter.  Default is 'bandpass'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['bandpass', 'lowpass', 'highpass', 'bandstop']]</values>
      <defaults>['band']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="analog" name="analog" port_type="basic:Boolean">
      <docstring>When True, return an analog filter, otherwise a digital filter is
returned.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ftype" name="ftype">
      <docstring>The type of IIR filter to design:

    - Butterworth   : 'butter'
    - Chebyshev I   : 'cheby1'
    - Chebyshev II  : 'cheby2'
    - Cauer/elliptic: 'ellip'
    - Bessel/Thomson: 'bessel'
</docstring>
      <defaults>['butter']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="output" name="output">
      <docstring>Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['ba', 'zpk', 'sos']]</values>
      <defaults>['ba']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
Only returned if ``output='ba'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="z" depth="1" name="z" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" depth="1" name="p" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" depth="1" name="k" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if ``output='zpk'``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="5">
      <docstring>Second-order sections representation of the IIR filter.
Only returned if ``output=='sos'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.impulse" module_name="impulse" namespace="'signal'" output_type="list">
    <docstring>Impulse response of continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector.  Defaults to zero.
T : array_like, optional
    Time points.  Computed if not given.
N : int, optional
    The number of time points to compute (if `T` is not given).

Returns
-------
T : ndarray
    A 1-D array of time points.
yout : ndarray
    A 1-D array containing the impulse response of the system (except for
    singularities at zero).</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>describing the system.
The following gives the number of elements in the tuple and
the interpretation:

    * 2 (num, den)
    * 3 (zeros, poles, gain)
    * 4 (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="X0" name="X0" port_type="basic:List">
      <docstring>Initial state-vector.  Defaults to zero.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:List">
      <docstring>Time points.  Computed if not given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>The number of time points to compute (if `T` is not given).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 1-D array of time points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>A 1-D array containing the impulse response of the system (except for
singularities at zero).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.impulse2" module_name="impulse2" namespace="'signal'" output_type="list">
    <docstring>Impulse response of a single-input, continuous-time linear system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : 1-D array_like, optional
    The initial condition of the state vector.  Default: 0 (the
    zero vector).
T : 1-D array_like, optional
    The time steps at which the input is defined and at which the
    output is desired.  If `T` is not given, the function will
    generate a set of time samples automatically.
N : int, optional
    Number of time points to compute.  Default: 100.
kwargs : various types
    Additional keyword arguments are passed on to the function
    `scipy.signal.lsim2`, which in turn passes them on to
    `scipy.integrate.odeint`; see the latter's documentation for
    information about these arguments.

Returns
-------
T : ndarray
    The time values for the output.
yout : ndarray
    The output response of the system.

See Also
--------
impulse, lsim2, integrate.odeint

Notes
-----
The solution is generated by calling `scipy.signal.lsim2`, which uses
the differential equation solver `scipy.integrate.odeint`.

.. versionadded:: 0.8.0

Examples
--------
Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = u(t)

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])
&gt;&gt;&gt; t, y = signal.impulse2(system)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, y)</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>describing the system.
The following gives the number of elements in the tuple and
the interpretation:

    * 2 (num, den)
    * 3 (zeros, poles, gain)
    * 4 (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="X0" name="X0" port_type="basic:List">
      <docstring>The initial condition of the state vector.  Default: 0 (the
zero vector).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:List">
      <docstring>The time steps at which the input is defined and at which the
output is desired.  If `T` is not given, the function will
generate a set of time samples automatically.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of time points to compute.  Default: 100.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" port_type="basic:Variant" show_port="True">
      <docstring>Additional keyword arguments are passed on to the function
`scipy.signal.lsim2`, which in turn passes them on to
`scipy.integrate.odeint`; see the latter's documentation for
information about these arguments.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The time values for the output.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The output response of the system.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.invres" module_name="invres" namespace="'signal'">
    <docstring>Compute b(s) and a(s) from partial fraction expansion.

If ``M = len(b)`` and ``N = len(a)``::

            b(s)     b[0] x**(M-1) + b[1] x**(M-2) + ... + b[M-1]
    H(s) = ------ = ----------------------------------------------
            a(s)     a[0] x**(N-1) + a[1] x**(N-2) + ... + a[N-1]

             r[0]       r[1]             r[-1]
         = -------- + -------- + ... + --------- + k(s)
           (s-p[0])   (s-p[1])         (s-p[-1])

If there are any repeated roots (closer than tol), then the partial
fraction expansion has terms like::

      r[i]      r[i+1]              r[i+n-1]
    -------- + ----------- + ... + -----------
    (s-p[i])  (s-p[i])**2          (s-p[i])**n

Parameters
----------
r : ndarray
    Residues.
p : ndarray
    Poles.
k : ndarray
    Coefficients of the direct polynomial term.
tol : float, optional
    The tolerance for two roots to be considered equal. Default is 1e-3.
rtype : {'max', 'min, 'avg'}, optional
    How to determine the returned root if multiple roots are within
    `tol` of each other.

      'max': pick the maximum of those roots.

      'min': pick the minimum of those roots.

      'avg': take the average of those roots.

See Also
--------
residue, unique_roots</docstring>
    <inputPortSpec arg="r" name="r" port_type="basic:List" show_port="True">
      <docstring>Residues.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>Poles.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:List" show_port="True">
      <docstring>Coefficients of the direct polynomial term.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>The tolerance for two roots to be considered equal. Default is 1e-3.</docstring>
      <defaults>[0.001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtype" name="rtype">
      <docstring>How to determine the returned root if multiple roots are within
`tol` of each other.

  'max': pick the maximum of those roots.

  'min': pick the minimum of those roots.

  'avg': take the average of those roots.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['max', "'min", 'avg']]</values>
      <defaults>['avg']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.invresz" module_name="invresz" namespace="'signal'">
    <docstring>Compute b(z) and a(z) from partial fraction expansion.

If ``M = len(b)`` and ``N = len(a)``::

            b(z)     b[0] + b[1] z**(-1) + ... + b[M-1] z**(-M+1)
    H(z) = ------ = ----------------------------------------------
            a(z)     a[0] + a[1] z**(-1) + ... + a[N-1] z**(-N+1)

                 r[0]                   r[-1]
         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1)...
           (1-p[0]z**(-1))         (1-p[-1]z**(-1))

If there are any repeated roots (closer than tol), then the partial
fraction expansion has terms like::

         r[i]              r[i+1]                    r[i+n-1]
    -------------- + ------------------ + ... + ------------------
    (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n

See Also
--------
residuez, unique_roots, invres</docstring>
    <inputPortSpec arg="p" name="p" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="k" name="k" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="r" name="r" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <defaults>[0.001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtype" name="rtype">
      <defaults>['avg']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.kaiser" module_name="kaiser" namespace="'signal'">
    <docstring>Return a Kaiser window.

The Kaiser window is a taper formed by using a Bessel function.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
beta : float
    Shape parameter, determines trade-off between main-lobe width and
    side lobe level. As beta gets large, the window narrows.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Notes
-----
The Kaiser window is defined as

.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
           \right)/I_0(\beta)

with

.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},

where :math:`I_0` is the modified zeroth-order Bessel function.

The Kaiser was named for Jim Kaiser, who discovered a simple approximation
to the DPSS window based on Bessel functions.
The Kaiser window is a very good approximation to the Digital Prolate
Spheroidal Sequence, or Slepian window, which is the transform which
maximizes the energy in the main lobe of the window relative to total
energy.

The Kaiser can approximate many other windows by varying the beta
parameter.

====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hann
8.6   Similar to a Blackman
====  =======================

A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
get returned.

Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
       digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
       John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
       University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, "Window function",
       http://en.wikipedia.org/wiki/Window_function

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.kaiser(51, beta=14)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(r"Kaiser window ($\beta$=14)")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title(r"Frequency response of the Kaiser window ($\beta$=14)")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="beta" name="beta" port_type="basic:Float" show_port="True">
      <docstring>Shape parameter, determines trade-off between main-lobe width and
side lobe level. As beta gets large, the window narrows.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.kaiser_atten" module_name="kaiser_atten" namespace="'signal'">
    <docstring>Compute the attenuation of a Kaiser FIR filter.

Given the number of taps `N` and the transition width `width`, compute the
attenuation `a` in dB, given by Kaiser's formula:

    a = 2.285 * (N - 1) * pi * width + 7.95

Parameters
----------
numtaps : int
    The number of taps in the FIR filter.
width : float
    The desired width of the transition region between passband and
    stopband (or, in general, at any discontinuity) for the filter.

Returns
-------
a : float
    The attenuation of the ripple, in dB.

See Also
--------
kaiserord, kaiser_beta</docstring>
    <inputPortSpec arg="numtaps" name="numtaps" port_type="basic:Integer" show_port="True">
      <docstring>The number of taps in the FIR filter.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="width" name="width" port_type="basic:Float" show_port="True">
      <docstring>The desired width of the transition region between passband and
stopband (or, in general, at any discontinuity) for the filter.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The attenuation of the ripple, in dB.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.kaiser_beta" module_name="kaiser_beta" namespace="'signal'">
    <docstring>Compute the Kaiser parameter `beta`, given the attenuation `a`.

Parameters
----------
a : float
    The desired attenuation in the stopband and maximum ripple in
    the passband, in dB.  This should be a *positive* number.

Returns
-------
beta : float
    The `beta` parameter to be used in the formula for a Kaiser window.

References
----------
Oppenheim, Schafer, "Discrete-Time Signal Processing", p.475-476.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>The desired attenuation in the stopband and maximum ripple in
the passband, in dB.  This should be a *positive* number.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="beta" name="beta" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The `beta` parameter to be used in the formula for a Kaiser window.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.kaiserord" module_name="kaiserord" namespace="'signal'" output_type="list">
    <docstring>Design a Kaiser window to limit ripple and width of transition region.

Parameters
----------
ripple : float
    Positive number specifying maximum ripple in passband (dB) and minimum
    ripple in stopband.
width : float
    Width of transition region (normalized so that 1 corresponds to pi
    radians / sample).

Returns
-------
numtaps : int
    The length of the kaiser window.
beta : float
    The beta parameter for the kaiser window.

See Also
--------
kaiser_beta, kaiser_atten

Notes
-----
There are several ways to obtain the Kaiser window:

- ``signal.kaiser(numtaps, beta, sym=0)``
- ``signal.get_window(beta, numtaps)``
- ``signal.get_window(('kaiser', beta), numtaps)``

The empirical equations discovered by Kaiser are used.

References
----------
Oppenheim, Schafer, "Discrete-Time Signal Processing", p.475-476.</docstring>
    <inputPortSpec arg="ripple" name="ripple" port_type="basic:Float" show_port="True">
      <docstring>Positive number specifying maximum ripple in passband (dB) and minimum
ripple in stopband.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="width" name="width" port_type="basic:Float" show_port="True">
      <docstring>Width of transition region (normalized so that 1 corresponds to pi
radians / sample).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="numtaps" name="numtaps" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The length of the kaiser window.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="beta" name="beta" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The beta parameter for the kaiser window.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lfilter" module_name="lfilter" namespace="'signal'" output_type="list">
    <docstring>Filter data along one-dimension with an IIR or FIR filter.

Filter a data sequence, `x`, using a digital filter.  This works for many
fundamental data types (including Object type).  The filter is a direct
form II transposed implementation of the standard difference equation
(see Notes).

Parameters
----------
b : array_like
    The numerator coefficient vector in a 1-D sequence.
a : array_like
    The denominator coefficient vector in a 1-D sequence.  If ``a[0]``
    is not 1, then both `a` and `b` are normalized by ``a[0]``.
x : array_like
    An N-dimensional input array.
axis : int, optional
    The axis of the input data array along which to apply the
    linear filter. The filter is applied to each subarray along
    this axis.  Default is -1.
zi : array_like, optional
    Initial conditions for the filter delays.  It is a vector
    (or array of vectors for an N-dimensional input) of length
    ``max(len(a),len(b))-1``.  If `zi` is None or is not given then
    initial rest is assumed.  See `lfiltic` for more information.

Returns
-------
y : array
    The output of the digital filter.
zf : array, optional
    If `zi` is None, this is not returned, otherwise, `zf` holds the
    final filter delay values.

Notes
-----
The filter function is implemented as a direct II transposed structure.
This means that the filter implements::

   a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[nb]*x[n-nb]
                           - a[1]*y[n-1] - ... - a[na]*y[n-na]

using the following difference equations::

     y[m] = b[0]*x[m] + z[0,m-1]
     z[0,m] = b[1]*x[m] + z[1,m-1] - a[1]*y[m]
     ...
     z[n-3,m] = b[n-2]*x[m] + z[n-2,m-1] - a[n-2]*y[m]
     z[n-2,m] = b[n-1]*x[m] - a[n-1]*y[m]

where m is the output sample number and n=max(len(a),len(b)) is the
model order.

The rational transfer function describing this filter in the
z-transform domain is::

                         -1               -nb
             b[0] + b[1]z  + ... + b[nb] z
     Y(z) = ---------------------------------- X(z)
                         -1               -na
             a[0] + a[1]z  + ... + a[na] z</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The numerator coefficient vector in a 1-D sequence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The denominator coefficient vector in a 1-D sequence.  If ``a[0]``
is not 1, then both `a` and `b` are normalized by ``a[0]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>An N-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="zi" name="zi" port_type="basic:List">
      <docstring>Initial conditions for the filter delays.  It is a vector
(or array of vectors for an N-dimensional input) of length
``max(len(a),len(b))-1``.  If `zi` is None or is not given then
initial rest is assumed.  See `lfiltic` for more information.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The output of the digital filter.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="zf" name="zf" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>If `zi` is None, this is not returned, otherwise, `zf` holds the
final filter delay values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lfilter_zi" module_name="lfilter_zi" namespace="'signal'">
    <docstring>Compute an initial state `zi` for the lfilter function that corresponds
to the steady state of the step response.

A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.

Parameters
----------
b, a : array_like (1-D)
    The IIR filter coefficients. See `lfilter` for more
    information.

Returns
-------
zi : 1-D ndarray
    The initial state for the filter.

Notes
-----
A linear filter with order m has a state space representation (A, B, C, D),
for which the output y of the filter can be expressed as::

    z(n+1) = A*z(n) + B*x(n)
    y(n)   = C*z(n) + D*x(n)

where z(n) is a vector of length m, A has shape (m, m), B has shape
(m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is
a scalar).  lfilter_zi solves::

    zi = A*zi + B

In other words, it finds the initial condition for which the response
to an input of all ones is a constant.

Given the filter coefficients `a` and `b`, the state space matrices
for the transposed direct form II implementation of the linear filter,
which is the implementation used by scipy.signal.lfilter, are::

    A = scipy.linalg.companion(a).T
    B = b[1:] - a[1:]*b[0]

assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first
divided by a[0].

Examples
--------
The following code creates a lowpass Butterworth filter. Then it
applies that filter to an array whose values are all 1.0; the
output is also all 1.0, as expected for a lowpass filter.  If the
`zi` argument of `lfilter` had not been given, the output would have
shown the transient signal.

&gt;&gt;&gt; from numpy import array, ones
&gt;&gt;&gt; from scipy.signal import lfilter, lfilter_zi, butter
&gt;&gt;&gt; b, a = butter(5, 0.25)
&gt;&gt;&gt; zi = lfilter_zi(b, a)
&gt;&gt;&gt; y, zo = lfilter(b, a, ones(10), zi=zi)
&gt;&gt;&gt; y
array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])

Another example:

&gt;&gt;&gt; x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])
&gt;&gt;&gt; y, zf = lfilter(b, a, x, zi=zi*x[0])
&gt;&gt;&gt; y
array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,
    0.44399389,  0.35505241])

Note that the `zi` argument to `lfilter` was computed using
`lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no
transient until the input drops from 0.5 to 0.0.</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The IIR filter coefficients. See `lfilter` for more
information.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The IIR filter coefficients. See `lfilter` for more
information.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="zi" name="zi" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The initial state for the filter.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lfiltic" module_name="lfiltic" namespace="'signal'">
    <docstring>Construct initial conditions for lfilter.

Given a linear filter (b, a) and initial conditions on the output `y`
and the input `x`, return the initial conditions on the state vector zi
which is used by `lfilter` to generate the output given the input.

Parameters
----------
b : array_like
    Linear filter term.
a : array_like
    Linear filter term.
y : array_like
    Initial conditions.

    If ``N=len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.

    If `y` is too short, it is padded with zeros.
x : array_like, optional
    Initial conditions.

    If ``M=len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.

    If `x` is not given, its initial conditions are assumed zero.

    If `x` is too short, it is padded with zeros.

Returns
-------
zi : ndarray
    The state vector ``zi``.
    ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``, where ``K = max(M,N)``.

See Also
--------
lfilter</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Linear filter term.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Linear filter term.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Initial conditions.

If ``N=len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.

If `y` is too short, it is padded with zeros.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List">
      <docstring>Initial conditions.

If ``M=len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.

If `x` is not given, its initial conditions are assumed zero.

If `x` is too short, it is padded with zeros.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="zi" name="zi" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The state vector ``zi``.
``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``, where ``K = max(M,N)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lombscargle" module_name="lombscargle" namespace="'signal'">
    <docstring>lombscargle(x, y, freqs)

Computes the Lomb-Scargle periodogram.

The Lomb-Scargle periodogram was developed by Lomb [1]_ and further
extended by Scargle [2]_ to find, and test the significance of weak
periodic signals with uneven temporal sampling.

The computed periodogram is unnormalized, it takes the value
``(A**2) * N/4`` for a harmonic signal with amplitude A for sufficiently
large N.

Parameters
----------
x : array_like
    Sample times.
y : array_like
    Measurement values.
freqs : array_like
    Angular frequencies for output periodogram.

Returns
-------
pgram : array_like
    Lomb-Scargle periodogram.

Raises
------
ValueError
    If the input arrays `x` and `y` do not have the same shape.

Notes
-----
This subroutine calculates the periodogram using a slightly
modified algorithm due to Townsend [3]_ which allows the
periodogram to be calculated using only a single pass through
the input arrays for each frequency.

The algorithm running time scales roughly as O(x * freqs) or O(N^2)
for a large number of samples and frequencies.

References
----------
.. [1] N.R. Lomb "Least-squares frequency analysis of unequally spaced
       data", Astrophysics and Space Science, vol 39, pp. 447-462, 1976

.. [2] J.D. Scargle "Studies in astronomical time series analysis. II - 
       Statistical aspects of spectral analysis of unevenly spaced data",
       The Astrophysical Journal, vol 263, pp. 835-853, 1982

.. [3] R.H.D. Townsend, "Fast calculation of the Lomb-Scargle
       periodogram using graphics processing units.", The Astrophysical
       Journal Supplement Series, vol 191, pp. 247-253, 2010

Examples
--------
&gt;&gt;&gt; import scipy.signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

First define some input parameters for the signal:

&gt;&gt;&gt; A = 2.
&gt;&gt;&gt; w = 1.
&gt;&gt;&gt; phi = 0.5 * np.pi
&gt;&gt;&gt; nin = 1000
&gt;&gt;&gt; nout = 100000
&gt;&gt;&gt; frac_points = 0.9 # Fraction of points to select
 
Randomly select a fraction of an array with timesteps:

&gt;&gt;&gt; r = np.random.rand(nin)
&gt;&gt;&gt; x = np.linspace(0.01, 10*np.pi, nin)
&gt;&gt;&gt; x = x[r &gt;= frac_points]
&gt;&gt;&gt; normval = x.shape[0] # For normalization of the periodogram
 
Plot a sine wave for the selected times:

&gt;&gt;&gt; y = A * np.sin(w*x+phi)

Define the array of frequencies for which to compute the periodogram:

&gt;&gt;&gt; f = np.linspace(0.01, 10, nout)
 
Calculate Lomb-Scargle periodogram:

&gt;&gt;&gt; import scipy.signal as signal
&gt;&gt;&gt; pgram = signal.lombscargle(x, y, f)

Now make a plot of the input data:

&gt;&gt;&gt; plt.subplot(2, 1, 1)
&lt;matplotlib.axes.AxesSubplot object at 0x102154f50&gt;
&gt;&gt;&gt; plt.plot(x, y, 'b+')
[&lt;matplotlib.lines.Line2D object at 0x102154a10&gt;]

Then plot the normalized periodogram:

&gt;&gt;&gt; plt.subplot(2, 1, 2)
&lt;matplotlib.axes.AxesSubplot object at 0x104b0a990&gt;
&gt;&gt;&gt; plt.plot(f, np.sqrt(4*(pgram/normval)))
[&lt;matplotlib.lines.Line2D object at 0x104b2f910&gt;]
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Sample times.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Measurement values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="freqs" name="freqs" port_type="basic:List" show_port="True">
      <docstring>Angular frequencies for output periodogram.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pgram" name="pgram" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Lomb-Scargle periodogram.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lp2bp" module_name="lp2bp" namespace="'signal'">
    <docstring>Transform a lowpass filter prototype to a bandpass filter.

Return an analog band-pass filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="wo" name="wo" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="bw" name="bw" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lp2bs" module_name="lp2bs" namespace="'signal'">
    <docstring>Transform a lowpass filter prototype to a bandstop filter.

Return an analog band-stop filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="wo" name="wo" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="bw" name="bw" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lp2hp" module_name="lp2hp" namespace="'signal'">
    <docstring>Transform a lowpass filter prototype to a highpass filter.

Return an analog high-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="wo" name="wo" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lp2lp" module_name="lp2lp" namespace="'signal'">
    <docstring>Transform a lowpass filter prototype to a different frequency.

Return an analog low-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="wo" name="wo" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lsim" module_name="lsim" namespace="'signal'" output_type="list">
    <docstring>Simulate output of a continuous-time linear system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

    * 2: (num, den)
    * 3: (zeros, poles, gain)
    * 4: (A, B, C, D)

U : array_like
    An input array describing the input at each time `T`
    (interpolation is assumed between given times).  If there are
    multiple inputs, then each column of the rank-2 array
    represents an input.  If U = 0 or None, a zero input is used.
T : array_like
    The time steps at which the input is defined and at which the
    output is desired.  Must be nonnegative, increasing, and equally spaced.
X0 : array_like, optional
    The initial conditions on the state vector (zero by default).
interp : bool, optional
    Whether to use linear (True, the default) or zero-order-hold (False)
    interpolation for the input array.

Returns
-------
T : 1D ndarray
    Time values for the output.
yout : 1D ndarray
    System response.
xout : ndarray
    Time evolution of the state vector.

Examples
--------
Simulate a double integrator y'' = u, with a constant input u = 1

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; system = signal.lti([[0., 1.], [0., 0.]], [[0.], [1.]], [[1., 0.]], 0.)
&gt;&gt;&gt; t = np.linspace(0, 5)
&gt;&gt;&gt; u = np.ones_like(t)
&gt;&gt;&gt; tout, y, x = signal.lsim(system, u, t)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, y)</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>The following gives the number of elements in the tuple and
the interpretation:

* 2: (num, den)
* 3: (zeros, poles, gain)
* 4: (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="U" name="U" port_type="basic:List" show_port="True">
      <docstring>An input array describing the input at each time `T`
(interpolation is assumed between given times).  If there are
multiple inputs, then each column of the rank-2 array
represents an input.  If U = 0 or None, a zero input is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:List" show_port="True">
      <docstring>The time steps at which the input is defined and at which the
output is desired.  Must be nonnegative, increasing, and equally spaced.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="X0" name="X0" port_type="basic:List">
      <docstring>The initial conditions on the state vector (zero by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="interp" name="interp" port_type="basic:Boolean">
      <docstring>Whether to use linear (True, the default) or zero-order-hold (False)
interpolation for the input array.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Time values for the output.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>System response.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xout" name="xout" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Time evolution of the state vector.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.lsim2" module_name="lsim2" namespace="'signal'" output_type="list">
    <docstring>Simulate output of a continuous-time linear system, by using
the ODE solver `scipy.integrate.odeint`.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

    * 2: (num, den)
    * 3: (zeros, poles, gain)
    * 4: (A, B, C, D)

U : array_like (1D or 2D), optional
    An input array describing the input at each time T.  Linear
    interpolation is used between given times.  If there are
    multiple inputs, then each column of the rank-2 array
    represents an input.  If U is not given, the input is assumed
    to be zero.
T : array_like (1D or 2D), optional
    The time steps at which the input is defined and at which the
    output is desired.  The default is 101 evenly spaced points on
    the interval [0,10.0].
X0 : array_like (1D), optional
    The initial condition of the state vector.  If `X0` is not
    given, the initial conditions are assumed to be 0.
kwargs : dict
    Additional keyword arguments are passed on to the function
    `odeint`.  See the notes below for more details.

Returns
-------
T : 1D ndarray
    The time values for the output.
yout : ndarray
    The response of the system.
xout : ndarray
    The time-evolution of the state-vector.

Notes
-----
This function uses `scipy.integrate.odeint` to solve the
system's differential equations.  Additional keyword arguments
given to `lsim2` are passed on to `odeint`.  See the documentation
for `scipy.integrate.odeint` for the full list of arguments.</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>The following gives the number of elements in the tuple and
the interpretation:

* 2: (num, den)
* 3: (zeros, poles, gain)
* 4: (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="U" name="UScalar">
      <docstring>An input array describing the input at each time T.  Linear
interpolation is used between given times.  If there are
multiple inputs, then each column of the rank-2 array
represents an input.  If U is not given, the input is assumed
to be zero.</docstring>
      <alternateSpec arg="U" name="USequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="T" name="TScalar">
      <docstring>The time steps at which the input is defined and at which the
output is desired.  The default is 101 evenly spaced points on
the interval [0,10.0].</docstring>
      <alternateSpec arg="T" name="TSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="X0" name="X0" port_type="basic:List">
      <docstring>The initial condition of the state vector.  If `X0` is not
given, the initial conditions are assumed to be 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" port_type="basic:Dictionary" show_port="True">
      <docstring>Additional keyword arguments are passed on to the function
`odeint`.  See the notes below for more details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The time values for the output.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The response of the system.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xout" name="xout" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The time-evolution of the state-vector.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.max_len_seq" module_name="max_len_seq" namespace="'signal'" output_type="list">
    <docstring>max_len_seq(nbits, state=None, length=None, taps=None)

Maximum Length Sequence (MLS) generator

Parameters
----------
nbits : int
    Number of bits to use. Length of the resulting sequence will
    be ``(2**nbits) - 1``. Note that generating long sequences
    (e.g., greater than ``nbits == 16``) can take a long time.
state : array_like, optional
    If array, must be of length ``nbits``, and will be cast to binary
    (bool) representation. If None, a seed of ones will be used,
    producing a repeatable representation. If ``state`` is all
    zeros, an error is raised as this is invalid. Default: None.
length : int | None, optional
    Number of samples to compute. If None, the entire length
    ``(2**nbits) - 1`` is computed.
taps : array_like, optional
    Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).
    If None, taps will be automatically selected (for up to
    ``nbits == 32``).

Returns
-------
seq : array
    Resulting MLS sequence of 0's and 1's.
state : array
    The final state of the shift register.

Notes
-----
The algorithm for MLS generation is generically described in:

    http://en.wikipedia.org/wiki/Maximum_length_sequence

The default values for taps are specifically taken from the first
option listed for each value of ``nbits`` in:

    http://www.newwaveinstruments.com/resources/articles/
        m_sequence_linear_feedback_shift_register_lfsr.htm

.. versionadded:: 0.15.0</docstring>
    <inputPortSpec arg="nbits" name="nbits" port_type="basic:Integer" show_port="True">
      <docstring>Number of bits to use. Length of the resulting sequence will
be ``(2**nbits) - 1``. Note that generating long sequences
(e.g., greater than ``nbits == 16``) can take a long time.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="state" name="state" port_type="basic:List">
      <docstring>If array, must be of length ``nbits``, and will be cast to binary
(bool) representation. If None, a seed of ones will be used,
producing a repeatable representation. If ``state`` is all
zeros, an error is raised as this is invalid. Default: None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="length" name="length">
      <docstring>Number of samples to compute. If None, the entire length
``(2**nbits) - 1`` is computed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="taps" name="taps" port_type="basic:List">
      <docstring>Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).
If None, taps will be automatically selected (for up to
``nbits == 32``).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="seq" name="seq" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Resulting MLS sequence of 0's and 1's.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="state" name="state" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The final state of the shift register.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.medfilt" module_name="medfilt" namespace="'signal'">
    <docstring>Perform a median filter on an N-dimensional array.

Apply a median filter to the input array using a local window-size
given by `kernel_size`.

Parameters
----------
volume : array_like
    An N-dimensional input array.
kernel_size : array_like, optional
    A scalar or an N-length list giving the size of the median filter
    window in each dimension.  Elements of `kernel_size` should be odd.
    If `kernel_size` is a scalar, then this scalar is used as the size in
    each dimension. Default size is 3 for each dimension.

Returns
-------
out : ndarray
    An array the same size as input containing the median filtered
    result.</docstring>
    <inputPortSpec arg="volume" name="volume" port_type="basic:List" show_port="True">
      <docstring>An N-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kernel_size" name="kernel_size" port_type="basic:List">
      <docstring>A scalar or an N-length list giving the size of the median filter
window in each dimension.  Elements of `kernel_size` should be odd.
If `kernel_size` is a scalar, then this scalar is used as the size in
each dimension. Default size is 3 for each dimension.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array the same size as input containing the median filtered
result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.medfilt2d" module_name="medfilt2d" namespace="'signal'">
    <docstring>Median filter a 2-dimensional array.

Apply a median filter to the `input` array using a local window-size
given by `kernel_size` (must be odd).

Parameters
----------
input : array_like
    A 2-dimensional input array.
kernel_size : array_like, optional
    A scalar or a list of length 2, giving the size of the
    median filter window in each dimension.  Elements of
    `kernel_size` should be odd.  If `kernel_size` is a scalar,
    then this scalar is used as the size in each dimension.
    Default is a kernel of size (3, 3).

Returns
-------
out : ndarray
    An array the same size as input containing the median filtered
    result.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>A 2-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kernel_size" name="kernel_sizeScalar" port_type="basic:Integer">
      <docstring>A scalar or a list of length 2, giving the size of the
median filter window in each dimension.  Elements of
`kernel_size` should be odd.  If `kernel_size` is a scalar,
then this scalar is used as the size in each dimension.
Default is a kernel of size (3, 3).</docstring>
      <defaults>[3]</defaults>
      <alternateSpec arg="kernel_size" name="kernel_sizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array the same size as input containing the median filtered
result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.morlet" module_name="morlet" namespace="'signal'">
    <docstring>Complex Morlet wavelet.

Parameters
----------
M : int
    Length of the wavelet.
w : float, optional
    Omega0. Default is 5
s : float, optional
    Scaling factor, windowed from ``-s*2*pi`` to ``+s*2*pi``. Default is 1.
complete : bool, optional
    Whether to use the complete or the standard version.

Returns
-------
morlet : (M,) ndarray

See Also
--------
scipy.signal.gausspulse

Notes
-----
The standard version::

    pi**-0.25 * exp(1j*w*x) * exp(-0.5*(x**2))

This commonly used wavelet is often referred to simply as the
Morlet wavelet.  Note that this simplified version can cause
admissibility problems at low values of w.

The complete version::

    pi**-0.25 * (exp(1j*w*x) - exp(-0.5*(w**2))) * exp(-0.5*(x**2))

The complete version of the Morlet wavelet, with a correction
term to improve admissibility. For w greater than 5, the
correction term is negligible.

Note that the energy of the return wavelet is not normalised
according to s.

The fundamental frequency of this wavelet in Hz is given
by ``f = 2*s*w*r / M`` where r is the sampling rate.</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Length of the wavelet.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:Float">
      <docstring>Omega0. Default is 5</docstring>
      <defaults>[5.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:Float">
      <docstring>Scaling factor, windowed from ``-s*2*pi`` to ``+s*2*pi``. Default is 1.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="complete" name="complete" port_type="basic:Boolean">
      <docstring>Whether to use the complete or the standard version.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="morlet" name="morlet" port_type="basic:List" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.normalize" module_name="normalize" namespace="'signal'">
    <docstring>Normalize polynomial representation of a transfer function.

If values of `b` are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.nuttall" module_name="nuttall" namespace="'signal'">
    <docstring>Return a minimum 4-term Blackman-Harris window according to Nuttall.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.nuttall(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Nuttall window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Nuttall window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.order_filter" module_name="order_filter" namespace="'signal'">
    <docstring>Perform an order filter on an N-dimensional array.

Perform an order filter on the array in.  The domain argument acts as a
mask centered over each pixel.  The non-zero elements of domain are
used to select elements surrounding each input pixel which are placed
in a list.   The list is sorted, and the output for that pixel is the
element corresponding to rank in the sorted list.

Parameters
----------
a : ndarray
    The N-dimensional input array.
domain : array_like
    A mask array with the same number of dimensions as `in`.
    Each dimension should have an odd number of elements.
rank : int
    A non-negative integer which selects the element from the
    sorted list (0 corresponds to the smallest element, 1 is the
    next smallest element, etc.).

Returns
-------
out : ndarray
    The results of the order filter in an array with the same
    shape as `in`.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; x = np.arange(25).reshape(5, 5)
&gt;&gt;&gt; domain = np.identity(3)
&gt;&gt;&gt; x
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
&gt;&gt;&gt; signal.order_filter(x, domain, 0)
array([[  0.,   0.,   0.,   0.,   0.],
       [  0.,   0.,   1.,   2.,   0.],
       [  0.,   5.,   6.,   7.,   0.],
       [  0.,  10.,  11.,  12.,   0.],
       [  0.,   0.,   0.,   0.,   0.]])
&gt;&gt;&gt; signal.order_filter(x, domain, 2)
array([[  6.,   7.,   8.,   9.,   4.],
       [ 11.,  12.,  13.,  14.,   9.],
       [ 16.,  17.,  18.,  19.,  14.],
       [ 21.,  22.,  23.,  24.,  19.],
       [ 20.,  21.,  22.,  23.,  24.]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The N-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="domain" name="domain" port_type="basic:List" show_port="True">
      <docstring>A mask array with the same number of dimensions as `in`.
Each dimension should have an odd number of elements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rank" name="rank" port_type="basic:Integer" show_port="True">
      <docstring>A non-negative integer which selects the element from the
sorted list (0 corresponds to the smallest element, 1 is the
next smallest element, etc.).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The results of the order filter in an array with the same
shape as `in`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.parzen" module_name="parzen" namespace="'signal'">
    <docstring>Return a Parzen window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.parzen(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Parzen window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Parzen window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.periodogram" module_name="periodogram" namespace="'signal'" output_type="list">
    <docstring>Estimate power spectral density using a periodogram.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. See `get_window` for a list of windows and
    required parameters. If `window` is an array it will be used
    directly as the window. Defaults to None; equivalent to 'boxcar'.
nfft : int, optional
    Length of the FFT used. If None the length of `x` will be used.
detrend : str or function or False, optional
    Specifies how to detrend `x` prior to computing the spectrum. If
    `detrend` is a string, it is passed as the ``type`` argument to
    `detrend`.  If it is a function, it should return a detrended array.
    If `detrend` is False, no detrending is done.  Defaults to 'constant'.
return_onesided : bool, optional
    If True, return a one-sided spectrum for real data. If False return
    a two-sided spectrum. Note that for complex data, a two-sided
    spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Pxx` has units of V**2/Hz and computing the power spectrum
    ('spectrum') where `Pxx` has units of V**2, if `x` is measured in V
    and fs is measured in Hz.  Defaults to 'density'
axis : int, optional
    Axis along which the periodogram is computed; the default is over
    the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxx : ndarray
    Power spectral density or power spectrum of `x`.

Notes
-----
.. versionadded:: 0.12.0

See Also
--------
welch: Estimate power spectral density using Welch's method
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2*np.sqrt(2)
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the power spectral density.

&gt;&gt;&gt; f, Pxx_den = signal.periodogram(x, fs)
&gt;&gt;&gt; plt.semilogy(f, Pxx_den)
&gt;&gt;&gt; plt.ylim([1e-7, 1e2])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()

If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.

&gt;&gt;&gt; np.mean(Pxx_den[256:])
0.0009924865443739191

Now compute and plot the power spectrum.

&gt;&gt;&gt; f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))
&gt;&gt;&gt; plt.ylim([1e-4, 1e1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]')
&gt;&gt;&gt; plt.show()

The peak height in the power spectrum is an estimate of the RMS amplitude.

&gt;&gt;&gt; np.sqrt(Pxx_spec.max())
2.0077340678640727</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fs" name="fs" port_type="basic:Float">
      <docstring>Sampling frequency of the `x` time series. Defaults to 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" name="windowScalar">
      <docstring>Desired window to use. See `get_window` for a list of windows and
required parameters. If `window` is an array it will be used
directly as the window. Defaults to None; equivalent to 'boxcar'.</docstring>
      <alternateSpec arg="window" name="windowSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nfft" name="nfft" port_type="basic:Integer">
      <docstring>Length of the FFT used. If None the length of `x` will be used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" name="detrend">
      <docstring>Specifies how to detrend `x` prior to computing the spectrum. If
`detrend` is a string, it is passed as the ``type`` argument to
`detrend`.  If it is a function, it should return a detrended array.
If `detrend` is False, no detrending is done.  Defaults to 'constant'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['function']]</values>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_onesided" name="return_onesided" port_type="basic:Boolean">
      <docstring>If True, return a one-sided spectrum for real data. If False return
a two-sided spectrum. Note that for complex data, a two-sided
spectrum is always returned.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scaling" name="scaling">
      <docstring>Selects between computing the power spectral density ('density')
where `Pxx` has units of V**2/Hz and computing the power spectrum
('spectrum') where `Pxx` has units of V**2, if `x` is measured in V
and fs is measured in Hz.  Defaults to 'density'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['density', 'spectrum']]</values>
      <defaults>['density']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the periodogram is computed; the default is over
the last axis (i.e. ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of sample frequencies.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Pxx" name="Pxx" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Power spectral density or power spectrum of `x`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.place_poles" module_name="place_poles" namespace="'signal'">
    <docstring>Compute K such that eigenvalues (A - dot(B, K))=poles.

K is the gain matrix such as the plant described by the linear system
``AX+BU`` will have its closed-loop poles, i.e the eigenvalues ``A - B*K``,
as close as possible to those asked for in poles.

SISO, MISO and MIMO systems are supported.

Parameters
----------
A, B : ndarray
    State-space representation of linear system ``AX + BU``.
poles : array_like
    Desired real poles and/or complex conjugates poles.
    Complex poles are only supported with ``method="YT"`` (default).
method: {'YT', 'KNV0'}, optional
    Which method to choose to find the gain matrix K. One of:

        - 'YT': Yang Tits
        - 'KNV0': Kautsky, Nichols, Van Dooren update method 0

    See References and Notes for details on the algorithms.
rtol: float, optional
    After each iteration the determinant of the eigenvectors of
    ``A - B*K`` is compared to its previous value, when the relative
    error between these two values becomes lower than `rtol` the algorithm
    stops.  Default is 1e-3.
maxiter: int, optional
    Maximum number of iterations to compute the gain matrix.
    Default is 30.

Returns
-------
full_state_feedback : Bunch object
    full_state_feedback is composed of:
        gain_matrix : 1-D ndarray
            The closed loop matrix K such as the eigenvalues of ``A-BK``
            are as close as possible to the requested poles.
        computed_poles : 1-D ndarray
            The poles corresponding to ``A-BK`` sorted as first the real
            poles in increasing order, then the complex congugates in
            lexicographic order.
        requested_poles : 1-D ndarray
            The poles the algorithm was asked to place sorted as above,
            they may differ from what was achieved.
        X : 2D ndarray
            The transfer matrix such as ``X * diag(poles) = (A - B*K)*X``
            (see Notes)
        rtol : float
            The relative tolerance achieved on ``det(X)`` (see Notes).
            `rtol` will be NaN if the optimisation algorithms can not run,
            i.e when ``B.shape[1] == 1``, or 0 when the solution is unique.
        nb_iter : int
            The number of iterations performed before converging.
            `nb_iter` will be NaN if the optimisation algorithms can
            not run, i.e when ``B.shape[1] == 1``, or 0 when the solution
            is unique.

Notes
-----
The Tits and Yang (YT), [2]_ paper is an update of the original Kautsky et
al. (KNV) paper [1]_.  KNV relies on rank-1 updates to find the transfer
matrix X such that ``X * diag(poles) = (A - B*K)*X``, whereas YT uses
rank-2 updates. This yields on average more robust solutions (see [2]_
pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV
does not in its original version.  Only update method 0 proposed by KNV has
been implemented here, hence the name ``'KNV0'``.

KNV extended to complex poles is used in Matlab's ``place`` function, YT is
distributed under a non-free licence by Slicot under the name ``robpole``.
It is unclear and undocumented how KNV0 has been extended to complex poles
(Tits and Yang claim on page 14 of their paper that their method can not be
used to extend KNV to complex poles), therefore only YT supports them in
this implementation.

As the solution to the problem of pole placement is not unique for MIMO
systems, both methods start with a tentative transfer matrix which is
altered in various way to increase its determinant.  Both methods have been
proven to converge to a stable solution, however depending on the way the
initial transfer matrix is chosen they will converge to different
solutions and therefore there is absolutely no guarantee that using
``'KNV0'`` will yield results similar to Matlab's or any other
implementation of these algorithms.

Using the default method ``'YT'`` should be fine in most cases; ``'KNV0'``
is only provided because it is needed by ``'YT'`` in some specific cases.
Furthermore ``'YT'`` gives on average more robust results than ``'KNV0'``
when ``abs(det(X))`` is used as a robustness indicator.

[2]_ is available as a technical report on the following URL:
http://drum.lib.umd.edu/handle/1903/5598

References
----------
.. [1] J. Kautsky, N.K. Nichols and P. van Dooren, "Robust pole assignment
       in linear state feedback", International Journal of Control, Vol. 41
       pp. 1129-1155, 1985.
.. [2] A.L. Tits and Y. Yang, "Globally convergent algorithms for robust
       pole assignment by state feedback, IEEE Transactions on Automatic
       Control, Vol. 41, pp. 1432-1452, 1996.

Examples
--------
A simple example demonstrating real pole placement using both KNV and YT
algorithms.  This is example number 1 from section 4 of the reference KNV
publication ([1]_):

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ],
...               [-0.5814, -4.290,   0,      0.6750 ],
...               [ 1.067,   4.273,  -6.654,  5.893  ],
...               [ 0.0480,  4.273,   1.343, -2.104  ]])
&gt;&gt;&gt; B = np.array([[ 0,      5.679 ],
...               [ 1.136,  1.136 ],
...               [ 0,      0,    ],
...               [-3.146,  0     ]])
&gt;&gt;&gt; P = np.array([-0.2, -0.5, -5.0566, -8.6659])

Now compute K with KNV method 0, with the default YT method and with the YT
method while forcing 100 iterations of the algorithm and print some results
after each call.

&gt;&gt;&gt; fsf1 = signal.place_poles(A, B, P, method='KNV0')
&gt;&gt;&gt; fsf1.gain_matrix
array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785],
       [ 0.50587268,  0.57779091,  0.51795763, -0.41991442]])

&gt;&gt;&gt; fsf2 = signal.place_poles(A, B, P)  # uses YT method
&gt;&gt;&gt; fsf2.computed_poles
array([-8.6659, -5.0566, -0.5   , -0.2   ])

&gt;&gt;&gt; fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100)
&gt;&gt;&gt; fsf3.X
array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j],
       [-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j],
       [-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j],
       [ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]])

The absolute value of the determinant of X is a good indicator to check the
robustness of the results, both ``'KNV0'`` and ``'YT'`` aim at maximizing
it.  Below a comparison of the robustness of the results above:

&gt;&gt;&gt; abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X))
True
&gt;&gt;&gt; abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X))
True

Now a simple example for complex poles:

&gt;&gt;&gt; A = np.array([[ 0,  7/3.,  0,   0   ],
...               [ 0,   0,    0,  7/9. ],
...               [ 0,   0,    0,   0   ],
...               [ 0,   0,    0,   0   ]])
&gt;&gt;&gt; B = np.array([[ 0,  0 ],
...               [ 0,  0 ],
...               [ 1,  0 ],
...               [ 0,  1 ]])
&gt;&gt;&gt; P = np.array([-3, -1, -2-1j, -2+1j]) / 3.
&gt;&gt;&gt; fsf = signal.place_poles(A, B, P, method='YT')

We can plot the desired and computed poles in the complex plane:

&gt;&gt;&gt; t = np.linspace(0, 2*np.pi, 401)
&gt;&gt;&gt; plt.plot(np.cos(t), np.sin(t), 'k--')  # unit circle
&gt;&gt;&gt; plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag,
...          'wo', label='Desired')
&gt;&gt;&gt; plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, 'bx',
...          label='Placed')
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.axis('image')
&gt;&gt;&gt; plt.axis([-1.1, 1.1, -1.1, 1.1])
&gt;&gt;&gt; plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1)</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system ``AX + BU``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system ``AX + BU``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="poles" name="poles" port_type="basic:List" show_port="True">
      <docstring>Desired real poles and/or complex conjugates poles.
Complex poles are only supported with ``method="YT"`` (default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="'KNV0'}" name="'KNV0'}" port_type="basic:Variant" show_port="True">
      <docstring>Which method to choose to find the gain matrix K. One of:

    - 'YT': Yang Tits
    - 'KNV0': Kautsky, Nichols, Van Dooren update method 0

See References and Notes for details on the algorithms.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="optional" name="optional" port_type="basic:Variant" show_port="True">
      <docstring>Which method to choose to find the gain matrix K. One of:

    - 'YT': Yang Tits
    - 'KNV0': Kautsky, Nichols, Van Dooren update method 0

See References and Notes for details on the algorithms.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="optional" name="optional" port_type="basic:Variant" show_port="True">
      <docstring>After each iteration the determinant of the eigenvectors of
``A - B*K`` is compared to its previous value, when the relative
error between these two values becomes lower than `rtol` the algorithm
stops.  Default is 1e-3.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="optional" name="optional" port_type="basic:Variant" show_port="True">
      <docstring>Maximum number of iterations to compute the gain matrix.
Default is 30.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rtol" name="rtol" port_type="basic:Float">
      <defaults>[0.001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <defaults>[30]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <defaults>['YT']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="full_state_feedback" name="full_state_feedback" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>full_state_feedback is composed of:
    gain_matrix : 1-D ndarray
        The closed loop matrix K such as the eigenvalues of ``A-BK``
        are as close as possible to the requested poles.
    computed_poles : 1-D ndarray
        The poles corresponding to ``A-BK`` sorted as first the real
        poles in increasing order, then the complex congugates in
        lexicographic order.
    requested_poles : 1-D ndarray
        The poles the algorithm was asked to place sorted as above,
        they may differ from what was achieved.
    X : 2D ndarray
        The transfer matrix such as ``X * diag(poles) = (A - B*K)*X``
        (see Notes)
    rtol : float
        The relative tolerance achieved on ``det(X)`` (see Notes).
        `rtol` will be NaN if the optimisation algorithms can not run,
        i.e when ``B.shape[1] == 1``, or 0 when the solution is unique.
    nb_iter : int
        The number of iterations performed before converging.
        `nb_iter` will be NaN if the optimisation algorithms can
        not run, i.e when ``B.shape[1] == 1``, or 0 when the solution
        is unique.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.qmf" module_name="qmf" namespace="'signal'">
    <docstring>Return high-pass qmf filter from low-pass

Parameters
----------
hk : array_like
    Coefficients of high-pass filter.</docstring>
    <inputPortSpec arg="hk" name="hk" port_type="basic:List" show_port="True">
      <docstring>Coefficients of high-pass filter.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.qspline1d" module_name="qspline1d" namespace="'signal'">
    <docstring>Compute quadratic spline coefficients for rank-1 array.

Find the quadratic spline coefficients for a 1-D signal assuming
mirror-symmetric boundary conditions.   To obtain the signal back from the
spline representation mirror-symmetric-convolve these coefficients with a
length 3 FIR window [1.0, 6.0, 1.0]/ 8.0 .

Parameters
----------
signal : ndarray
    A rank-1 array representing samples of a signal.
lamb : float, optional
    Smoothing coefficient (must be zero for now).

Returns
-------
c : ndarray
    Cubic spline coefficients.</docstring>
    <inputPortSpec arg="signal" name="signal" port_type="basic:List" show_port="True">
      <docstring>A rank-1 array representing samples of a signal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lamb" name="lamb" port_type="basic:Float">
      <docstring>Smoothing coefficient (must be zero for now).</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="c" name="c" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Cubic spline coefficients.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.qspline1d_eval" module_name="qspline1d_eval" namespace="'signal'">
    <docstring>Evaluate a quadratic spline at the new set of points.

`dx` is the old sample-spacing while `x0` was the old origin.  In
other-words the old-sample points (knot-points) for which the `cj`
represent spline coefficients were at equally-spaced points of::

  oldx = x0 + j*dx  j=0...N-1, with N=len(cj)

Edges are handled using mirror-symmetric boundary conditions.</docstring>
    <inputPortSpec arg="cj" name="cj" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="newx" name="newx" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="x0" name="x0" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="dx" name="dx" port_type="basic:Float">
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.qspline2d" module_name="qspline2d" namespace="'signal'">
    <docstring>qspline2d(input {, lambda, precision}) -&gt; qk

Description:

  Return the second-order B-spline coefficients over a regularly spaced
  input grid for the two-dimensional input image.  The lambda argument
  specifies the amount of smoothing.  The precision argument allows specifying
  the precision used when computing the infinite sum needed to apply mirror-
  symmetric boundary conditions.</docstring>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.quadratic" module_name="quadratic" namespace="'signal'">
    <docstring>A quadratic B-spline.

This is a special case of `bspline`, and equivalent to ``bspline(x, 2)``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.remez" module_name="remez" namespace="'signal'">
    <docstring>Calculate the minimax optimal filter using the Remez exchange algorithm.

Calculate the filter-coefficients for the finite impulse response
(FIR) filter whose transfer function minimizes the maximum error
between the desired gain and the realized gain in the specified
frequency bands using the Remez exchange algorithm.

Parameters
----------
numtaps : int
    The desired number of taps in the filter. The number of taps is
    the number of terms in the filter, or the filter order plus one.
bands : array_like
    A monotonic sequence containing the band edges in Hz.
    All elements must be non-negative and less than half the sampling
    frequency as given by `Hz`.
desired : array_like
    A sequence half the size of bands containing the desired gain
    in each of the specified bands.
weight : array_like, optional
    A relative weighting to give to each band region. The length of
    `weight` has to be half the length of `bands`.
Hz : scalar, optional
    The sampling frequency in Hz. Default is 1.
type : {'bandpass', 'differentiator', 'hilbert'}, optional
    The type of filter:

      'bandpass' : flat response in bands. This is the default.

      'differentiator' : frequency proportional response in bands.

      'hilbert' : filter with odd symmetry, that is, type III
                  (for even order) or type IV (for odd order)
                  linear phase filters.

maxiter : int, optional
    Maximum number of iterations of the algorithm. Default is 25.
grid_density : int, optional
    Grid density. The dense grid used in `remez` is of size
    ``(numtaps + 1) * grid_density``. Default is 16.

Returns
-------
out : ndarray
    A rank-1 array containing the coefficients of the optimal
    (in a minimax sense) filter.

See Also
--------
freqz : Compute the frequency response of a digital filter.

References
----------
.. [1] J. H. McClellan and T. W. Parks, "A unified approach to the
       design of optimum FIR linear phase digital filters",
       IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.
.. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, "A Computer
       Program for Designing Optimum FIR Linear Phase Digital
       Filters", IEEE Trans. Audio Electroacoust., vol. AU-21,
       pp. 506-525, 1973.

Examples
--------
We want to construct a filter with a passband at 0.2-0.4 Hz, and
stop bands at 0-0.1 Hz and 0.45-0.5 Hz. Note that this means that the
behavior in the frequency ranges between those bands is unspecified and
may overshoot.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; bpass = signal.remez(72, [0, 0.1, 0.2, 0.4, 0.45, 0.5], [0, 1, 0])
&gt;&gt;&gt; freq, response = signal.freqz(bpass)
&gt;&gt;&gt; ampl = np.abs(response)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(111)
&gt;&gt;&gt; ax1.semilogy(freq/(2*np.pi), ampl, 'b-')  # freq in Hz
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="numtaps" name="numtaps" port_type="basic:Integer" show_port="True">
      <docstring>The desired number of taps in the filter. The number of taps is
the number of terms in the filter, or the filter order plus one.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bands" name="bands" port_type="basic:List" show_port="True">
      <docstring>A monotonic sequence containing the band edges in Hz.
All elements must be non-negative and less than half the sampling
frequency as given by `Hz`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="desired" name="desired" port_type="basic:List" show_port="True">
      <docstring>A sequence half the size of bands containing the desired gain
in each of the specified bands.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weight" name="weight" port_type="basic:List">
      <docstring>A relative weighting to give to each band region. The length of
`weight` has to be half the length of `bands`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Hz" name="Hz" port_type="basic:Float">
      <docstring>The sampling frequency in Hz. Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type">
      <docstring>The type of filter:

  'bandpass' : flat response in bands. This is the default.

  'differentiator' : frequency proportional response in bands.

  'hilbert' : filter with odd symmetry, that is, type III
              (for even order) or type IV (for odd order)
              linear phase filters.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['bandpass', 'differentiator', 'hilbert']]</values>
      <defaults>['bandpass']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations of the algorithm. Default is 25.</docstring>
      <defaults>[25]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="grid_density" name="grid_density" port_type="basic:Integer">
      <docstring>Grid density. The dense grid used in `remez` is of size
``(numtaps + 1) * grid_density``. Default is 16.</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A rank-1 array containing the coefficients of the optimal
(in a minimax sense) filter.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.resample" module_name="resample" namespace="'signal'" output_type="list">
    <docstring>Resample `x` to `num` samples using Fourier method along the given axis.

The resampled signal starts at the same value as `x` but is sampled
with a spacing of ``len(x) / num * (spacing of x)``.  Because a
Fourier method is used, the signal is assumed to be periodic.

Parameters
----------
x : array_like
    The data to be resampled.
num : int
    The number of samples in the resampled signal.
t : array_like, optional
    If `t` is given, it is assumed to be the sample positions
    associated with the signal data in `x`.
axis : int, optional
    The axis of `x` that is resampled.  Default is 0.
window : array_like, callable, string, float, or tuple, optional
    Specifies the window applied to the signal in the Fourier
    domain.  See below for details.

Returns
-------
resampled_x or (resampled_x, resampled_t)
    Either the resampled array, or, if `t` was given, a tuple
    containing the resampled array and the corresponding resampled
    positions.

Notes
-----
The argument `window` controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn't intend to be
interpreted as band-limited.

If `window` is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).

If `window` is an array of the same length as `x.shape[axis]` it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).

For any other type of `window`, the function `scipy.signal.get_window`
is called to generate the window.

The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from ``dx`` to ``dx * len(x) / num``.

If `t` is not None, then it represents the old sample positions,
and the new sample positions will be returned as well as the new
samples.

As noted, `resample` uses FFT transformations, which can be very
slow if the number of input samples is large and prime, see
`scipy.fftpack.fft`.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The data to be resampled.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="num" name="num" port_type="basic:Integer" show_port="True">
      <docstring>The number of samples in the resampled signal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:List">
      <docstring>If `t` is given, it is assumed to be the sample positions
associated with the signal data in `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of `x` that is resampled.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" depth="1" name="window" port_type="basic:Float">
      <docstring>Specifies the window applied to the signal in the Fourier
domain.  See below for details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" show_port="True" sort_key="0">
      <docstring>Either the resampled array, or, if `t` was given, a tuple
containing the resampled array and the corresponding resampled
positions.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>Either the resampled array, or, if `t` was given, a tuple
containing the resampled array and the corresponding resampled
positions.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.residue" module_name="residue" namespace="'signal'" output_type="list">
    <docstring>Compute partial-fraction expansion of b(s) / a(s).

If ``M = len(b)`` and ``N = len(a)``, then the partial-fraction
expansion H(s) is defined as::

          b(s)     b[0] s**(M-1) + b[1] s**(M-2) + ... + b[M-1]
  H(s) = ------ = ----------------------------------------------
          a(s)     a[0] s**(N-1) + a[1] s**(N-2) + ... + a[N-1]

           r[0]       r[1]             r[-1]
       = -------- + -------- + ... + --------- + k(s)
         (s-p[0])   (s-p[1])         (s-p[-1])

If there are any repeated roots (closer together than `tol`), then H(s)
has terms like::

        r[i]      r[i+1]              r[i+n-1]
      -------- + ----------- + ... + -----------
      (s-p[i])  (s-p[i])**2          (s-p[i])**n

Returns
-------
r : ndarray
    Residues.
p : ndarray
    Poles.
k : ndarray
    Coefficients of the direct polynomial term.

See Also
--------
invres, numpy.poly, unique_roots</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <defaults>[0.001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtype" name="rtype">
      <defaults>['avg']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="r" name="r" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Residues.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Poles.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" name="k" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Coefficients of the direct polynomial term.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.residuez" module_name="residuez" namespace="'signal'">
    <docstring>Compute partial-fraction expansion of b(z) / a(z).

If ``M = len(b)`` and ``N = len(a)``::

            b(z)     b[0] + b[1] z**(-1) + ... + b[M-1] z**(-M+1)
    H(z) = ------ = ----------------------------------------------
            a(z)     a[0] + a[1] z**(-1) + ... + a[N-1] z**(-N+1)

             r[0]                   r[-1]
     = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...
       (1-p[0]z**(-1))         (1-p[-1]z**(-1))

If there are any repeated roots (closer than tol), then the partial
fraction expansion has terms like::

         r[i]              r[i+1]                    r[i+n-1]
    -------------- + ------------------ + ... + ------------------
    (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n

See also
--------
invresz, unique_roots</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <defaults>[0.001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtype" name="rtype">
      <defaults>['avg']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.ricker" module_name="ricker" namespace="'signal'">
    <docstring>Return a Ricker wavelet, also known as the "Mexican hat wavelet".

It models the function:

    ``A (1 - x^2/a^2) exp(-x^2/2 a^2)``,

where ``A = 2/sqrt(3a)pi^1/4``.

Parameters
----------
points : int
    Number of points in `vector`.
    Will be centered around 0.
a : scalar
    Width parameter of the wavelet.

Returns
-------
vector : (N,) ndarray
    Array of length `points` in shape of ricker curve.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; points = 100
&gt;&gt;&gt; a = 4.0
&gt;&gt;&gt; vec2 = signal.ricker(points, a)
&gt;&gt;&gt; print(len(vec2))
100
&gt;&gt;&gt; plt.plot(vec2)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="points" name="points" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in `vector`.
Will be centered around 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Float" show_port="True">
      <docstring>Width parameter of the wavelet.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="vector" name="vector" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of length `points` in shape of ricker curve.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.savgol_coeffs" module_name="savgol_coeffs" namespace="'signal'">
    <docstring>Compute the coefficients for a 1-d Savitzky-Golay FIR filter.

Parameters
----------
window_length : int
    The length of the filter window (i.e. the number of coefficients).
    `window_length` must be an odd positive integer.
polyorder : int
    The order of the polynomial used to fit the samples.
    `polyorder` must be less than `window_length`.
deriv : int, optional
    The order of the derivative to compute.  This must be a
    nonnegative integer.  The default is 0, which means to filter
    the data without differentiating.
delta : float, optional
    The spacing of the samples to which the filter will be applied.
    This is only used if deriv &gt; 0.
pos : int or None, optional
    If pos is not None, it specifies evaluation position within the
    window.  The default is the middle of the window.
use : str, optional
    Either 'conv' or 'dot'.  This argument chooses the order of the
    coefficients.  The default is 'conv', which means that the
    coefficients are ordered to be used in a convolution.  With
    use='dot', the order is reversed, so the filter is applied by
    dotting the coefficients with the data set.

Returns
-------
coeffs : 1-d ndarray
    The filter coefficients.

References
----------
A. Savitzky, M. J. E. Golay, Smoothing and Differentiation of Data by
Simplified Least Squares Procedures. Analytical Chemistry, 1964, 36 (8),
pp 1627-1639.

See Also
--------
savgol_filter

Notes
-----

.. versionadded:: 0.14.0

Examples
--------
&gt;&gt;&gt; from scipy.signal import savgol_coeffs
&gt;&gt;&gt; savgol_coeffs(5, 2)
array([-0.08571429,  0.34285714,  0.48571429,  0.34285714, -0.08571429])
&gt;&gt;&gt; savgol_coeffs(5, 2, deriv=1)
array([  2.00000000e-01,   1.00000000e-01,   2.00607895e-16,
        -1.00000000e-01,  -2.00000000e-01])

Note that use='dot' simply reverses the coefficients.

&gt;&gt;&gt; savgol_coeffs(5, 2, pos=3)
array([ 0.25714286,  0.37142857,  0.34285714,  0.17142857, -0.14285714])
&gt;&gt;&gt; savgol_coeffs(5, 2, pos=3, use='dot')
array([-0.14285714,  0.17142857,  0.34285714,  0.37142857,  0.25714286])

`x` contains data from the parabola x = t**2, sampled at
t = -1, 0, 1, 2, 3.  `c` holds the coefficients that will compute the
derivative at the last position.  When dotted with `x` the result should
be 6.

&gt;&gt;&gt; x = np.array([1, 0, 1, 4, 9])
&gt;&gt;&gt; c = savgol_coeffs(5, 2, pos=4, deriv=1, use='dot')
&gt;&gt;&gt; c.dot(x)
6.0000000000000018</docstring>
    <inputPortSpec arg="window_length" name="window_length" port_type="basic:Integer" show_port="True">
      <docstring>The length of the filter window (i.e. the number of coefficients).
`window_length` must be an odd positive integer.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="polyorder" name="polyorder" port_type="basic:Integer" show_port="True">
      <docstring>The order of the polynomial used to fit the samples.
`polyorder` must be less than `window_length`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deriv" name="deriv" port_type="basic:Integer">
      <docstring>The order of the derivative to compute.  This must be a
nonnegative integer.  The default is 0, which means to filter
the data without differentiating.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="delta" name="delta" port_type="basic:Float">
      <docstring>The spacing of the samples to which the filter will be applied.
This is only used if deriv &gt; 0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pos" name="pos">
      <docstring>If pos is not None, it specifies evaluation position within the
window.  The default is the middle of the window.</docstring>
      <defaults>['the']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="use" name="use">
      <docstring>Either 'conv' or 'dot'.  This argument chooses the order of the
coefficients.  The default is 'conv', which means that the
coefficients are ordered to be used in a convolution.  With
use='dot', the order is reversed, so the filter is applied by
dotting the coefficients with the data set.</docstring>
      <defaults>['conv']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="coeffs" name="coeffs" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filter coefficients.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.savgol_filter" module_name="savgol_filter" namespace="'signal'">
    <docstring>Apply a Savitzky-Golay filter to an array.

This is a 1-d filter.  If `x`  has dimension greater than 1, `axis`
determines the axis along which the filter is applied.

Parameters
----------
x : array_like
    The data to be filtered.  If `x` is not a single or double precision
    floating point array, it will be converted to type `numpy.float64`
    before filtering.
window_length : int
    The length of the filter window (i.e. the number of coefficients).
    `window_length` must be a positive odd integer.
polyorder : int
    The order of the polynomial used to fit the samples.
    `polyorder` must be less than `window_length`.
deriv : int, optional
    The order of the derivative to compute.  This must be a
    nonnegative integer.  The default is 0, which means to filter
    the data without differentiating.
delta : float, optional
    The spacing of the samples to which the filter will be applied.
    This is only used if deriv &gt; 0.  Default is 1.0.
axis : int, optional
    The axis of the array `x` along which the filter is to be applied.
    Default is -1.
mode : str, optional
    Must be 'mirror', 'constant', 'nearest', 'wrap' or 'interp'.  This
    determines the type of extension to use for the padded signal to
    which the filter is applied.  When `mode` is 'constant', the padding
    value is given by `cval`.  See the Notes for more details on 'mirror',
    'constant', 'wrap', and 'nearest'.
    When the 'interp' mode is selected (the default), no extension
    is used.  Instead, a degree `polyorder` polynomial is fit to the
    last `window_length` values of the edges, and this polynomial is
    used to evaluate the last `window_length // 2` output values.
cval : scalar, optional
    Value to fill past the edges of the input if `mode` is 'constant'.
    Default is 0.0.

Returns
-------
y : ndarray, same shape as `x`
    The filtered data.

See Also
--------
savgol_coeffs

Notes
-----
Details on the `mode` options:

    'mirror':
        Repeats the values at the edges in reverse order.  The value
        closest to the edge is not included.
    'nearest':
        The extension contains the nearest input value.
    'constant':
        The extension contains the value given by the `cval` argument.
    'wrap':
        The extension contains the values from the other end of the array.

For example, if the input is [1, 2, 3, 4, 5, 6, 7, 8], and
`window_length` is 7, the following shows the extended data for
the various `mode` options (assuming `cval` is 0)::

    mode       |   Ext   |         Input          |   Ext
    -----------+---------+------------------------+---------
    'mirror'   | 4  3  2 | 1  2  3  4  5  6  7  8 | 7  6  5
    'nearest'  | 1  1  1 | 1  2  3  4  5  6  7  8 | 8  8  8
    'constant' | 0  0  0 | 1  2  3  4  5  6  7  8 | 0  0  0
    'wrap'     | 6  7  8 | 1  2  3  4  5  6  7  8 | 1  2  3

.. versionadded:: 0.14.0

Examples
--------
&gt;&gt;&gt; np.set_printoptions(precision=2)  # For compact display.
&gt;&gt;&gt; x = np.array([2, 2, 5, 2, 1, 0, 1, 4, 9])

Filter with a window length of 5 and a degree 2 polynomial.  Use
the defaults for all other parameters.

&gt;&gt;&gt; y = savgol_filter(x, 5, 2)
array([ 1.66,  3.17,  3.54,  2.86,  0.66,  0.17,  1.  ,  4.  ,  9.  ])

Note that the last five values in x are samples of a parabola, so
when mode='interp' (the default) is used with polyorder=2, the last
three values are unchanged.  Compare that to, for example,
`mode='nearest'`:

&gt;&gt;&gt; savgol_filter(x, 5, 2, mode='nearest')
array([ 1.74,  3.03,  3.54,  2.86,  0.66,  0.17,  1.  ,  4.6 ,  7.97])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The data to be filtered.  If `x` is not a single or double precision
floating point array, it will be converted to type `numpy.float64`
before filtering.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="window_length" name="window_length" port_type="basic:Integer" show_port="True">
      <docstring>The length of the filter window (i.e. the number of coefficients).
`window_length` must be a positive odd integer.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="polyorder" name="polyorder" port_type="basic:Integer" show_port="True">
      <docstring>The order of the polynomial used to fit the samples.
`polyorder` must be less than `window_length`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="deriv" name="deriv" port_type="basic:Integer">
      <docstring>The order of the derivative to compute.  This must be a
nonnegative integer.  The default is 0, which means to filter
the data without differentiating.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="delta" name="delta" port_type="basic:Float">
      <docstring>The spacing of the samples to which the filter will be applied.
This is only used if deriv &gt; 0.  Default is 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the array `x` along which the filter is to be applied.
Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Must be 'mirror', 'constant', 'nearest', 'wrap' or 'interp'.  This
determines the type of extension to use for the padded signal to
which the filter is applied.  When `mode` is 'constant', the padding
value is given by `cval`.  See the Notes for more details on 'mirror',
'constant', 'wrap', and 'nearest'.
When the 'interp' mode is selected (the default), no extension
is used.  Instead, a degree `polyorder` polynomial is fit to the
last `window_length` values of the edges, and this polynomial is
used to evaluate the last `window_length // 2` output values.</docstring>
      <defaults>['interp']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cval" name="cval" port_type="basic:Float">
      <docstring>Value to fill past the edges of the input if `mode` is 'constant'.
Default is 0.0.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered data.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sawtooth" module_name="sawtooth" namespace="'signal'">
    <docstring>Return a periodic sawtooth or triangle waveform.

The sawtooth waveform has a period ``2*pi``, rises from -1 to 1 on the
interval 0 to ``width*2*pi``, then drops from 1 to -1 on the interval
``width*2*pi`` to ``2*pi``. `width` must be in the interval [0, 1].

Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.

Parameters
----------
t : array_like
    Time.
width : array_like, optional
    Width of the rising ramp as a proportion of the total cycle.
    Default is 1, producing a rising ramp, while 0 produces a falling
    ramp.  `t` = 0.5 produces a triangle wave.
    If an array, causes wave shape to change over time, and must be the
    same length as t.

Returns
-------
y : ndarray
    Output array containing the sawtooth waveform.

Examples
--------
A 5 Hz waveform sampled at 500 Hz for 1 second:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.linspace(0, 1, 500)
&gt;&gt;&gt; plt.plot(t, signal.sawtooth(2 * np.pi * 5 * t))</docstring>
    <inputPortSpec arg="t" name="t" port_type="basic:List" show_port="True">
      <docstring>Time.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="width" name="widthScalar" port_type="basic:Integer">
      <docstring>Width of the rising ramp as a proportion of the total cycle.
Default is 1, producing a rising ramp, while 0 produces a falling
ramp.  `t` = 0.5 produces a triangle wave.
If an array, causes wave shape to change over time, and must be the
same length as t.</docstring>
      <defaults>[1]</defaults>
      <alternateSpec arg="width" name="widthSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array containing the sawtooth waveform.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sepfir2d" module_name="sepfir2d" namespace="'signal'">
    <docstring>sepfir2d(input, hrow, hcol) -&gt; output

Description:

  Convolve the rank-2 input array with the separable filter defined by the
  rank-1 arrays hrow, and hcol. Mirror symmetric boundary conditions are
  assumed.  This function can be used to find an image given its B-spline
  representation.</docstring>
    <inputPortSpec arg="hrow" name="hrow" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="input" name="input" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="hcol" name="hcol" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.slepian" module_name="slepian" namespace="'signal'">
    <docstring>Return a digital Slepian (DPSS) window.

Used to maximize the energy concentration in the main lobe.  Also called
the digital prolate spheroidal sequence (DPSS).

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
width : float
    Bandwidth
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value always normalized to 1

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.slepian(51, width=0.3)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Slepian (DPSS) window (BW=0.3)")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Slepian window (BW=0.3)")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="width" name="width" port_type="basic:Float" show_port="True">
      <docstring>Bandwidth</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value always normalized to 1</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sos2tf" module_name="sos2tf" namespace="'signal'" output_type="list">
    <docstring>Return a single transfer function from a series of second-order sections

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

Returns
-------
b : ndarray
    Numerator polynomial coefficients.
a : ndarray
    Denominator polynomial coefficients.

Notes
-----
.. versionadded:: 0.16.0</docstring>
    <inputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True">
      <docstring>Array of second-order filter coefficients, must have shape
``(n_sections, 6)``. See `sosfilt` for the SOS filter format
specification.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator polynomial coefficients.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Denominator polynomial coefficients.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sos2zpk" module_name="sos2zpk" namespace="'signal'" output_type="list">
    <docstring>Return zeros, poles, and gain of a series of second-order sections

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

Returns
-------
z : ndarray
    Zeros of the transfer function.
p : ndarray
    Poles of the transfer function.
k : float
    System gain.

Notes
-----
.. versionadded:: 0.16.0</docstring>
    <inputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True">
      <docstring>Array of second-order filter coefficients, must have shape
``(n_sections, 6)``. See `sosfilt` for the SOS filter format
specification.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Zeros of the transfer function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Poles of the transfer function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>System gain.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sosfilt" module_name="sosfilt" namespace="'signal'" output_type="list">
    <docstring>Filter data along one dimension using cascaded second-order sections

Filter a data sequence, `x`, using a digital IIR filter defined by
`sos`. This is implemented by performing `lfilter` for each
second-order section.  See `lfilter` for details.

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. Each row corresponds to a second-order
    section, with the first three columns providing the numerator
    coefficients and the last three providing the denominator
    coefficients.
x : array_like
    An N-dimensional input array.
axis : int, optional
    The axis of the input data array along which to apply the
    linear filter. The filter is applied to each subarray along
    this axis.  Default is -1.
zi : array_like, optional
    Initial conditions for the cascaded filter delays.  It is a (at
    least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where
    ``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]``
    replaced by 2.  If `zi` is None or is not given then initial rest
    (i.e. all zeros) is assumed.
    Note that these initial conditions are *not* the same as the initial
    conditions given by `lfiltic` or `lfilter_zi`.

Returns
-------
y : ndarray
    The output of the digital filter.
zf : ndarray, optional
    If `zi` is None, this is not returned, otherwise, `zf` holds the
    final filter delay values.

See Also
--------
zpk2sos, sos2zpk, sosfilt_zi

Notes
-----
The filter function is implemented as a series of second-order filters
with direct-form II transposed structure. It is designed to minimize
numerical precision errors for high-order filters.

.. versionadded:: 0.16.0

Examples
--------
Plot a 13th-order filter's impulse response using both `lfilter` and
`sosfilt`, showing the instability that results from trying to do a
13th-order filter in a single stage (the numerical error pushes some poles
outside of the unit circle):

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; b, a = signal.ellip(13, 0.009, 80, 0.05, output='ba')
&gt;&gt;&gt; sos = signal.ellip(13, 0.009, 80, 0.05, output='sos')
&gt;&gt;&gt; x = np.zeros(700)
&gt;&gt;&gt; x[0] = 1.
&gt;&gt;&gt; y_tf = signal.lfilter(b, a, x)
&gt;&gt;&gt; y_sos = signal.sosfilt(sos, x)
&gt;&gt;&gt; plt.plot(y_tf, 'r', label='TF')
&gt;&gt;&gt; plt.plot(y_sos, 'k', label='SOS')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True">
      <docstring>Array of second-order filter coefficients, must have shape
``(n_sections, 6)``. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>An N-dimensional input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="zi" name="zi" port_type="basic:List">
      <docstring>Initial conditions for the cascaded filter delays.  It is a (at
least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where
``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]``
replaced by 2.  If `zi` is None or is not given then initial rest
(i.e. all zeros) is assumed.
Note that these initial conditions are *not* the same as the initial
conditions given by `lfiltic` or `lfilter_zi`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The output of the digital filter.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="zf" name="zf" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>If `zi` is None, this is not returned, otherwise, `zf` holds the
final filter delay values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sosfilt_zi" module_name="sosfilt_zi" namespace="'signal'">
    <docstring>Compute an initial state `zi` for the sosfilt function that corresponds
to the steady state of the step response.

A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

Returns
-------
zi : ndarray
    Initial conditions suitable for use with ``sosfilt``, shape
    ``(n_sections, 2)``.

See Also
--------
sosfilt, zpk2sos

Notes
-----
.. versionadded:: 0.16.0

Examples
--------
Filter a rectangular pulse that begins at time 0, with and without
the use of the `zi` argument of `scipy.signal.sosfilt`.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; sos = signal.butter(9, 0.125, output='sos')
&gt;&gt;&gt; zi = signal.sosfilt_zi(sos)
&gt;&gt;&gt; x = (np.arange(250) &lt; 100).astype(int)
&gt;&gt;&gt; f1 = signal.sosfilt(sos, x)
&gt;&gt;&gt; f2, zo = signal.sosfilt(sos, x, zi=zi)

&gt;&gt;&gt; plt.plot(x, 'k--', label='x')
&gt;&gt;&gt; plt.plot(f1, 'b', alpha=0.5, linewidth=2, label='filtered')
&gt;&gt;&gt; plt.plot(f2, 'g', alpha=0.25, linewidth=4, label='filtered with zi')
&gt;&gt;&gt; plt.legend(loc='best')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True">
      <docstring>Array of second-order filter coefficients, must have shape
``(n_sections, 6)``. See `sosfilt` for the SOS filter format
specification.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="zi" name="zi" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Initial conditions suitable for use with ``sosfilt``, shape
``(n_sections, 2)``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.spectrogram" module_name="spectrogram" namespace="'signal'" output_type="list">
    <docstring>Compute a spectrogram with consecutive Fourier transforms.

Spectrograms can be used as a way of visualizing the change of a
nonstationary signal's frequency content over time.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length will be used for nperseg.
    Defaults to a Tukey window with shape parameter of 0.25.
nperseg : int, optional
    Length of each segment.  Defaults to 256.
noverlap : int, optional
    Number of points to overlap between segments. If None,
    ``noverlap = nperseg // 8``.  Defaults to None.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired.  If None,
    the FFT length is `nperseg`. Defaults to None.
detrend : str or function or False, optional
    Specifies how to detrend each segment. If `detrend` is a string,
    it is passed as the ``type`` argument to `detrend`.  If it is a
    function, it takes a segment and returns a detrended segment.
    If `detrend` is False, no detrending is done.  Defaults to 'constant'.
return_onesided : bool, optional
    If True, return a one-sided spectrum for real data. If False return
    a two-sided spectrum. Note that for complex data, a two-sided
    spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Pxx` has units of V**2/Hz and computing the power spectrum
    ('spectrum') where `Pxx` has units of V**2, if `x` is measured in V
    and fs is measured in Hz.  Defaults to 'density'
axis : int, optional
    Axis along which the spectrogram is computed; the default is over
    the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
t : ndarray
    Array of segment times.
Sxx : ndarray
    Spectrogram of x. By default, the last axis of Sxx corresponds to the
    segment times.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. In contrast to welch's method, where the entire
data stream is averaged over, one may wish to use a smaller overlap (or
perhaps none at all) when computing a spectrogram, to maintain some
statistical independence between individual segments.

.. versionadded:: 0.16.0

References
----------
...[1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck "Discrete-Time
       Signal Processing", Prentice Hall, 1999.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate a test signal, a 2 Vrms sine wave whose frequency linearly changes
with time from 1kHz to 2kHz, corrupted by 0.001 V**2/Hz of white noise
sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; freq = np.linspace(1e3, 2e3, N)
&gt;&gt;&gt; x = amp * np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the spectrogram.

&gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs)
&gt;&gt;&gt; plt.pcolormesh(t, f, Sxx)
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fs" name="fs" port_type="basic:Float">
      <docstring>Sampling frequency of the `x` time series. Defaults to 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" name="windowScalar">
      <docstring>Desired window to use. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length will be used for nperseg.
Defaults to a Tukey window with shape parameter of 0.25.</docstring>
      <defaults>[('tukey', 0.25)]</defaults>
      <alternateSpec arg="window" name="windowSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nperseg" name="nperseg" port_type="basic:Integer">
      <docstring>Length of each segment.  Defaults to 256.</docstring>
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" name="noverlap" port_type="basic:Integer">
      <docstring>Number of points to overlap between segments. If None,
``noverlap = nperseg // 8``.  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nfft" name="nfft" port_type="basic:Integer">
      <docstring>Length of the FFT used, if a zero padded FFT is desired.  If None,
the FFT length is `nperseg`. Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" name="detrend">
      <docstring>Specifies how to detrend each segment. If `detrend` is a string,
it is passed as the ``type`` argument to `detrend`.  If it is a
function, it takes a segment and returns a detrended segment.
If `detrend` is False, no detrending is done.  Defaults to 'constant'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['function']]</values>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_onesided" name="return_onesided" port_type="basic:Boolean">
      <docstring>If True, return a one-sided spectrum for real data. If False return
a two-sided spectrum. Note that for complex data, a two-sided
spectrum is always returned.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scaling" name="scaling">
      <docstring>Selects between computing the power spectral density ('density')
where `Pxx` has units of V**2/Hz and computing the power spectrum
('spectrum') where `Pxx` has units of V**2, if `x` is measured in V
and fs is measured in Hz.  Defaults to 'density'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['density', 'spectrum']]</values>
      <defaults>['density']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the spectrogram is computed; the default is over
the last axis (i.e. ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of sample frequencies.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="t" name="t" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Array of segment times.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Sxx" name="Sxx" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Spectrogram of x. By default, the last axis of Sxx corresponds to the
segment times.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.spline_filter" module_name="spline_filter" namespace="'signal'">
    <docstring>Smoothing spline (cubic) filtering of a rank-2 array.

Filter an input data set, `Iin`, using a (cubic) smoothing spline of
fall-off `lmbda`.</docstring>
    <inputPortSpec arg="lmbda" name="lmbda" port_type="basic:Float">
      <defaults>[5.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Iin" name="Iin" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.square" module_name="square" namespace="'signal'">
    <docstring>Return a periodic square-wave waveform.

The square wave has a period ``2*pi``, has value +1 from 0 to
``2*pi*duty`` and -1 from ``2*pi*duty`` to ``2*pi``. `duty` must be in
the interval [0,1].

Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.

Parameters
----------
t : array_like
    The input time array.
duty : array_like, optional
    Duty cycle.  Default is 0.5 (50% duty cycle).
    If an array, causes wave shape to change over time, and must be the
    same length as t.

Returns
-------
y : ndarray
    Output array containing the square waveform.

Examples
--------
A 5 Hz waveform sampled at 500 Hz for 1 second:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; t = np.linspace(0, 1, 500, endpoint=False)
&gt;&gt;&gt; plt.plot(t, signal.square(2 * np.pi * 5 * t))
&gt;&gt;&gt; plt.ylim(-2, 2)

A pulse-width modulated sine wave:

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; sig = np.sin(2 * np.pi * t)
&gt;&gt;&gt; pwm = signal.square(2 * np.pi * 30 * t, duty=(sig + 1)/2)
&gt;&gt;&gt; plt.subplot(2, 1, 1)
&gt;&gt;&gt; plt.plot(t, sig)
&gt;&gt;&gt; plt.subplot(2, 1, 2)
&gt;&gt;&gt; plt.plot(t, pwm)
&gt;&gt;&gt; plt.ylim(-1.5, 1.5)</docstring>
    <inputPortSpec arg="t" name="t" port_type="basic:List" show_port="True">
      <docstring>The input time array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="duty" name="dutyScalar" port_type="basic:Float">
      <docstring>Duty cycle.  Default is 0.5 (50% duty cycle).
If an array, causes wave shape to change over time, and must be the
same length as t.</docstring>
      <defaults>[0.5]</defaults>
      <alternateSpec arg="duty" name="dutySequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output array containing the square waveform.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.ss2tf" module_name="ss2tf" namespace="'signal'" output_type="list">
    <docstring>State-space to transfer function.

Parameters
----------
A, B, C, D : ndarray
    State-space representation of linear system.
input : int, optional
    For multiple-input systems, the input to use.

Returns
-------
num : 2-D ndarray
    Numerator(s) of the resulting transfer function(s).  `num` has one row
    for each of the system's outputs. Each row is a sequence representation
    of the numerator polynomial.
den : 1-D ndarray
    Denominator of the resulting transfer function(s).  `den` is a sequence
    representation of the denominator polynomial.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="C" name="C" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="D" name="D" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="input" name="input" port_type="basic:Integer">
      <docstring>For multiple-input systems, the input to use.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="num" name="num" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator(s) of the resulting transfer function(s).  `num` has one row
for each of the system's outputs. Each row is a sequence representation
of the numerator polynomial.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="den" name="den" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Denominator of the resulting transfer function(s).  `den` is a sequence
representation of the denominator polynomial.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.ss2zpk" module_name="ss2zpk" namespace="'signal'" output_type="list">
    <docstring>State-space representation to zero-pole-gain representation.

Parameters
----------
A, B, C, D : ndarray
    State-space representation of linear system.
input : int, optional
    For multiple-input systems, the input to use.

Returns
-------
z, p : sequence
    Zeros and poles.
k : float
    System gain.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="C" name="C" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="D" name="D" port_type="basic:List" show_port="True">
      <docstring>State-space representation of linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="input" name="input" port_type="basic:Integer">
      <docstring>For multiple-input systems, the input to use.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Zeros and poles.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Zeros and poles.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>System gain.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.step" module_name="step" namespace="'signal'" output_type="list">
    <docstring>Step response of continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector (default is zero).
T : array_like, optional
    Time points (computed if not given).
N : int, optional
    Number of time points to compute if `T` is not given.

Returns
-------
T : 1D ndarray
    Output time points.
yout : 1D ndarray
    Step response of system.

See also
--------
scipy.signal.step2</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>describing the system.
The following gives the number of elements in the tuple and
the interpretation:

    * 2 (num, den)
    * 3 (zeros, poles, gain)
    * 4 (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="X0" name="X0" port_type="basic:List">
      <docstring>Initial state-vector (default is zero).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:List">
      <docstring>Time points (computed if not given).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of time points to compute if `T` is not given.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output time points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Step response of system.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.step2" module_name="step2" namespace="'signal'" output_type="list">
    <docstring>Step response of continuous-time system.

This function is functionally the same as `scipy.signal.step`, but
it uses the function `scipy.signal.lsim2` to compute the step
response.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector (default is zero).
T : array_like, optional
    Time points (computed if not given).
N : int, optional
    Number of time points to compute if `T` is not given.
kwargs : various types
    Additional keyword arguments are passed on the function
    `scipy.signal.lsim2`, which in turn passes them on to
    `scipy.integrate.odeint`.  See the documentation for
    `scipy.integrate.odeint` for information about these arguments.

Returns
-------
T : 1D ndarray
    Output time points.
yout : 1D ndarray
    Step response of system.

See also
--------
scipy.signal.step

Notes
-----
.. versionadded:: 0.8.0</docstring>
    <inputPortSpec arg="system" name="systemScalar" show_port="True">
      <docstring>describing the system.
The following gives the number of elements in the tuple and
the interpretation:

    * 2 (num, den)
    * 3 (zeros, poles, gain)
    * 4 (A, B, C, D)
</docstring>
      <alternateSpec arg="system" name="systemSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="X0" name="X0" port_type="basic:List">
      <docstring>Initial state-vector (default is zero).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="T" name="T" port_type="basic:List">
      <docstring>Time points (computed if not given).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of time points to compute if `T` is not given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" port_type="basic:Variant" show_port="True">
      <docstring>Additional keyword arguments are passed on the function
`scipy.signal.lsim2`, which in turn passes them on to
`scipy.integrate.odeint`.  See the documentation for
`scipy.integrate.odeint` for information about these arguments.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="T" name="T" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Output time points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="yout" name="yout" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Step response of system.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.sweep_poly" module_name="sweep_poly" namespace="'signal'">
    <docstring>Frequency-swept cosine generator, with a time-dependent frequency.

This function generates a sinusoidal function whose instantaneous
frequency varies with time.  The frequency at time `t` is given by
the polynomial `poly`.

Parameters
----------
t : ndarray
    Times at which to evaluate the waveform.
poly : 1-D array_like or instance of numpy.poly1d
    The desired frequency expressed as a polynomial.  If `poly` is
    a list or ndarray of length n, then the elements of `poly` are
    the coefficients of the polynomial, and the instantaneous
    frequency is

      ``f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]``

    If `poly` is an instance of numpy.poly1d, then the
    instantaneous frequency is

      ``f(t) = poly(t)``

phi : float, optional
    Phase offset, in degrees, Default: 0.

Returns
-------
sweep_poly : ndarray
    A numpy array containing the signal evaluated at `t` with the
    requested time-varying frequency.  More precisely, the function
    returns ``cos(phase + (pi/180)*phi)``, where `phase` is the integral
    (from 0 to t) of ``2 * pi * f(t)``; ``f(t)`` is defined above.

See Also
--------
chirp

Notes
-----
.. versionadded:: 0.8.0

If `poly` is a list or ndarray of length `n`, then the elements of
`poly` are the coefficients of the polynomial, and the instantaneous
frequency is:

    ``f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]``

If `poly` is an instance of `numpy.poly1d`, then the instantaneous
frequency is:

      ``f(t) = poly(t)``

Finally, the output `s` is:

    ``cos(phase + (pi/180)*phi)``

where `phase` is the integral from 0 to `t` of ``2 * pi * f(t)``,
``f(t)`` as defined above.</docstring>
    <inputPortSpec arg="t" name="t" port_type="basic:List" show_port="True">
      <docstring>Times at which to evaluate the waveform.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="poly" name="polyScalar" show_port="True">
      <docstring>The desired frequency expressed as a polynomial.  If `poly` is
a list or ndarray of length n, then the elements of `poly` are
the coefficients of the polynomial, and the instantaneous
frequency is

  ``f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]``

If `poly` is an instance of numpy.poly1d, then the
instantaneous frequency is

  ``f(t) = poly(t)``
</docstring>
      <alternateSpec arg="poly" name="polySequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="phi" name="phi" port_type="basic:Float">
      <docstring>Phase offset, in degrees, Default: 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sweep_poly" name="sweep_poly" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A numpy array containing the signal evaluated at `t` with the
requested time-varying frequency.  More precisely, the function
returns ``cos(phase + (pi/180)*phi)``, where `phase` is the integral
(from 0 to t) of ``2 * pi * f(t)``; ``f(t)`` is defined above.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.symiirorder1" module_name="symiirorder1" namespace="'signal'">
    <docstring>symiirorder1(input, c0, z1 {, precision}) -&gt; output

Implement a smoothing IIR filter with mirror-symmetric boundary conditions
using a cascade of first-order sections.  The second section uses a
reversed sequence.  This implements a system with the following
transfer function and mirror-symmetric boundary conditions::

                       c0              
       H(z) = ---------------------    
               (1-z1/z) (1 - z1 z)     

The resulting signal will have mirror symmetric boundary conditions as well.

Parameters
----------
input : ndarray
    The input signal.
c0, z1 : scalar
    Parameters in the transfer function.
precision :
    Specifies the precision for calculating initial conditions
    of the recursive filter based on mirror-symmetric input.

Returns
-------
output : ndarray
    The filtered signal.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input signal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c0" name="c0" port_type="basic:Float" show_port="True">
      <docstring>Parameters in the transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z1" name="z1" port_type="basic:Float" show_port="True">
      <docstring>Parameters in the transfer function.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered signal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.symiirorder2" module_name="symiirorder2" namespace="'signal'">
    <docstring>symiirorder2(input, r, omega {, precision}) -&gt; output

Implement a smoothing IIR filter with mirror-symmetric boundary conditions
using a cascade of second-order sections.  The second section uses a
reversed sequence.  This implements the following transfer function::

                              cs^2
     H(z) = ---------------------------------------
            (1 - a2/z - a3/z^2) (1 - a2 z - a3 z^2 )

where::

      a2 = (2 r cos omega)
      a3 = - r^2
      cs = 1 - 2 r cos omega + r^2

Parameters
----------
input : ndarray
    The input signal.
r, omega : scalar
    Parameters in the transfer function.
precision :
    Specifies the precision for calculating initial conditions
    of the recursive filter based on mirror-symmetric input.

Returns
-------
output : ndarray
    The filtered signal.</docstring>
    <inputPortSpec arg="input" name="input" port_type="basic:List" show_port="True">
      <docstring>The input signal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" name="r" port_type="basic:Float" show_port="True">
      <docstring>Parameters in the transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="omega" name="omega" port_type="basic:Float" show_port="True">
      <docstring>Parameters in the transfer function.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The filtered signal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.tf2sos" module_name="tf2sos" namespace="'signal'">
    <docstring>Return second-order sections from transfer function representation

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
pairing : {'nearest', 'keep_odd'}, optional
    The method to use to combine pairs of poles and zeros into sections.
    See `zpk2sos`.

Returns
-------
sos : ndarray
    Array of second-order filter coefficients, with shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

See Also
--------
zpk2sos, sosfilt

Notes
-----
It is generally discouraged to convert from TF to SOS format, since doing
so usually will not improve numerical precision errors. Instead, consider
designing filters in ZPK format and converting directly to SOS. TF is
converted to SOS by first converting to ZPK format, then converting
ZPK to SOS.

.. versionadded:: 0.16.0</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Numerator polynomial coefficients.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Denominator polynomial coefficients.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pairing" name="pairing">
      <docstring>The method to use to combine pairs of poles and zeros into sections.
See `zpk2sos`.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['nearest', 'keep_odd']]</values>
      <defaults>['nearest']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of second-order filter coefficients, with shape
``(n_sections, 6)``. See `sosfilt` for the SOS filter format
specification.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.tf2ss" module_name="tf2ss" namespace="'signal'" output_type="list">
    <docstring>Transfer function to state-space representation.

Parameters
----------
num, den : array_like
    Sequences representing the numerator and denominator polynomials.
    The denominator needs to be at least as long as the numerator.

Returns
-------
A, B, C, D : ndarray
    State space representation of the system, in controller canonical
    form.</docstring>
    <inputPortSpec arg="num" name="num" port_type="basic:List" show_port="True">
      <docstring>Sequences representing the numerator and denominator polynomials.
The denominator needs to be at least as long as the numerator.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="den" name="den" port_type="basic:List" show_port="True">
      <docstring>Sequences representing the numerator and denominator polynomials.
The denominator needs to be at least as long as the numerator.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="C" name="C" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="D" name="D" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.tf2zpk" module_name="tf2zpk" namespace="'signal'" output_type="list">
    <docstring>Return zero, pole, gain (z, p, k) representation from a numerator,
denominator representation of a linear filter.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.

Returns
-------
z : ndarray
    Zeros of the transfer function.
p : ndarray
    Poles of the transfer function.
k : float
    System gain.

Notes
-----
If some values of `b` are too close to 0, they are removed. In that case,
a BadCoefficients warning is emitted.

The `b` and `a` arrays are interpreted as coefficients for positive,
descending powers of the transfer function variable.  So the inputs
:math:`b = [b_0, b_1, ..., b_M]` and :math:`a =[a_0, a_1, ..., a_N]`
can represent an analog filter of the form:

.. math::

    H(s) = \frac
    {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
    {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}

or a discrete-time filter of the form:

.. math::

    H(z) = \frac
    {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
    {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}

This "positive powers" form is found more commonly in controls
engineering.  If `M` and `N` are equal (which is true for all filters
generated by the bilinear transform), then this happens to be equivalent
to the "negative powers" discrete-time form preferred in DSP:

.. math::

    H(z) = \frac
    {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
    {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}

Although this is true for common filters, remember that this is not true
in the general case.  If `M` and `N` are not equal, the discrete-time
transfer function coefficients must first be converted to the "positive
powers" form before finding the poles and zeros.</docstring>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Numerator polynomial coefficients.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Denominator polynomial coefficients.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Zeros of the transfer function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Poles of the transfer function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>System gain.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.triang" module_name="triang" namespace="'signal'">
    <docstring>Return a triangular window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.triang(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Triangular window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the triangular window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.tukey" module_name="tukey" namespace="'signal'">
    <docstring>Return a Tukey window, also known as a tapered cosine window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.
alpha : float, optional
    Shape parameter of the Tukey window, representing the faction of the
    window inside the cosine tapered region.
    If zero, the Tukey window is equivalent to a rectangular window.
    If one, the Tukey window is equivalent to a Hann window.
sym : bool, optional
    When True (default), generates a symmetric window, for use in filter
    design.
    When False, generates a periodic window, for use in spectral analysis.

Returns
-------
w : ndarray
    The window, with the maximum value normalized to 1 (though the value 1
    does not appear if `M` is even and `sym` is True).

References
----------
.. [1] Harris, Fredric J. (Jan 1978). "On the use of Windows for Harmonic
       Analysis with the Discrete Fourier Transform". Proceedings of the
       IEEE 66 (1): 51-83. doi:10.1109/PROC.1978.10837
.. [2] Wikipedia, "Window function",
       http://en.wikipedia.org/wiki/Window_function#Tukey_window

Examples
--------
Plot the window and its frequency response:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = signal.tukey(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title("Tukey window")
&gt;&gt;&gt; plt.ylabel("Amplitude")
&gt;&gt;&gt; plt.xlabel("Sample")
&gt;&gt;&gt; plt.ylim([0, 1.1])

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0)
&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))
&gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0])
&gt;&gt;&gt; plt.title("Frequency response of the Tukey window")
&gt;&gt;&gt; plt.ylabel("Normalized magnitude [dB]")
&gt;&gt;&gt; plt.xlabel("Normalized frequency [cycles per sample]")</docstring>
    <inputPortSpec arg="M" name="M" port_type="basic:Integer" show_port="True">
      <docstring>Number of points in the output window. If zero or less, an empty
array is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Shape parameter of the Tukey window, representing the faction of the
window inside the cosine tapered region.
If zero, the Tukey window is equivalent to a rectangular window.
If one, the Tukey window is equivalent to a Hann window.</docstring>
      <defaults>[0.5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sym" name="sym" port_type="basic:Boolean">
      <docstring>When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The window, with the maximum value normalized to 1 (though the value 1
does not appear if `M` is even and `sym` is True).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.unique_roots" module_name="unique_roots" namespace="'signal'" output_type="list">
    <docstring>Determine unique roots and their multiplicities from a list of roots.

Parameters
----------
p : array_like
    The list of roots.
tol : float, optional
    The tolerance for two roots to be considered equal. Default is 1e-3.
rtype : {'max', 'min, 'avg'}, optional
    How to determine the returned root if multiple roots are within
    `tol` of each other.

      - 'max': pick the maximum of those roots.
      - 'min': pick the minimum of those roots.
      - 'avg': take the average of those roots.

Returns
-------
pout : ndarray
    The list of unique roots, sorted from low to high.
mult : ndarray
    The multiplicity of each root.

Notes
-----
This utility function is not specific to roots but can be used for any
sequence of values for which uniqueness and multiplicity has to be
determined. For a more general routine, see `numpy.unique`.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]
&gt;&gt;&gt; uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg')

Check which roots have multiplicity larger than 1:

&gt;&gt;&gt; uniq[mult &gt; 1]
array([ 1.305])</docstring>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>The list of roots.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>The tolerance for two roots to be considered equal. Default is 1e-3.</docstring>
      <defaults>[0.001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="rtype" name="rtype">
      <docstring>How to determine the returned root if multiple roots are within
`tol` of each other.

  - 'max': pick the maximum of those roots.
  - 'min': pick the minimum of those roots.
  - 'avg': take the average of those roots.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['max', "'min", 'avg']]</values>
      <defaults>['min']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="pout" name="pout" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The list of unique roots, sorted from low to high.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mult" name="mult" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The multiplicity of each root.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.vectorstrength" module_name="vectorstrength" namespace="'signal'" output_type="list">
    <docstring>Determine the vector strength of the events corresponding to the given
period.

The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.

If multiple periods are used, calculate the vector strength of each.
This is called the "resonating vector strength".

Parameters
----------
events : 1D array_like
    An array of time points containing the timing of the events.
period : float or array_like
    The period of the signal that the events should synchronize to.
    The period is in the same units as `events`.  It can also be an array
    of periods, in which case the outputs are arrays of the same length.

Returns
-------
strength : float or 1D array
    The strength of the synchronization.  1.0 is perfect synchronization
    and 0.0 is no synchronization.  If `period` is an array, this is also
    an array with each element containing the vector strength at the
    corresponding period.
phase : float or array
    The phase that the events are most strongly synchronized to in radians.
    If `period` is an array, this is also an array with each element
    containing the phase for the corresponding period.

References
----------
van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector
    strength: Auditory system, electric fish, and noise.
    Chaos 21, 047508 (2011);
    doi: 10.1063/1.3670512
van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:
    biological and mathematical perspectives.  Biol Cybern.
    2013 Aug;107(4):385-96. doi: 10.1007/s00422-013-0561-7.
van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens
    when we vary the "probing" frequency while keeping the spike times
    fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
    doi: 10.1007/s00422-013-0560-8</docstring>
    <inputPortSpec arg="events" name="events" port_type="basic:List" show_port="True">
      <docstring>An array of time points containing the timing of the events.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="period" name="periodScalar" port_type="basic:Float" show_port="True">
      <docstring>The period of the signal that the events should synchronize to.
The period is in the same units as `events`.  It can also be an array
of periods, in which case the outputs are arrays of the same length.</docstring>
      <alternateSpec arg="period" name="periodSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="strength" name="strength" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The strength of the synchronization.  1.0 is perfect synchronization
and 0.0 is no synchronization.  If `period` is an array, this is also
an array with each element containing the vector strength at the
corresponding period.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="phase" name="phase" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The phase that the events are most strongly synchronized to in radians.
If `period` is an array, this is also an array with each element
containing the phase for the corresponding period.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.welch" module_name="welch" namespace="'signal'" output_type="list">
    <docstring>Estimate power spectral density using Welch's method.

Welch's method [1]_ computes an estimate of the power spectral density
by dividing the data into overlapping segments, computing a modified
periodogram for each segment and averaging the periodograms.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length will be used for nperseg.
    Defaults to 'hanning'.
nperseg : int, optional
    Length of each segment.  Defaults to 256.
noverlap : int, optional
    Number of points to overlap between segments. If None,
    ``noverlap = nperseg // 2``.  Defaults to None.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired.  If None,
    the FFT length is `nperseg`. Defaults to None.
detrend : str or function or False, optional
    Specifies how to detrend each segment. If `detrend` is a string,
    it is passed as the ``type`` argument to `detrend`.  If it is a
    function, it takes a segment and returns a detrended segment.
    If `detrend` is False, no detrending is done.  Defaults to 'constant'.
return_onesided : bool, optional
    If True, return a one-sided spectrum for real data. If False return
    a two-sided spectrum. Note that for complex data, a two-sided
    spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Pxx` has units of V**2/Hz and computing the power spectrum
    ('spectrum') where `Pxx` has units of V**2, if `x` is measured in V
    and fs is measured in Hz.  Defaults to 'density'
axis : int, optional
    Axis along which the periodogram is computed; the default is over
    the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxx : ndarray
    Power spectral density or power spectrum of x.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements.  For the default 'hanning' window an
overlap of 50% is a reasonable trade off between accurately estimating
the signal power, while not over counting any of the data.  Narrower
windows may require a larger overlap.

If `noverlap` is 0, this method is equivalent to Bartlett's method [2]_.

.. versionadded:: 0.12.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
       Biometrika, vol. 37, pp. 1-16, 1950.

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2*np.sqrt(2)
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the power spectral density.

&gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, Pxx_den)
&gt;&gt;&gt; plt.ylim([0.5e-3, 1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()

If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.

&gt;&gt;&gt; np.mean(Pxx_den[256:])
0.0009924865443739191

Now compute and plot the power spectrum.

&gt;&gt;&gt; f, Pxx_spec = signal.welch(x, fs, 'flattop', 1024, scaling='spectrum')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]')
&gt;&gt;&gt; plt.show()

The peak height in the power spectrum is an estimate of the RMS amplitude.

&gt;&gt;&gt; np.sqrt(Pxx_spec.max())
2.0077340678640727</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Time series of measurement values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fs" name="fs" port_type="basic:Float">
      <docstring>Sampling frequency of the `x` time series. Defaults to 1.0.</docstring>
      <defaults>[1.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" name="windowScalar">
      <docstring>Desired window to use. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length will be used for nperseg.
Defaults to 'hanning'.</docstring>
      <defaults>['hanning']</defaults>
      <alternateSpec arg="window" name="windowSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="nperseg" name="nperseg" port_type="basic:Integer">
      <docstring>Length of each segment.  Defaults to 256.</docstring>
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" name="noverlap" port_type="basic:Integer">
      <docstring>Number of points to overlap between segments. If None,
``noverlap = nperseg // 2``.  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nfft" name="nfft" port_type="basic:Integer">
      <docstring>Length of the FFT used, if a zero padded FFT is desired.  If None,
the FFT length is `nperseg`. Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" name="detrend">
      <docstring>Specifies how to detrend each segment. If `detrend` is a string,
it is passed as the ``type`` argument to `detrend`.  If it is a
function, it takes a segment and returns a detrended segment.
If `detrend` is False, no detrending is done.  Defaults to 'constant'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['function']]</values>
      <defaults>['constant']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_onesided" name="return_onesided" port_type="basic:Boolean">
      <docstring>If True, return a one-sided spectrum for real data. If False return
a two-sided spectrum. Note that for complex data, a two-sided
spectrum is always returned.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scaling" name="scaling">
      <docstring>Selects between computing the power spectral density ('density')
where `Pxx` has units of V**2/Hz and computing the power spectrum
('spectrum') where `Pxx` has units of V**2, if `x` is measured in V
and fs is measured in Hz.  Defaults to 'density'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['density', 'spectrum']]</values>
      <defaults>['density']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the periodogram is computed; the default is over
the last axis (i.e. ``axis=-1``).</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="f" name="f" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of sample frequencies.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Pxx" name="Pxx" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Power spectral density or power spectrum of x.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.wiener" module_name="wiener" namespace="'signal'">
    <docstring>Perform a Wiener filter on an N-dimensional array.

Apply a Wiener filter to the N-dimensional array `im`.

Parameters
----------
im : ndarray
    An N-dimensional array.
mysize : int or arraylike, optional
    A scalar or an N-length list giving the size of the Wiener filter
    window in each dimension.  Elements of mysize should be odd.
    If mysize is a scalar, then this scalar is used as the size
    in each dimension.
noise : float, optional
    The noise-power to use. If None, then noise is estimated as the
    average of the local variance of the input.

Returns
-------
out : ndarray
    Wiener filtered result with the same shape as `im`.</docstring>
    <inputPortSpec arg="im" name="im" port_type="basic:List" show_port="True">
      <docstring>An N-dimensional array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mysize" name="mysizeScalar" port_type="basic:Integer">
      <docstring>A scalar or an N-length list giving the size of the Wiener filter
window in each dimension.  Elements of mysize should be odd.
If mysize is a scalar, then this scalar is used as the size
in each dimension.</docstring>
      <alternateSpec arg="mysize" name="mysizeSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="noise" name="noise" port_type="basic:Float">
      <docstring>The noise-power to use. If None, then noise is estimated as the
average of the local variance of the input.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Wiener filtered result with the same shape as `im`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.zpk2sos" module_name="zpk2sos" namespace="'signal'">
    <docstring>Return second-order sections from zeros, poles, and gain of a system

Parameters
----------
z : array_like
    Zeros of the transfer function.
p : array_like
    Poles of the transfer function.
k : float
    System gain.
pairing : {'nearest', 'keep_odd'}, optional
    The method to use to combine pairs of poles and zeros into sections.
    See Notes below.

Returns
-------
sos : ndarray
    Array of second-order filter coefficients, with shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

See Also
--------
sosfilt

Notes
-----
The algorithm used to convert ZPK to SOS format is designed to
minimize errors due to numerical precision issues. The pairing
algorithm attempts to minimize the peak gain of each biquadratic
section. This is done by pairing poles with the nearest zeros, starting
with the poles closest to the unit circle.

*Algorithms*

The current algorithms are designed specifically for use with digital
filters. Although they can operate on analog filters, the results may
be sub-optimal.

The steps in the ``pairing='nearest'`` and ``pairing='keep_odd'``
algorithms are mostly shared. The ``nearest`` algorithm attempts to
minimize the peak gain, while ``'keep_odd'`` minimizes peak gain under
the constraint that odd-order systems should retain one section
as first order. The algorithm steps and are as follows:

As a pre-processing step, add poles or zeros to the origin as
necessary to obtain the same number of poles and zeros for pairing.
If ``pairing == 'nearest'`` and there are an odd number of poles,
add an additional pole and a zero at the origin.

The following steps are then iterated over until no more poles or
zeros remain:

1. Take the (next remaining) pole (complex or real) closest to the
   unit circle to begin a new filter section.

2. If the pole is real and there are no other remaining real poles [#]_,
   add the closest real zero to the section and leave it as a first
   order section. Note that after this step we are guaranteed to be
   left with an even number of real poles, complex poles, real zeros,
   and complex zeros for subsequent pairing iterations.

3. Else:

    1. If the pole is complex and the zero is the only remaining real
       zero*, then pair the pole with the *next* closest zero
       (guaranteed to be complex). This is necessary to ensure that
       there will be a real zero remaining to eventually create a
       first-order section (thus keeping the odd order).

    2. Else pair the pole with the closest remaining zero (complex or
       real).

    3. Proceed to complete the second-order section by adding another
       pole and zero to the current pole and zero in the section:

        1. If the current pole and zero are both complex, add their
           conjugates.

        2. Else if the pole is complex and the zero is real, add the
           conjugate pole and the next closest real zero.

        3. Else if the pole is real and the zero is complex, add the
           conjugate zero and the real pole closest to those zeros.

        4. Else (we must have a real pole and real zero) add the next
           real pole closest to the unit circle, and then add the real
           zero closest to that pole.

.. [#] This conditional can only be met for specific odd-order inputs
       with the ``pairing == 'keep_odd'`` method.

.. versionadded:: 0.16.0

Examples
--------

Design a 6th order low-pass elliptic digital filter for a system with a
sampling rate of 8000 Hz that has a pass-band corner frequency of
1000 Hz.  The ripple in the pass-band should not exceed 0.087 dB, and
the attenuation in the stop-band should be at least 90 dB.

In the following call to `signal.ellip`, we could use ``output='sos'``,
but for this example, we'll use ``output='zpk'``, and then convert to SOS
format with `zpk2sos`:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output='zpk')

Now convert to SOS format.

&gt;&gt;&gt; sos = signal.zpk2sos(z, p, k)

The coefficents of the numerators of the sections:

&gt;&gt;&gt; sos[:, :3]
array([[ 0.0014154 ,  0.00248707,  0.0014154 ],
       [ 1.        ,  0.72965193,  1.        ],
       [ 1.        ,  0.17594966,  1.        ]])

The symmetry in the coefficients occurs because all the zeros are on the
unit circle.

The coefficients of the denominators of the sections:

&gt;&gt;&gt; sos[:, 3:]
array([[ 1.        , -1.32543251,  0.46989499],
       [ 1.        , -1.26117915,  0.6262586 ],
       [ 1.        , -1.25707217,  0.86199667]])

The next example shows the effect of the `pairing` option.  We have a
system with three poles and three zeros, so the SOS array will have
shape (2, 6).  The means there is, in effect, an extra pole and an extra
zero at the origin in the SOS representation.

&gt;&gt;&gt; z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j])
&gt;&gt;&gt; p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j])

With ``pairing='nearest'`` (the default), we obtain

&gt;&gt;&gt; signal.zpk2sos(z1, p1, 1)
array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ],
       [ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]])

The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles
{0, 0.75}, and the second section has the zeros {-1, 0} and poles
{0.8+0.1j, 0.8-0.1j}.  Note that the extra pole and zero at the origin
have been assigned to different sections.

With ``pairing='keep_odd'``, we obtain:

&gt;&gt;&gt; signal.zpk2sos(z1, p1, 1, pairing='keep_odd')
array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ],
       [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])

The extra pole and zero at the origin are in the same section.
The first section is, in effect, a first-order section.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Zeros of the transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>Poles of the transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True">
      <docstring>System gain.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pairing" name="pairing">
      <docstring>The method to use to combine pairs of poles and zeros into sections.
See Notes below.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['nearest', 'keep_odd']]</values>
      <defaults>['nearest']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sos" name="sos" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of second-order filter coefficients, with shape
``(n_sections, 6)``. See `sosfilt` for the SOS filter format
specification.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.zpk2ss" module_name="zpk2ss" namespace="'signal'" output_type="list">
    <docstring>Zero-pole-gain representation to state-space representation

Parameters
----------
z, p : sequence
    Zeros and poles.
k : float
    System gain.

Returns
-------
A, B, C, D : ndarray
    State space representation of the system, in controller canonical
    form.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Zeros and poles.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>Zeros and poles.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True">
      <docstring>System gain.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="A" name="A" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="B" name="B" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="C" name="C" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="D" name="D" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>State space representation of the system, in controller canonical
form.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.signal.zpk2tf" module_name="zpk2tf" namespace="'signal'" output_type="list">
    <docstring>Return polynomial transfer function representation from zeros and poles

Parameters
----------
z : array_like
    Zeros of the transfer function.
p : array_like
    Poles of the transfer function.
k : float
    System gain.

Returns
-------
b : ndarray
    Numerator polynomial coefficients.
a : ndarray
    Denominator polynomial coefficients.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Zeros of the transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:List" show_port="True">
      <docstring>Poles of the transfer function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True">
      <docstring>System gain.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="b" name="b" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Numerator polynomial coefficients.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Denominator polynomial coefficients.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.block_diag" module_name="block_diag" namespace="'sparse'">
    <docstring>Build a block diagonal sparse matrix from provided matrices.

Parameters
----------
mats : sequence of matrices
    Input matrices.
format : str, optional
    The sparse format of the result (e.g. "csr").  If not given, the matrix
    is returned in "coo" format.
dtype : dtype specifier, optional
    The data-type of the output matrix.  If not given, the dtype is
    determined from that of `blocks`.

Returns
-------
res : sparse matrix

Notes
-----

.. versionadded:: 0.11.0

See Also
--------
bmat, diags

Examples
--------
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5], [6]])
&gt;&gt;&gt; C = coo_matrix([[7]])
&gt;&gt;&gt; block_diag((A, B, C)).toarray()
array([[1, 2, 0, 0],
       [3, 4, 0, 0],
       [0, 0, 5, 0],
       [0, 0, 6, 0],
       [0, 0, 0, 7]])</docstring>
    <inputPortSpec arg="mats" name="mats" port_type="basic:List" show_port="True">
      <docstring>Input matrices.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>The sparse format of the result (e.g. "csr").  If not given, the matrix
is returned in "coo" format.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data-type of the output matrix.  If not given, the dtype is
determined from that of `blocks`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.bmat" module_name="bmat" namespace="'sparse'">
    <docstring>Build a sparse matrix from sparse sub-blocks

Parameters
----------
blocks : array_like
    Grid of sparse matrices with compatible shapes.
    An entry of None implies an all-zero matrix.
format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional
    The sparse format of the result (e.g. "csr").  By default an
    appropriate sparse matrix format is returned.
    This choice is subject to change.
dtype : dtype, optional
    The data-type of the output matrix.  If not given, the dtype is
    determined from that of `blocks`.

Returns
-------
bmat : sparse matrix

See Also
--------
block_diag, diags

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, bmat
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5], [6]])
&gt;&gt;&gt; C = coo_matrix([[7]])
&gt;&gt;&gt; bmat([[A, B], [None, C]]).toarray()
array([[1, 2, 5],
       [3, 4, 6],
       [0, 0, 7]])

&gt;&gt;&gt; bmat([[A, None], [None, C]]).toarray()
array([[1, 2, 0],
       [3, 4, 0],
       [0, 0, 7]])</docstring>
    <inputPortSpec arg="blocks" name="blocks" port_type="basic:List" show_port="True">
      <docstring>Grid of sparse matrices with compatible shapes.
An entry of None implies an all-zero matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>The sparse format of the result (e.g. "csr").  By default an
appropriate sparse matrix format is returned.
This choice is subject to change.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil']]</values>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data-type of the output matrix.  If not given, the dtype is
determined from that of `blocks`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="bmat" name="bmat" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.cs_graph_components" module_name="cs_graph_components" namespace="'sparse'">
    <docstring>`cs_graph_components` is deprecated!
In the future, use csgraph.connected_components. Note that this new function has a slightly different interface: see the docstring for more information.


    Determine connected components of a graph stored as a compressed
    sparse row or column matrix.

    For speed reasons, the symmetry of the matrix x is not checked. A
    nonzero at index `(i, j)` means that node `i` is connected to node
    `j` by an edge. The number of rows/columns of the matrix thus
    corresponds to the number of nodes in the graph.

    Parameters
    -----------
    x : array_like or sparse matrix, 2 dimensions
        The adjacency matrix of the graph. Only the upper triangular part
        is used.

    Returns
    --------
    n_comp : int
        The number of connected components.
    label : ndarray (ints, 1 dimension):
        The label array of each connected component (-2 is used to
        indicate empty rows in the matrix: 0 everywhere, including
        diagonal). This array has the length of the number of nodes,
        i.e. one label for each node of the graph. Nodes having the same
        label belong to the same connected component.

    Notes
    ------
    The matrix is assumed to be symmetric and the upper triangular part
    of the matrix is used. The matrix is converted to a CSR matrix unless
    it is already a CSR.

    Examples
    --------
    &gt;&gt;&gt; from scipy.sparse.csgraph import connected_components
    &gt;&gt;&gt; D = np.eye(4)
    &gt;&gt;&gt; D[0,1] = D[1,0] = 1
    &gt;&gt;&gt; cs_graph_components(D)
    (3, array([0, 0, 1, 2]))
    &gt;&gt;&gt; from scipy.sparse import dok_matrix
    &gt;&gt;&gt; cs_graph_components(dok_matrix(D))
    (3, array([0, 0, 1, 2]))</docstring>
    <inputPortSpec arg="x" name="xScalar" show_port="True">
      <docstring>The adjacency matrix of the graph. Only the upper triangular part
is used.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="n_comp" name="n_comp" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>    The number of connected components.
label : ndarray (ints, 1 dimension):
    The label array of each connected component (-2 is used to
    indicate empty rows in the matrix: 0 everywhere, including
    diagonal). This array has the length of the number of nodes,
    i.e. one label for each node of the graph. Nodes having the same
    label belong to the same connected component.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.diags" module_name="diags" namespace="'sparse'">
    <docstring>Construct a sparse matrix from diagonals.

Parameters
----------
diagonals : sequence of array_like
    Sequence of arrays containing the matrix diagonals,
    corresponding to `offsets`.
offsets : sequence of int
    Diagonals to set:
      - k = 0  the main diagonal
      - k &gt; 0  the k-th upper diagonal
      - k &lt; 0  the k-th lower diagonal
shape : tuple of int, optional
    Shape of the result. If omitted, a square matrix large enough
    to contain the diagonals is returned.
format : {"dia", "csr", "csc", "lil", ...}, optional
    Matrix format of the result.  By default (format=None) an
    appropriate sparse matrix format is returned.  This choice is
    subject to change.
dtype : dtype, optional
    Data type of the matrix.

See Also
--------
spdiags : construct matrix from diagonals

Notes
-----
This function differs from `spdiags` in the way it handles
off-diagonals.

The result from `diags` is the sparse equivalent of::

    np.diag(diagonals[0], offsets[0])
    + ...
    + np.diag(diagonals[k], offsets[k])

Repeated diagonal offsets are disallowed.

.. versionadded:: 0.11

Examples
--------
&gt;&gt;&gt; diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]]
&gt;&gt;&gt; diags(diagonals, [0, -1, 2]).toarray()
array([[1, 0, 1, 0],
       [1, 2, 0, 2],
       [0, 2, 3, 0],
       [0, 0, 3, 4]])

Broadcasting of scalars is supported (but shape needs to be
specified):

&gt;&gt;&gt; diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray()
array([[-2.,  1.,  0.,  0.],
       [ 1., -2.,  1.,  0.],
       [ 0.,  1., -2.,  1.],
       [ 0.,  0.,  1., -2.]])


If only one diagonal is wanted (as in `numpy.diag`), the following
works as well:

&gt;&gt;&gt; diags([1, 2, 3], 1).toarray()
array([[ 0.,  1.,  0.,  0.],
       [ 0.,  0.,  2.,  0.],
       [ 0.,  0.,  0.,  3.],
       [ 0.,  0.,  0.,  0.]])</docstring>
    <inputPortSpec arg="diagonals" name="diagonals" port_type="basic:List" show_port="True">
      <docstring>Sequence of arrays containing the matrix diagonals,
corresponding to `offsets`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="offsets" depth="1" name="offsets" port_type="basic:Integer" show_port="True">
      <docstring>Diagonals to set:
  - k = 0  the main diagonal
  - k &gt; 0  the k-th upper diagonal
  - k &lt; 0  the k-th lower diagonal</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shape" depth="1" name="shape" port_type="basic:Integer">
      <docstring>Shape of the result. If omitted, a square matrix large enough
to contain the diagonals is returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>Matrix format of the result.  By default (format=None) an
appropriate sparse matrix format is returned.  This choice is
subject to change.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dia', 'csr', 'csc', 'lil', '...']]</values>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.eye" module_name="eye" namespace="'sparse'">
    <docstring>Sparse matrix with ones on diagonal

Returns a sparse (m x n) matrix where the k-th diagonal
is all ones and everything else is zeros.

Parameters
----------
n : int
    Number of rows in the matrix.
m : int, optional
    Number of columns. Default: n
k : int, optional
    Diagonal to place ones on. Default: 0 (main diagonal)
dtype : dtype, optional
    Data type of the matrix
format : str, optional
    Sparse format of the result, e.g. format="csr", etc.

Examples
--------
&gt;&gt;&gt; from scipy import sparse
&gt;&gt;&gt; sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '&lt;type 'numpy.int8'&gt;'
    with 3 stored elements (1 diagonals) in DIAgonal format&gt;</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Number of rows in the matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer">
      <docstring>Number of columns. Default: n</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Diagonal to place ones on. Default: 0 (main diagonal)</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Data type of the matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>Sparse format of the result, e.g. format="csr", etc.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.find" module_name="find" namespace="'sparse'" output_type="list">
    <docstring>Return the indices and values of the nonzero elements of a matrix

Parameters
----------
A : dense or sparse matrix
    Matrix whose nonzero elements are desired.

Returns
-------
(I,J,V) : tuple of arrays
    I,J, and V contain the row indices, column indices, and values
    of the nonzero matrix entries.


Examples
--------
&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; A = csr_matrix([[7.0, 8.0, 0],[0, 0, 9.0]])
&gt;&gt;&gt; find(A)
(array([0, 0, 1], dtype=int32), array([0, 1, 2], dtype=int32), array([ 7.,  8.,  9.]))</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>Matrix whose nonzero elements are desired.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dense']]</values>
    </inputPortSpec>
    <outputPortSpec arg="(I" name="(I" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>I,J, and V contain the row indices, column indices, and values
of the nonzero matrix entries.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="J" name="J" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>I,J, and V contain the row indices, column indices, and values
of the nonzero matrix entries.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="V)" name="V)" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>I,J, and V contain the row indices, column indices, and values
of the nonzero matrix entries.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.hstack" module_name="hstack" namespace="'sparse'">
    <docstring>Stack sparse matrices horizontally (column wise)

Parameters
----------
blocks
    sequence of sparse matrices with compatible shapes
format : str
    sparse format of the result (e.g. "csr")
    by default an appropriate sparse matrix format is returned.
    This choice is subject to change.
dtype : dtype, optional
    The data-type of the output matrix.  If not given, the dtype is
    determined from that of `blocks`.

See Also
--------
vstack : stack sparse matrices vertically (row wise)

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, hstack
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5], [6]])
&gt;&gt;&gt; hstack([A,B]).toarray()
array([[1, 2, 5],
       [3, 4, 6]])</docstring>
    <inputPortSpec arg="blocks" name="blocks" port_type="basic:Variant" show_port="True">
      <docstring>sequence of sparse matrices with compatible shapes</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format" show_port="True">
      <docstring>sparse format of the result (e.g. "csr")
by default an appropriate sparse matrix format is returned.
This choice is subject to change.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data-type of the output matrix.  If not given, the dtype is
determined from that of `blocks`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.identity" module_name="identity" namespace="'sparse'">
    <docstring>Identity matrix in sparse format

Returns an identity matrix with shape (n,n) using a given
sparse format and dtype.

Parameters
----------
n : int
    Shape of the identity matrix.
dtype : dtype, optional
    Data type of the matrix
format : str, optional
    Sparse format of the result, e.g. format="csr", etc.

Examples
--------
&gt;&gt;&gt; identity(3).toarray()
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
&gt;&gt;&gt; identity(3, dtype='int8', format='dia')
&lt;3x3 sparse matrix of type '&lt;type 'numpy.int8'&gt;'
        with 3 stored elements (1 diagonals) in DIAgonal format&gt;</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the identity matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype">
      <docstring>Data type of the matrix</docstring>
      <defaults>['d']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>Sparse format of the result, e.g. format="csr", etc.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.issparse" module_name="issparse" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix" module_name="isspmatrix" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_bsr" module_name="isspmatrix_bsr" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_coo" module_name="isspmatrix_coo" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_csc" module_name="isspmatrix_csc" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_csr" module_name="isspmatrix_csr" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_dia" module_name="isspmatrix_dia" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_dok" module_name="isspmatrix_dok" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.isspmatrix_lil" module_name="isspmatrix_lil" namespace="'sparse'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.kron" module_name="kron" namespace="'sparse'">
    <docstring>kronecker product of sparse matrices A and B

Parameters
----------
A : sparse or dense matrix
    first matrix of the product
B : sparse or dense matrix
    second matrix of the product
format : str, optional
    format of the result (e.g. "csr")

Returns
-------
kronecker product in a sparse matrix format


Examples
--------
&gt;&gt;&gt; from scipy import sparse
&gt;&gt;&gt; A = sparse.csr_matrix(np.array([[0, 2], [5, 0]]))
&gt;&gt;&gt; B = sparse.csr_matrix(np.array([[1, 2], [3, 4]]))
&gt;&gt;&gt; sparse.kron(A, B).toarray()
array([[ 0,  0,  2,  4],
       [ 0,  0,  6,  8],
       [ 5, 10,  0,  0],
       [15, 20,  0,  0]])

&gt;&gt;&gt; sparse.kron(A, [[1, 2], [3, 4]]).toarray()
array([[ 0,  0,  2,  4],
       [ 0,  0,  6,  8],
       [ 5, 10,  0,  0],
       [15, 20,  0,  0]])</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>first matrix of the product</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['sparse']]</values>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" show_port="True">
      <docstring>second matrix of the product</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['sparse']]</values>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>format of the result (e.g. "csr")</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.kronsum" module_name="kronsum" namespace="'sparse'">
    <docstring>kronecker sum of sparse matrices A and B

Kronecker sum of two sparse matrices is a sum of two Kronecker
products kron(I_n,A) + kron(B,I_m) where A has shape (m,m)
and B has shape (n,n) and I_m and I_n are identity matrices
of shape (m,m) and (n,n) respectively.

Parameters
----------
A
    square matrix
B
    square matrix
format : str
    format of the result (e.g. "csr")

Returns
-------
kronecker sum in a sparse matrix format

Examples
--------</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:Variant" show_port="True">
      <docstring>square matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:Variant" show_port="True">
      <docstring>square matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format" show_port="True">
      <docstring>format of the result (e.g. "csr")</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.rand" module_name="rand" namespace="'sparse'">
    <docstring>Generate a sparse matrix of the given shape and density with uniformly
distributed values.

Parameters
----------
m, n : int
    shape of the matrix
density : real, optional
    density of the generated matrix: density equal to one means a full
    matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
    sparse matrix format.
dtype : dtype, optional
    type of the returned matrix values.
random_state : {numpy.random.RandomState, int}, optional
    Random number generator or random seed. If not given, the singleton
    numpy.random will be used.

Notes
-----
Only float types are supported for now.</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>shape of the matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>shape of the matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="density" name="density" port_type="basic:Float">
      <docstring>density of the generated matrix: density equal to one means a full
matrix, density of 0 means a matrix with no non-zero items.</docstring>
      <defaults>[0.01]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>sparse matrix format.</docstring>
      <defaults>['coo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>type of the returned matrix values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="random_state" name="random_state">
      <docstring>Random number generator or random seed. If not given, the singleton
numpy.random will be used.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['numpy.random.RandomState']]</values>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.random" module_name="random" namespace="'sparse'">
    <docstring>Generate a sparse matrix of the given shape and density with randomly
distributed values.

Parameters
----------
m, n : int
    shape of the matrix
density : real, optional
    density of the generated matrix: density equal to one means a full
    matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
    sparse matrix format.
dtype : dtype, optional
    type of the returned matrix values.
random_state : {numpy.random.RandomState, int}, optional
    Random number generator or random seed. If not given, the singleton
    numpy.random will be used.  This random state will be used
    for sampling the sparsity structure, but not necessarily for sampling
    the values of the structurally nonzero entries of the matrix.
data_rvs : callable, optional
    Samples a requested number of random values.
    This function should take a single argument specifying the length
    of the ndarray that it will return.  The structurally nonzero entries
    of the sparse random matrix will be taken from the array sampled
    by this function.  By default, uniform [0, 1) random values will be
    sampled using the same random state as is used for sampling
    the sparsity structure.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import construct
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; class CustomRandomState(object):
...     def randint(self, k):
...         i = np.random.randint(k)
...         return i - i % 2
&gt;&gt;&gt; rs = CustomRandomState()
&gt;&gt;&gt; rvs = stats.poisson(25, loc=10).rvs
&gt;&gt;&gt; S = construct.random(3, 4, density=0.25, random_state=rs, data_rvs=rvs)
&gt;&gt;&gt; S.A
array([[ 36.,   0.,  33.,   0.],
       [  0.,   0.,   0.,   0.],
       [  0.,   0.,  36.,   0.]])

Notes
-----
Only float types are supported for now.</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>shape of the matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>shape of the matrix</docstring>
    </inputPortSpec>
    <inputPortSpec arg="density" name="density" port_type="basic:Float">
      <docstring>density of the generated matrix: density equal to one means a full
matrix, density of 0 means a matrix with no non-zero items.</docstring>
      <defaults>[0.01]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>sparse matrix format.</docstring>
      <defaults>['coo']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>type of the returned matrix values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="random_state" name="random_state">
      <docstring>Random number generator or random seed. If not given, the singleton
numpy.random will be used.  This random state will be used
for sampling the sparsity structure, but not necessarily for sampling
the values of the structurally nonzero entries of the matrix.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['numpy.random.RandomState']]</values>
    </inputPortSpec>
    <inputPortSpec arg="data_rvs" name="data_rvs" port_type="basic:Variant">
      <docstring>Samples a requested number of random values.
This function should take a single argument specifying the length
of the ndarray that it will return.  The structurally nonzero entries
of the sparse random matrix will be taken from the array sampled
by this function.  By default, uniform [0, 1) random values will be
sampled using the same random state as is used for sampling
the sparsity structure.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.spdiags" module_name="spdiags" namespace="'sparse'">
    <docstring>Return a sparse matrix from diagonals.

Parameters
----------
data : array_like
    matrix diagonals stored row-wise
diags : diagonals to set
    - k = 0  the main diagonal
    - k &gt; 0  the k-th upper diagonal
    - k &lt; 0  the k-th lower diagonal
m, n : int
    shape of the result
format : str, optional
    Format of the result. By default (format=None) an appropriate sparse
    matrix format is returned.  This choice is subject to change.

See Also
--------
diags : more convenient form of this function
dia_matrix : the sparse DIAgonal format.

Examples
--------
&gt;&gt;&gt; data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])
&gt;&gt;&gt; diags = np.array([0, -1, 2])
&gt;&gt;&gt; spdiags(data, diags, 4, 4).toarray()
array([[1, 0, 3, 0],
       [1, 2, 0, 4],
       [0, 2, 3, 0],
       [0, 0, 3, 4]])</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>matrix diagonals stored row-wise</docstring>
    </inputPortSpec>
    <inputPortSpec arg="diags" name="diags" port_type="basic:Variant" show_port="True">
      <docstring>- k = 0  the main diagonal
- k &gt; 0  the k-th upper diagonal
- k &lt; 0  the k-th lower diagonal</docstring>
    </inputPortSpec>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>shape of the result</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>shape of the result</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>Format of the result. By default (format=None) an appropriate sparse
matrix format is returned.  This choice is subject to change.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.tril" module_name="tril" namespace="'sparse'">
    <docstring>Return the lower triangular portion of a matrix in sparse format

Returns the elements on or below the k-th diagonal of the matrix A.
    - k = 0 corresponds to the main diagonal
    - k &gt; 0 is above the main diagonal
    - k &lt; 0 is below the main diagonal

Parameters
----------
A : dense or sparse matrix
    Matrix whose lower trianglar portion is desired.
k : integer : optional
    The top-most diagonal of the lower triangle.
format : string
    Sparse format of the result, e.g. format="csr", etc.

Returns
-------
L : sparse matrix
    Lower triangular portion of A in sparse format.

See Also
--------
triu : upper triangle in sparse format

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
...                dtype='int32')
&gt;&gt;&gt; A.toarray()
array([[1, 2, 0, 0, 3],
       [4, 5, 0, 6, 7],
       [0, 0, 8, 9, 0]])
&gt;&gt;&gt; tril(A).toarray()
array([[1, 0, 0, 0, 0],
       [4, 5, 0, 0, 0],
       [0, 0, 8, 0, 0]])
&gt;&gt;&gt; tril(A).nnz
4
&gt;&gt;&gt; tril(A, k=1).toarray()
array([[1, 2, 0, 0, 0],
       [4, 5, 0, 0, 0],
       [0, 0, 8, 9, 0]])
&gt;&gt;&gt; tril(A, k=-1).toarray()
array([[0, 0, 0, 0, 0],
       [4, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; tril(A, format='csc')
&lt;3x5 sparse matrix of type '&lt;type 'numpy.int32'&gt;'
        with 4 stored elements in Compressed Sparse Column format&gt;</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>Matrix whose lower trianglar portion is desired.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dense']]</values>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>The top-most diagonal of the lower triangle.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format" show_port="True">
      <docstring>Sparse format of the result, e.g. format="csr", etc.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="L" name="L" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Lower triangular portion of A in sparse format.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.triu" module_name="triu" namespace="'sparse'">
    <docstring>Return the upper triangular portion of a matrix in sparse format

Returns the elements on or above the k-th diagonal of the matrix A.
    - k = 0 corresponds to the main diagonal
    - k &gt; 0 is above the main diagonal
    - k &lt; 0 is below the main diagonal

Parameters
----------
A : dense or sparse matrix
    Matrix whose upper trianglar portion is desired.
k : integer : optional
    The bottom-most diagonal of the upper triangle.
format : string
    Sparse format of the result, e.g. format="csr", etc.

Returns
-------
L : sparse matrix
    Upper triangular portion of A in sparse format.

See Also
--------
tril : lower triangle in sparse format

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
...                dtype='int32')
&gt;&gt;&gt; A.toarray()
array([[1, 2, 0, 0, 3],
       [4, 5, 0, 6, 7],
       [0, 0, 8, 9, 0]])
&gt;&gt;&gt; triu(A).toarray()
array([[1, 2, 0, 0, 3],
       [0, 5, 0, 6, 7],
       [0, 0, 8, 9, 0]])
&gt;&gt;&gt; triu(A).nnz
8
&gt;&gt;&gt; triu(A, k=1).toarray()
array([[0, 2, 0, 0, 3],
       [0, 0, 0, 6, 7],
       [0, 0, 0, 9, 0]])
&gt;&gt;&gt; triu(A, k=-1).toarray()
array([[1, 2, 0, 0, 3],
       [4, 5, 0, 6, 7],
       [0, 0, 8, 9, 0]])
&gt;&gt;&gt; triu(A, format='csc')
&lt;3x5 sparse matrix of type '&lt;type 'numpy.int32'&gt;'
        with 8 stored elements in Compressed Sparse Column format&gt;</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>Matrix whose upper trianglar portion is desired.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['dense']]</values>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>The bottom-most diagonal of the upper triangle.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format" show_port="True">
      <docstring>Sparse format of the result, e.g. format="csr", etc.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="L" name="L" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Upper triangular portion of A in sparse format.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.vstack" module_name="vstack" namespace="'sparse'">
    <docstring>Stack sparse matrices vertically (row wise)

Parameters
----------
blocks
    sequence of sparse matrices with compatible shapes
format : str, optional
    sparse format of the result (e.g. "csr")
    by default an appropriate sparse matrix format is returned.
    This choice is subject to change.
dtype : dtype, optional
    The data-type of the output matrix.  If not given, the dtype is
    determined from that of `blocks`.

See Also
--------
hstack : stack sparse matrices horizontally (column wise)

Examples
--------
&gt;&gt;&gt; from scipy.sparse import coo_matrix, vstack
&gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]])
&gt;&gt;&gt; B = coo_matrix([[5, 6]])
&gt;&gt;&gt; vstack([A, B]).toarray()
array([[1, 2],
       [3, 4],
       [5, 6]])</docstring>
    <inputPortSpec arg="blocks" name="blocks" port_type="basic:Variant" show_port="True">
      <docstring>sequence of sparse matrices with compatible shapes</docstring>
    </inputPortSpec>
    <inputPortSpec arg="format" name="format">
      <docstring>sparse format of the result (e.g. "csr")
by default an appropriate sparse matrix format is returned.
This choice is subject to change.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The data-type of the output matrix.  If not given, the dtype is
determined from that of `blocks`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.all" module_name="all" namespace="'sparse|linalg'">
    <docstring>Test whether all array elements along a given axis evaluate to True.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical AND reduction is performed.
    The default (`axis` = `None`) is to perform a logical AND over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.
    It must have the same shape as the expected output and its
    type is preserved (e.g., if ``dtype(out)`` is float, the result
    will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section
    "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
all : ndarray, bool
    A new boolean or array is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.all : equivalent method

any : Test whether any element along a given axis evaluates to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to `True` because these are not equal to zero.

Examples
--------
&gt;&gt;&gt; np.all([[True,False],[True,True]])
False

&gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)
array([ True, False], dtype=bool)

&gt;&gt;&gt; np.all([-1, 4, 5])
True

&gt;&gt;&gt; np.all([1.0, np.nan])
True

&gt;&gt;&gt; o=np.array([False])
&gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)
&gt;&gt;&gt; id(z), id(o), z                             # doctest: +SKIP
(28293632, 28293632, array([ True], dtype=bool))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which a logical AND reduction is performed.
The default (`axis` = `None`) is to perform a logical AND over all
the dimensions of the input array. `axis` may be negative, in
which case it counts from the last to the first axis.

.. versionadded:: 1.7.0

If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if ``dtype(out)`` is float, the result
will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section
"Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="all" depth="1" name="all" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>A new boolean or array is returned unless `out` is specified,
in which case a reference to `out` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.amax" module_name="amax" namespace="'sparse|linalg'">
    <docstring>Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array
3
&gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
&gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])

&gt;&gt;&gt; b = np.arange(5, dtype=np.float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amax(b)
nan
&gt;&gt;&gt; np.nanmax(b)
4.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which to operate.  By default, flattened input is
used.

.. versionadded: 1.7.0

If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="amax" name="amax" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Maximum of `a`. If `axis` is None, the result is a scalar value.
If `axis` is given, the result is an array of dimension
``a.ndim - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.amin" module_name="amin" namespace="'sparse|linalg'">
    <docstring>Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
&gt;&gt;&gt; a = np.arange(4).reshape((2,2))
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array
0
&gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
&gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])

&gt;&gt;&gt; b = np.arange(5, dtype=np.float)
&gt;&gt;&gt; b[2] = np.NaN
&gt;&gt;&gt; np.amin(b)
nan
&gt;&gt;&gt; np.nanmin(b)
0.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which to operate.  By default, flattened input is
used.

.. versionadded: 1.7.0

If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See `doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="amin" name="amin" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Minimum of `a`. If `axis` is None, the result is a scalar value.
If `axis` is given, the result is an array of dimension
``a.ndim - 1``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.array" module_name="array" namespace="'sparse|linalg'">
    <docstring>array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)

Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an
    object whose __array__ method returns an array, or any
    (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then
    the type will be determined as the minimum type required
    to hold the objects in the sequence.  This argument can only
    be used to 'upcast' the array.  For downcasting, use the
    .astype(t) method.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy
    will only be made if __array__ returns a copy, if obj is a
    nested sequence, or if a copy is needed to satisfy any of the other
    requirements (`dtype`, `order`, etc.).
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Returns
-------
out : ndarray
    An array object satisfying the specified requirements.

See Also
--------
empty, empty_like, zeros, zeros_like, ones, ones_like, fill

Examples
--------
&gt;&gt;&gt; np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

&gt;&gt;&gt; np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

&gt;&gt;&gt; np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

&gt;&gt;&gt; np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

&gt;&gt;&gt; np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

&gt;&gt;&gt; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
&gt;&gt;&gt; x['a']
array([1, 3])

Creating an array from sub-classes:

&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])</docstring>
    <inputPortSpec arg="object" name="object" port_type="basic:List" show_port="True">
      <docstring>An array, any object exposing the array interface, an
object whose __array__ method returns an array, or any
(nested) sequence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The desired data-type for the array.  If not given, then
the type will be determined as the minimum type required
to hold the objects in the sequence.  This argument can only
be used to 'upcast' the array.  For downcasting, use the
.astype(t) method.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <docstring>If true (default), then the object is copied.  Otherwise, a copy
will only be made if __array__ returns a copy, if obj is a
nested sequence, or if a copy is needed to satisfy any of the other
requirements (`dtype`, `order`, etc.).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Specify the order of the array.  If order is 'C', then the array
will be in C-contiguous order (last-index varies the fastest).
If order is 'F', then the returned array will be in
Fortran-contiguous order (first-index varies the fastest).
If order is 'A' (default), then the returned array may be
in any order (either C-, Fortran-contiguous, or even discontiguous),
unless a copy is required, in which case it will be C-contiguous.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['A']]</values>
      <defaults>['A']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="subok" name="subok" port_type="basic:Boolean">
      <docstring>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ndmin" name="ndmin" port_type="basic:Integer">
      <docstring>Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array object satisfying the specified requirements.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.asarray" module_name="asarray" namespace="'sparse|linalg'">
    <docstring>Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; np.asarray(a)
array([1, 2])

Existing arrays are not copied:

&gt;&gt;&gt; a = np.array([1, 2])
&gt;&gt;&gt; np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

&gt;&gt;&gt; a = np.array([1, 2], dtype=np.float32)
&gt;&gt;&gt; np.asarray(a, dtype=np.float32) is a
True
&gt;&gt;&gt; np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

&gt;&gt;&gt; issubclass(np.matrix, np.ndarray)
True
&gt;&gt;&gt; a = np.matrix([[1, 2]])
&gt;&gt;&gt; np.asarray(a) is a
False
&gt;&gt;&gt; np.asanyarray(a) is a
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>By default, the data-type is inferred from the input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array interpretation of `a`.  No copy is performed if the input
is already an ndarray.  If `a` is a subclass of ndarray, a base
class ndarray is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.aslinearoperator" module_name="aslinearoperator" namespace="'sparse|linalg'">
    <docstring>Return A as a LinearOperator.

'A' may be any of the following types:
 - ndarray
 - matrix
 - sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
 - LinearOperator
 - An object with .shape and .matvec attributes

See the LinearOperator documentation for additional information.

Examples
--------
&gt;&gt;&gt; from scipy import matrix
&gt;&gt;&gt; M = matrix( [[1,2,3],[4,5,6]], dtype='int32' )
&gt;&gt;&gt; aslinearoperator( M )
&lt;2x3 LinearOperator with dtype=int32&gt;</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.bicg" module_name="bicg" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use BIConjugate Gradient iteration to solve A x = b

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real or complex N-by-N matrix of the linear system
    It is required that the linear operator can produce
    ``Ax`` and ``A^T x``.
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        &gt;0 : convergence to tolerance not achieved, number of iterations
        &lt;0 : illegal input or breakdown

Other Parameters
----------------
x0  : {array, matrix}
    Starting guess for the solution.
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
xtype : {'f','d','F','D'}
    This parameter is deprecated -- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real or complex N-by-N matrix of the linear system
It is required that the linear operator can produce
``Ax`` and ``A^T x``.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer" show_port="True">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" show_port="True">
      <docstring>Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is deprecated -- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
    0  : successful exit
    &gt;0 : convergence to tolerance not achieved, number of iterations
    &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.bicgstab" module_name="bicgstab" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use BIConjugate Gradient STABilized iteration to solve A x = b

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real or complex N-by-N matrix of the linear system
    ``A`` must represent a hermitian, positive definite matrix
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        &gt;0 : convergence to tolerance not achieved, number of iterations
        &lt;0 : illegal input or breakdown

Other Parameters
----------------
x0  : {array, matrix}
    Starting guess for the solution.
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
xtype : {'f','d','F','D'}
    This parameter is deprecated -- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real or complex N-by-N matrix of the linear system
``A`` must represent a hermitian, positive definite matrix</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer" show_port="True">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" show_port="True">
      <docstring>Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is deprecated -- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
    0  : successful exit
    &gt;0 : convergence to tolerance not achieved, number of iterations
    &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.cg" module_name="cg" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use Conjugate Gradient iteration to solve A x = b

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real or complex N-by-N matrix of the linear system
    ``A`` must represent a hermitian, positive definite matrix
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        &gt;0 : convergence to tolerance not achieved, number of iterations
        &lt;0 : illegal input or breakdown

Other Parameters
----------------
x0  : {array, matrix}
    Starting guess for the solution.
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
xtype : {'f','d','F','D'}
    This parameter is deprecated -- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real or complex N-by-N matrix of the linear system
``A`` must represent a hermitian, positive definite matrix</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer" show_port="True">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" show_port="True">
      <docstring>Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is deprecated -- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
    0  : successful exit
    &gt;0 : convergence to tolerance not achieved, number of iterations
    &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.cgs" module_name="cgs" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use Conjugate Gradient Squared iteration to solve A x = b

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real-valued N-by-N matrix of the linear system
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        &gt;0 : convergence to tolerance not achieved, number of iterations
        &lt;0 : illegal input or breakdown

Other Parameters
----------------
x0  : {array, matrix}
    Starting guess for the solution.
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
xtype : {'f','d','F','D'}
    This parameter is deprecated -- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real-valued N-by-N matrix of the linear system</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer" show_port="True">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" show_port="True">
      <docstring>Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is deprecated -- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
    0  : successful exit
    &gt;0 : convergence to tolerance not achieved, number of iterations
    &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.dot" module_name="dot" namespace="'sparse|linalg'">
    <docstring>dot(a, b, out=None)

Dot product of two arrays.

For 2-D arrays it is equivalent to matrix multiplication, and for 1-D
arrays to inner product of vectors (without complex conjugation). For
N dimensions it is a sum product over the last axis of `a` and
the second-to-last of `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.

Examples
--------
&gt;&gt;&gt; np.dot(3, 4)
12

Neither argument is complex-conjugated:

&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it is the matrix product:

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.dot(a, b)
array([[4, 1],
       [2, 2]])

&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))
&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]
499128
&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])
499128</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>First argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Second argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for `dot(a,b)`. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="output" name="output" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns the dot product of `a` and `b`.  If `a` and `b` are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If `out` is given, then it is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.eigs" module_name="eigs" namespace="'sparse|linalg'" output_type="list">
    <docstring>Find k eigenvalues and eigenvectors of the square matrix A.

Solves ``A * x[i] = w[i] * x[i]``, the standard eigenvalue problem
for w[i] eigenvalues with corresponding eigenvectors x[i].

If M is specified, solves ``A * x[i] = w[i] * M * x[i]``, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i]

Parameters
----------
A : ndarray, sparse matrix or LinearOperator
    An array, sparse matrix, or LinearOperator representing
    the operation ``A * x``, where A is a real or complex square matrix.
k : int, optional
    The number of eigenvalues and eigenvectors desired.
    `k` must be smaller than N. It is not possible to compute all
    eigenvectors of a matrix.
M : ndarray, sparse matrix or LinearOperator, optional
    An array, sparse matrix, or LinearOperator representing
    the operation M*x for the generalized eigenvalue problem

        A * x = w * M * x.

    M must represent a real, symmetric matrix if A is real, and must
    represent a complex, hermitian matrix if A is complex. For best
    results, the data type of M should be the same as that of A.
    Additionally:

        If `sigma` is None, M is positive definite

        If sigma is specified, M is positive semi-definite

    If sigma is None, eigs requires an operator to compute the solution
    of the linear equation ``M * x = b``.  This is done internally via a
    (sparse) LU decomposition for an explicit matrix M, or via an
    iterative solver for a general linear operator.  Alternatively,
    the user can supply the matrix or operator Minv, which gives
    ``x = Minv * b = M^-1 * b``.
sigma : real or complex, optional
    Find eigenvalues near sigma using shift-invert mode.  This requires
    an operator to compute the solution of the linear system
    ``[A - sigma * M] * x = b``, where M is the identity matrix if
    unspecified. This is computed internally via a (sparse) LU
    decomposition for explicit matrices A &amp; M, or via an iterative
    solver if either A or M is a general linear operator.
    Alternatively, the user can supply the matrix or operator OPinv,
    which gives ``x = OPinv * b = [A - sigma * M]^-1 * b``.
    For a real matrix A, shift-invert can either be done in imaginary
    mode or real mode, specified by the parameter OPpart ('r' or 'i').
    Note that when sigma is specified, the keyword 'which' (below)
    refers to the shifted eigenvalues ``w'[i]`` where:

        If A is real and OPpart == 'r' (default),
          ``w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]``.

        If A is real and OPpart == 'i',
          ``w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]``.

        If A is complex, ``w'[i] = 1/(w[i]-sigma)``.

v0 : ndarray, optional
    Starting vector for iteration.
    Default: random
ncv : int, optional
    The number of Lanczos vectors generated
    `ncv` must be greater than `k`; it is recommended that ``ncv &gt; 2*k``.
    Default: ``min(n, 2*k + 1)``
which : str, ['LM' | 'SM' | 'LR' | 'SR' | 'LI' | 'SI'], optional
    Which `k` eigenvectors and eigenvalues to find:

        'LM' : largest magnitude

        'SM' : smallest magnitude

        'LR' : largest real part

        'SR' : smallest real part

        'LI' : largest imaginary part

        'SI' : smallest imaginary part

    When sigma != None, 'which' refers to the shifted eigenvalues w'[i]
    (see discussion in 'sigma', above).  ARPACK is generally better
    at finding large values than small values.  If small eigenvalues are
    desired, consider using shift-invert mode for better performance.
maxiter : int, optional
    Maximum number of Arnoldi update iterations allowed
    Default: ``n*10``
tol : float, optional
    Relative accuracy for eigenvalues (stopping criterion)
    The default value of 0 implies machine precision.
return_eigenvectors : bool, optional
    Return eigenvectors (True) in addition to eigenvalues
Minv : ndarray, sparse matrix or LinearOperator, optional
    See notes in M, above.
OPinv : ndarray, sparse matrix or LinearOperator, optional
    See notes in sigma, above.
OPpart : {'r' or 'i'}, optional
    See notes in sigma, above

Returns
-------
w : ndarray
    Array of k eigenvalues.
v : ndarray
    An array of `k` eigenvectors.
    ``v[:, i]`` is the eigenvector corresponding to the eigenvalue w[i].

Raises
------
ArpackNoConvergence
    When the requested convergence is not obtained.
    The currently converged eigenvalues and eigenvectors can be found
    as ``eigenvalues`` and ``eigenvectors`` attributes of the exception
    object.

See Also
--------
eigsh : eigenvalues and eigenvectors for symmetric matrix A
svds : singular value decomposition for a matrix A

Notes
-----
This function is a wrapper to the ARPACK [1]_ SNEUPD, DNEUPD, CNEUPD,
ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to
find the eigenvalues and eigenvectors [2]_.

References
----------
.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
   Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
   Arnoldi Methods. SIAM, Philadelphia, PA, 1998.

Examples
--------
Find 6 eigenvectors of the identity matrix:

&gt;&gt;&gt; import scipy.sparse as sparse
&gt;&gt;&gt; id = np.eye(13)
&gt;&gt;&gt; vals, vecs = sparse.linalg.eigs(id, k=6)
&gt;&gt;&gt; vals
array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])
&gt;&gt;&gt; vecs.shape
(13, 6)</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>An array, sparse matrix, or LinearOperator representing
the operation ``A * x``, where A is a real or complex square matrix.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>The number of eigenvalues and eigenvectors desired.
`k` must be smaller than N. It is not possible to compute all
eigenvectors of a matrix.</docstring>
      <defaults>[6]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="M" name="MScalar">
      <docstring>An array, sparse matrix, or LinearOperator representing
the operation M*x for the generalized eigenvalue problem

    A * x = w * M * x.

M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:

    If `sigma` is None, M is positive definite

    If sigma is specified, M is positive semi-definite

If sigma is None, eigs requires an operator to compute the solution
of the linear equation ``M * x = b``.  This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
``x = Minv * b = M^-1 * b``.</docstring>
      <alternateSpec arg="M" name="MSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigma">
      <docstring>Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
``[A - sigma * M] * x = b``, where M is the identity matrix if
unspecified. This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives ``x = OPinv * b = [A - sigma * M]^-1 * b``.
For a real matrix A, shift-invert can either be done in imaginary
mode or real mode, specified by the parameter OPpart ('r' or 'i').
Note that when sigma is specified, the keyword 'which' (below)
refers to the shifted eigenvalues ``w'[i]`` where:

    If A is real and OPpart == 'r' (default),
      ``w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]``.

    If A is real and OPpart == 'i',
      ``w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]``.

    If A is complex, ``w'[i] = 1/(w[i]-sigma)``.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['r']]</values>
      <defaults>['r']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="v0" name="v0" port_type="basic:List">
      <docstring>Starting vector for iteration.
Default: random</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ncv" name="ncv" port_type="basic:Integer">
      <docstring>The number of Lanczos vectors generated
`ncv` must be greater than `k`; it is recommended that ``ncv &gt; 2*k``.
Default: ``min(n, 2*k + 1)``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="which" name="which">
      <docstring>Which `k` eigenvectors and eigenvalues to find:

    'LM' : largest magnitude

    'SM' : smallest magnitude

    'LR' : largest real part

    'SR' : smallest real part

    'LI' : largest imaginary part

    'SI' : smallest imaginary part

When sigma != None, 'which' refers to the shifted eigenvalues w'[i]
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LM', 'SM', 'LR', 'SR', 'LI', 'SI']]</values>
      <defaults>['LM']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of Arnoldi update iterations allowed
Default: ``n*10``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Relative accuracy for eigenvalues (stopping criterion)
The default value of 0 implies machine precision.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_eigenvectors" name="return_eigenvectors" port_type="basic:Boolean">
      <docstring>Return eigenvectors (True) in addition to eigenvalues</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Minv" name="MinvScalar">
      <docstring>See notes in M, above.</docstring>
      <alternateSpec arg="Minv" name="MinvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="OPinv" name="OPinvScalar">
      <docstring>See notes in sigma, above.</docstring>
      <alternateSpec arg="OPinv" name="OPinvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="OPpart" name="OPpart">
      <docstring>See notes in sigma, above</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['r', "{'r'"]]</values>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of k eigenvalues.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array of `k` eigenvectors.
``v[:, i]`` is the eigenvector corresponding to the eigenvalue w[i].</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.eigsh" module_name="eigsh" namespace="'sparse|linalg'" output_type="list">
    <docstring>Find k eigenvalues and eigenvectors of the real symmetric square matrix
or complex hermitian matrix A.

Solves ``A * x[i] = w[i] * x[i]``, the standard eigenvalue problem for
w[i] eigenvalues with corresponding eigenvectors x[i].

If M is specified, solves ``A * x[i] = w[i] * M * x[i]``, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i]

Parameters
----------
A : An N x N matrix, array, sparse matrix, or LinearOperator representing
    the operation A * x, where A is a real symmetric matrix
    For buckling mode (see below) A must additionally be positive-definite
k : int, optional
    The number of eigenvalues and eigenvectors desired.
    `k` must be smaller than N. It is not possible to compute all
    eigenvectors of a matrix.

Returns
-------
w : array
    Array of k eigenvalues
v : array
    An array representing the `k` eigenvectors.  The column ``v[:, i]`` is
    the eigenvector corresponding to the eigenvalue ``w[i]``.

Other Parameters
----------------
M : An N x N matrix, array, sparse matrix, or linear operator representing
    the operation M * x for the generalized eigenvalue problem

        A * x = w * M * x.

    M must represent a real, symmetric matrix if A is real, and must
    represent a complex, hermitian matrix if A is complex. For best
    results, the data type of M should be the same as that of A.
    Additionally:

        If sigma is None, M is symmetric positive definite

        If sigma is specified, M is symmetric positive semi-definite

        In buckling mode, M is symmetric indefinite.

    If sigma is None, eigsh requires an operator to compute the solution
    of the linear equation ``M * x = b``. This is done internally via a
    (sparse) LU decomposition for an explicit matrix M, or via an
    iterative solver for a general linear operator.  Alternatively,
    the user can supply the matrix or operator Minv, which gives
    ``x = Minv * b = M^-1 * b``.
sigma : real
    Find eigenvalues near sigma using shift-invert mode.  This requires
    an operator to compute the solution of the linear system
    `[A - sigma * M] x = b`, where M is the identity matrix if
    unspecified.  This is computed internally via a (sparse) LU
    decomposition for explicit matrices A &amp; M, or via an iterative
    solver if either A or M is a general linear operator.
    Alternatively, the user can supply the matrix or operator OPinv,
    which gives ``x = OPinv * b = [A - sigma * M]^-1 * b``.
    Note that when sigma is specified, the keyword 'which' refers to
    the shifted eigenvalues ``w'[i]`` where:

        if mode == 'normal', ``w'[i] = 1 / (w[i] - sigma)``.

        if mode == 'cayley', ``w'[i] = (w[i] + sigma) / (w[i] - sigma)``.

        if mode == 'buckling', ``w'[i] = w[i] / (w[i] - sigma)``.

    (see further discussion in 'mode' below)
v0 : ndarray, optional
    Starting vector for iteration.
    Default: random
ncv : int, optional
    The number of Lanczos vectors generated ncv must be greater than k and
    smaller than n; it is recommended that ``ncv &gt; 2*k``.
    Default: ``min(n, 2*k + 1)``
which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE']
    If A is a complex hermitian matrix, 'BE' is invalid.
    Which `k` eigenvectors and eigenvalues to find:

        'LM' : Largest (in magnitude) eigenvalues

        'SM' : Smallest (in magnitude) eigenvalues

        'LA' : Largest (algebraic) eigenvalues

        'SA' : Smallest (algebraic) eigenvalues

        'BE' : Half (k/2) from each end of the spectrum

    When k is odd, return one more (k/2+1) from the high end.
    When sigma != None, 'which' refers to the shifted eigenvalues ``w'[i]``
    (see discussion in 'sigma', above).  ARPACK is generally better
    at finding large values than small values.  If small eigenvalues are
    desired, consider using shift-invert mode for better performance.
maxiter : int, optional
    Maximum number of Arnoldi update iterations allowed
    Default: ``n*10``
tol : float
    Relative accuracy for eigenvalues (stopping criterion).
    The default value of 0 implies machine precision.
Minv : N x N matrix, array, sparse matrix, or LinearOperator
    See notes in M, above
OPinv : N x N matrix, array, sparse matrix, or LinearOperator
    See notes in sigma, above.
return_eigenvectors : bool
    Return eigenvectors (True) in addition to eigenvalues
mode : string ['normal' | 'buckling' | 'cayley']
    Specify strategy to use for shift-invert mode.  This argument applies
    only for real-valued A and sigma != None.  For shift-invert mode,
    ARPACK internally solves the eigenvalue problem
    ``OP * x'[i] = w'[i] * B * x'[i]``
    and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i]
    into the desired eigenvectors and eigenvalues of the problem
    ``A * x[i] = w[i] * M * x[i]``.
    The modes are as follows:

        'normal' :
            OP = [A - sigma * M]^-1 * M,
            B = M,
            w'[i] = 1 / (w[i] - sigma)

        'buckling' :
            OP = [A - sigma * M]^-1 * A,
            B = A,
            w'[i] = w[i] / (w[i] - sigma)

        'cayley' :
            OP = [A - sigma * M]^-1 * [A + sigma * M],
            B = M,
            w'[i] = (w[i] + sigma) / (w[i] - sigma)

    The choice of mode will affect which eigenvalues are selected by
    the keyword 'which', and can also impact the stability of
    convergence (see [2] for a discussion)

Raises
------
ArpackNoConvergence
    When the requested convergence is not obtained.

    The currently converged eigenvalues and eigenvectors can be found
    as ``eigenvalues`` and ``eigenvectors`` attributes of the exception
    object.

See Also
--------
eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
svds : singular value decomposition for a matrix A

Notes
-----
This function is a wrapper to the ARPACK [1]_ SSEUPD and DSEUPD
functions which use the Implicitly Restarted Lanczos Method to
find the eigenvalues and eigenvectors [2]_.

References
----------
.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
   Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
   Arnoldi Methods. SIAM, Philadelphia, PA, 1998.

Examples
--------
&gt;&gt;&gt; import scipy.sparse as sparse
&gt;&gt;&gt; id = np.eye(13)
&gt;&gt;&gt; vals, vecs = sparse.linalg.eigsh(id, k=6)
&gt;&gt;&gt; vals
array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])
&gt;&gt;&gt; vecs.shape
(13, 6)</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>the operation A * x, where A is a real symmetric matrix
For buckling mode (see below) A must additionally be positive-definite</docstring>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>The number of eigenvalues and eigenvectors desired.
`k` must be smaller than N. It is not possible to compute all
eigenvectors of a matrix.</docstring>
      <defaults>[6]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="M" name="MScalar" show_port="True">
      <docstring>the operation M * x for the generalized eigenvalue problem

    A * x = w * M * x.

M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:

    If sigma is None, M is symmetric positive definite

    If sigma is specified, M is symmetric positive semi-definite

    In buckling mode, M is symmetric indefinite.

If sigma is None, eigsh requires an operator to compute the solution
of the linear equation ``M * x = b``. This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
``x = Minv * b = M^-1 * b``.</docstring>
      <alternateSpec arg="M" name="MSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="sigma" name="sigma" port_type="basic:Variant" show_port="True">
      <docstring>Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
`[A - sigma * M] x = b`, where M is the identity matrix if
unspecified.  This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives ``x = OPinv * b = [A - sigma * M]^-1 * b``.
Note that when sigma is specified, the keyword 'which' refers to
the shifted eigenvalues ``w'[i]`` where:

    if mode == 'normal', ``w'[i] = 1 / (w[i] - sigma)``.

    if mode == 'cayley', ``w'[i] = (w[i] + sigma) / (w[i] - sigma)``.

    if mode == 'buckling', ``w'[i] = w[i] / (w[i] - sigma)``.

(see further discussion in 'mode' below)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v0" name="v0" port_type="basic:List">
      <docstring>Starting vector for iteration.
Default: random</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ncv" name="ncv" port_type="basic:Integer">
      <docstring>The number of Lanczos vectors generated ncv must be greater than k and
smaller than n; it is recommended that ``ncv &gt; 2*k``.
Default: ``min(n, 2*k + 1)``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="which" name="which">
      <docstring>If A is a complex hermitian matrix, 'BE' is invalid.
Which `k` eigenvectors and eigenvalues to find:

    'LM' : Largest (in magnitude) eigenvalues

    'SM' : Smallest (in magnitude) eigenvalues

    'LA' : Largest (algebraic) eigenvalues

    'SA' : Smallest (algebraic) eigenvalues

    'BE' : Half (k/2) from each end of the spectrum

When k is odd, return one more (k/2+1) from the high end.
When sigma != None, 'which' refers to the shifted eigenvalues ``w'[i]``
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LM', 'SM', 'LA', 'SA', 'BE']]</values>
      <defaults>['LM']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of Arnoldi update iterations allowed
Default: ``n*10``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Relative accuracy for eigenvalues (stopping criterion).
The default value of 0 implies machine precision.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Minv" name="MinvScalar" show_port="True">
      <docstring>See notes in M, above</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
      <alternateSpec arg="Minv" name="MinvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="OPinv" name="OPinvScalar" show_port="True">
      <docstring>See notes in sigma, above.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
      <alternateSpec arg="OPinv" name="OPinvSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="return_eigenvectors" name="return_eigenvectors" port_type="basic:Boolean">
      <docstring>Return eigenvectors (True) in addition to eigenvalues</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Specify strategy to use for shift-invert mode.  This argument applies
only for real-valued A and sigma != None.  For shift-invert mode,
ARPACK internally solves the eigenvalue problem
``OP * x'[i] = w'[i] * B * x'[i]``
and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i]
into the desired eigenvectors and eigenvalues of the problem
``A * x[i] = w[i] * M * x[i]``.
The modes are as follows:

    'normal' :
        OP = [A - sigma * M]^-1 * M,
        B = M,
        w'[i] = 1 / (w[i] - sigma)

    'buckling' :
        OP = [A - sigma * M]^-1 * A,
        B = A,
        w'[i] = w[i] / (w[i] - sigma)

    'cayley' :
        OP = [A - sigma * M]^-1 * [A + sigma * M],
        B = M,
        w'[i] = (w[i] + sigma) / (w[i] - sigma)

The choice of mode will affect which eigenvalues are selected by
the keyword 'which', and can also impact the stability of
convergence (see [2] for a discussion)</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['normal', 'buckling', 'cayley']]</values>
      <defaults>['normal']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of k eigenvalues</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array representing the `k` eigenvectors.  The column ``v[:, i]`` is
the eigenvector corresponding to the eigenvalue ``w[i]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.empty" module_name="empty" namespace="'sparse|linalg'">
    <docstring>empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array
dtype : data-type, optional
    Desired output data-type.
order : {'C', 'F'}, optional
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the given
    shape, dtype, and order.

See Also
--------
empty_like, zeros, ones

Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
&gt;&gt;&gt; np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #random

&gt;&gt;&gt; np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #random</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the empty array</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Desired output data-type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of uninitialized (arbitrary) data with the given
shape, dtype, and order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.empty_like" module_name="empty_like" namespace="'sparse|linalg'">
    <docstring>empty_like(a, dtype=None, order='K', subok=True)

Return a new array with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of the
    returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if ``a`` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of ``a`` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `a`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
&gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like
&gt;&gt;&gt; np.empty_like(a)
array([[-1073741821, -1073741821,           3],    #random
       [          0,           0, -1073741821]])
&gt;&gt;&gt; a = np.array([[1., 2., 3.],[4.,5.,6.]])
&gt;&gt;&gt; np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The shape and data-type of `a` define these same attributes of the
returned array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Overrides the data type of the result.

.. versionadded:: 1.6.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Overrides the memory layout of the result. 'C' means C-order,
'F' means F-order, 'A' means 'F' if ``a`` is Fortran contiguous,
'C' otherwise. 'K' means match the layout of ``a`` as closely
as possible.

.. versionadded:: 1.6.0</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F', 'A']]</values>
      <defaults>['K']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="subok" name="subok" port_type="basic:Boolean">
      <docstring>If True, then the newly created array will use the sub-class
type of 'a', otherwise it will be a base-class array. Defaults
to True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of uninitialized (arbitrary) data with the same
shape and type as `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.expm" module_name="expm" namespace="'sparse|linalg'">
    <docstring>Compute the matrix exponential using Pade approximation.

Parameters
----------
A : (M,M) array_like or sparse matrix
    2D Array or Matrix (sparse or dense) to be exponentiated

Returns
-------
expA : (M,M) ndarray
    Matrix exponential of `A`

Notes
-----
This is algorithm (6.1) which is a simplification of algorithm (5.1).

.. versionadded:: 0.12.0

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       "A New Scaling and Squaring Algorithm for the Matrix Exponential."
       SIAM Journal on Matrix Analysis and Applications.
       31 (3). pp. 970-989. ISSN 1095-7162</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>2D Array or Matrix (sparse or dense) to be exponentiated</docstring>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="expA" name="expA" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Matrix exponential of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.expm_multiply" module_name="expm_multiply" namespace="'sparse|linalg'">
    <docstring>Compute the action of the matrix exponential of A on B.

Parameters
----------
A : transposable linear operator
    The operator whose exponential is of interest.
B : ndarray
    The matrix or vector to be multiplied by the matrix exponential of A.
start : scalar, optional
    The starting time point of the sequence.
stop : scalar, optional
    The end time point of the sequence, unless `endpoint` is set to False.
    In that case, the sequence consists of all but the last of ``num + 1``
    evenly spaced time points, so that `stop` is excluded.
    Note that the step size changes when `endpoint` is False.
num : int, optional
    Number of time points to use.
endpoint : bool, optional
    If True, `stop` is the last time point.  Otherwise, it is not included.

Returns
-------
expm_A_B : ndarray
     The result of the action :math:`e^{t_k A} B`.

Notes
-----
The optional arguments defining the sequence of evenly spaced time points
are compatible with the arguments of `numpy.linspace`.

The output ndarray shape is somewhat complicated so I explain it here.
The ndim of the output could be either 1, 2, or 3.
It would be 1 if you are computing the expm action on a single vector
at a single time point.
It would be 2 if you are computing the expm action on a vector
at multiple time points, or if you are computing the expm action
on a matrix at a single time point.
It would be 3 if you want the action on a matrix with multiple
columns at multiple time points.
If multiple time points are requested, expm_A_B[0] will always
be the action of the expm at the first time point,
regardless of whether the action is on a vector or a matrix.

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2011)
       "Computing the Action of the Matrix Exponential,
       with an Application to Exponential Integrators."
       SIAM Journal on Scientific Computing,
       33 (2). pp. 488-511. ISSN 1064-8275
       http://eprints.ma.man.ac.uk/1591/

.. [2] Nicholas J. Higham and Awad H. Al-Mohy (2010)
       "Computing Matrix Functions."
       Acta Numerica,
       19. 159-208. ISSN 0962-4929
       http://eprints.ma.man.ac.uk/1451/</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:Variant" show_port="True">
      <docstring>The operator whose exponential is of interest.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B" port_type="basic:List" show_port="True">
      <docstring>The matrix or vector to be multiplied by the matrix exponential of A.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="start" name="start" port_type="basic:Float">
      <docstring>The starting time point of the sequence.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="stop" name="stop" port_type="basic:Float">
      <docstring>The end time point of the sequence, unless `endpoint` is set to False.
In that case, the sequence consists of all but the last of ``num + 1``
evenly spaced time points, so that `stop` is excluded.
Note that the step size changes when `endpoint` is False.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="num" name="num" port_type="basic:Integer">
      <docstring>Number of time points to use.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="endpoint" name="endpoint" port_type="basic:Boolean">
      <docstring>If True, `stop` is the last time point.  Otherwise, it is not included.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="expm_A_B" name="expm_A_B" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result of the action :math:`e^{t_k A} B`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.factorized" module_name="factorized" namespace="'sparse|linalg'">
    <docstring>Return a fuction for solving a sparse linear system, with A pre-factorized.

Parameters
----------
A : (N, N) array_like
    Input.

Returns
-------
solve : callable
    To solve the linear system of equations given in `A`, the `solve`
    callable should be passed an ndarray of shape (N,).

Examples
--------
&gt;&gt;&gt; A = np.array([[ 3. ,  2. , -1. ],
                  [ 2. , -2. ,  4. ],
                  [-1. ,  0.5, -1. ]])

&gt;&gt;&gt; solve = factorized( A ) # Makes LU decomposition.

&gt;&gt;&gt; rhs1 = np.array([1,-2,0])
&gt;&gt;&gt; x1 = solve( rhs1 ) # Uses the LU factors.
array([ 1., -2., -2.])</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Input.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="solve" name="solve" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>To solve the linear system of equations given in `A`, the `solve`
callable should be passed an ndarray of shape (N,).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.fastCopyAndTranspose" module_name="fastCopyAndTranspose" namespace="'sparse|linalg'">
    <docstring>_fastCopyAndTranspose(a)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.geterrobj" module_name="geterrobj" namespace="'sparse|linalg'">
    <docstring>geterrobj()

Return the current object that defines floating-point error handling.

The error object contains all information that defines the error handling
behavior in Numpy. `geterrobj` is used internally by the other
functions that get and set error handling behavior (`geterr`, `seterr`,
`geterrcall`, `seterrcall`).

Returns
-------
errobj : list
    The error object, a list containing three elements:
    [internal numpy buffer size, error mask, error callback function].

    The error mask is a single integer that holds the treatment information
    on all four floating point errors. The information for each error type
    is contained in three bits of the integer. If we print it in base 8, we
    can see what treatment is set for "invalid", "under", "over", and
    "divide" (in that order). The printed string can be interpreted with

    * 0 : 'ignore'
    * 1 : 'warn'
    * 2 : 'raise'
    * 3 : 'call'
    * 4 : 'print'
    * 5 : 'log'

See Also
--------
seterrobj, seterr, geterr, seterrcall, geterrcall
getbufsize, setbufsize

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
&gt;&gt;&gt; np.geterrobj()  # first get the defaults
[10000, 0, None]

&gt;&gt;&gt; def err_handler(type, flag):
...     print "Floating point error (%s), with flag %s" % (type, flag)
...
&gt;&gt;&gt; old_bufsize = np.setbufsize(20000)
&gt;&gt;&gt; old_err = np.seterr(divide='raise')
&gt;&gt;&gt; old_handler = np.seterrcall(err_handler)
&gt;&gt;&gt; np.geterrobj()
[20000, 2, &lt;function err_handler at 0x91dcaac&gt;]

&gt;&gt;&gt; old_err = np.seterr(all='ignore')
&gt;&gt;&gt; np.base_repr(np.geterrobj()[1], 8)
'0'
&gt;&gt;&gt; old_err = np.seterr(divide='warn', over='log', under='call',
                        invalid='print')
&gt;&gt;&gt; np.base_repr(np.geterrobj()[1], 8)
'4351'</docstring>
    <outputPortSpec arg="errobj" name="errobj" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The error object, a list containing three elements:
[internal numpy buffer size, error mask, error callback function].

The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for "invalid", "under", "over", and
"divide" (in that order). The printed string can be interpreted with

* 0 : 'ignore'
* 1 : 'warn'
* 2 : 'raise'
* 3 : 'call'
* 4 : 'print'
* 5 : 'log'</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.gmres" module_name="gmres" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use Generalized Minimal RESidual iteration to solve A x = b.

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real or complex N-by-N matrix of the linear system.
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : int
    Provides convergence information:
      * 0  : successful exit
      * &gt;0 : convergence to tolerance not achieved, number of iterations
      * &lt;0 : illegal input or breakdown

Other parameters
----------------
x0 : {array, matrix}
    Starting guess for the solution (a vector of zeros by default).
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
restart : int, optional
    Number of iterations between restarts. Larger values increase
    iteration cost, but may be necessary for convergence.
    Default is 20.
maxiter : int, optional
    Maximum number of iterations (restart cycles).  Iteration will stop
    after maxiter steps even if the specified tolerance has not been
    achieved.
xtype : {'f','d','F','D'}
    This parameter is DEPRECATED --- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.
M : {sparse matrix, dense matrix, LinearOperator}
    Inverse of the preconditioner of A.  M should approximate the
    inverse of A and be easy to solve for (see Notes).  Effective
    preconditioning dramatically improves the rate of convergence,
    which implies that fewer iterations are needed to reach a given
    error tolerance.  By default, no preconditioner is used.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(rk), where rk is the current residual vector.
restrt : int, optional
    DEPRECATED - use `restart` instead.

See Also
--------
LinearOperator

Notes
-----
A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
``M = P^-1``. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::

  # Construct a linear operator that computes P^-1 * x.
  import scipy.sparse.linalg as spla
  M_x = lambda x: spla.spsolve(P, x)
  M = spla.LinearOperator((n, n), M_x)</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real or complex N-by-N matrix of the linear system.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution (a vector of zeros by default).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="restart" name="restart" port_type="basic:Integer">
      <docstring>Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is DEPRECATED --- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" show_port="True">
      <docstring>Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(rk), where rk is the current residual vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="restrt" name="restrt" port_type="basic:Integer">
      <docstring>DEPRECATED - use `restart` instead.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
  * 0  : successful exit
  * &gt;0 : convergence to tolerance not achieved, number of iterations
  * &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.inv" module_name="inv" namespace="'sparse|linalg'">
    <docstring>Compute the inverse of a sparse matrix

Parameters
----------
A : (M,M) ndarray or sparse matrix
    square matrix to be inverted

Returns
-------
Ainv : (M,M) ndarray or sparse matrix
    inverse of `A`

Notes
-----
This computes the sparse inverse of `A`.  If the inverse of `A` is expected
to be non-sparse, it will likely be faster to convert `A` to dense and use
scipy.linalg.inv.

.. versionadded:: 0.12.0</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>square matrix to be inverted</docstring>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="Ainv" name="Ainv" show_port="True" sort_key="0">
      <docstring>inverse of `A`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.issparse" module_name="issparse" namespace="'sparse|linalg'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.lgmres" module_name="lgmres" namespace="'sparse|linalg'" output_type="list">
    <docstring>Solve a matrix equation using the LGMRES algorithm.

The LGMRES algorithm [1]_ [2]_ is designed to avoid some problems
in the convergence in restarted GMRES, and often converges in fewer
iterations.

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real or complex N-by-N matrix of the linear system.
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).
x0  : {array, matrix}
    Starting guess for the solution.
tol : float, optional
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : int, optional
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}, optional
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function, optional
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
inner_m : int, optional
    Number of inner GMRES iterations per each outer iteration.
outer_k : int, optional
    Number of vectors to carry between inner GMRES iterations.
    According to [1]_, good values are in the range of 1...3.
    However, note that if you want to use the additional vectors to
    accelerate solving multiple similar problems, larger values may
    be beneficial.
outer_v : list of tuples, optional
    List containing tuples ``(v, Av)`` of vectors and corresponding
    matrix-vector products, used to augment the Krylov subspace, and
    carried between inner GMRES iterations. The element ``Av`` can
    be `None` if the matrix-vector product should be re-evaluated.
    This parameter is modified in-place by `lgmres`, and can be used
    to pass "guess" vectors in and out of the algorithm when solving
    similar problems.
store_outer_Av : bool, optional
    Whether LGMRES should store also A*v in addition to vectors `v`
    in the `outer_v` list. Default is True.

Returns
-------
x : array or matrix
    The converged solution.
info : int
    Provides convergence information:

        - 0  : successful exit
        - &gt;0 : convergence to tolerance not achieved, number of iterations
        - &lt;0 : illegal input or breakdown

Notes
-----
The LGMRES algorithm [1]_ [2]_ is designed to avoid the
slowing of convergence in restarted GMRES, due to alternating
residual vectors. Typically, it often outperforms GMRES(m) of
comparable memory requirements by some measure, or at least is not
much worse.

Another advantage in this algorithm is that you can supply it with
'guess' vectors in the `outer_v` argument that augment the Krylov
subspace. If the solution lies close to the span of these vectors,
the algorithm converges faster. This can be useful if several very
similar matrices need to be inverted one after another, such as in
Newton-Krylov iteration where the Jacobian matrix often changes
little in the nonlinear steps.

References
----------
.. [1] A.H. Baker and E.R. Jessup and T. Manteuffel,
         SIAM J. Matrix Anal. Appl. 26, 962 (2005).
.. [2] A.H. Baker, PhD thesis, University of Colorado (2003).
         http://amath.colorado.edu/activities/thesis/allisonb/Thesis.ps</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real or complex N-by-N matrix of the linear system.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
      <defaults>[1000]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M">
      <docstring>Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inner_m" name="inner_m" port_type="basic:Integer">
      <docstring>Number of inner GMRES iterations per each outer iteration.</docstring>
      <defaults>[30]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="outer_k" name="outer_k" port_type="basic:Integer">
      <docstring>Number of vectors to carry between inner GMRES iterations.
According to [1]_, good values are in the range of 1...3.
However, note that if you want to use the additional vectors to
accelerate solving multiple similar problems, larger values may
be beneficial.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="outer_v" name="outer_v" port_type="basic:List">
      <docstring>List containing tuples ``(v, Av)`` of vectors and corresponding
matrix-vector products, used to augment the Krylov subspace, and
carried between inner GMRES iterations. The element ``Av`` can
be `None` if the matrix-vector product should be re-evaluated.
This parameter is modified in-place by `lgmres`, and can be used
to pass "guess" vectors in and out of the algorithm when solving
similar problems.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="store_outer_Av" name="store_outer_Av" port_type="basic:Boolean">
      <docstring>Whether LGMRES should store also A*v in addition to vectors `v`
in the `outer_v` list. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:

    - 0  : successful exit
    - &gt;0 : convergence to tolerance not achieved, number of iterations
    - &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.lobpcg" module_name="lobpcg" namespace="'sparse|linalg'" output_type="list">
    <docstring>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)

LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The symmetric linear operator of the problem, usually a
    sparse matrix.  Often called the "stiffness matrix".
X : array_like
    Initial approximation to the k eigenvectors. If A has
    shape=(n,n) then X should have shape shape=(n,k).
B : {dense matrix, sparse matrix, LinearOperator}, optional
    the right hand side operator in a generalized eigenproblem.
    by default, B = Identity
    often called the "mass matrix"
M : {dense matrix, sparse matrix, LinearOperator}, optional
    preconditioner to A; by default M = Identity
    M should approximate the inverse of A
Y : array_like, optional
    n-by-sizeY matrix of constraints, sizeY &lt; n
    The iterations will be performed in the B-orthogonal complement
    of the column-space of Y. Y must be full rank.

Returns
-------
w : array
    Array of k eigenvalues
v : array
    An array of k eigenvectors.  V has the same shape as X.

Other Parameters
----------------
tol : scalar, optional
    Solver tolerance (stopping criterion)
    by default: tol=n*sqrt(eps)
maxiter : integer, optional
    maximum number of iterations
    by default: maxiter=min(n,20)
largest : bool, optional
    when True, solve for the largest eigenvalues, otherwise the smallest
verbosityLevel : integer, optional
    controls solver output.  default: verbosityLevel = 0.
retLambdaHistory : boolean, optional
    whether to return eigenvalue history
retResidualNormsHistory : boolean, optional
    whether to return history of residual norms

Examples
--------
&gt;&gt;&gt; # Solve A x = lambda B x with constraints and preconditioning.
&gt;&gt;&gt; n = 100
&gt;&gt;&gt; vals = [nm.arange( n, dtype = nm.float64 ) + 1]
&gt;&gt;&gt; # Matrix A.
&gt;&gt;&gt; operatorA = spdiags( vals, 0, n, n )
&gt;&gt;&gt; # Matrix B
&gt;&gt;&gt; operatorB = nm.eye( n, n )
&gt;&gt;&gt; # Constraints.
&gt;&gt;&gt; Y = nm.eye( n, 3 )
&gt;&gt;&gt; # Initial guess for eigenvectors, should have linearly independent
&gt;&gt;&gt; # columns. Column dimension = number of requested eigenvalues.
&gt;&gt;&gt; X = sc.rand( n, 3 )
&gt;&gt;&gt; # Preconditioner - inverse of A.
&gt;&gt;&gt; ivals = [1./vals[0]]
&gt;&gt;&gt; def precond( x ):
    invA = spdiags( ivals, 0, n, n )
    y = invA  * x
    if sp.issparse( y ):
        y = y.toarray()

    return as2d( y )

&gt;&gt;&gt; # Alternative way of providing the same preconditioner.
&gt;&gt;&gt; #precond = spdiags( ivals, 0, n, n )

&gt;&gt;&gt; tt = time.clock()
&gt;&gt;&gt; eigs, vecs = lobpcg(X, operatorA, operatorB, blockVectorY=Y,
&gt;&gt;&gt;                     operatorT=precond,
&gt;&gt;&gt;                     residualTolerance=1e-4, maxIterations=40,
&gt;&gt;&gt;                     largest=False, verbosityLevel=1)
&gt;&gt;&gt; print 'solution time:', time.clock() - tt
&gt;&gt;&gt; print eigs


Notes
-----
If both retLambdaHistory and retResidualNormsHistory are True,
the return tuple has the following format
(lambda, V, lambda history, residual norms history).

In the following ``n`` denotes the matrix size and ``m`` the number
of required eigenvalues (smallest or largest).

The LOBPCG code internally solves eigenproblems of the size 3``m`` on every
iteration by calling the "standard" dense eigensolver, so if ``m`` is not
small enough compared to ``n``, it does not make sense to call the LOBPCG
code, but rather one should use the "standard" eigensolver,
e.g. numpy or scipy function in this case.
If one calls the LOBPCG algorithm for 5``m``&gt;``n``,
it will most likely break internally, so the code tries to call the standard
function instead.

It is not that n should be large for the LOBPCG to work, but rather the
ratio ``n``/``m`` should be large. It you call the LOBPCG code with ``m``=1
and ``n``=10, it should work, though ``n`` is small. The method is intended
for extremely large ``n``/``m``, see e.g., reference [28] in
http://arxiv.org/abs/0705.2626

The convergence speed depends basically on two factors:

1.  How well relatively separated the seeking eigenvalues are
    from the rest of the eigenvalues.
    One can try to vary ``m`` to make this better.

2.  How well conditioned the problem is. This can be changed by using proper
    preconditioning. For example, a rod vibration test problem (under tests
    directory) is ill-conditioned for large ``n``, so convergence will be
    slow, unless efficient preconditioning is used.
    For this specific problem, a good simple preconditioner function would
    be a linear solve for A, which is easy to code since A is tridiagonal.

*Acknowledgements*

lobpcg.py code was written by Robert Cimrman.
Many thanks belong to Andrew Knyazev, the author of the algorithm,
for lots of advice and support.

References
----------
.. [1] A. V. Knyazev (2001),
       Toward the Optimal Preconditioned Eigensolver: Locally Optimal
       Block Preconditioned Conjugate Gradient Method.
       SIAM Journal on Scientific Computing 23, no. 2,
       pp. 517-541. http://dx.doi.org/10.1137/S1064827500366124

.. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov (2007),
       Block Locally Optimal Preconditioned Eigenvalue Xolvers (BLOPEX)
       in hypre and PETSc.  http://arxiv.org/abs/0705.2626

.. [3] A. V. Knyazev's C and MATLAB implementations:
       http://www-math.cudenver.edu/~aknyazev/software/BLOPEX/</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the "stiffness matrix".</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="X" name="X" port_type="basic:List" show_port="True">
      <docstring>Initial approximation to the k eigenvectors. If A has
shape=(n,n) then X should have shape shape=(n,k).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="B" name="B">
      <docstring>the right hand side operator in a generalized eigenproblem.
by default, B = Identity
often called the "mass matrix"</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M">
      <docstring>preconditioner to A; by default M = Identity
M should approximate the inverse of A</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="Y" name="Y" port_type="basic:List">
      <docstring>n-by-sizeY matrix of constraints, sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Solver tolerance (stopping criterion)
by default: tol=n*sqrt(eps)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>maximum number of iterations
by default: maxiter=min(n,20)</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="largest" name="largest" port_type="basic:Boolean">
      <docstring>when True, solve for the largest eigenvalues, otherwise the smallest</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="verbosityLevel" name="verbosityLevel" port_type="basic:Integer">
      <docstring>controls solver output.  default: verbosityLevel = 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="retLambdaHistory" name="retLambdaHistory" port_type="basic:Boolean">
      <docstring>whether to return eigenvalue history</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="retResidualNormsHistory" name="retResidualNormsHistory" port_type="basic:Boolean">
      <docstring>whether to return history of residual norms</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of k eigenvalues</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>An array of k eigenvectors.  V has the same shape as X.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.lsmr" module_name="lsmr" namespace="'sparse|linalg'" output_type="list">
    <docstring>Iterative solver for least-squares problems.

lsmr solves the system of linear equations ``Ax = b``. If the system
is inconsistent, it solves the least-squares problem ``min ||b - Ax||_2``.
A is a rectangular matrix of dimension m-by-n, where all cases are
allowed: m = n, m &gt; n, or m &lt; n. B is a vector of length m.
The matrix A may be dense or sparse (usually sparse).

Parameters
----------
A : {matrix, sparse matrix, ndarray, LinearOperator}
    Matrix A in the linear system.
b : (m,) ndarray
    Vector b in the linear system.
damp : float
    Damping factor for regularized least-squares. `lsmr` solves
    the regularized least-squares problem::

     min ||(b) - (  A   )x||
         ||(0)   (damp*I) ||_2

    where damp is a scalar.  If damp is None or 0, the system
    is solved without regularization.
atol, btol : float, optional
    Stopping tolerances. `lsmr` continues iterations until a
    certain backward error estimate is smaller than some quantity
    depending on atol and btol.  Let ``r = b - Ax`` be the
    residual vector for the current approximate solution ``x``.
    If ``Ax = b`` seems to be consistent, ``lsmr`` terminates
    when ``norm(r) &lt;= atol * norm(A) * norm(x) + btol * norm(b)``.
    Otherwise, lsmr terminates when ``norm(A^{T} r) &lt;=
    atol * norm(A) * norm(r)``.  If both tolerances are 1.0e-6 (say),
    the final ``norm(r)`` should be accurate to about 6
    digits. (The final x will usually have fewer correct digits,
    depending on ``cond(A)`` and the size of LAMBDA.)  If `atol`
    or `btol` is None, a default value of 1.0e-6 will be used.
    Ideally, they should be estimates of the relative error in the
    entries of A and B respectively.  For example, if the entries
    of `A` have 7 correct digits, set atol = 1e-7. This prevents
    the algorithm from doing unnecessary work beyond the
    uncertainty of the input data.
conlim : float, optional
    `lsmr` terminates if an estimate of ``cond(A)`` exceeds
    `conlim`.  For compatible systems ``Ax = b``, conlim could be
    as large as 1.0e+12 (say).  For least-squares problems,
    `conlim` should be less than 1.0e+8. If `conlim` is None, the
    default value is 1e+8.  Maximum precision can be obtained by
    setting ``atol = btol = conlim = 0``, but the number of
    iterations may then be excessive.
maxiter : int, optional
    `lsmr` terminates if the number of iterations reaches
    `maxiter`.  The default is ``maxiter = min(m, n)``.  For
    ill-conditioned systems, a larger value of `maxiter` may be
    needed.
show : bool, optional
    Print iterations logs if ``show=True``.

Returns
-------
x : ndarray of float
    Least-square solution returned.
istop : int
    istop gives the reason for stopping::

      istop   = 0 means x=0 is a solution.
              = 1 means x is an approximate solution to A*x = B,
                  according to atol and btol.
              = 2 means x approximately solves the least-squares problem
                  according to atol.
              = 3 means COND(A) seems to be greater than CONLIM.
              = 4 is the same as 1 with atol = btol = eps (machine
                  precision)
              = 5 is the same as 2 with atol = eps.
              = 6 is the same as 3 with CONLIM = 1/eps.
              = 7 means ITN reached maxiter before the other stopping
                  conditions were satisfied.

itn : int
    Number of iterations used.
normr : float
    ``norm(b-Ax)``
normar : float
    ``norm(A^T (b - Ax))``
norma : float
    ``norm(A)``
conda : float
    Condition number of A.
normx : float
    ``norm(x)``

Notes
-----

.. versionadded:: 0.11.0

References
----------
.. [1] D. C.-L. Fong and M. A. Saunders,
       "LSMR: An iterative algorithm for sparse least-squares problems",
       SIAM J. Sci. Comput., vol. 33, pp. 2950-2971, 2011.
       http://arxiv.org/abs/1006.0758
.. [2] LSMR Software, http://web.stanford.edu/group/SOL/software/lsmr/</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>Matrix A in the linear system.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix', 'LinearOperator']]</values>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Vector b in the linear system.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="damp" name="damp" port_type="basic:Float">
      <docstring>Damping factor for regularized least-squares. `lsmr` solves
the regularized least-squares problem::

 min ||(b) - (  A   )x||
     ||(0)   (damp*I) ||_2

where damp is a scalar.  If damp is None or 0, the system
is solved without regularization.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>Stopping tolerances. `lsmr` continues iterations until a
certain backward error estimate is smaller than some quantity
depending on atol and btol.  Let ``r = b - Ax`` be the
residual vector for the current approximate solution ``x``.
If ``Ax = b`` seems to be consistent, ``lsmr`` terminates
when ``norm(r) &lt;= atol * norm(A) * norm(x) + btol * norm(b)``.
Otherwise, lsmr terminates when ``norm(A^{T} r) &lt;=
atol * norm(A) * norm(r)``.  If both tolerances are 1.0e-6 (say),
the final ``norm(r)`` should be accurate to about 6
digits. (The final x will usually have fewer correct digits,
depending on ``cond(A)`` and the size of LAMBDA.)  If `atol`
or `btol` is None, a default value of 1.0e-6 will be used.
Ideally, they should be estimates of the relative error in the
entries of A and B respectively.  For example, if the entries
of `A` have 7 correct digits, set atol = 1e-7. This prevents
the algorithm from doing unnecessary work beyond the
uncertainty of the input data.</docstring>
      <defaults>[1e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="btol" name="btol" port_type="basic:Float">
      <docstring>Stopping tolerances. `lsmr` continues iterations until a
certain backward error estimate is smaller than some quantity
depending on atol and btol.  Let ``r = b - Ax`` be the
residual vector for the current approximate solution ``x``.
If ``Ax = b`` seems to be consistent, ``lsmr`` terminates
when ``norm(r) &lt;= atol * norm(A) * norm(x) + btol * norm(b)``.
Otherwise, lsmr terminates when ``norm(A^{T} r) &lt;=
atol * norm(A) * norm(r)``.  If both tolerances are 1.0e-6 (say),
the final ``norm(r)`` should be accurate to about 6
digits. (The final x will usually have fewer correct digits,
depending on ``cond(A)`` and the size of LAMBDA.)  If `atol`
or `btol` is None, a default value of 1.0e-6 will be used.
Ideally, they should be estimates of the relative error in the
entries of A and B respectively.  For example, if the entries
of `A` have 7 correct digits, set atol = 1e-7. This prevents
the algorithm from doing unnecessary work beyond the
uncertainty of the input data.</docstring>
      <defaults>[1e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="conlim" name="conlim" port_type="basic:Float">
      <docstring>`lsmr` terminates if an estimate of ``cond(A)`` exceeds
`conlim`.  For compatible systems ``Ax = b``, conlim could be
as large as 1.0e+12 (say).  For least-squares problems,
`conlim` should be less than 1.0e+8. If `conlim` is None, the
default value is 1e+8.  Maximum precision can be obtained by
setting ``atol = btol = conlim = 0``, but the number of
iterations may then be excessive.</docstring>
      <defaults>[100000000.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>`lsmr` terminates if the number of iterations reaches
`maxiter`.  The default is ``maxiter = min(m, n)``.  For
ill-conditioned systems, a larger value of `maxiter` may be
needed.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="show" name="show" port_type="basic:Boolean">
      <docstring>Print iterations logs if ``show=True``.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" depth="1" name="x" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Least-square solution returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="istop" name="istop" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>istop gives the reason for stopping::

  istop   = 0 means x=0 is a solution.
          = 1 means x is an approximate solution to A*x = B,
              according to atol and btol.
          = 2 means x approximately solves the least-squares problem
              according to atol.
          = 3 means COND(A) seems to be greater than CONLIM.
          = 4 is the same as 1 with atol = btol = eps (machine
              precision)
          = 5 is the same as 2 with atol = eps.
          = 6 is the same as 3 with CONLIM = 1/eps.
          = 7 means ITN reached maxiter before the other stopping
              conditions were satisfied.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="itn" name="itn" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Number of iterations used.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="normr" name="normr" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>``norm(b-Ax)``</docstring>
    </outputPortSpec>
    <outputPortSpec arg="normar" name="normar" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>``norm(A^T (b - Ax))``</docstring>
    </outputPortSpec>
    <outputPortSpec arg="norma" name="norma" port_type="basic:Float" show_port="True" sort_key="5">
      <docstring>``norm(A)``</docstring>
    </outputPortSpec>
    <outputPortSpec arg="conda" name="conda" port_type="basic:Float" show_port="True" sort_key="6">
      <docstring>Condition number of A.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="normx" name="normx" port_type="basic:Float" show_port="True" sort_key="7">
      <docstring>``norm(x)``</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.lsqr" module_name="lsqr" namespace="'sparse|linalg'" output_type="list">
    <docstring>Find the least-squares solution to a large, sparse, linear system
of equations.

The function solves ``Ax = b``  or  ``min ||b - Ax||^2`` or
``min ||Ax - b||^2 + d^2 ||x||^2``.

The matrix A may be square or rectangular (over-determined or
under-determined), and may have any rank.

::

  1. Unsymmetric equations --    solve  A*x = b

  2. Linear least squares  --    solve  A*x = b
                                 in the least-squares sense

  3. Damped least squares  --    solve  (   A    )*x = ( b )
                                        ( damp*I )     ( 0 )
                                 in the least-squares sense

Parameters
----------
A : {sparse matrix, ndarray, LinearOperator}
    Representation of an m-by-n matrix.  It is required that
    the linear operator can produce ``Ax`` and ``A^T x``.
b : (m,) ndarray
    Right-hand side vector ``b``.
damp : float
    Damping coefficient.
atol, btol : float, optional
    Stopping tolerances. If both are 1.0e-9 (say), the final
    residual norm should be accurate to about 9 digits.  (The
    final x will usually have fewer correct digits, depending on
    cond(A) and the size of damp.)
conlim : float, optional
    Another stopping tolerance.  lsqr terminates if an estimate of
    ``cond(A)`` exceeds `conlim`.  For compatible systems ``Ax =
    b``, `conlim` could be as large as 1.0e+12 (say).  For
    least-squares problems, conlim should be less than 1.0e+8.
    Maximum precision can be obtained by setting ``atol = btol =
    conlim = zero``, but the number of iterations may then be
    excessive.
iter_lim : int, optional
    Explicit limitation on number of iterations (for safety).
show : bool, optional
    Display an iteration log.
calc_var : bool, optional
    Whether to estimate diagonals of ``(A'A + damp^2*I)^{-1}``.

Returns
-------
x : ndarray of float
    The final solution.
istop : int
    Gives the reason for termination.
    1 means x is an approximate solution to Ax = b.
    2 means x approximately solves the least-squares problem.
itn : int
    Iteration number upon termination.
r1norm : float
    ``norm(r)``, where ``r = b - Ax``.
r2norm : float
    ``sqrt( norm(r)^2  +  damp^2 * norm(x)^2 )``.  Equal to `r1norm` if
    ``damp == 0``.
anorm : float
    Estimate of Frobenius norm of ``Abar = [[A]; [damp*I]]``.
acond : float
    Estimate of ``cond(Abar)``.
arnorm : float
    Estimate of ``norm(A'*r - damp^2*x)``.
xnorm : float
    ``norm(x)``
var : ndarray of float
    If ``calc_var`` is True, estimates all diagonals of
    ``(A'A)^{-1}`` (if ``damp == 0``) or more generally ``(A'A +
    damp^2*I)^{-1}``.  This is well defined if A has full column
    rank or ``damp &gt; 0``.  (Not sure what var means if ``rank(A)
    &lt; n`` and ``damp = 0.``)

Notes
-----
LSQR uses an iterative method to approximate the solution.  The
number of iterations required to reach a certain accuracy depends
strongly on the scaling of the problem.  Poor scaling of the rows
or columns of A should therefore be avoided where possible.

For example, in problem 1 the solution is unaltered by
row-scaling.  If a row of A is very small or large compared to
the other rows of A, the corresponding row of ( A  b ) should be
scaled up or down.

In problems 1 and 2, the solution x is easily recovered
following column-scaling.  Unless better information is known,
the nonzero columns of A should be scaled so that they all have
the same Euclidean norm (e.g., 1.0).

In problem 3, there is no freedom to re-scale if damp is
nonzero.  However, the value of damp should be assigned only
after attention has been paid to the scaling of A.

The parameter damp is intended to help regularize
ill-conditioned systems, by preventing the true solution from
being very large.  Another aid to regularization is provided by
the parameter acond, which may be used to terminate iterations
before the computed solution becomes very large.

If some initial estimate ``x0`` is known and if ``damp == 0``,
one could proceed as follows:

  1. Compute a residual vector ``r0 = b - A*x0``.
  2. Use LSQR to solve the system  ``A*dx = r0``.
  3. Add the correction dx to obtain a final solution ``x = x0 + dx``.

This requires that ``x0`` be available before and after the call
to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations
to solve A*x = b and k2 iterations to solve A*dx = r0.
If x0 is "good", norm(r0) will be smaller than norm(b).
If the same stopping tolerances atol and btol are used for each
system, k1 and k2 will be similar, but the final solution x0 + dx
should be more accurate.  The only way to reduce the total work
is to use a larger stopping tolerance for the second system.
If some value btol is suitable for A*x = b, the larger value
btol*norm(b)/norm(r0)  should be suitable for A*dx = r0.

Preconditioning is another way to reduce the number of iterations.
If it is possible to solve a related system ``M*x = b``
efficiently, where M approximates A in some helpful way (e.g. M -
A has low rank or its elements are small relative to those of A),
LSQR may converge more rapidly on the system ``A*M(inverse)*z =
b``, after which x can be recovered by solving M*x = z.

If A is symmetric, LSQR should not be used!

Alternatives are the symmetric conjugate-gradient method (cg)
and/or SYMMLQ.  SYMMLQ is an implementation of symmetric cg that
applies to any symmetric A and will converge more rapidly than
LSQR.  If A is positive definite, there are other implementations
of symmetric cg that require slightly less work per iteration than
SYMMLQ (but will take the same number of iterations).

References
----------
.. [1] C. C. Paige and M. A. Saunders (1982a).
       "LSQR: An algorithm for sparse linear equations and
       sparse least squares", ACM TOMS 8(1), 43-71.
.. [2] C. C. Paige and M. A. Saunders (1982b).
       "Algorithm 583.  LSQR: Sparse linear equations and least
       squares problems", ACM TOMS 8(2), 195-209.
.. [3] M. A. Saunders (1995).  "Solution of sparse rectangular
       systems using LSQR and CRAIG", BIT 35, 588-604.</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>Representation of an m-by-n matrix.  It is required that
the linear operator can produce ``Ax`` and ``A^T x``.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>Right-hand side vector ``b``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="damp" name="damp" port_type="basic:Float">
      <docstring>Damping coefficient.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="atol" name="atol" port_type="basic:Float">
      <docstring>Stopping tolerances. If both are 1.0e-9 (say), the final
residual norm should be accurate to about 9 digits.  (The
final x will usually have fewer correct digits, depending on
cond(A) and the size of damp.)</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="btol" name="btol" port_type="basic:Float">
      <docstring>Stopping tolerances. If both are 1.0e-9 (say), the final
residual norm should be accurate to about 9 digits.  (The
final x will usually have fewer correct digits, depending on
cond(A) and the size of damp.)</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="conlim" name="conlim" port_type="basic:Float">
      <docstring>Another stopping tolerance.  lsqr terminates if an estimate of
``cond(A)`` exceeds `conlim`.  For compatible systems ``Ax =
b``, `conlim` could be as large as 1.0e+12 (say).  For
least-squares problems, conlim should be less than 1.0e+8.
Maximum precision can be obtained by setting ``atol = btol =
conlim = zero``, but the number of iterations may then be
excessive.</docstring>
      <defaults>[100000000.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="iter_lim" name="iter_lim" port_type="basic:Integer">
      <docstring>Explicit limitation on number of iterations (for safety).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="show" name="show" port_type="basic:Boolean">
      <docstring>Display an iteration log.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="calc_var" name="calc_var" port_type="basic:Boolean">
      <docstring>Whether to estimate diagonals of ``(A'A + damp^2*I)^{-1}``.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" depth="1" name="x" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The final solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="istop" name="istop" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Gives the reason for termination.
1 means x is an approximate solution to Ax = b.
2 means x approximately solves the least-squares problem.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="itn" name="itn" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Iteration number upon termination.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r1norm" name="r1norm" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>``norm(r)``, where ``r = b - Ax``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r2norm" name="r2norm" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>``sqrt( norm(r)^2  +  damp^2 * norm(x)^2 )``.  Equal to `r1norm` if
``damp == 0``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="anorm" name="anorm" port_type="basic:Float" show_port="True" sort_key="5">
      <docstring>Estimate of Frobenius norm of ``Abar = [[A]; [damp*I]]``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="acond" name="acond" port_type="basic:Float" show_port="True" sort_key="6">
      <docstring>Estimate of ``cond(Abar)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="arnorm" name="arnorm" port_type="basic:Float" show_port="True" sort_key="7">
      <docstring>Estimate of ``norm(A'*r - damp^2*x)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xnorm" name="xnorm" port_type="basic:Float" show_port="True" sort_key="8">
      <docstring>``norm(x)``</docstring>
    </outputPortSpec>
    <outputPortSpec arg="var" depth="1" name="var" port_type="basic:Float" show_port="True" sort_key="9">
      <docstring>If ``calc_var`` is True, estimates all diagonals of
``(A'A)^{-1}`` (if ``damp == 0``) or more generally ``(A'A +
damp^2*I)^{-1}``.  This is well defined if A has full column
rank or ``damp &gt; 0``.  (Not sure what var means if ``rank(A)
&lt; n`` and ``damp = 0.``)</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.minres" module_name="minres" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use MINimum RESidual iteration to solve Ax=b

MINRES minimizes norm(A*x - b) for a real symmetric matrix A.  Unlike
the Conjugate Gradient method, A can be indefinite or singular.

If shift != 0 then the method solves (A - shift*I)x = b


Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real symmetric N-by-N matrix of the linear system
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        &gt;0 : convergence to tolerance not achieved, number of iterations
        &lt;0 : illegal input or breakdown

Other Parameters
----------------
x0  : {array, matrix}
    Starting guess for the solution.
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
xtype : {'f','d','F','D'}
    This parameter is deprecated -- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.



Notes
-----
THIS FUNCTION IS EXPERIMENTAL AND SUBJECT TO CHANGE!

References
----------
Solution of sparse indefinite systems of linear equations,
    C. C. Paige and M. A. Saunders (1975),
    SIAM J. Numer. Anal. 12(4), pp. 617-629.
    http://www.stanford.edu/group/SOL/software/minres.html

This file is a translation of the following MATLAB implementation:
    http://www.stanford.edu/group/SOL/software/minres/matlab/</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real symmetric N-by-N matrix of the linear system</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer" show_port="True">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M" name="M" show_port="True">
      <docstring>Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is deprecated -- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <inputPortSpec arg="show" name="show" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="shift" name="shift" port_type="basic:Float" show_port="True" />
    <inputPortSpec arg="check" name="check" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
    0  : successful exit
    &gt;0 : convergence to tolerance not achieved, number of iterations
    &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.norm" module_name="norm" namespace="'sparse|linalg'">
    <docstring>Norm of a sparse matrix

This function is able to return one of seven different matrix norms,
depending on the value of the ``ord`` parameter.

Parameters
----------
x : a sparse matrix
    Input sparse matrix.
ord : {non-zero int, inf, -inf, 'fro'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object.

Returns
-------
n : float or matrix

Notes
-----
Some of the ord are not implemented because some associated functions like, 
_multi_svd_norm, are not yet available for sparse matrix. 

This docstring is modified based on numpy.linalg.norm. 
https://github.com/numpy/numpy/blob/master/numpy/linalg/linalg.py 

The following norms can be calculated:

=====  ============================  
ord    norm for sparse matrices             
=====  ============================  
None   Frobenius norm                
'fro'  Frobenius norm                
inf    max(sum(abs(x), axis=1))      
-inf   min(sum(abs(x), axis=1))      
0      abs(x).sum(axis=axis)                           
1      max(sum(abs(x), axis=0))      
-1     min(sum(abs(x), axis=0))      
2      Not implemented  
-2     Not implemented      
other  Not implemented                               
=====  ============================  

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
    Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
&gt;&gt;&gt; from scipy.sparse import *
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.sparse.linalg import norm
&gt;&gt;&gt; a = np.arange(9) - 4
&gt;&gt;&gt; a
array([-4, -3, -2, -1, 0, 1, 2, 3, 4])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[-4, -3, -2],
       [-1, 0, 1],
       [ 2, 3, 4]])

&gt;&gt;&gt; b = csr_matrix(b)
&gt;&gt;&gt; norm(b)
7.745966692414834
&gt;&gt;&gt; norm(b, 'fro')
7.745966692414834
&gt;&gt;&gt; norm(b, np.inf)
9
&gt;&gt;&gt; norm(b, -np.inf)
2
&gt;&gt;&gt; norm(b, 1)
7
&gt;&gt;&gt; norm(b, -1)
6</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True">
      <docstring>Input sparse matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ord" name="ord">
      <docstring>Order of the norm (see table under ``Notes``). inf means numpy's
`inf` object.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['inf', '-inf', 'fro']]</values>
    </inputPortSpec>
    <outputPortSpec arg="n" name="n" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.onenormest" module_name="onenormest" namespace="'sparse|linalg'" output_type="list">
    <docstring>Compute a lower bound of the 1-norm of a sparse matrix.

Parameters
----------
A : ndarray or other linear operator
    A linear operator that can be transposed and that can
    produce matrix products.
t : int, optional
    A positive parameter controlling the tradeoff between
    accuracy versus time and memory usage.
    Larger values take longer and use more memory
    but give more accurate output.
itmax : int, optional
    Use at most this many iterations.
compute_v : bool, optional
    Request a norm-maximizing linear operator input vector if True.
compute_w : bool, optional
    Request a norm-maximizing linear operator output vector if True.

Returns
-------
est : float
    An underestimate of the 1-norm of the sparse matrix.
v : ndarray, optional
    The vector such that ||Av||_1 == est*||v||_1.
    It can be thought of as an input to the linear operator
    that gives an output with particularly large norm.
w : ndarray, optional
    The vector Av which has relatively large 1-norm.
    It can be thought of as an output of the linear operator
    that is relatively large in norm compared to the input.

Notes
-----
This is algorithm 2.4 of [1].

In [2] it is described as follows.
"This algorithm typically requires the evaluation of
about 4t matrix-vector products and almost invariably
produces a norm estimate (which is, in fact, a lower
bound on the norm) correct to within a factor 3."

.. versionadded:: 0.13.0

References
----------
.. [1] Nicholas J. Higham and Francoise Tisseur (2000),
       "A Block Algorithm for Matrix 1-Norm Estimation,
       with an Application to 1-Norm Pseudospectra."
       SIAM J. Matrix Anal. Appl. Vol. 21, No. 4, pp. 1185-1201.

.. [2] Awad H. Al-Mohy and Nicholas J. Higham (2009),
       "A new scaling and squaring algorithm for the matrix exponential."
       SIAM J. Matrix Anal. Appl. Vol. 31, No. 3, pp. 970-989.</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>A linear operator that can be transposed and that can
produce matrix products.</docstring>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="t" name="t" port_type="basic:Integer">
      <docstring>A positive parameter controlling the tradeoff between
accuracy versus time and memory usage.
Larger values take longer and use more memory
but give more accurate output.</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="itmax" name="itmax" port_type="basic:Integer">
      <docstring>Use at most this many iterations.</docstring>
      <defaults>[5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="compute_v" name="compute_v" port_type="basic:Boolean">
      <docstring>Request a norm-maximizing linear operator input vector if True.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="compute_w" name="compute_w" port_type="basic:Boolean">
      <docstring>Request a norm-maximizing linear operator output vector if True.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="est" name="est" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>An underestimate of the 1-norm of the sparse matrix.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="v" name="v" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The vector such that ||Av||_1 == est*||v||_1.
It can be thought of as an input to the linear operator
that gives an output with particularly large norm.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The vector Av which has relatively large 1-norm.
It can be thought of as an output of the linear operator
that is relatively large in norm compared to the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.product" module_name="product" namespace="'sparse|linalg'">
    <docstring>Return the product of array elements over a given axis.

See Also
--------
prod : equivalent function; see for details.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="out" name="out" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.qmr" module_name="qmr" namespace="'sparse|linalg'" output_type="list">
    <docstring>Use Quasi-Minimal Residual iteration to solve A x = b

Parameters
----------
A : {sparse matrix, dense matrix, LinearOperator}
    The real-valued N-by-N matrix of the linear system.
    It is required that the linear operator can produce
    ``Ax`` and ``A^T x``.
b : {array, matrix}
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : {array, matrix}
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        &gt;0 : convergence to tolerance not achieved, number of iterations
        &lt;0 : illegal input or breakdown

Other Parameters
----------------
x0  : {array, matrix}
    Starting guess for the solution.
tol : float
    Tolerance to achieve. The algorithm terminates when either the relative
    or the absolute residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M1 : {sparse matrix, dense matrix, LinearOperator}
    Left preconditioner for A.
M2 : {sparse matrix, dense matrix, LinearOperator}
    Right preconditioner for A. Used together with the left
    preconditioner M1.  The matrix M1*A*M2 should have better
    conditioned than A alone.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
xtype : {'f','d','F','D'}
    This parameter is DEPRECATED -- avoid using it.

    The type of the result.  If None, then it will be determined from
    A.dtype.char and b.  If A does not have a typecode method then it
    will compute A.matvec(x0) to get a typecode.   To save the extra
    computation when A does not have a typecode attribute use xtype=0
    for the same type as b or use xtype='f','d','F',or 'D'.
    This parameter has been superseded by LinearOperator.

See Also
--------
LinearOperator</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>The real-valued N-by-N matrix of the linear system.
It is required that the linear operator can produce
``Ax`` and ``A^T x``.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>Right hand side of the linear system. Has shape (N,) or (N,1).</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x0" name="x0Scalar" show_port="True">
      <docstring>Starting guess for the solution.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['matrix']]</values>
      <alternateSpec arg="x0" name="x0Sequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance to achieve. The algorithm terminates when either the relative
or the absolute residual is below `tol`.</docstring>
      <defaults>[1e-05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer" show_port="True">
      <docstring>Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="M1" name="M1" show_port="True">
      <docstring>Left preconditioner for A.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="M2" name="M2" show_port="True">
      <docstring>Right preconditioner for A. Used together with the left
preconditioner M1.  The matrix M1*A*M2 should have better
conditioned than A alone.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="callback" name="callback" port_type="basic:Variant" show_port="True">
      <docstring>User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xtype" name="xtype" show_port="True">
      <docstring>This parameter is DEPRECATED -- avoid using it.

The type of the result.  If None, then it will be determined from
A.dtype.char and b.  If A does not have a typecode method then it
will compute A.matvec(x0) to get a typecode.   To save the extra
computation when A does not have a typecode attribute use xtype=0
for the same type as b or use xtype='f','d','F',or 'D'.
This parameter has been superseded by LinearOperator.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['f', 'd', 'F', 'D']]</values>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>The converged solution.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" name="info" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>Provides convergence information:
    0  : successful exit
    &gt;0 : convergence to tolerance not achieved, number of iterations
    &lt;0 : illegal input or breakdown</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.ravel" module_name="ravel" namespace="'sparse|linalg'">
    <docstring>Return a contiguous flattened array.

A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.

As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)

Parameters
----------
a : array_like
    Input array.  The elements in `a` are read in the order specified by
    `order`, and packed as a 1-D array.
order : {'C','F', 'A', 'K'}, optional

    The elements of `a` are read using this index order. 'C' means
    to index the elements in row-major, C-style order,
    with the last axis index changing fastest, back to the first
    axis index changing slowest.  'F' means to index the elements
    in column-major, Fortran-style order, with the
    first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of
    the memory layout of the underlying array, and only refer to
    the order of axis indexing.  'A' means to read the elements in
    Fortran-like index order if `a` is Fortran *contiguous* in
    memory, C-like order otherwise.  'K' means to read the
    elements in the order they occur in memory, except for
    reversing the data when strides are negative.  By default, 'C'
    index order is used.

Returns
-------
y : array_like
    If `a` is a matrix, y is a 1-D ndarray, otherwise y is an array of
    the same subtype as `a`. The shape of the returned array is
    ``(a.size,)``. Matrices are special cased for backward
    compatibility.

See Also
--------
ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array
                  in row-major order.
ndarray.reshape : Change the shape of an array without changing its data.

Notes
-----
In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.

When a view is desired in as many cases as possible, ``arr.reshape(-1)``
may be preferable.

Examples
--------
It is equivalent to ``reshape(-1, order=order)``.

&gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; print np.ravel(x)
[1 2 3 4 5 6]

&gt;&gt;&gt; print x.reshape(-1)
[1 2 3 4 5 6]

&gt;&gt;&gt; print np.ravel(x, order='F')
[1 4 2 5 3 6]

When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:

&gt;&gt;&gt; print np.ravel(x.T)
[1 4 2 5 3 6]
&gt;&gt;&gt; print np.ravel(x.T, order='A')
[1 2 3 4 5 6]

When ``order`` is 'K', it will preserve orderings that are neither 'C'
nor 'F', but won't reverse axes:

&gt;&gt;&gt; a = np.arange(3)[::-1]; a
array([2, 1, 0])
&gt;&gt;&gt; a.ravel(order='C')
array([2, 1, 0])
&gt;&gt;&gt; a.ravel(order='K')
array([2, 1, 0])

&gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
array([[[ 0,  2,  4],
        [ 1,  3,  5]],
       [[ 6,  8, 10],
        [ 7,  9, 11]]])
&gt;&gt;&gt; a.ravel(order='C')
array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
&gt;&gt;&gt; a.ravel(order='K')
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.  The elements in `a` are read in the order specified by
`order`, and packed as a 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>
The elements of `a` are read using this index order. 'C' means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  'F' means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  'A' means to read the elements in
Fortran-like index order if `a` is Fortran *contiguous* in
memory, C-like order otherwise.  'K' means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, 'C'
index order is used.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F', 'A', 'K']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="y" name="y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If `a` is a matrix, y is a 1-D ndarray, otherwise y is an array of
the same subtype as `a`. The shape of the returned array is
``(a.size,)``. Matrices are special cased for backward
compatibility.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.rollaxis" module_name="rollaxis" namespace="'sparse|linalg'">
    <docstring>Roll the specified axis backwards, until it lies in a given position.

Parameters
----------
a : ndarray
    Input array.
axis : int
    The axis to roll backwards.  The positions of the other axes do not
    change relative to one another.
start : int, optional
    The axis is rolled until it lies before this position.  The default,
    0, results in a "complete" roll.

Returns
-------
res : ndarray
    For Numpy &gt;= 1.10 a view of `a` is always returned. For earlier
    Numpy versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

See Also
--------
roll : Roll the elements of an array by a number of positions along a
    given axis.

Examples
--------
&gt;&gt;&gt; a = np.ones((3,4,5,6))
&gt;&gt;&gt; np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
&gt;&gt;&gt; np.rollaxis(a, 2).shape
(5, 3, 4, 6)
&gt;&gt;&gt; np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer" show_port="True">
      <docstring>The axis to roll backwards.  The positions of the other axes do not
change relative to one another.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="start" name="start" port_type="basic:Integer">
      <docstring>The axis is rolled until it lies before this position.  The default,
0, results in a "complete" roll.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>For Numpy &gt;= 1.10 a view of `a` is always returned. For earlier
Numpy versions a view of `a` is returned only if the order of the
axes is changed, otherwise the input array is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.size" module_name="size" namespace="'sparse|linalg'">
    <docstring>Return the number of elements along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which the elements are counted.  By default, give
    the total number of elements.

Returns
-------
element_count : int
    Number of elements along the specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; np.size(a)
6
&gt;&gt;&gt; np.size(a,1)
3
&gt;&gt;&gt; np.size(a,0)
2</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the elements are counted.  By default, give
the total number of elements.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="element_count" name="element_count" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Number of elements along the specified axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.spilu" module_name="spilu" namespace="'sparse|linalg'">
    <docstring>Compute an incomplete LU decomposition for a sparse, square matrix.

The resulting object is an approximation to the inverse of `A`.

Parameters
----------
A : (N, N) array_like
    Sparse matrix to factorize
drop_tol : float, optional
    Drop tolerance (0 &lt;= tol &lt;= 1) for an incomplete LU decomposition.
    (default: 1e-4)
fill_factor : float, optional
    Specifies the fill ratio upper bound (&gt;= 1.0) for ILU. (default: 10)
drop_rule : str, optional
    Comma-separated string of drop rules to use.
    Available rules: ``basic``, ``prows``, ``column``, ``area``,
    ``secondary``, ``dynamic``, ``interp``. (Default: ``basic,area``)

    See SuperLU documentation for details.

Remaining other options
    Same as for `splu`

Returns
-------
invA_approx : scipy.sparse.linalg.SuperLU
    Object, which has a ``solve`` method.

See also
--------
splu : complete LU decomposition

Notes
-----
To improve the better approximation to the inverse, you may need to
increase `fill_factor` AND decrease `drop_tol`.

This function uses the SuperLU library.</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:List" show_port="True">
      <docstring>Sparse matrix to factorize</docstring>
    </inputPortSpec>
    <inputPortSpec arg="drop_tol" name="drop_tol" port_type="basic:Float">
      <docstring>Drop tolerance (0 &lt;= tol &lt;= 1) for an incomplete LU decomposition.
(default: 1e-4)</docstring>
      <defaults>[0.0001]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_factor" name="fill_factor" port_type="basic:Float">
      <docstring>Specifies the fill ratio upper bound (&gt;= 1.0) for ILU. (default: 10)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="drop_rule" name="drop_rule">
      <docstring>Comma-separated string of drop rules to use.
Available rules: ``basic``, ``prows``, ``column``, ``area``,
``secondary``, ``dynamic``, ``interp``. (Default: ``basic,area``)

See SuperLU documentation for details.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="relax" name="relax" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="diag_pivot_thresh" name="diag_pivot_thresh" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="permc_spec" name="permc_spec" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="panel_size" name="panel_size" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="options" name="options" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="invA_approx" name="invA_approx" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Object, which has a ``solve`` method.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.splu" module_name="splu" namespace="'sparse|linalg'">
    <docstring>Compute the LU decomposition of a sparse, square matrix.

Parameters
----------
A : sparse matrix
    Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
    How to permute the columns of the matrix for sparsity preservation.
    (default: 'COLAMD')

    - ``NATURAL``: natural ordering.
    - ``MMD_ATA``: minimum degree ordering on the structure of A^T A.
    - ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.
    - ``COLAMD``: approximate minimum degree column ordering

diag_pivot_thresh : float, optional
    Threshold used for a diagonal entry to be an acceptable pivot.
    See SuperLU user's guide for details [1]_
drop_tol : float, optional
    (deprecated) No effect.
relax : int, optional
    Expert option for customizing the degree of relaxing supernodes.
    See SuperLU user's guide for details [1]_
panel_size : int, optional
    Expert option for customizing the panel size.
    See SuperLU user's guide for details [1]_
options : dict, optional
    Dictionary containing additional expert options to SuperLU.
    See SuperLU user guide [1]_ (section 2.4 on the 'Options' argument)
    for more details. For example, you can specify
    ``options=dict(Equil=False, IterRefine='SINGLE'))``
    to turn equilibration off and perform a single iterative refinement.

Returns
-------
invA : scipy.sparse.linalg.SuperLU
    Object, which has a ``solve`` method.

See also
--------
spilu : incomplete LU decomposition

Notes
-----
This function uses the SuperLU library.

References
----------
.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</docstring>
    <inputPortSpec arg="A" name="A" port_type="basic:Variant" show_port="True">
      <docstring>Sparse matrix to factorize. Should be in CSR or CSC format.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="permc_spec" name="permc_spec">
      <docstring>How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')

- ``NATURAL``: natural ordering.
- ``MMD_ATA``: minimum degree ordering on the structure of A^T A.
- ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.
- ``COLAMD``: approximate minimum degree column ordering
</docstring>
      <defaults>['COLAMD']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="diag_pivot_thresh" name="diag_pivot_thresh" port_type="basic:Float">
      <docstring>Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]_</docstring>
    </inputPortSpec>
    <inputPortSpec arg="drop_tol" name="drop_tol" port_type="basic:Float">
      <docstring>(deprecated) No effect.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="relax" name="relax" port_type="basic:Integer">
      <docstring>Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]_</docstring>
    </inputPortSpec>
    <inputPortSpec arg="panel_size" name="panel_size" port_type="basic:Integer">
      <docstring>Expert option for customizing the panel size.
See SuperLU user's guide for details [1]_</docstring>
    </inputPortSpec>
    <inputPortSpec arg="options" name="options">
      <docstring>Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]_ (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
``options=dict(Equil=False, IterRefine='SINGLE'))``
to turn equilibration off and perform a single iterative refinement.</docstring>
      <defaults>[{}]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="invA" name="invA" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Object, which has a ``solve`` method.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.spsolve" module_name="spsolve" namespace="'sparse|linalg'">
    <docstring>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.

Parameters
----------
A : ndarray or sparse matrix
    The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
    The matrix or vector representing the right hand side of the equation.
    If a vector, b.size must be (n,) or (n, 1)
permc_spec : str, optional
    How to permute the columns of the matrix for sparsity preservation.
    (default: 'COLAMD')

    - ``NATURAL``: natural ordering.
    - ``MMD_ATA``: minimum degree ordering on the structure of A^T A.
    - ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.
    - ``COLAMD``: approximate minimum degree column ordering
use_umfpack : bool, optional
    if True (default) then use umfpack for the solution.  This is
    only referenced if b is a vector and ``scikit-umfpack`` is installed.

Returns
-------
x : ndarray or sparse matrix
    the solution of the sparse linear equation.
    If b is a vector, then x is a vector of size A.shape[1]
    If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])

Notes
-----
For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.</docstring>
    <inputPortSpec arg="A" name="AScalar" show_port="True">
      <docstring>The square matrix A will be converted into CSC or CSR form</docstring>
      <alternateSpec arg="A" name="ASequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" show_port="True">
      <docstring>The matrix or vector representing the right hand side of the equation.
If a vector, b.size must be (n,) or (n, 1)</docstring>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="permc_spec" name="permc_spec">
      <docstring>How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')

- ``NATURAL``: natural ordering.
- ``MMD_ATA``: minimum degree ordering on the structure of A^T A.
- ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.
- ``COLAMD``: approximate minimum degree column ordering</docstring>
      <defaults>['COLAMD']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="use_umfpack" name="use_umfpack" port_type="basic:Boolean">
      <docstring>if True (default) then use umfpack for the solution.  This is
only referenced if b is a vector and ``scikit-umfpack`` is installed.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" show_port="True" sort_key="0">
      <docstring>the solution of the sparse linear equation.
If b is a vector, then x is a vector of size A.shape[1]
If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.sum" module_name="sum" namespace="'sparse|linalg'">
    <docstring>Sum of array elements over a given axis.

Parameters
----------
a : array_like
    Elements to sum.
axis : None or int or tuple of ints, optional
    Axis or axes along which a sum is performed.
    The default (`axis` = `None`) is perform a sum over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a sum is performed on multiple
    axes, instead of a single axis or all the axes as before.
dtype : dtype, optional
    The type of the returned array and of the accumulator in which
    the elements are summed.  By default, the dtype of `a` is used.
    An exception is when `a` has an integer type with less precision
    than the default platform integer.  In that case, the default
    platform integer is used instead.
out : ndarray, optional
    Array into which the output is placed.  By default, a new array is
    created.  If `out` is given, it must be of the appropriate shape
    (the shape of `a` with `axis` removed, i.e.,
    ``numpy.delete(a.shape, axis)``).  Its type is preserved. See
    `doc.ufuncs` (Section "Output arguments") for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

Returns
-------
sum_along_axis : ndarray
    An array with the same shape as `a`, with the specified
    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
    is returned.  If an output array is specified, a reference to
    `out` is returned.

See Also
--------
ndarray.sum : Equivalent method.

cumsum : Cumulative sum of array elements.

trapz : Integration of array values using the composite trapezoidal rule.

mean, average

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

The sum of an empty array is the neutral element 0:

&gt;&gt;&gt; np.sum([])
0.0

Examples
--------
&gt;&gt;&gt; np.sum([0.5, 1.5])
2.0
&gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
1
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])
6
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)
array([1, 5])

If the accumulator is too small, overflow occurs:

&gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)
-128</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Elements to sum.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axisScalar" port_type="basic:Integer">
      <docstring>Axis or axes along which a sum is performed.
The default (`axis` = `None`) is perform a sum over all
the dimensions of the input array. `axis` may be negative, in
which case it counts from the last to the first axis.

.. versionadded:: 1.7.0

If this is a tuple of ints, a sum is performed on multiple
axes, instead of a single axis or all the axes as before.</docstring>
      <alternateSpec arg="axis" depth="1" name="axisSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The type of the returned array and of the accumulator in which
the elements are summed.  By default, the dtype of `a` is used.
An exception is when `a` has an integer type with less precision
than the default platform integer.  In that case, the default
platform integer is used instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="out" name="out" port_type="basic:List">
      <docstring>Array into which the output is placed.  By default, a new array is
created.  If `out` is given, it must be of the appropriate shape
(the shape of `a` with `axis` removed, i.e.,
``numpy.delete(a.shape, axis)``).  Its type is preserved. See
`doc.ufuncs` (Section "Output arguments") for more details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="keepdims" name="keepdims" port_type="basic:Boolean">
      <docstring>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original `arr`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="sum_along_axis" name="sum_along_axis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array with the same shape as `a`, with the specified
axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
is returned.  If an output array is specified, a reference to
`out` is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.svds" module_name="svds" namespace="'sparse|linalg'" output_type="list">
    <docstring>Compute the largest k singular values/vectors for a sparse matrix.

Parameters
----------
A : {sparse matrix, LinearOperator}
    Array to compute the SVD on, of shape (M, N)
k : int, optional
    Number of singular values and vectors to compute.
ncv : int, optional
    The number of Lanczos vectors generated
    ncv must be greater than k+1 and smaller than n;
    it is recommended that ncv &gt; 2*k
    Default: ``min(n, 2*k + 1)``
tol : float, optional
    Tolerance for singular values. Zero (default) means machine precision.
which : str, ['LM' | 'SM'], optional
    Which `k` singular values to find:

        - 'LM' : largest singular values
        - 'SM' : smallest singular values

    .. versionadded:: 0.12.0
v0 : ndarray, optional
    Starting vector for iteration, of length min(A.shape). Should be an
    (approximate) right singular vector if N &gt; M and a right singular vector
    otherwise.
    Default: random

    .. versionadded:: 0.12.0
maxiter : int, optional
    Maximum number of iterations.

    .. versionadded:: 0.12.0
return_singular_vectors : bool or str, optional
    - True: return singular vectors (True) in addition to singular values.

    .. versionadded:: 0.12.0

    - "u": only return the u matrix, without computing vh (if N &gt; M).
    - "vh": only return the vh matrix, without computing u (if N &lt;= M).

    .. versionadded:: 0.16.0

Returns
-------
u : ndarray, shape=(M, k)
    Unitary matrix having left singular vectors as columns.
    If `return_singular_vectors` is "vh", this variable is not computed,
    and None is returned instead.
s : ndarray, shape=(k,)
    The singular values.
vt : ndarray, shape=(k, N)
    Unitary matrix having right singular vectors as rows.
    If `return_singular_vectors` is "u", this variable is not computed,
    and None is returned instead.


Notes
-----
This is a naive implementation using ARPACK as an eigensolver
on A.H * A or A * A.H, depending on which one is more efficient.</docstring>
    <inputPortSpec arg="A" name="A" show_port="True">
      <docstring>Array to compute the SVD on, of shape (M, N)</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LinearOperator']]</values>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Number of singular values and vectors to compute.</docstring>
      <defaults>[6]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ncv" name="ncv" port_type="basic:Integer">
      <docstring>The number of Lanczos vectors generated
ncv must be greater than k+1 and smaller than n;
it is recommended that ncv &gt; 2*k
Default: ``min(n, 2*k + 1)``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Tolerance for singular values. Zero (default) means machine precision.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="which" name="which">
      <docstring>Which `k` singular values to find:

    - 'LM' : largest singular values
    - 'SM' : smallest singular values

.. versionadded:: 0.12.0</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['LM', 'SM']]</values>
      <defaults>['LM']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="v0" name="v0" port_type="basic:List">
      <docstring>Starting vector for iteration, of length min(A.shape). Should be an
(approximate) right singular vector if N &gt; M and a right singular vector
otherwise.
Default: random

.. versionadded:: 0.12.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations.

.. versionadded:: 0.12.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="return_singular_vectors" name="return_singular_vectorsScalar">
      <docstring>- True: return singular vectors (True) in addition to singular values.

.. versionadded:: 0.12.0

- "u": only return the u matrix, without computing vh (if N &gt; M).
- "vh": only return the vh matrix, without computing u (if N &lt;= M).

.. versionadded:: 0.16.0</docstring>
      <defaults>[True]</defaults>
      <alternateSpec arg="return_singular_vectors" name="return_singular_vectorsBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="u" name="u" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Unitary matrix having left singular vectors as columns.
If `return_singular_vectors` is "vh", this variable is not computed,
and None is returned instead.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The singular values.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vt" name="vt" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Unitary matrix having right singular vectors as rows.
If `return_singular_vectors` is "u", this variable is not computed,
and None is returned instead.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.transpose" module_name="transpose" namespace="'sparse|linalg'">
    <docstring>Permute the dimensions of an array.

Parameters
----------
a : array_like
    Input array.
axes : list of ints, optional
    By default, reverse the dimensions, otherwise permute the axes
    according to the values given.

Returns
-------
p : ndarray
    `a` with its axes permuted.  A view is returned whenever
    possible.

See Also
--------
rollaxis
argsort

Notes
-----
Use `transpose(a, argsort(axes))` to invert the transposition of tensors
when using the `axes` keyword argument.

Transposing a 1-D array returns an unchanged view of the original array.

Examples
--------
&gt;&gt;&gt; x = np.arange(4).reshape((2,2))
&gt;&gt;&gt; x
array([[0, 1],
       [2, 3]])

&gt;&gt;&gt; np.transpose(x)
array([[0, 2],
       [1, 3]])

&gt;&gt;&gt; x = np.ones((1, 2, 3))
&gt;&gt;&gt; np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axes" depth="1" name="axes" port_type="basic:Integer">
      <docstring>By default, reverse the dimensions, otherwise permute the axes
according to the values given.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`a` with its axes permuted.  A view is returned whenever
possible.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.use_solver" module_name="use_solver" namespace="'sparse|linalg'">
    <docstring>Valid keyword arguments with defaults (other ignored)::

  useUmfpack = True
  assumeSortedIndices = False

The default sparse solver is umfpack when available. This can be changed by
passing useUmfpack = False, which then causes the always present SuperLU
based solver to be used.

Umfpack requires a CSR/CSC matrix to have sorted column/row indices. If
sure that the matrix fulfills this, pass ``assumeSortedIndices=True``
to gain some speed.</docstring>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.linalg.zeros" module_name="zeros" namespace="'sparse|linalg'">
    <docstring>zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
empty : Return a new uninitialized array.

Examples
--------
&gt;&gt;&gt; np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

&gt;&gt;&gt; np.zeros((5,), dtype=np.int)
array([0, 0, 0, 0, 0])

&gt;&gt;&gt; np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

&gt;&gt;&gt; s = (2,2)
&gt;&gt;&gt; np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

&gt;&gt;&gt; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</docstring>
    <inputPortSpec arg="shape" name="shapeScalar" port_type="basic:Integer" show_port="True">
      <docstring>Shape of the new array, e.g., ``(2, 3)`` or ``2``.</docstring>
      <alternateSpec arg="shape" depth="1" name="shapeSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>The desired data-type for the array, e.g., `numpy.int8`.  Default is
`numpy.float64`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="order" name="order">
      <docstring>Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['C', 'F']]</values>
      <defaults>['C']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of zeros with the given shape, dtype, and order.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.cs_graph_components" module_name="cs_graph_components" namespace="'sparse|csgraph'">
    <docstring>`cs_graph_components` is deprecated!
In the future, use csgraph.connected_components. Note that this new function has a slightly different interface: see the docstring for more information.


    Determine connected components of a graph stored as a compressed
    sparse row or column matrix.

    For speed reasons, the symmetry of the matrix x is not checked. A
    nonzero at index `(i, j)` means that node `i` is connected to node
    `j` by an edge. The number of rows/columns of the matrix thus
    corresponds to the number of nodes in the graph.

    Parameters
    -----------
    x : array_like or sparse matrix, 2 dimensions
        The adjacency matrix of the graph. Only the upper triangular part
        is used.

    Returns
    --------
    n_comp : int
        The number of connected components.
    label : ndarray (ints, 1 dimension):
        The label array of each connected component (-2 is used to
        indicate empty rows in the matrix: 0 everywhere, including
        diagonal). This array has the length of the number of nodes,
        i.e. one label for each node of the graph. Nodes having the same
        label belong to the same connected component.

    Notes
    ------
    The matrix is assumed to be symmetric and the upper triangular part
    of the matrix is used. The matrix is converted to a CSR matrix unless
    it is already a CSR.

    Examples
    --------
    &gt;&gt;&gt; from scipy.sparse.csgraph import connected_components
    &gt;&gt;&gt; D = np.eye(4)
    &gt;&gt;&gt; D[0,1] = D[1,0] = 1
    &gt;&gt;&gt; cs_graph_components(D)
    (3, array([0, 0, 1, 2]))
    &gt;&gt;&gt; from scipy.sparse import dok_matrix
    &gt;&gt;&gt; cs_graph_components(dok_matrix(D))
    (3, array([0, 0, 1, 2]))</docstring>
    <inputPortSpec arg="x" name="xScalar" show_port="True">
      <docstring>The adjacency matrix of the graph. Only the upper triangular part
is used.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="n_comp" name="n_comp" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>    The number of connected components.
label : ndarray (ints, 1 dimension):
    The label array of each connected component (-2 is used to
    indicate empty rows in the matrix: 0 everywhere, including
    diagonal). This array has the length of the number of nodes,
    i.e. one label for each node of the graph. Nodes having the same
    label belong to the same connected component.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.connected_components" module_name="connected_components" namespace="'sparse|csgraph'" output_type="list">
    <docstring>connected_components(csgraph, directed=True, connection='weak',
                     return_labels=True)

Analyze the connected components of a sparse graph

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix
    The N x N matrix representing the compressed sparse graph.  The input
    csgraph will be converted to csr format for the calculation.
directed : bool, optional
    If True (default), then operate on a directed graph: only
    move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i].
connection : str, optional
    ['weak'|'strong'].  For directed graphs, the type of connection to
    use.  Nodes i and j are strongly connected if a path exists both
    from i to j and from j to i.  Nodes i and j are weakly connected if
    only one of these paths exists.  If directed == False, this keyword
    is not referenced.
return_labels : str, optional
    If True (default), then return the labels for each of the connected
    components.

Returns
-------
n_components: int
    The number of connected components.
labels: ndarray
    The length-N array of labels of the connected components.

References
----------
.. [1] D. J. Pearce, "An Improved Algorithm for Finding the Strongly
       Connected Components of a Directed Graph", Technical Report, 2005</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N matrix representing the compressed sparse graph.  The input
csgraph will be converted to csr format for the calculation.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="connection" name="connection">
      <docstring>['weak'|'strong'].  For directed graphs, the type of connection to
use.  Nodes i and j are strongly connected if a path exists both
from i to j and from j to i.  Nodes i and j are weakly connected if
only one of these paths exists.  If directed == False, this keyword
is not referenced.</docstring>
      <defaults>['weak']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_labels" name="return_labelsBool" port_type="basic:Boolean">
      <docstring>If True (default), then return the labels for each of the connected
components.</docstring>
      <defaults>[True]</defaults>
      <alternateSpec arg="return_labels" name="return_labelsScalar" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of connected components.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The length-N array of labels of the connected components.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.laplacian" module_name="laplacian" namespace="'sparse|csgraph'" output_type="list">
    <docstring>Return the Laplacian matrix of a directed graph.

Parameters
----------
csgraph : array_like or sparse matrix, 2 dimensions
    compressed-sparse graph, with shape (N, N).
normed : bool, optional
    If True, then compute normalized Laplacian.
return_diag : bool, optional
    If True, then also return an array related to vertex degrees.
use_out_degree : bool, optional
    If True, then use out-degree instead of in-degree.
    This distinction matters only if the graph is asymmetric.
    Default: False.

Returns
-------
lap : ndarray
    The N x N laplacian matrix of graph.
diag : ndarray, optional
    The length-N diagonal of the Laplacian matrix.
    For the normalized Laplacian, this is the array of square roots
    of vertex degrees or 1 if the degree is zero.

Notes
-----
The Laplacian matrix of a graph is sometimes referred to as the
"Kirchoff matrix" or the "admittance matrix", and is useful in many
parts of spectral graph theory.  In particular, the eigen-decomposition
of the laplacian matrix can give insight into many properties of the graph.

Examples
--------
&gt;&gt;&gt; from scipy.sparse import csgraph
&gt;&gt;&gt; G = np.arange(5) * np.arange(5)[:, np.newaxis]
&gt;&gt;&gt; G
array([[ 0,  0,  0,  0,  0],
       [ 0,  1,  2,  3,  4],
       [ 0,  2,  4,  6,  8],
       [ 0,  3,  6,  9, 12],
       [ 0,  4,  8, 12, 16]])
&gt;&gt;&gt; csgraph.laplacian(G, normed=False)
array([[  0,   0,   0,   0,   0],
       [  0,   9,  -2,  -3,  -4],
       [  0,  -2,  16,  -6,  -8],
       [  0,  -3,  -6,  21, -12],
       [  0,  -4,  -8, -12,  24]])</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>compressed-sparse graph, with shape (N, N).</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="normed" name="normed" port_type="basic:Boolean">
      <docstring>If True, then compute normalized Laplacian.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_diag" name="return_diag" port_type="basic:Boolean">
      <docstring>If True, then also return an array related to vertex degrees.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="use_out_degree" name="use_out_degree" port_type="basic:Boolean">
      <docstring>If True, then use out-degree instead of in-degree.
This distinction matters only if the graph is asymmetric.
Default: False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="lap" name="lap" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The N x N laplacian matrix of graph.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="diag" name="diag" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The length-N diagonal of the Laplacian matrix.
For the normalized Laplacian, this is the array of square roots
of vertex degrees or 1 if the degree is zero.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.shortest_path" module_name="shortest_path" namespace="'sparse|csgraph'" output_type="list">
    <docstring>shortest_path(csgraph, method='auto', directed=True, return_predecessors=False,
              unweighted=False, overwrite=False)

Perform a shortest-path graph search on a positive directed or
undirected graph.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array, matrix, or sparse matrix, 2 dimensions
    The N x N array of distances representing the input graph.
method : string ['auto'|'FW'|'D'], optional
    Algorithm to use for shortest paths.  Options are:

       'auto' -- (default) select the best among 'FW', 'D', 'BF', or 'J'
                 based on the input data.

       'FW'   -- Floyd-Warshall algorithm.  Computational cost is
                 approximately ``O[N^3]``.  The input csgraph will be
                 converted to a dense representation.

       'D'    -- Dijkstra's algorithm with Fibonacci heaps.  Computational
                 cost is approximately ``O[N(N*k + N*log(N))]``, where
                 ``k`` is the average number of connected edges per node.
                 The input csgraph will be converted to a csr
                 representation.

       'BF'   -- Bellman-Ford algorithm.  This algorithm can be used when
                 weights are negative.  If a negative cycle is encountered,
                 an error will be raised.  Computational cost is
                 approximately ``O[N(N^2 k)]``, where ``k`` is the average
                 number of connected edges per node. The input csgraph will
                 be converted to a csr representation.

       'J'    -- Johnson's algorithm.  Like the Bellman-Ford algorithm,
                 Johnson's algorithm is designed for use when the weights
                 are negative.  It combines the Bellman-Ford algorithm
                 with Dijkstra's algorithm for faster computation.

directed : bool, optional
    If True (default), then find the shortest path on a directed graph:
    only move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i]
return_predecessors : bool, optional
    If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
    If True, then find unweighted distances.  That is, rather than finding
    the path between each point such that the sum of weights is minimized,
    find the path such that the number of edges is minimized.
overwrite : bool, optional
    If True, overwrite csgraph with the result.  This applies only if
    method == 'FW' and csgraph is a dense, c-ordered array with
    dtype=float64.

Returns
-------
dist_matrix : ndarray
    The N x N matrix of distances between graph nodes. dist_matrix[i,j]
    gives the shortest distance from point i to point j along the graph.

predecessors : ndarray
    Returned only if return_predecessors == True.
    The N x N matrix of predecessors, which can be used to reconstruct
    the shortest paths.  Row i of the predecessor matrix contains
    information on the shortest paths from point i: each entry
    predecessors[i, j] gives the index of the previous node in the
    path from point i to point j.  If no path exists between point
    i and j, then predecessors[i, j] = -9999

Raises
------
NegativeCycleError:
    if there are negative cycles in the graph

Notes
-----
As currently implemented, Dijkstra's algorithm and Johnson's algorithm
do not work for graphs with direction-dependent distances when
directed == False.  i.e., if csgraph[i,j] and csgraph[j,i] are non-equal
edges, method='D' may yield an incorrect result.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N array of distances representing the input graph.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Algorithm to use for shortest paths.  Options are:

   'auto' -- (default) select the best among 'FW', 'D', 'BF', or 'J'
             based on the input data.

   'FW'   -- Floyd-Warshall algorithm.  Computational cost is
             approximately ``O[N^3]``.  The input csgraph will be
             converted to a dense representation.

   'D'    -- Dijkstra's algorithm with Fibonacci heaps.  Computational
             cost is approximately ``O[N(N*k + N*log(N))]``, where
             ``k`` is the average number of connected edges per node.
             The input csgraph will be converted to a csr
             representation.

   'BF'   -- Bellman-Ford algorithm.  This algorithm can be used when
             weights are negative.  If a negative cycle is encountered,
             an error will be raised.  Computational cost is
             approximately ``O[N(N^2 k)]``, where ``k`` is the average
             number of connected edges per node. The input csgraph will
             be converted to a csr representation.

   'J'    -- Johnson's algorithm.  Like the Bellman-Ford algorithm,
             Johnson's algorithm is designed for use when the weights
             are negative.  It combines the Bellman-Ford algorithm
             with Dijkstra's algorithm for faster computation.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['auto', 'FW', 'D']]</values>
      <defaults>['auto']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True, return the size (N, N) predecesor matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="unweighted" name="unweighted" port_type="basic:Boolean">
      <docstring>If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite" name="overwrite" port_type="basic:Boolean">
      <docstring>If True, overwrite csgraph with the result.  This applies only if
method == 'FW' and csgraph is a dense, c-ordered array with
dtype=float64.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="dist_matrix" name="dist_matrix" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.floyd_warshall" module_name="floyd_warshall" namespace="'sparse|csgraph'" output_type="list">
    <docstring>floyd_warshall(csgraph, directed=True, return_predecessors=False,
               unweighted=False, overwrite=False)

Compute the shortest path lengths using the Floyd-Warshall algorithm

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array, matrix, or sparse matrix, 2 dimensions
    The N x N array of distances representing the input graph.
directed : bool, optional
    If True (default), then find the shortest path on a directed graph:
    only move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i]
return_predecessors : bool, optional
    If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
    If True, then find unweighted distances.  That is, rather than finding
    the path between each point such that the sum of weights is minimized,
    find the path such that the number of edges is minimized.
overwrite : bool, optional
    If True, overwrite csgraph with the result.  This applies only if
    csgraph is a dense, c-ordered array with dtype=float64.

Returns
-------
dist_matrix : ndarray
    The N x N matrix of distances between graph nodes. dist_matrix[i,j]
    gives the shortest distance from point i to point j along the graph.

predecessors : ndarray
    Returned only if return_predecessors == True.
    The N x N matrix of predecessors, which can be used to reconstruct
    the shortest paths.  Row i of the predecessor matrix contains
    information on the shortest paths from point i: each entry
    predecessors[i, j] gives the index of the previous node in the
    path from point i to point j.  If no path exists between point
    i and j, then predecessors[i, j] = -9999

Raises
------
NegativeCycleError:
    if there are negative cycles in the graph</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N array of distances representing the input graph.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True, return the size (N, N) predecesor matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="unweighted" name="unweighted" port_type="basic:Boolean">
      <docstring>If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="overwrite" name="overwrite" port_type="basic:Boolean">
      <docstring>If True, overwrite csgraph with the result.  This applies only if
csgraph is a dense, c-ordered array with dtype=float64.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="dist_matrix" name="dist_matrix" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.dijkstra" module_name="dijkstra" namespace="'sparse|csgraph'" output_type="list">
    <docstring>dijkstra(csgraph, directed=True, indices=None, return_predecessors=False,
         unweighted=False)

Dijkstra algorithm using Fibonacci Heaps

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array, matrix, or sparse matrix, 2 dimensions
    The N x N array of non-negative distances representing the input graph.
directed : bool, optional
    If True (default), then find the shortest path on a directed graph:
    only move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i]
indices : array_like or int, optional
    if specified, only compute the paths for the points at the given
    indices.
return_predecessors : bool, optional
    If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
    If True, then find unweighted distances.  That is, rather than finding
    the path between each point such that the sum of weights is minimized,
    find the path such that the number of edges is minimized.
limit : float, optional
    The maximum distance to calculate, must be &gt;= 0. Using a smaller limit
    will decrease computation time by aborting calculations between pairs
    that are separated by a distance &gt; limit. For such pairs, the distance
    will be equal to np.inf (i.e., not connected).
    .. versionadded:: 0.14.0

Returns
-------
dist_matrix : ndarray
    The matrix of distances between graph nodes. dist_matrix[i,j]
    gives the shortest distance from point i to point j along the graph.

predecessors : ndarray
    Returned only if return_predecessors == True.
    The matrix of predecessors, which can be used to reconstruct
    the shortest paths.  Row i of the predecessor matrix contains
    information on the shortest paths from point i: each entry
    predecessors[i, j] gives the index of the previous node in the
    path from point i to point j.  If no path exists between point
    i and j, then predecessors[i, j] = -9999

Notes
-----
As currently implemented, Dijkstra's algorithm does not work for
graphs with direction-dependent distances when directed == False.
i.e., if csgraph[i,j] and csgraph[j,i] are not equal and
both are nonzero, setting directed=False will not yield the correct
result.

Also, this routine does not work for graphs with negative
distances.  Negative distances can lead to infinite cycles that must
be handled by specialized algorithms such as Bellman-Ford's algorithm
or Johnson's algorithm.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N array of non-negative distances representing the input graph.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="indices" name="indicesScalar" port_type="basic:Integer">
      <docstring>if specified, only compute the paths for the points at the given
indices.</docstring>
      <alternateSpec arg="indices" name="indicesSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True, return the size (N, N) predecesor matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="unweighted" name="unweighted" port_type="basic:Boolean">
      <docstring>If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="limit" name="limit" port_type="basic:Float">
      <docstring>The maximum distance to calculate, must be &gt;= 0. Using a smaller limit
will decrease computation time by aborting calculations between pairs
that are separated by a distance &gt; limit. For such pairs, the distance
will be equal to np.inf (i.e., not connected).
.. versionadded:: 0.14.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="dist_matrix" name="dist_matrix" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors == True.
The matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.bellman_ford" module_name="bellman_ford" namespace="'sparse|csgraph'" output_type="list">
    <docstring>bellman_ford(csgraph, directed=True, indices=None, return_predecessors=False,
             unweighted=False)

Compute the shortest path lengths using the Bellman-Ford algorithm.

The Bellman-ford algorithm can robustly deal with graphs with negative
weights.  If a negative cycle is detected, an error is raised.  For
graphs without negative edge weights, dijkstra's algorithm may be faster.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array, matrix, or sparse matrix, 2 dimensions
    The N x N array of distances representing the input graph.
directed : bool, optional
    If True (default), then find the shortest path on a directed graph:
    only move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i]
indices : array_like or int, optional
    if specified, only compute the paths for the points at the given
    indices.
return_predecessors : bool, optional
    If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
    If True, then find unweighted distances.  That is, rather than finding
    the path between each point such that the sum of weights is minimized,
    find the path such that the number of edges is minimized.

Returns
-------
dist_matrix : ndarray
    The N x N matrix of distances between graph nodes. dist_matrix[i,j]
    gives the shortest distance from point i to point j along the graph.

predecessors : ndarray
    Returned only if return_predecessors == True.
    The N x N matrix of predecessors, which can be used to reconstruct
    the shortest paths.  Row i of the predecessor matrix contains
    information on the shortest paths from point i: each entry
    predecessors[i, j] gives the index of the previous node in the
    path from point i to point j.  If no path exists between point
    i and j, then predecessors[i, j] = -9999

Raises
------
NegativeCycleError:
    if there are negative cycles in the graph

Notes
-----
This routine is specially designed for graphs with negative edge weights.
If all edge weights are positive, then Dijkstra's algorithm is a better
choice.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N array of distances representing the input graph.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="indices" name="indicesScalar" port_type="basic:Integer">
      <docstring>if specified, only compute the paths for the points at the given
indices.</docstring>
      <alternateSpec arg="indices" name="indicesSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True, return the size (N, N) predecesor matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="unweighted" name="unweighted" port_type="basic:Boolean">
      <docstring>If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="dist_matrix" name="dist_matrix" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.johnson" module_name="johnson" namespace="'sparse|csgraph'" output_type="list">
    <docstring>johnson(csgraph, directed=True, indices=None, return_predecessors=False,
        unweighted=False)

Compute the shortest path lengths using Johnson's algorithm.

Johnson's algorithm combines the Bellman-Ford algorithm and Dijkstra's
algorithm to quickly find shortest paths in a way that is robust to
the presence of negative cycles.  If a negative cycle is detected,
an error is raised.  For graphs without negative edge weights,
dijkstra() may be faster.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array, matrix, or sparse matrix, 2 dimensions
    The N x N array of distances representing the input graph.
directed : bool, optional
    If True (default), then find the shortest path on a directed graph:
    only move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i]
indices : array_like or int, optional
    if specified, only compute the paths for the points at the given
    indices.
return_predecessors : bool, optional
    If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
    If True, then find unweighted distances.  That is, rather than finding
    the path between each point such that the sum of weights is minimized,
    find the path such that the number of edges is minimized.

Returns
-------
dist_matrix : ndarray
    The N x N matrix of distances between graph nodes. dist_matrix[i,j]
    gives the shortest distance from point i to point j along the graph.

predecessors : ndarray
    Returned only if return_predecessors == True.
    The N x N matrix of predecessors, which can be used to reconstruct
    the shortest paths.  Row i of the predecessor matrix contains
    information on the shortest paths from point i: each entry
    predecessors[i, j] gives the index of the previous node in the
    path from point i to point j.  If no path exists between point
    i and j, then predecessors[i, j] = -9999

Raises
------
NegativeCycleError:
    if there are negative cycles in the graph

Notes
-----
This routine is specially designed for graphs with negative edge weights.
If all edge weights are positive, then Dijkstra's algorithm is a better
choice.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N array of distances representing the input graph.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="indices" name="indicesScalar" port_type="basic:Integer">
      <docstring>if specified, only compute the paths for the points at the given
indices.</docstring>
      <alternateSpec arg="indices" name="indicesSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True, return the size (N, N) predecesor matrix</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="unweighted" name="unweighted" port_type="basic:Boolean">
      <docstring>If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="dist_matrix" name="dist_matrix" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.breadth_first_order" module_name="breadth_first_order" namespace="'sparse|csgraph'" output_type="list">
    <docstring>breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True)

Return a breadth-first ordering starting with specified node.

Note that a breadth-first order is not unique, but the tree which it
generates is unique.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix
    The N x N compressed sparse graph.  The input csgraph will be
    converted to csr format for the calculation.
i_start : int
    The index of starting node.
directed : bool, optional
    If True (default), then operate on a directed graph: only
    move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i].
return_predecessors : bool, optional
    If True (default), then return the predecesor array (see below).

Returns
-------
node_array : ndarray, one dimension
    The breadth-first list of nodes, starting with specified node.  The
    length of node_array is the number of nodes reachable from the
    specified node.
predecessors : ndarray, one dimension
    Returned only if return_predecessors is True.
    The length-N list of predecessors of each node in a breadth-first
    tree.  If node i is in the tree, then its parent is given by
    predecessors[i]. If node i is not in the tree (and for the parent
    node) then predecessors[i] = -9999.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N compressed sparse graph.  The input csgraph will be
converted to csr format for the calculation.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="i_start" name="i_start" port_type="basic:Integer" show_port="True">
      <docstring>The index of starting node.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True (default), then return the predecesor array (see below).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="node_array" name="node_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The breadth-first list of nodes, starting with specified node.  The
length of node_array is the number of nodes reachable from the
specified node.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors is True.
The length-N list of predecessors of each node in a breadth-first
tree.  If node i is in the tree, then its parent is given by
predecessors[i]. If node i is not in the tree (and for the parent
node) then predecessors[i] = -9999.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.depth_first_order" module_name="depth_first_order" namespace="'sparse|csgraph'" output_type="list">
    <docstring>depth_first_order(csgraph, i_start, directed=True, return_predecessors=True)

Return a depth-first ordering starting with specified node.

Note that a depth-first order is not unique.  Furthermore, for graphs
with cycles, the tree generated by a depth-first search is not
unique either.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix
    The N x N compressed sparse graph.  The input csgraph will be
    converted to csr format for the calculation.
i_start : int
    The index of starting node.
directed : bool, optional
    If True (default), then operate on a directed graph: only
    move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i].
return_predecessors : bool, optional
    If True (default), then return the predecesor array (see below).

Returns
-------
node_array : ndarray, one dimension
    The breadth-first list of nodes, starting with specified node.  The
    length of node_array is the number of nodes reachable from the
    specified node.
predecessors : ndarray, one dimension
    Returned only if return_predecessors is True.
    The length-N list of predecessors of each node in a breadth-first
    tree.  If node i is in the tree, then its parent is given by
    predecessors[i]. If node i is not in the tree (and for the parent
    node) then predecessors[i] = -9999.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N compressed sparse graph.  The input csgraph will be
converted to csr format for the calculation.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="i_start" name="i_start" port_type="basic:Integer" show_port="True">
      <docstring>The index of starting node.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="return_predecessors" name="return_predecessors" port_type="basic:Boolean">
      <docstring>If True (default), then return the predecesor array (see below).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="node_array" name="node_array" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The breadth-first list of nodes, starting with specified node.  The
length of node_array is the number of nodes reachable from the
specified node.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Returned only if return_predecessors is True.
The length-N list of predecessors of each node in a breadth-first
tree.  If node i is in the tree, then its parent is given by
predecessors[i]. If node i is not in the tree (and for the parent
node) then predecessors[i] = -9999.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.breadth_first_tree" module_name="breadth_first_tree" namespace="'sparse|csgraph'">
    <docstring>breadth_first_tree(csgraph, i_start, directed=True)

Return the tree generated by a breadth-first search

Note that a breadth-first tree from a specified node is unique.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix
    The N x N matrix representing the compressed sparse graph.  The input
    csgraph will be converted to csr format for the calculation.
i_start : int
    The index of starting node.
directed : bool, optional
    If True (default), then operate on a directed graph: only
    move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i].

Returns
-------
cstree : csr matrix
    The N x N directed compressed-sparse representation of the breadth-
    first tree drawn from csgraph, starting at the specified node.

Examples
--------
The following example shows the computation of a depth-first tree
over a simple four-component graph, starting at node 0::

     input graph          breadth first tree from (0)

         (0)                         (0)
        /   \                       /   \
       3     8                     3     8
      /       \                   /       \
    (3)---5---(1)               (3)       (1)
      \       /                           /
       6     2                           2
        \   /                           /
         (2)                         (2)

In compressed sparse representation, the solution looks like this:

&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; from scipy.sparse.csgraph import breadth_first_tree
&gt;&gt;&gt; X = csr_matrix([[0, 8, 0, 3],
...                 [0, 0, 2, 5],
...                 [0, 0, 0, 6],
...                 [0, 0, 0, 0]])
&gt;&gt;&gt; Tcsr = breadth_first_tree(X, 0, directed=False)
&gt;&gt;&gt; Tcsr.toarray().astype(int)
array([[0, 8, 0, 3],
       [0, 0, 2, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]])

Note that the resulting graph is a Directed Acyclic Graph which spans
the graph.  A breadth-first tree from a given node is unique.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N matrix representing the compressed sparse graph.  The input
csgraph will be converted to csr format for the calculation.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="i_start" name="i_start" port_type="basic:Integer" show_port="True">
      <docstring>The index of starting node.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="cstree" name="cstree" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The N x N directed compressed-sparse representation of the breadth-
first tree drawn from csgraph, starting at the specified node.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.depth_first_tree" module_name="depth_first_tree" namespace="'sparse|csgraph'">
    <docstring>depth_first_tree(csgraph, i_start, directed=True)

Return a tree generated by a depth-first search.

Note that a tree generated by a depth-first search is not unique:
it depends on the order that the children of each node are searched.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix
    The N x N matrix representing the compressed sparse graph.  The input
    csgraph will be converted to csr format for the calculation.
i_start : int
    The index of starting node.
directed : bool, optional
    If True (default), then operate on a directed graph: only
    move from point i to point j along paths csgraph[i, j].
    If False, then find the shortest path on an undirected graph: the
    algorithm can progress from point i to j along csgraph[i, j] or
    csgraph[j, i].

Returns
-------
cstree : csr matrix
    The N x N directed compressed-sparse representation of the depth-
    first tree drawn from csgraph, starting at the specified node.

Examples
--------
The following example shows the computation of a depth-first tree
over a simple four-component graph, starting at node 0::

     input graph           depth first tree from (0)

         (0)                         (0)
        /   \                           \
       3     8                           8
      /       \                           \
    (3)---5---(1)               (3)       (1)
      \       /                   \       /
       6     2                     6     2
        \   /                       \   /
         (2)                         (2)

In compressed sparse representation, the solution looks like this:

&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; from scipy.sparse.csgraph import depth_first_tree
&gt;&gt;&gt; X = csr_matrix([[0, 8, 0, 3],
...                 [0, 0, 2, 5],
...                 [0, 0, 0, 6],
...                 [0, 0, 0, 0]])
&gt;&gt;&gt; Tcsr = depth_first_tree(X, 0, directed=False)
&gt;&gt;&gt; Tcsr.toarray().astype(int)
array([[0, 8, 0, 0],
       [0, 0, 2, 0],
       [0, 0, 0, 6],
       [0, 0, 0, 0]])

Note that the resulting graph is a Directed Acyclic Graph which spans
the graph.  Unlike a breadth-first tree, a depth-first tree of a given
graph is not unique if the graph contains cycles.  If the above solution
had begun with the edge connecting nodes 0 and 3, the result would have
been different.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N matrix representing the compressed sparse graph.  The input
csgraph will be converted to csr format for the calculation.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="i_start" name="i_start" port_type="basic:Integer" show_port="True">
      <docstring>The index of starting node.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="cstree" name="cstree" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The N x N directed compressed-sparse representation of the depth-
first tree drawn from csgraph, starting at the specified node.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.minimum_spanning_tree" module_name="minimum_spanning_tree" namespace="'sparse|csgraph'">
    <docstring>minimum_spanning_tree(csgraph, overwrite=False)

Return a minimum spanning tree of an undirected graph

A minimum spanning tree is a graph consisting of the subset of edges
which together connect all connected nodes, while minimizing the total
sum of weights on the edges.  This is computed using the Kruskal algorithm.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix, 2 dimensions
    The N x N matrix representing an undirected graph over N nodes
    (see notes below).
overwrite : bool, optional
    if true, then parts of the input graph will be overwritten for
    efficiency.

Returns
-------
span_tree : csr matrix
    The N x N compressed-sparse representation of the undirected minimum
    spanning tree over the input (see notes below).

Notes
-----
This routine uses undirected graphs as input and output.  That is, if
graph[i, j] and graph[j, i] are both zero, then nodes i and j do not
have an edge connecting them.  If either is nonzero, then the two are
connected by the minimum nonzero value of the two.

Examples
--------
The following example shows the computation of a minimum spanning tree
over a simple four-component graph::

     input graph             minimum spanning tree

         (0)                         (0)
        /   \                       /
       3     8                     3
      /       \                   /
    (3)---5---(1)               (3)---5---(1)
      \       /                           /
       6     2                           2
        \   /                           /
         (2)                         (2)

It is easy to see from inspection that the minimum spanning tree involves
removing the edges with weights 8 and 6.  In compressed sparse
representation, the solution looks like this:

&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; from scipy.sparse.csgraph import minimum_spanning_tree
&gt;&gt;&gt; X = csr_matrix([[0, 8, 0, 3],
...                 [0, 0, 2, 5],
...                 [0, 0, 0, 6],
...                 [0, 0, 0, 0]])
&gt;&gt;&gt; Tcsr = minimum_spanning_tree(X)
&gt;&gt;&gt; Tcsr.toarray().astype(int)
array([[0, 0, 0, 3],
       [0, 0, 2, 5],
       [0, 0, 0, 0],
       [0, 0, 0, 0]])</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N matrix representing an undirected graph over N nodes
(see notes below).</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="overwrite" name="overwrite" port_type="basic:Boolean">
      <docstring>if true, then parts of the input graph will be overwritten for
efficiency.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="span_tree" name="span_tree" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The N x N compressed-sparse representation of the undirected minimum
spanning tree over the input (see notes below).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.reverse_cuthill_mckee" module_name="reverse_cuthill_mckee" namespace="'sparse|csgraph'">
    <docstring>Returns the permutation array that orders a sparse CSR or CSC matrix
in Reverse-Cuthill McKee ordering.  

It is assumed by default, ``symmetric_mode=False``, that the input matrix 
is not symmetric and works on the matrix ``A+A.T``. If you are 
guaranteed that the matrix is symmetric in structure (values of matrix 
elements do not matter) then set ``symmetric_mode=True``.

Parameters
----------
graph : sparse matrix
    Input sparse in CSC or CSR sparse matrix format.
symmetric_mode : bool, optional
    Is input matrix guaranteed to be symmetric.

Returns
-------
perm : ndarray
    Array of permuted row and column indices.

Notes
-----
.. versionadded:: 0.15.0

References
----------
E. Cuthill and J. McKee, "Reducing the Bandwidth of Sparse Symmetric Matrices",
ACM '69 Proceedings of the 1969 24th national conference, (1969).</docstring>
    <inputPortSpec arg="graph" name="graph" port_type="basic:Variant" show_port="True">
      <docstring>Input sparse in CSC or CSR sparse matrix format.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="symmetric_mode" name="symmetric_mode" port_type="basic:Boolean">
      <docstring>Is input matrix guaranteed to be symmetric.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="perm" name="perm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of permuted row and column indices.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.maximum_bipartite_matching" module_name="maximum_bipartite_matching" namespace="'sparse|csgraph'">
    <docstring>Returns an array of row or column permutations that makes
the diagonal of a nonsingular square CSC sparse matrix zero free.  

Such a permutation is always possible provided that the matrix 
is nonsingular. This function looks at the structure of the matrix 
only. The input matrix will be converted to CSC matrix format if
necessary.

Parameters
----------
graph : sparse matrix
    Input sparse in CSC format
perm_type : str, {'row', 'column'}
    Type of permutation to generate.

Returns
-------
perm : ndarray
    Array of row or column permutations.

Notes
-----
This function relies on a maximum cardinality bipartite matching 
algorithm based on a breadth-first search (BFS) of the underlying 
graph.

.. versionadded:: 0.15.0

References
----------
I. S. Duff, K. Kaya, and B. Ucar, "Design, Implementation, and 
Analysis of Maximum Transversal Algorithms", ACM Trans. Math. Softw.
38, no. 2, (2011).</docstring>
    <inputPortSpec arg="graph" name="graph" port_type="basic:Variant" show_port="True">
      <docstring>Input sparse in CSC format</docstring>
    </inputPortSpec>
    <inputPortSpec arg="perm_type" name="perm_type" show_port="True">
      <docstring>Type of permutation to generate.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['row', 'column']]</values>
    </inputPortSpec>
    <outputPortSpec arg="perm" name="perm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of row or column permutations.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.construct_dist_matrix" module_name="construct_dist_matrix" namespace="'sparse|csgraph'">
    <docstring>construct_dist_matrix(graph, predecessors, directed=True, null_value=np.inf)

Construct distance matrix from a predecessor matrix

.. versionadded:: 0.11.0

Parameters
----------
graph : array_like or sparse
    The N x N matrix representation of a directed or undirected graph.
    If dense, then non-edges are indicated by zeros or infinities.
predecessors : array_like
    The N x N matrix of predecessors of each node (see Notes below).
directed : bool, optional
    If True (default), then operate on a directed graph: only move from
    point i to point j along paths csgraph[i, j].
    If False, then operate on an undirected graph: the algorithm can
    progress from point i to j along csgraph[i, j] or csgraph[j, i].
null_value : bool, optional
    value to use for distances between unconnected nodes.  Default is
    np.inf

Returns
-------
dist_matrix : ndarray
    The N x N matrix of distances between nodes along the path specified
    by the predecessor matrix.  If no path exists, the distance is zero.

Notes
-----
The predecessor matrix is of the form returned by
:func:`graph_shortest_path`.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the path from
point i to point j.  If no path exists between point i and j, then
predecessors[i, j] = -9999</docstring>
    <inputPortSpec arg="graph" name="graphScalar" show_port="True">
      <docstring>The N x N matrix representation of a directed or undirected graph.
If dense, then non-edges are indicated by zeros or infinities.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['sparse']]</values>
      <alternateSpec arg="graph" name="graphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True">
      <docstring>The N x N matrix of predecessors of each node (see Notes below).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only move from
point i to point j along paths csgraph[i, j].
If False, then operate on an undirected graph: the algorithm can
progress from point i to j along csgraph[i, j] or csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="null_value" name="null_value" port_type="basic:Boolean">
      <docstring>value to use for distances between unconnected nodes.  Default is
np.inf</docstring>
    </inputPortSpec>
    <outputPortSpec arg="dist_matrix" name="dist_matrix" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The N x N matrix of distances between nodes along the path specified
by the predecessor matrix.  If no path exists, the distance is zero.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.reconstruct_path" module_name="reconstruct_path" namespace="'sparse|csgraph'">
    <docstring>reconstruct_path(csgraph, predecessors, directed=True)

Construct a tree from a graph and a predecessor list.

.. versionadded:: 0.11.0

Parameters
----------
csgraph : array_like or sparse matrix
    The N x N matrix representing the directed or undirected graph
    from which the predecessors are drawn.
predecessors : array_like, one dimension
    The length-N array of indices of predecessors for the tree.  The
    index of the parent of node i is given by predecessors[i].
directed : bool, optional
    If True (default), then operate on a directed graph: only move from
    point i to point j along paths csgraph[i, j].
    If False, then operate on an undirected graph: the algorithm can
    progress from point i to j along csgraph[i, j] or csgraph[j, i].

Returns
-------
cstree : csr matrix
    The N x N directed compressed-sparse representation of the tree drawn
    from csgraph which is encoded by the predecessor list.</docstring>
    <inputPortSpec arg="csgraph" name="csgraphScalar" show_port="True">
      <docstring>The N x N matrix representing the directed or undirected graph
from which the predecessors are drawn.</docstring>
      <alternateSpec arg="csgraph" name="csgraphSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="predecessors" name="predecessors" port_type="basic:List" show_port="True">
      <docstring>The length-N array of indices of predecessors for the tree.  The
index of the parent of node i is given by predecessors[i].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="directed" name="directed" port_type="basic:Boolean">
      <docstring>If True (default), then operate on a directed graph: only move from
point i to point j along paths csgraph[i, j].
If False, then operate on an undirected graph: the algorithm can
progress from point i to j along csgraph[i, j] or csgraph[j, i].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="cstree" name="cstree" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The N x N directed compressed-sparse representation of the tree drawn
from csgraph which is encoded by the predecessor list.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.csgraph_from_dense" module_name="csgraph_from_dense" namespace="'sparse|csgraph'">
    <docstring>csgraph_from_dense(graph, null_value=0, nan_null=True, infinity_null=True)

Construct a CSR-format sparse graph from a dense matrix.

.. versionadded:: 0.11.0

Parameters
----------
graph : array_like
    Input graph.  Shape should be (n_nodes, n_nodes).
null_value : float or None (optional)
    Value that denotes non-edges in the graph.  Default is zero.
infinity_null : bool
    If True (default), then infinite entries (both positive and negative)
    are treated as null edges.
nan_null : bool
    If True (default), then NaN entries are treated as non-edges

Returns
-------
csgraph : csr_matrix
    Compressed sparse representation of graph,</docstring>
    <inputPortSpec arg="graph" name="graph" port_type="basic:List" show_port="True">
      <docstring>Input graph.  Shape should be (n_nodes, n_nodes).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="null_value" name="null_value">
      <docstring>Value that denotes non-edges in the graph.  Default is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="infinity_null" name="infinity_null" port_type="basic:Boolean">
      <docstring>If True (default), then infinite entries (both positive and negative)
are treated as null edges.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="nan_null" name="nan_null" port_type="basic:Boolean">
      <docstring>If True (default), then NaN entries are treated as non-edges</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="csgraph" name="csgraph" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Compressed sparse representation of graph,</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.csgraph_masked_from_dense" module_name="csgraph_masked_from_dense" namespace="'sparse|csgraph'">
    <docstring>csgraph_masked_from_dense(graph, null_value=0, nan_null=True,
                          infinity_null=True, copy=True)

Construct a masked array graph representation from a dense matrix.

.. versionadded:: 0.11.0

Parameters
----------
graph : array_like
    Input graph.  Shape should be (n_nodes, n_nodes).
null_value : float or None (optional)
    Value that denotes non-edges in the graph.  Default is zero.
infinity_null : bool
    If True (default), then infinite entries (both positive and negative)
    are treated as null edges.
nan_null : bool
    If True (default), then NaN entries are treated as non-edges

Returns
-------
csgraph : MaskedArray
    masked array representation of graph</docstring>
    <inputPortSpec arg="graph" name="graph" port_type="basic:List" show_port="True">
      <docstring>Input graph.  Shape should be (n_nodes, n_nodes).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="null_value" name="null_value">
      <docstring>Value that denotes non-edges in the graph.  Default is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="infinity_null" name="infinity_null" port_type="basic:Boolean">
      <docstring>If True (default), then infinite entries (both positive and negative)
are treated as null edges.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="nan_null" name="nan_null" port_type="basic:Boolean">
      <docstring>If True (default), then NaN entries are treated as non-edges</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="copy" name="copy" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="csgraph" name="csgraph" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>masked array representation of graph</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.sparse.csgraph.csgraph_to_dense" module_name="csgraph_to_dense" namespace="'sparse|csgraph'">
    <docstring>csgraph_to_dense(csgraph, null_value=0)

Convert a sparse graph representation to a dense representation

.. versionadded:: 0.11.0

Parameters
----------
csgraph : csr_matrix, csc_matrix, or lil_matrix
    Sparse representation of a graph.
null_value : float, optional
    The value used to indicate null edges in the dense representation.
    Default is 0.

Returns
-------
graph : ndarray
    The dense representation of the sparse graph.

Notes
-----
For normal sparse graph representations, calling csgraph_to_dense with
null_value=0 produces an equivalent result to using dense format
conversions in the main sparse package.  When the sparse representations
have repeated values, however, the results will differ.  The tools in
scipy.sparse will add repeating values to obtain a final value.  This
function will select the minimum among repeating values to obtain a
final value.  For example, here we'll create a two-node directed sparse
graph with multiple edges from node 0 to node 1, of weights 2 and 3.
This illustrates the difference in behavior:

&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; data = np.array([2, 3])
&gt;&gt;&gt; indices = np.array([1, 1])
&gt;&gt;&gt; indptr = np.array([0, 2, 2])
&gt;&gt;&gt; M = csr_matrix((data, indices, indptr), shape=(2, 2))
&gt;&gt;&gt; M.toarray()
array([[0, 5],
       [0, 0]])
&gt;&gt;&gt; csgraph_to_dense(M)
array([[0, 2],
       [0, 0]])

The reason for this difference is to allow a compressed sparse graph to
represent multiple edges between any two nodes.  As most sparse graph
algorithms are concerned with the single lowest-cost edge between any
two nodes, the default scipy.sparse behavior of summming multiple weights
does not make sense in this context.

The other reason for using this routine is to allow for graphs with
zero-weight edges.  Let's look at the example of a two-node directed
graph, connected by an edge of weight zero:

&gt;&gt;&gt; from scipy.sparse import csr_matrix
&gt;&gt;&gt; data = np.array([0.0])
&gt;&gt;&gt; indices = np.array([1])
&gt;&gt;&gt; indptr = np.array([0, 2, 2])
&gt;&gt;&gt; M = csr_matrix((data, indices, indptr), shape=(2, 2))
&gt;&gt;&gt; M.toarray()
array([[0, 0],
       [0, 0]])
&gt;&gt;&gt; csgraph_to_dense(M, np.inf)
array([[ Inf,   0.],
       [ Inf,  Inf]])

In the first case, the zero-weight edge gets lost in the dense
representation.  In the second case, we can choose a different null value
and see the true form of the graph.</docstring>
    <inputPortSpec arg="csgraph" name="csgraph" show_port="True">
      <docstring>Sparse representation of a graph.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['lil_matrix']]</values>
    </inputPortSpec>
    <inputPortSpec arg="null_value" name="null_value" port_type="basic:Float">
      <docstring>The value used to indicate null edges in the dense representation.
Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="graph" name="graph" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The dense representation of the sparse graph.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.braycurtis" module_name="braycurtis" namespace="'spatial|distance'">
    <docstring>Computes the Bray-Curtis distance between two 1-D arrays.

Bray-Curtis distance is defined as

.. math::

   \sum{|u_i-v_i|} / \sum{|u_i+v_i|}

The Bray-Curtis distance is in the range [0, 1] if all coordinates are
positive, and is undefined if the inputs are of length zero.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
braycurtis : double
    The Bray-Curtis distance between 1-D arrays `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="braycurtis" name="braycurtis" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Bray-Curtis distance between 1-D arrays `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.callable" module_name="callable" namespace="'spatial|distance'">
    <docstring>callable(object) -&gt; bool

Return whether the object is callable (i.e., some kind of function).
Note that classes are callable, as are instances with a __call__() method.</docstring>
    <inputPortSpec arg="object" name="object" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Boolean" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.canberra" module_name="canberra" namespace="'spatial|distance'">
    <docstring>Computes the Canberra distance between two 1-D arrays.

The Canberra distance is defined as

.. math::

     d(u,v) = \sum_i \frac{|u_i-v_i|}
                          {|u_i|+|v_i|}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
canberra : double
    The Canberra distance between vectors `u` and `v`.

Notes
-----
When `u[i]` and `v[i]` are 0 for given i, then the fraction 0/0 = 0 is
used in the calculation.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="canberra" name="canberra" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Canberra distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.cdist" module_name="cdist" namespace="'spatial|distance'">
    <docstring>Computes distance between each pair of the two collections of inputs.

The following are common calling conventions:

1. ``Y = cdist(XA, XB, 'euclidean')``

   Computes the distance between :math:`m` points using
   Euclidean distance (2-norm) as the distance metric between the
   points. The points are arranged as :math:`m`
   :math:`n`-dimensional row vectors in the matrix X.

2. ``Y = cdist(XA, XB, 'minkowski', p)``

   Computes the distances using the Minkowski distance
   :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \geq 1`.

3. ``Y = cdist(XA, XB, 'cityblock')``

   Computes the city block or Manhattan distance between the
   points.

4. ``Y = cdist(XA, XB, 'seuclidean', V=None)``

   Computes the standardized Euclidean distance. The standardized
   Euclidean distance between two n-vectors ``u`` and ``v`` is

   .. math::

      \sqrt{\sum {(u_i-v_i)^2 / V[x_i]}}.

   V is the variance vector; V[i] is the variance computed over all
   the i'th components of the points. If not passed, it is
   automatically computed.

5. ``Y = cdist(XA, XB, 'sqeuclidean')``

   Computes the squared Euclidean distance :math:`||u-v||_2^2` between
   the vectors.

6. ``Y = cdist(XA, XB, 'cosine')``

   Computes the cosine distance between vectors u and v,

   .. math::

      1 - \frac{u \cdot v}
               {{||u||}_2 {||v||}_2}

   where :math:`||*||_2` is the 2-norm of its argument ``*``, and
   :math:`u \cdot v` is the dot product of :math:`u` and :math:`v`.

7. ``Y = cdist(XA, XB, 'correlation')``

   Computes the correlation distance between vectors u and v. This is

   .. math::

      1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
               {{||(u - \bar{u})||}_2 {||(v - \bar{v})||}_2}

   where :math:`\bar{v}` is the mean of the elements of vector v,
   and :math:`x \cdot y` is the dot product of :math:`x` and :math:`y`.


8. ``Y = cdist(XA, XB, 'hamming')``

   Computes the normalized Hamming distance, or the proportion of
   those vector elements between two n-vectors ``u`` and ``v``
   which disagree. To save memory, the matrix ``X`` can be of type
   boolean.

9. ``Y = cdist(XA, XB, 'jaccard')``

   Computes the Jaccard distance between the points. Given two
   vectors, ``u`` and ``v``, the Jaccard distance is the
   proportion of those elements ``u[i]`` and ``v[i]`` that
   disagree where at least one of them is non-zero.

10. ``Y = cdist(XA, XB, 'chebyshev')``

   Computes the Chebyshev distance between the points. The
   Chebyshev distance between two n-vectors ``u`` and ``v`` is the
   maximum norm-1 distance between their respective elements. More
   precisely, the distance is given by

   .. math::

      d(u,v) = \max_i {|u_i-v_i|}.

11. ``Y = cdist(XA, XB, 'canberra')``

   Computes the Canberra distance between the points. The
   Canberra distance between two points ``u`` and ``v`` is

   .. math::

     d(u,v) = \sum_i \frac{|u_i-v_i|}
                          {|u_i|+|v_i|}.

12. ``Y = cdist(XA, XB, 'braycurtis')``

   Computes the Bray-Curtis distance between the points. The
   Bray-Curtis distance between two points ``u`` and ``v`` is


   .. math::

        d(u,v) = \frac{\sum_i (u_i-v_i)}
                      {\sum_i (u_i+v_i)}

13. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)``

   Computes the Mahalanobis distance between the points. The
   Mahalanobis distance between two points ``u`` and ``v`` is
   :math:`(u-v)(1/V)(u-v)^T` where :math:`(1/V)` (the ``VI``
   variable) is the inverse covariance. If ``VI`` is not None,
   ``VI`` will be used as the inverse covariance matrix.

14. ``Y = cdist(XA, XB, 'yule')``

   Computes the Yule distance between the boolean
   vectors. (see `yule` function documentation)

15. ``Y = cdist(XA, XB, 'matching')``

   Computes the matching distance between the boolean
   vectors. (see `matching` function documentation)

16. ``Y = cdist(XA, XB, 'dice')``

   Computes the Dice distance between the boolean vectors. (see
   `dice` function documentation)

17. ``Y = cdist(XA, XB, 'kulsinski')``

   Computes the Kulsinski distance between the boolean
   vectors. (see `kulsinski` function documentation)

18. ``Y = cdist(XA, XB, 'rogerstanimoto')``

   Computes the Rogers-Tanimoto distance between the boolean
   vectors. (see `rogerstanimoto` function documentation)

19. ``Y = cdist(XA, XB, 'russellrao')``

   Computes the Russell-Rao distance between the boolean
   vectors. (see `russellrao` function documentation)

20. ``Y = cdist(XA, XB, 'sokalmichener')``

   Computes the Sokal-Michener distance between the boolean
   vectors. (see `sokalmichener` function documentation)

21. ``Y = cdist(XA, XB, 'sokalsneath')``

   Computes the Sokal-Sneath distance between the vectors. (see
   `sokalsneath` function documentation)


22. ``Y = cdist(XA, XB, 'wminkowski')``

   Computes the weighted Minkowski distance between the
   vectors. (see `wminkowski` function documentation)

23. ``Y = cdist(XA, XB, f)``

   Computes the distance between all pairs of vectors in X
   using the user supplied 2-arity function f. For example,
   Euclidean distance between the vectors could be computed
   as follows::

     dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))

   Note that you should avoid passing a reference to one of
   the distance functions defined in this library. For example,::

     dm = cdist(XA, XB, sokalsneath)

   would calculate the pair-wise distances between the vectors in
   X using the Python function `sokalsneath`. This would result in
   sokalsneath being called :math:`{n \choose 2}` times, which
   is inefficient. Instead, the optimized C version is more
   efficient, and we call it using the following syntax::

     dm = cdist(XA, XB, 'sokalsneath')

Parameters
----------
XA : ndarray
    An :math:`m_A` by :math:`n` array of :math:`m_A`
    original observations in an :math:`n`-dimensional space.
    Inputs are converted to float type.
XB : ndarray
    An :math:`m_B` by :math:`n` array of :math:`m_B`
    original observations in an :math:`n`-dimensional space.
    Inputs are converted to float type.
metric : str or callable, optional
    The distance metric to use.  If a string, the distance function can be
    'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
    'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'kulsinski',
    'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao',
    'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
    'wminkowski', 'yule'.
w : ndarray, optional
    The weight vector (for weighted Minkowski).
p : scalar, optional
    The p-norm to apply (for Minkowski, weighted and unweighted)
V : ndarray, optional
    The variance vector (for standardized Euclidean).
VI : ndarray, optional
    The inverse of the covariance matrix (for Mahalanobis).

Returns
-------
Y : ndarray
    A :math:`m_A` by :math:`m_B` distance matrix is returned.
    For each :math:`i` and :math:`j`, the metric
    ``dist(u=XA[i], v=XB[j])`` is computed and stored in the
    :math:`ij` th entry.

Raises
------
ValueError
    An exception is thrown if `XA` and `XB` do not have
    the same number of columns.

Examples
--------
Find the Euclidean distances between four 2-D coordinates:

&gt;&gt;&gt; from scipy.spatial import distance
&gt;&gt;&gt; coords = [(35.0456, -85.2672),
...           (35.1174, -89.9711),
...           (35.9728, -83.9422),
...           (36.1667, -86.7833)]
&gt;&gt;&gt; distance.cdist(coords, coords, 'euclidean')
array([[ 0.    ,  4.7044,  1.6172,  1.8856],
       [ 4.7044,  0.    ,  6.0893,  3.3561],
       [ 1.6172,  6.0893,  0.    ,  2.8477],
       [ 1.8856,  3.3561,  2.8477,  0.    ]])


Find the Manhattan distance from a 3-D point to the corners of the unit
cube:

&gt;&gt;&gt; a = np.array([[0, 0, 0],
                  [0, 0, 1],
                  [0, 1, 0],
                  [0, 1, 1],
                  [1, 0, 0],
                  [1, 0, 1],
                  [1, 1, 0],
                  [1, 1, 1]])
&gt;&gt;&gt; b = np.array([[ 0.1,  0.2,  0.4]])
&gt;&gt;&gt; distance.cdist(a, b, 'cityblock')
array([[ 0.7],
       [ 0.9],
       [ 1.3],
       [ 1.5],
       [ 1.5],
       [ 1.7],
       [ 2.1],
       [ 2.3]])</docstring>
    <inputPortSpec arg="XA" name="XA" port_type="basic:List" show_port="True">
      <docstring>An :math:`m_A` by :math:`n` array of :math:`m_A`
original observations in an :math:`n`-dimensional space.
Inputs are converted to float type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="XB" name="XB" port_type="basic:List" show_port="True">
      <docstring>An :math:`m_B` by :math:`n` array of :math:`m_B`
original observations in an :math:`n`-dimensional space.
Inputs are converted to float type.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="metric" name="metric">
      <docstring>The distance metric to use.  If a string, the distance function can be
'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'kulsinski',
'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao',
'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
'wminkowski', 'yule'.</docstring>
      <defaults>['euclidean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>The weight vector (for weighted Minkowski).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Float">
      <docstring>The p-norm to apply (for Minkowski, weighted and unweighted)</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="V" name="V" port_type="basic:List">
      <docstring>The variance vector (for standardized Euclidean).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="VI" name="VI" port_type="basic:List">
      <docstring>The inverse of the covariance matrix (for Mahalanobis).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Y" name="Y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A :math:`m_A` by :math:`m_B` distance matrix is returned.
For each :math:`i` and :math:`j`, the metric
``dist(u=XA[i], v=XB[j])`` is computed and stored in the
:math:`ij` th entry.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.chebyshev" module_name="chebyshev" namespace="'spatial|distance'">
    <docstring>Computes the Chebyshev distance.

Computes the Chebyshev distance between two 1-D arrays `u` and `v`,
which is defined as

.. math::

   \max_i {|u_i-v_i|}.

Parameters
----------
u : (N,) array_like
    Input vector.
v : (N,) array_like
    Input vector.

Returns
-------
chebyshev : double
    The Chebyshev distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input vector.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="chebyshev" name="chebyshev" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Chebyshev distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.cityblock" module_name="cityblock" namespace="'spatial|distance'">
    <docstring>Computes the City Block (Manhattan) distance.

Computes the Manhattan distance between two 1-D arrays `u` and `v`,
which is defined as

.. math::

   \sum_i {\left| u_i - v_i \right|}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
cityblock : double
    The City Block (Manhattan) distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="cityblock" name="cityblock" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The City Block (Manhattan) distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.correlation" module_name="correlation" namespace="'spatial|distance'">
    <docstring>Computes the correlation distance between two 1-D arrays.

The correlation distance between `u` and `v`, is
defined as

.. math::

   1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
           {{||(u - \bar{u})||}_2 {||(v - \bar{v})||}_2}

where :math:`\bar{u}` is the mean of the elements of `u`
and :math:`x \cdot y` is the dot product of :math:`x` and :math:`y`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
correlation : double
    The correlation distance between 1-D array `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The correlation distance between 1-D array `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.cosine" module_name="cosine" namespace="'spatial|distance'">
    <docstring>Computes the Cosine distance between 1-D arrays.

The Cosine distance between `u` and `v`, is defined as

.. math::

   1 - \frac{u \cdot v}
            {||u||_2 ||v||_2}.

where :math:`u \cdot v` is the dot product of :math:`u` and
:math:`v`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
cosine : double
    The Cosine distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="cosine" name="cosine" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Cosine distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.dice" module_name="dice" namespace="'spatial|distance'">
    <docstring>Computes the Dice dissimilarity between two boolean 1-D arrays.

The Dice dissimilarity between `u` and `v`, is

.. math::

     \frac{c_{TF} + c_{FT}}
          {2c_{TT} + c_{FT} + c_{TF}}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`.

Parameters
----------
u : (N,) ndarray, bool
    Input 1-D array.
v : (N,) ndarray, bool
    Input 1-D array.

Returns
-------
dice : double
    The Dice dissimilarity between 1-D arrays `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input 1-D array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input 1-D array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="dice" name="dice" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Dice dissimilarity between 1-D arrays `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.euclidean" module_name="euclidean" namespace="'spatial|distance'">
    <docstring>Computes the Euclidean distance between two 1-D arrays.

The Euclidean distance between 1-D arrays `u` and `v`, is defined as

.. math::

   {||u-v||}_2

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
euclidean : double
    The Euclidean distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="euclidean" name="euclidean" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Euclidean distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.hamming" module_name="hamming" namespace="'spatial|distance'">
    <docstring>Computes the Hamming distance between two 1-D arrays.

The Hamming distance between 1-D arrays `u` and `v`, is simply the
proportion of disagreeing components in `u` and `v`. If `u` and `v` are
boolean vectors, the Hamming distance is

.. math::

   \frac{c_{01} + c_{10}}{n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
hamming : double
    The Hamming distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="hamming" name="hamming" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Hamming distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.is_valid_dm" module_name="is_valid_dm" namespace="'spatial|distance'">
    <docstring>Returns True if input array is a valid distance matrix.

Distance matrices must be 2-dimensional numpy arrays containing
doubles. They must have a zero-diagonal, and they must be symmetric.

Parameters
----------
D : ndarray
    The candidate object to test for validity.
tol : float, optional
    The distance matrix should be symmetric. `tol` is the maximum
    difference between entries ``ij`` and ``ji`` for the distance
    metric to be considered symmetric.
throw : bool, optional
    An exception is thrown if the distance matrix passed is not valid.
name : str, optional
    The name of the variable to checked. This is useful if
    throw is set to True so the offending variable can be identified
    in the exception message when an exception is thrown.
warning : bool, optional
    Instead of throwing an exception, a warning message is
    raised.

Returns
-------
valid : bool
    True if the variable `D` passed is a valid distance matrix.

Notes
-----
Small numerical differences in `D` and `D.T` and non-zeroness of
the diagonal are ignored if they are within the tolerance specified
by `tol`.</docstring>
    <inputPortSpec arg="D" name="D" port_type="basic:List" show_port="True">
      <docstring>The candidate object to test for validity.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>The distance matrix should be symmetric. `tol` is the maximum
difference between entries ``ij`` and ``ji`` for the distance
metric to be considered symmetric.</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="throw" name="throw" port_type="basic:Boolean">
      <docstring>An exception is thrown if the distance matrix passed is not valid.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="name" name="name">
      <docstring>The name of the variable to checked. This is useful if
throw is set to True so the offending variable can be identified
in the exception message when an exception is thrown.</docstring>
      <defaults>['D']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="warning" name="warning" port_type="basic:Boolean">
      <docstring>Instead of throwing an exception, a warning message is
raised.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="valid" name="valid" port_type="basic:Boolean" show_port="True" sort_key="0">
      <docstring>True if the variable `D` passed is a valid distance matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.is_valid_y" module_name="is_valid_y" namespace="'spatial|distance'">
    <docstring>Returns True if the input array is a valid condensed distance matrix.

Condensed distance matrices must be 1-dimensional
numpy arrays containing doubles. Their length must be a binomial
coefficient :math:`{n \choose 2}` for some positive integer n.

Parameters
----------
y : ndarray
    The condensed distance matrix.
warning : bool, optional
    Invokes a warning if the variable passed is not a valid
    condensed distance matrix. The warning message explains why
    the distance matrix is not valid.  `name` is used when
    referencing the offending variable.
throw : bool, optional
    Throws an exception if the variable passed is not a valid
    condensed distance matrix.
name : bool, optional
    Used when referencing the offending variable in the
    warning or exception message.</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The condensed distance matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="warning" name="warning" port_type="basic:Boolean">
      <docstring>Invokes a warning if the variable passed is not a valid
condensed distance matrix. The warning message explains why
the distance matrix is not valid.  `name` is used when
referencing the offending variable.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="throw" name="throw" port_type="basic:Boolean">
      <docstring>Throws an exception if the variable passed is not a valid
condensed distance matrix.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="name" name="name" port_type="basic:Boolean">
      <docstring>Used when referencing the offending variable in the
warning or exception message.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.jaccard" module_name="jaccard" namespace="'spatial|distance'">
    <docstring>Computes the Jaccard-Needham dissimilarity between two boolean 1-D arrays.

The Jaccard-Needham dissimilarity between 1-D boolean arrays `u` and `v`,
is defined as

.. math::

   \frac{c_{TF} + c_{FT}}
        {c_{TT} + c_{FT} + c_{TF}}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
jaccard : double
    The Jaccard distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="jaccard" name="jaccard" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Jaccard distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.kulsinski" module_name="kulsinski" namespace="'spatial|distance'">
    <docstring>Computes the Kulsinski dissimilarity between two boolean 1-D arrays.

The Kulsinski dissimilarity between two boolean 1-D arrays `u` and `v`,
is defined as

.. math::

     \frac{c_{TF} + c_{FT} - c_{TT} + n}
          {c_{FT} + c_{TF} + n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
kulsinski : double
    The Kulsinski distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="kulsinski" name="kulsinski" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Kulsinski distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.mahalanobis" module_name="mahalanobis" namespace="'spatial|distance'">
    <docstring>Computes the Mahalanobis distance between two 1-D arrays.

The Mahalanobis distance between 1-D arrays `u` and `v`, is defined as

.. math::

   \sqrt{ (u-v) V^{-1} (u-v)^T }

where ``V`` is the covariance matrix.  Note that the argument `VI`
is the inverse of ``V``.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
VI : ndarray
    The inverse of the covariance matrix.

Returns
-------
mahalanobis : double
    The Mahalanobis distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="VI" name="VI" port_type="basic:List" show_port="True">
      <docstring>The inverse of the covariance matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mahalanobis" name="mahalanobis" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Mahalanobis distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.matching" module_name="matching" namespace="'spatial|distance'">
    <docstring>Computes the Matching dissimilarity between two boolean 1-D arrays.

The Matching dissimilarity between two boolean 1-D arrays
`u` and `v`, is defined as

.. math::

   \frac{c_{TF} + c_{FT}}{n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
matching : double
    The Matching dissimilarity between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="matching" name="matching" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Matching dissimilarity between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.minkowski" module_name="minkowski" namespace="'spatial|distance'">
    <docstring>Computes the Minkowski distance between two 1-D arrays.

The Minkowski distance between 1-D arrays `u` and `v`,
is defined as

.. math::

   {||u-v||}_p = (\sum{|u_i - v_i|^p})^{1/p}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
p : int
    The order of the norm of the difference :math:`{||u-v||}_p`.

Returns
-------
d : double
    The Minkowski distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer" show_port="True">
      <docstring>The order of the norm of the difference :math:`{||u-v||}_p`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="d" name="d" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Minkowski distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.norm" module_name="norm" namespace="'spatial|distance'">
    <docstring>Matrix or vector norm.

This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
a : (M,) or (M, N) array_like
    Input array.
ord : {non-zero int, inf, -inf, 'fro'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object.

Returns
-------
norm : float
    Norm of the matrix or vector.

Notes
-----
For values of ``ord &lt;= 0``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
&gt;&gt;&gt; from scipy.linalg import norm
&gt;&gt;&gt; a = np.arange(9) - 4
&gt;&gt;&gt; a
array([-4, -3, -2, -1,  0,  1,  2,  3,  4])
&gt;&gt;&gt; b = a.reshape((3, 3))
&gt;&gt;&gt; b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])

&gt;&gt;&gt; norm(a)
7.745966692414834
&gt;&gt;&gt; norm(b)
7.745966692414834
&gt;&gt;&gt; norm(b, 'fro')
7.745966692414834
&gt;&gt;&gt; norm(a, np.inf)
4
&gt;&gt;&gt; norm(b, np.inf)
9
&gt;&gt;&gt; norm(a, -np.inf)
0
&gt;&gt;&gt; norm(b, -np.inf)
2

&gt;&gt;&gt; norm(a, 1)
20
&gt;&gt;&gt; norm(b, 1)
7
&gt;&gt;&gt; norm(a, -1)
-4.6566128774142013e-010
&gt;&gt;&gt; norm(b, -1)
6
&gt;&gt;&gt; norm(a, 2)
7.745966692414834
&gt;&gt;&gt; norm(b, 2)
7.3484692283495345

&gt;&gt;&gt; norm(a, -2)
nan
&gt;&gt;&gt; norm(b, -2)
1.8570331885190563e-016
&gt;&gt;&gt; norm(a, 3)
5.8480354764257312
&gt;&gt;&gt; norm(a, -3)
nan</docstring>
    <inputPortSpec arg="a" name="aScalar" show_port="True">
      <docstring>Input array.</docstring>
      <alternateSpec arg="a" name="aSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="ord" name="ord">
      <docstring>Order of the norm (see table under ``Notes``). inf means numpy's
`inf` object.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['inf', '-inf', 'fro']]</values>
    </inputPortSpec>
    <outputPortSpec arg="norm" name="norm" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Norm of the matrix or vector.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.num_obs_dm" module_name="num_obs_dm" namespace="'spatial|distance'">
    <docstring>Returns the number of original observations that correspond to a
square, redundant distance matrix.

Parameters
----------
d : ndarray
    The target distance matrix.

Returns
-------
num_obs_dm : int
    The number of observations in the redundant distance matrix.</docstring>
    <inputPortSpec arg="d" name="d" port_type="basic:List" show_port="True">
      <docstring>The target distance matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="num_obs_dm" name="num_obs_dm" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of observations in the redundant distance matrix.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.num_obs_y" module_name="num_obs_y" namespace="'spatial|distance'">
    <docstring>Returns the number of original observations that correspond to a
condensed distance matrix.

Parameters
----------
Y : ndarray
    Condensed distance matrix.

Returns
-------
n : int
    The number of observations in the condensed distance matrix `Y`.</docstring>
    <inputPortSpec arg="Y" name="Y" port_type="basic:List" show_port="True">
      <docstring>Condensed distance matrix.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of observations in the condensed distance matrix `Y`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.pdist" module_name="pdist" namespace="'spatial|distance'">
    <docstring>Pairwise distances between observations in n-dimensional space.

The following are common calling conventions.

1. ``Y = pdist(X, 'euclidean')``

   Computes the distance between m points using Euclidean distance
   (2-norm) as the distance metric between the points. The points
   are arranged as m n-dimensional row vectors in the matrix X.

2. ``Y = pdist(X, 'minkowski', p)``

   Computes the distances using the Minkowski distance
   :math:`||u-v||_p` (p-norm) where :math:`p \geq 1`.

3. ``Y = pdist(X, 'cityblock')``

   Computes the city block or Manhattan distance between the
   points.

4. ``Y = pdist(X, 'seuclidean', V=None)``

   Computes the standardized Euclidean distance. The standardized
   Euclidean distance between two n-vectors ``u`` and ``v`` is

   .. math::

      \sqrt{\sum {(u_i-v_i)^2 / V[x_i]}}


   V is the variance vector; V[i] is the variance computed over all
   the i'th components of the points.  If not passed, it is
   automatically computed.

5. ``Y = pdist(X, 'sqeuclidean')``

   Computes the squared Euclidean distance :math:`||u-v||_2^2` between
   the vectors.

6. ``Y = pdist(X, 'cosine')``

   Computes the cosine distance between vectors u and v,

   .. math::

      1 - \frac{u \cdot v}
               {{||u||}_2 {||v||}_2}

   where :math:`||*||_2` is the 2-norm of its argument ``*``, and
   :math:`u \cdot v` is the dot product of ``u`` and ``v``.

7. ``Y = pdist(X, 'correlation')``

   Computes the correlation distance between vectors u and v. This is

   .. math::

      1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
               {{||(u - \bar{u})||}_2 {||(v - \bar{v})||}_2}

   where :math:`\bar{v}` is the mean of the elements of vector v,
   and :math:`x \cdot y` is the dot product of :math:`x` and :math:`y`.

8. ``Y = pdist(X, 'hamming')``

   Computes the normalized Hamming distance, or the proportion of
   those vector elements between two n-vectors ``u`` and ``v``
   which disagree. To save memory, the matrix ``X`` can be of type
   boolean.

9. ``Y = pdist(X, 'jaccard')``

   Computes the Jaccard distance between the points. Given two
   vectors, ``u`` and ``v``, the Jaccard distance is the
   proportion of those elements ``u[i]`` and ``v[i]`` that
   disagree where at least one of them is non-zero.

10. ``Y = pdist(X, 'chebyshev')``

   Computes the Chebyshev distance between the points. The
   Chebyshev distance between two n-vectors ``u`` and ``v`` is the
   maximum norm-1 distance between their respective elements. More
   precisely, the distance is given by

   .. math::

      d(u,v) = \max_i {|u_i-v_i|}

11. ``Y = pdist(X, 'canberra')``

   Computes the Canberra distance between the points. The
   Canberra distance between two points ``u`` and ``v`` is

   .. math::

     d(u,v) = \sum_i \frac{|u_i-v_i|}
                          {|u_i|+|v_i|}


12. ``Y = pdist(X, 'braycurtis')``

   Computes the Bray-Curtis distance between the points. The
   Bray-Curtis distance between two points ``u`` and ``v`` is


   .. math::

        d(u,v) = \frac{\sum_i {u_i-v_i}}
                      {\sum_i {u_i+v_i}}

13. ``Y = pdist(X, 'mahalanobis', VI=None)``

   Computes the Mahalanobis distance between the points. The
   Mahalanobis distance between two points ``u`` and ``v`` is
   :math:`(u-v)(1/V)(u-v)^T` where :math:`(1/V)` (the ``VI``
   variable) is the inverse covariance. If ``VI`` is not None,
   ``VI`` will be used as the inverse covariance matrix.

14. ``Y = pdist(X, 'yule')``

   Computes the Yule distance between each pair of boolean
   vectors. (see yule function documentation)

15. ``Y = pdist(X, 'matching')``

   Computes the matching distance between each pair of boolean
   vectors. (see matching function documentation)

16. ``Y = pdist(X, 'dice')``

   Computes the Dice distance between each pair of boolean
   vectors. (see dice function documentation)

17. ``Y = pdist(X, 'kulsinski')``

   Computes the Kulsinski distance between each pair of
   boolean vectors. (see kulsinski function documentation)

18. ``Y = pdist(X, 'rogerstanimoto')``

   Computes the Rogers-Tanimoto distance between each pair of
   boolean vectors. (see rogerstanimoto function documentation)

19. ``Y = pdist(X, 'russellrao')``

   Computes the Russell-Rao distance between each pair of
   boolean vectors. (see russellrao function documentation)

20. ``Y = pdist(X, 'sokalmichener')``

   Computes the Sokal-Michener distance between each pair of
   boolean vectors. (see sokalmichener function documentation)

21. ``Y = pdist(X, 'sokalsneath')``

   Computes the Sokal-Sneath distance between each pair of
   boolean vectors. (see sokalsneath function documentation)

22. ``Y = pdist(X, 'wminkowski')``

   Computes the weighted Minkowski distance between each pair of
   vectors. (see wminkowski function documentation)

23. ``Y = pdist(X, f)``

   Computes the distance between all pairs of vectors in X
   using the user supplied 2-arity function f. For example,
   Euclidean distance between the vectors could be computed
   as follows::

     dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))

   Note that you should avoid passing a reference to one of
   the distance functions defined in this library. For example,::

     dm = pdist(X, sokalsneath)

   would calculate the pair-wise distances between the vectors in
   X using the Python function sokalsneath. This would result in
   sokalsneath being called :math:`{n \choose 2}` times, which
   is inefficient. Instead, the optimized C version is more
   efficient, and we call it using the following syntax.::

     dm = pdist(X, 'sokalsneath')

Parameters
----------
X : ndarray
    An m by n array of m original observations in an
    n-dimensional space.
metric : str or function, optional
    The distance metric to use. The distance function can
    be 'braycurtis', 'canberra', 'chebyshev', 'cityblock',
    'correlation', 'cosine', 'dice', 'euclidean', 'hamming',
    'jaccard', 'kulsinski', 'mahalanobis', 'matching',
    'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
    'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'.
w : ndarray, optional
    The weight vector (for weighted Minkowski).
p : double, optional
    The p-norm to apply (for Minkowski, weighted and unweighted)
V : ndarray, optional
    The variance vector (for standardized Euclidean).
VI : ndarray, optional
    The inverse of the covariance matrix (for Mahalanobis).

Returns
-------
Y : ndarray
    Returns a condensed distance matrix Y.  For
    each :math:`i` and :math:`j` (where :math:`i&lt;j&lt;n`), the
    metric ``dist(u=X[i], v=X[j])`` is computed and stored in entry ``ij``.

See Also
--------
squareform : converts between condensed distance matrices and
             square distance matrices.

Notes
-----
See ``squareform`` for information on how to calculate the index of
this entry or to convert the condensed distance matrix to a
redundant square matrix.</docstring>
    <inputPortSpec arg="X" name="X" port_type="basic:List" show_port="True">
      <docstring>An m by n array of m original observations in an
n-dimensional space.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="metric" name="metric">
      <docstring>The distance metric to use. The distance function can
be 'braycurtis', 'canberra', 'chebyshev', 'cityblock',
'correlation', 'cosine', 'dice', 'euclidean', 'hamming',
'jaccard', 'kulsinski', 'mahalanobis', 'matching',
'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'.</docstring>
      <defaults>['euclidean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List">
      <docstring>The weight vector (for weighted Minkowski).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Float">
      <docstring>The p-norm to apply (for Minkowski, weighted and unweighted)</docstring>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="V" name="V" port_type="basic:List">
      <docstring>The variance vector (for standardized Euclidean).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="VI" name="VI" port_type="basic:List">
      <docstring>The inverse of the covariance matrix (for Mahalanobis).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Y" name="Y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns a condensed distance matrix Y.  For
each :math:`i` and :math:`j` (where :math:`i&lt;j&lt;n`), the
metric ``dist(u=X[i], v=X[j])`` is computed and stored in entry ``ij``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.rogerstanimoto" module_name="rogerstanimoto" namespace="'spatial|distance'">
    <docstring>Computes the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.

The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays
`u` and `v`, is defined as

.. math::
   \frac{R}
        {c_{TT} + c_{FF} + R}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
rogerstanimoto : double
    The Rogers-Tanimoto dissimilarity between vectors
    `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="rogerstanimoto" name="rogerstanimoto" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Rogers-Tanimoto dissimilarity between vectors
`u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.russellrao" module_name="russellrao" namespace="'spatial|distance'">
    <docstring>Computes the Russell-Rao dissimilarity between two boolean 1-D arrays.

The Russell-Rao dissimilarity between two boolean 1-D arrays, `u` and
`v`, is defined as

.. math::

  \frac{n - c_{TT}}
       {n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
russellrao : double
    The Russell-Rao dissimilarity between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="russellrao" name="russellrao" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Russell-Rao dissimilarity between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.seuclidean" module_name="seuclidean" namespace="'spatial|distance'">
    <docstring>Returns the standardized Euclidean distance between two 1-D arrays.

The standardized Euclidean distance between `u` and `v`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
V : (N,) array_like
    `V` is an 1-D array of component variances. It is usually computed
    among a larger collection vectors.

Returns
-------
seuclidean : double
    The standardized Euclidean distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="V" name="V" port_type="basic:List" show_port="True">
      <docstring>`V` is an 1-D array of component variances. It is usually computed
among a larger collection vectors.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="seuclidean" name="seuclidean" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The standardized Euclidean distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.sokalmichener" module_name="sokalmichener" namespace="'spatial|distance'">
    <docstring>Computes the Sokal-Michener dissimilarity between two boolean 1-D arrays.

The Sokal-Michener dissimilarity between boolean 1-D arrays `u` and `v`,
is defined as

.. math::

   \frac{R}
        {S + R}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n`, :math:`R = 2 * (c_{TF} + c_{FT})` and
:math:`S = c_{FF} + c_{TT}`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
sokalmichener : double
    The Sokal-Michener dissimilarity between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sokalmichener" name="sokalmichener" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Sokal-Michener dissimilarity between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.sokalsneath" module_name="sokalsneath" namespace="'spatial|distance'">
    <docstring>Computes the Sokal-Sneath dissimilarity between two boolean 1-D arrays.

The Sokal-Sneath dissimilarity between `u` and `v`,

.. math::

   \frac{R}
        {c_{TT} + R}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
sokalsneath : double
    The Sokal-Sneath dissimilarity between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sokalsneath" name="sokalsneath" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Sokal-Sneath dissimilarity between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.sqeuclidean" module_name="sqeuclidean" namespace="'spatial|distance'">
    <docstring>Computes the squared Euclidean distance between two 1-D arrays.

The squared Euclidean distance between `u` and `v` is defined as

.. math::

   {||u-v||}_2^2.


Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
sqeuclidean : double
    The squared Euclidean distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="sqeuclidean" name="sqeuclidean" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The squared Euclidean distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.squareform" module_name="squareform" namespace="'spatial|distance'">
    <docstring>Converts a vector-form distance vector to a square-form distance
matrix, and vice-versa.

Parameters
----------
X : ndarray
    Either a condensed or redundant distance matrix.
force : str, optional
    As with MATLAB(TM), if force is equal to 'tovector' or 'tomatrix',
    the input will be treated as a distance matrix or distance vector
    respectively.
checks : bool, optional
    If `checks` is set to False, no checks will be made for matrix
    symmetry nor zero diagonals. This is useful if it is known that
    ``X - X.T1`` is small and ``diag(X)`` is close to zero.
    These values are ignored any way so they do not disrupt the
    squareform transformation.

Returns
-------
Y : ndarray
    If a condensed distance matrix is passed, a redundant one is
    returned, or if a redundant one is passed, a condensed distance
    matrix is returned.

Notes
-----

1. v = squareform(X)

   Given a square d-by-d symmetric distance matrix X,
   ``v=squareform(X)`` returns a ``d * (d-1) / 2`` (or
   `${n \choose 2}$`) sized vector v.

  v[{n \choose 2}-{n-i \choose 2} + (j-i-1)] is the distance
  between points i and j. If X is non-square or asymmetric, an error
  is returned.

2. X = squareform(v)

  Given a d*d(-1)/2 sized v for some integer d&gt;=2 encoding distances
  as described, X=squareform(v) returns a d by d distance matrix X. The
  X[i, j] and X[j, i] values are set to
  v[{n \choose 2}-{n-i \choose 2} + (j-u-1)] and all
  diagonal elements are zero.</docstring>
    <inputPortSpec arg="X" name="X" port_type="basic:List" show_port="True">
      <docstring>Either a condensed or redundant distance matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="force" name="force">
      <docstring>As with MATLAB(TM), if force is equal to 'tovector' or 'tomatrix',
the input will be treated as a distance matrix or distance vector
respectively.</docstring>
      <defaults>['no']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="checks" name="checks" port_type="basic:Boolean">
      <docstring>If `checks` is set to False, no checks will be made for matrix
symmetry nor zero diagonals. This is useful if it is known that
``X - X.T1`` is small and ``diag(X)`` is close to zero.
These values are ignored any way so they do not disrupt the
squareform transformation.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Y" name="Y" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>If a condensed distance matrix is passed, a redundant one is
returned, or if a redundant one is passed, a condensed distance
matrix is returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.wminkowski" module_name="wminkowski" namespace="'spatial|distance'">
    <docstring>Computes the weighted Minkowski distance between two 1-D arrays.

The weighted Minkowski distance between `u` and `v`, defined as

.. math::

   \left(\sum{(w_i |u_i - v_i|^p)}\right)^{1/p}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
p : int
    The order of the norm of the difference :math:`{||u-v||}_p`.
w : (N,) array_like
    The weight vector.

Returns
-------
wminkowski : double
    The weighted Minkowski distance between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" name="u" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer" show_port="True">
      <docstring>The order of the norm of the difference :math:`{||u-v||}_p`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" name="w" port_type="basic:List" show_port="True">
      <docstring>The weight vector.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="wminkowski" name="wminkowski" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The weighted Minkowski distance between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.distance.yule" module_name="yule" namespace="'spatial|distance'">
    <docstring>Computes the Yule dissimilarity between two boolean 1-D arrays.

The Yule dissimilarity is defined as

.. math::

     \frac{R}{c_{TT} * c_{FF} + \frac{R}{2}}

where :math:`c_{ij}` is the number of occurrences of
:math:`\mathtt{u[k]} = i` and :math:`\mathtt{v[k]} = j` for
:math:`k &lt; n` and :math:`R = 2.0 * c_{TF} * c_{FT}`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
yule : double
    The Yule dissimilarity between vectors `u` and `v`.</docstring>
    <inputPortSpec arg="u" depth="1" name="u" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" depth="1" name="v" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="yule" name="yule" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Yule dissimilarity between vectors `u` and `v`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.agm" module_name="agm" namespace="'special'">
    <docstring>Arithmetic, Geometric Mean

Start with a_0=a and b_0=b and iteratively compute

a_{n+1} = (a_n+b_n)/2
b_{n+1} = sqrt(a_n*b_n)

until a_n=b_n.   The result is agm(a,b)

agm(a,b)=agm(b,a)
agm(a,a) = a
min(a,b) &lt; agm(a,b) &lt; max(a,b)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ai_zeros" module_name="ai_zeros" namespace="'special'" output_type="list">
    <docstring>Compute the zeros of Airy Functions Ai(x) and Ai'(x), a and a'
respectively, and the associated values of Ai(a') and Ai'(a).

Returns
-------
a[l-1]   -- the lth zero of Ai(x)
ap[l-1]  -- the lth zero of Ai'(x)
ai[l-1]  -- Ai(ap[l-1])
aip[l-1] -- Ai'(a[l-1])</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="1" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="2" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.assoc_laguerre" module_name="assoc_laguerre" namespace="'special'">
    <docstring>Returns the n-th order generalized (associated) Laguerre polynomial.

The polynomial :math:`L^(alpha)_n(x)` is orthogonal over ``[0, inf)``,
with weighting function ``exp(-x) * x**alpha`` with ``alpha &gt; -1``.

Notes
-----
`assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with
reversed argument order ``(x, n, k=0.0) --&gt; (n, k, x)``.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="k" name="k" port_type="basic:Float" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.bei_zeros" module_name="bei_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function bei x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.beip_zeros" module_name="beip_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function bei' x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ber_zeros" module_name="ber_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function ber x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.bernoulli" module_name="bernoulli" namespace="'special'">
    <docstring>Return an array of the Bernoulli numbers B0..Bn</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.berp_zeros" module_name="berp_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function ber' x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.bessel_diff_formula" module_name="bessel_diff_formula" namespace="'special'">
    <docstring>`_bessel_diff_formula` is deprecated!
bessel_diff_formula is a private function, do not use it!</docstring>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.bi_zeros" module_name="bi_zeros" namespace="'special'" output_type="list">
    <docstring>Compute the zeros of Airy Functions Bi(x) and Bi'(x), b and b'
respectively, and the associated values of Ai(b') and Ai'(b).

Returns
-------
b[l-1]   -- the lth zero of Bi(x)
bp[l-1]  -- the lth zero of Bi'(x)
bi[l-1]  -- Bi(bp[l-1])
bip[l-1] -- Bi'(b[l-1])</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="1" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="2" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="3" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.c_roots" module_name="c_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Chebyshev (first kind) quadrature

Computes the sample points and weights for Gauss-Chebyshev quadrature.
The sample points are the roots of the `n`th degree Chebyshev polynomial of
the first kind, :math:`C_n(x)`.  These sample points and weights correctly
integrate polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-2, 2]` with weight function :math:`f(x) = 1/\sqrt{1 - (x/2)^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.cg_roots" module_name="cg_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Gegenbauer quadrature

Computes the sample points and weights for Gauss-Gegenbauer quadrature.
The sample points are the roots of the `n`th degree Gegenbauer polynomial,
:math:`C^{\alpha}_n(x)`.  These sample points and weights correctly
integrate polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-1, 1]` with weight function :math:`f(x) = (1-x^2)^{\alpha-1/2}`.

Parameters
----------
n : int
    quadrature order
alpha : float
    alpha must be &gt; -0.5
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float" show_port="True">
      <docstring>alpha must be &gt; -0.5</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.chebyc" module_name="chebyc" namespace="'special'">
    <docstring>Return nth order Chebyshev polynomial of first kind, Cn(x).  Orthogonal
over [-2,2] with weight function (1-(x/2)**2)**(-1/2).</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.chebys" module_name="chebys" namespace="'special'">
    <docstring>Return nth order Chebyshev polynomial of second kind, Sn(x).  Orthogonal
over [-2,2] with weight function (1-(x/2)**2)**(1/2).</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.chebyt" module_name="chebyt" namespace="'special'">
    <docstring>Return nth order Chebyshev polynomial of first kind, Tn(x).  Orthogonal
over [-1,1] with weight function (1-x**2)**(-1/2).</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.chebyu" module_name="chebyu" namespace="'special'">
    <docstring>Return nth order Chebyshev polynomial of second kind, Un(x).  Orthogonal
over [-1,1] with weight function (1-x**2)**(1/2).</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.clpmn" module_name="clpmn" namespace="'special'" output_type="list">
    <docstring>Associated Legendre function of the first kind, Pmn(z)

Computes the (associated) Legendre function of the first kind
of order m and degree n,::

    Pmn(z) = P_n^m(z)

and its derivative, ``Pmn'(z)``.  Returns two arrays of size
``(m+1, n+1)`` containing ``Pmn(z)`` and ``Pmn'(z)`` for all
orders from ``0..m`` and degrees from ``0..n``.

Parameters
----------
m : int
   ``|m| &lt;= n``; the order of the Legendre function.
n : int
   where ``n &gt;= 0``; the degree of the Legendre function.  Often
   called ``l`` (lower case L) in descriptions of the associated
   Legendre function
z : float or complex
    Input value.
type : int, optional
   takes values 2 or 3
   2: cut on the real axis ``|x| &gt; 1``
   3: cut on the real axis ``-1 &lt; x &lt; 1`` (default)

Returns
-------
Pmn_z : (m+1, n+1) array
   Values for all orders ``0..m`` and degrees ``0..n``
Pmn_d_z : (m+1, n+1) array
   Derivatives for all orders ``0..m`` and degrees ``0..n``

See Also
--------
lpmn: associated Legendre functions of the first kind for real z

Notes
-----
By default, i.e. for ``type=3``, phase conventions are chosen according
to [1]_ such that the function is analytic. The cut lies on the interval
(-1, 1). Approaching the cut from above or below in general yields a phase
factor with respect to Ferrer's function of the first kind
(cf. `lpmn`).

For ``type=2`` a cut at ``|x| &gt; 1`` is chosen. Approaching the real values
on the interval (-1, 1) in the complex plane yields Ferrer's function
of the first kind.

References
----------
.. [1] NIST Digital Library of Mathematical Functions
       http://dlmf.nist.gov/14.21</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>``|m| &lt;= n``; the order of the Legendre function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>where ``n &gt;= 0``; the degree of the Legendre function.  Often
called ``l`` (lower case L) in descriptions of the associated
Legendre function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Float" show_port="True">
      <docstring>Input value.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type" name="type" port_type="basic:Integer">
      <docstring>takes values 2 or 3
2: cut on the real axis ``|x| &gt; 1``
3: cut on the real axis ``-1 &lt; x &lt; 1`` (default)</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Pmn_z" name="Pmn_z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Values for all orders ``0..m`` and degrees ``0..n``</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Pmn_d_z" name="Pmn_d_z" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Derivatives for all orders ``0..m`` and degrees ``0..n``</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.comb" module_name="comb" namespace="'special'">
    <docstring>The number of combinations of N things taken k at a time.

This is often expressed as "N choose k".

Parameters
----------
N : int, ndarray
    Number of things.
k : int, ndarray
    Number of elements taken.
exact : bool, optional
    If `exact` is False, then floating point precision is used, otherwise
    exact long integer is computed.
repetition : bool, optional
    If `repetition` is True, then the number of combinations with
    repetition is computed.

Returns
-------
val : int, ndarray
    The total number of combinations.

Notes
-----
- Array arguments accepted only for exact=False case.
- If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.

Examples
--------
&gt;&gt;&gt; from scipy.special import comb
&gt;&gt;&gt; k = np.array([3, 4])
&gt;&gt;&gt; n = np.array([10, 10])
&gt;&gt;&gt; comb(n, k, exact=False)
array([ 120.,  210.])
&gt;&gt;&gt; comb(10, 3, exact=True)
120L
&gt;&gt;&gt; comb(10, 3, exact=True, repetition=True)
220L</docstring>
    <inputPortSpec arg="N" depth="1" name="N" port_type="basic:Integer" show_port="True">
      <docstring>Number of things.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" depth="1" name="k" port_type="basic:Integer" show_port="True">
      <docstring>Number of elements taken.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>If `exact` is False, then floating point precision is used, otherwise
exact long integer is computed.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="repetition" name="repetition" port_type="basic:Boolean">
      <docstring>If `repetition` is True, then the number of combinations with
repetition is computed.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="val" depth="1" name="val" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The total number of combinations.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.diric" module_name="diric" namespace="'special'">
    <docstring>Return the periodic sinc function, also called the Dirichlet function.

The Dirichlet function is defined as::

    diric(x) = sin(x * n/2) / (n * sin(x / 2)),

where n is a positive integer.

Parameters
----------
x : array_like
    Input data
n : int
    Integer defining the periodicity.

Returns
-------
diric : ndarray

Examples
--------
&gt;&gt;&gt; from scipy import special
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; x = np.linspace(-8*np.pi, 8*np.pi, num=201)
&gt;&gt;&gt; plt.figure(figsize=(8,8));
&gt;&gt;&gt; for idx, n in enumerate([2,3,4,9]):
...     plt.subplot(2, 2, idx+1)
...     plt.plot(x, special.diric(x, n))
...     plt.title('diric, n={}'.format(n))
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Integer defining the periodicity.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="diric" name="diric" port_type="basic:List" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ellip_harm" module_name="ellip_harm" namespace="'special'">
    <docstring>Ellipsoidal harmonic functions E^p_n(l)

These are also known as Lame functions of the first kind, and are
solutions to the Lame equation:

.. math:: (s^2 - h^2)(s^2 - k^2)E''(s) + s(2s^2 - h^2 - k^2)E'(s) + (a - q s^2)E(s) = 0

where :math:`q = (n+1)n` and :math:`a` is the eigenvalue (not
returned) corresponding to the solutions.

Parameters
----------
h2 : float
    ``h**2``
k2 : float
    ``k**2``; should be larger than ``h**2``
n : int
    Degree
s : float
    Coordinate
p : int
    Order, can range between [1,2n+1]
signm : {1, -1}, optional
    Sign of prefactor of functions. Can be +/-1. See Notes.
signn : {1, -1}, optional
    Sign of prefactor of functions. Can be +/-1. See Notes.

Returns
-------
E : float
    the harmonic :math:`E^p_n(s)`

See Also
--------
ellip_harm_2, ellip_normal

Notes
-----
The geometric intepretation of the ellipsoidal functions is
explained in [2]_, [3]_, [4]_.  The `signm` and `signn` arguments control the
sign of prefactors for functions according to their type::

    K : +1
    L : signm
    M : signn
    N : signm*signn

.. versionadded:: 0.15.0

References
----------
.. [1] Digital Libary of Mathematical Functions 29.12
   http://dlmf.nist.gov/29.12
.. [2] Bardhan and Knepley, "Computational science and
   re-discovery: open-source implementations of
   ellipsoidal harmonics for problems in potential theory",
   Comput. Sci. Disc. 5, 014006 (2012)
   doi:10.1088/1749-4699/5/1/014006
.. [3] David J.and Dechambre P, "Computation of Ellipsoidal
   Gravity Field Harmonics for small solar system bodies"
   pp. 30-36, 2000
.. [4] George Dassios, "Ellipsoidal Harmonics: Theory and Applications"
   pp. 418, 2012

Examples
--------
&gt;&gt;&gt; from scipy.special import ellip_harm
&gt;&gt;&gt; w = ellip_harm(5,8,1,1,2.5)
&gt;&gt;&gt; w
2.5

Check that the functions indeed are solutions to the Lame equation:

&gt;&gt;&gt; from scipy.interpolate import UnivariateSpline
&gt;&gt;&gt; def eigenvalue(f, df, ddf):
...     r = ((s**2 - h**2)*(s**2 - k**2)*ddf + s*(2*s**2 - h**2 - k**2)*df - n*(n+1)*s**2*f)/f
...     return -r.mean(), r.std()
&gt;&gt;&gt; s = np.linspace(0.1, 10, 200)
&gt;&gt;&gt; k, h, n, p = 8.0, 2.2, 3, 2
&gt;&gt;&gt; E = ellip_harm(h**2, k**2, n, p, s)
&gt;&gt;&gt; E_spl = UnivariateSpline(s, E)
&gt;&gt;&gt; a, a_err = eigenvalue(E_spl(s), E_spl(s,1), E_spl(s,2))
&gt;&gt;&gt; a, a_err
(583.44366156701483, 6.4580890640310646e-11)</docstring>
    <inputPortSpec arg="h2" name="h2" port_type="basic:Float" show_port="True">
      <docstring>``h**2``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k2" name="k2" port_type="basic:Float" show_port="True">
      <docstring>``k**2``; should be larger than ``h**2``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Degree</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:Float" show_port="True">
      <docstring>Coordinate</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer" show_port="True">
      <docstring>Order, can range between [1,2n+1]</docstring>
    </inputPortSpec>
    <inputPortSpec arg="signm" name="signm" port_type="basic:Integer">
      <docstring>Sign of prefactor of functions. Can be +/-1. See Notes.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, -1]]</values>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="signn" name="signn" port_type="basic:Integer">
      <docstring>Sign of prefactor of functions. Can be +/-1. See Notes.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, -1]]</values>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="E" name="E" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>the harmonic :math:`E^p_n(s)`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ellip_harm_2" module_name="ellip_harm_2" namespace="'special'">
    <docstring>Ellipsoidal harmonic functions F^p_n(l)

These are also known as Lame functions of the second kind, and are
solutions to the Lame equation:

.. math:: (s^2 - h^2)(s^2 - k^2)F''(s) + s(2s^2 - h^2 - k^2)F'(s) + (a - q s^2)F(s) = 0

where :math:`q = (n+1)n` and :math:`a` is the eigenvalue (not
returned) corresponding to the solutions.

Parameters
----------
h2 : float
    ``h**2``
k2 : float
    ``k**2``; should be larger than ``h**2``
n : int
    Degree.
p : int
    Order, can range between [1,2n+1].
s : float
    Coordinate

Returns
-------
F : float
    The harmonic :math:`F^p_n(s)`

Notes
-----
Lame functions of the second kind are related to the functions of the first kind:

.. math::

   F^p_n(s)=(2n + 1)E^p_n(s)\int_{0}^{1/s}\frac{du}{(E^p_n(1/u))^2\sqrt{(1-u^2k^2)(1-u^2h^2)}}

.. versionadded:: 0.15.0

See Also
--------
ellip_harm, ellip_normal

Examples
--------
&gt;&gt;&gt; from scipy.special import ellip_harm_2
&gt;&gt;&gt; w = ellip_harm_2(5,8,2,1,10)
&gt;&gt;&gt; w
0.00108056853382</docstring>
    <inputPortSpec arg="h2" name="h2" port_type="basic:Float" show_port="True">
      <docstring>``h**2``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k2" name="k2" port_type="basic:Float" show_port="True">
      <docstring>``k**2``; should be larger than ``h**2``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Degree.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer" show_port="True">
      <docstring>Order, can range between [1,2n+1].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:Float" show_port="True">
      <docstring>Coordinate</docstring>
    </inputPortSpec>
    <outputPortSpec arg="F" name="F" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The harmonic :math:`F^p_n(s)`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ellip_normal" module_name="ellip_normal" namespace="'special'">
    <docstring>Ellipsoidal harmonic normalization constants gamma^p_n

The normalization constant is defined as

.. math::

   \gamma^p_n=8\int_{0}^{h}dx\int_{h}^{k}dy\frac{(y^2-x^2)(E^p_n(y)E^p_n(x))^2}{\sqrt((k^2-y^2)(y^2-h^2)(h^2-x^2)(k^2-x^2)}

Parameters
----------
h2 : float
    ``h**2``
k2 : float
    ``k**2``; should be larger than ``h**2``
n : int
    Degree.
p : int
    Order, can range between [1,2n+1].

Returns
-------
gamma : float
    The normalization constant :math:`\gamma^p_n`

See Also
--------
ellip_harm, ellip_harm_2

Notes
-----
.. versionadded:: 0.15.0

Examples
--------
&gt;&gt;&gt; from scipy.special import ellip_normal
&gt;&gt;&gt; w = ellip_normal(5,8,3,7)
&gt;&gt;&gt; w
1723.38796997</docstring>
    <inputPortSpec arg="h2" name="h2" port_type="basic:Float" show_port="True">
      <docstring>``h**2``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k2" name="k2" port_type="basic:Float" show_port="True">
      <docstring>``k**2``; should be larger than ``h**2``</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Degree.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Integer" show_port="True">
      <docstring>Order, can range between [1,2n+1].</docstring>
    </inputPortSpec>
    <outputPortSpec arg="gamma" name="gamma" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The normalization constant :math:`\gamma^p_n`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ellipk" module_name="ellipk" namespace="'special'">
    <docstring>Complete elliptic integral of the first kind

This function is defined as

.. math:: K(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{-1/2} dt

Parameters
----------
m : array_like
    The parameter of the elliptic integral.

Returns
-------
K : array_like
    Value of the elliptic integral.

Notes
-----
For more precision around point m = 1, use `ellipkm1`.

See Also
--------
ellipkm1 : Complete elliptic integral of the first kind around m = 1
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:List" show_port="True">
      <docstring>The parameter of the elliptic integral.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="K" name="K" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Value of the elliptic integral.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.erf_zeros" module_name="erf_zeros" namespace="'special'">
    <docstring>Compute nt complex zeros of the error function erf(z).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.erfcinv" module_name="erfcinv" namespace="'special'">
    <docstring>Inverse function for erfc</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.erfinv" module_name="erfinv" namespace="'special'">
    <docstring>Inverse function for erf</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.errprint" module_name="errprint" namespace="'special'">
    <docstring>errprint(inflag=None)

Sets or returns the error printing flag for special functions.

Parameters
----------
inflag : bool, optional
    Whether warnings concerning evaluation of special functions in
    scipy.special are shown. If omitted, no change is made to the
    current setting.

Returns
-------
old_flag
    Previous value of the error flag</docstring>
    <inputPortSpec arg="inflag" name="inflag" port_type="basic:Boolean">
      <docstring>Whether warnings concerning evaluation of special functions in
scipy.special are shown. If omitted, no change is made to the
current setting.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Previous value of the error flag</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.euler" module_name="euler" namespace="'special'">
    <docstring>Return an array of the Euler numbers E0..En (inclusive)</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.factorial" module_name="factorial" namespace="'special'">
    <docstring>The factorial function, n! = special.gamma(n+1).

If exact is 0, then floating point precision is used, otherwise
exact long integer is computed.

- Array argument accepted only for exact=False case.
- If n&lt;0, the return value is 0.

Parameters
----------
n : int or array_like of ints
    Calculate ``n!``.  Arrays are only supported with `exact` set
    to False.  If ``n &lt; 0``, the return value is 0.
exact : bool, optional
    The result can be approximated rapidly using the gamma-formula
    above.  If `exact` is set to True, calculate the
    answer exactly using integer arithmetic. Default is False.

Returns
-------
nf : float or int
    Factorial of `n`, as an integer or a float depending on `exact`.

Examples
--------
&gt;&gt;&gt; from scipy.special import factorial
&gt;&gt;&gt; arr = np.array([3,4,5])
&gt;&gt;&gt; factorial(arr, exact=False)
array([   6.,   24.,  120.])
&gt;&gt;&gt; factorial(5, exact=True)
120L</docstring>
    <inputPortSpec arg="n" name="nScalar" port_type="basic:Integer" show_port="True">
      <docstring>Calculate ``n!``.  Arrays are only supported with `exact` set
to False.  If ``n &lt; 0``, the return value is 0.</docstring>
      <alternateSpec arg="n" depth="1" name="nSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>The result can be approximated rapidly using the gamma-formula
above.  If `exact` is set to True, calculate the
answer exactly using integer arithmetic. Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nf" name="nf" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Factorial of `n`, as an integer or a float depending on `exact`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.factorial2" module_name="factorial2" namespace="'special'">
    <docstring>Double factorial.

This is the factorial with every second value skipped, i.e.,
``7!! = 7 * 5 * 3 * 1``.  It can be approximated numerically as::

  n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd
      = 2**(n/2) * (n/2)!                           n even

Parameters
----------
n : int or array_like
    Calculate ``n!!``.  Arrays are only supported with `exact` set
    to False.  If ``n &lt; 0``, the return value is 0.
exact : bool, optional
    The result can be approximated rapidly using the gamma-formula
    above (default).  If `exact` is set to True, calculate the
    answer exactly using integer arithmetic.

Returns
-------
nff : float or int
    Double factorial of `n`, as an int or a float depending on
    `exact`.

Examples
--------
&gt;&gt;&gt; from scipy.special import factorial2
&gt;&gt;&gt; factorial2(7, exact=False)
array(105.00000000000001)
&gt;&gt;&gt; factorial2(7, exact=True)
105L</docstring>
    <inputPortSpec arg="n" name="nScalar" port_type="basic:Integer" show_port="True">
      <docstring>Calculate ``n!!``.  Arrays are only supported with `exact` set
to False.  If ``n &lt; 0``, the return value is 0.</docstring>
      <alternateSpec arg="n" name="nSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>The result can be approximated rapidly using the gamma-formula
above (default).  If `exact` is set to True, calculate the
answer exactly using integer arithmetic.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nff" name="nff" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Double factorial of `n`, as an int or a float depending on
`exact`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.factorialk" module_name="factorialk" namespace="'special'">
    <docstring>n(!!...!)  = multifactorial of order k
k times

Parameters
----------
n : int
    Calculate multifactorial. If `n` &lt; 0, the return value is 0.
k : int
    Order of multifactorial.
exact : bool, optional
    If exact is set to True, calculate the answer exactly using
    integer arithmetic.

Returns
-------
val : int
    Multi factorial of `n`.

Raises
------
NotImplementedError
    Raises when exact is False

Examples
--------
&gt;&gt;&gt; from scipy.special import factorialk
&gt;&gt;&gt; factorialk(5, 1, exact=True)
120L
&gt;&gt;&gt; factorialk(5, 3, exact=True)
10L</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>Calculate multifactorial. If `n` &lt; 0, the return value is 0.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer" show_port="True">
      <docstring>Order of multifactorial.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>If exact is set to True, calculate the answer exactly using
integer arithmetic.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="val" name="val" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Multi factorial of `n`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.fresnel_zeros" module_name="fresnel_zeros" namespace="'special'">
    <docstring>Compute nt complex zeros of the sine and cosine Fresnel integrals
S(z) and C(z).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.fresnelc_zeros" module_name="fresnelc_zeros" namespace="'special'">
    <docstring>Compute nt complex zeros of the cosine Fresnel integral C(z).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.fresnels_zeros" module_name="fresnels_zeros" namespace="'special'">
    <docstring>Compute nt complex zeros of the sine Fresnel integral S(z).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.gegenbauer" module_name="gegenbauer" namespace="'special'">
    <docstring>Return the nth order Gegenbauer (ultraspherical) polynomial,
C^(alpha)_n(x), orthogonal over [-1,1] with weighting function
(1-x**2)**(alpha-1/2) with alpha &gt; -1/2</docstring>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.genlaguerre" module_name="genlaguerre" namespace="'special'">
    <docstring>Returns the nth order generalized (associated) Laguerre polynomial,
L^(alpha)_n(x), orthogonal over [0,inf) with weighting function
exp(-x) x**alpha with alpha &gt; -1</docstring>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.h1vp" module_name="h1vp" namespace="'special'">
    <docstring>Return the nth derivative of H1v(z) with respect to z.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.h2vp" module_name="h2vp" namespace="'special'">
    <docstring>Return the nth derivative of H2v(z) with respect to z.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.h_roots" module_name="h_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Hermite (physicst's) quadrature

Computes the sample points and weights for Gauss-Hermite quadrature.
The sample points are the roots of the `n`th degree Hermite polynomial,
:math:`H_n(x)`.  These sample points and weights correctly integrate
polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-inf, inf]` with weight function :math:`f(x) = e^{-x^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

Notes
-----
For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.

For n larger than 150 an optimal asymptotic algorithm is applied
which computes nodes and weights in a numerically stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.

See Also
--------
integrate.quadrature
integrate.fixed_quad
numpy.polynomial.hermite.hermgauss

References
----------
.. [townsend.trogdon.olver-2014]
   Townsend, A. and Trogdon, T. and Olver, S. (2014)
   *Fast computation of Gauss quadrature nodes and
   weights on the whole real line*. ArXiv 1410.5286.

.. [townsend.trogdon.olver-2015]
   Townsend, A. and Trogdon, T. and Olver, S. (2015)
   *Fast computation of Gauss quadrature nodes and
   weights on the whole real line*.
   IMA Journal of Numerical Analysis
   doi: 10.1093/imanum/drv002</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.he_roots" module_name="he_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Hermite (statistician's) quadrature

Computes the sample points and weights for Gauss-Hermite quadrature.
The sample points are the roots of the `n`th degree Hermite polynomial,
:math:`He_n(x)`.  These sample points and weights correctly integrate
polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-inf, inf]` with weight function :math:`f(x) = e^{-(x/2)^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

Notes
-----
For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.

For n larger than 150 an optimal asymptotic algorithm is used
which computes nodes and weights in a numerical stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.

See Also
--------
integrate.quadrature
integrate.fixed_quad
numpy.polynomial.hermite_e.hermegauss</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.hermite" module_name="hermite" namespace="'special'">
    <docstring>Return the nth order Hermite polynomial, H_n(x), orthogonal over
(-inf,inf) with weighting function exp(-x**2)</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.hermitenorm" module_name="hermitenorm" namespace="'special'">
    <docstring>Return the nth order normalized Hermite polynomial, He_n(x), orthogonal
over (-inf,inf) with weighting function exp(-(x/2)**2)</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.hyp0f1" module_name="hyp0f1" namespace="'special'">
    <docstring>Confluent hypergeometric limit function 0F1.

Parameters
----------
v, z : array_like
    Input values.

Returns
-------
hyp0f1 : ndarray
    The confluent hypergeometric limit function.

Notes
-----
This function is defined as:

.. math:: _0F_1(v,z) = \sum_{k=0}^{\inf}\frac{z^k}{(v)_k k!}.

It's also the limit as q -&gt; infinity of ``1F1(q;v;z/q)``, and satisfies
the differential equation :math:`f''(z) + vf'(z) = f(z)`.</docstring>
    <inputPortSpec arg="v" name="v" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Input values.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="hyp0f1" name="hyp0f1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The confluent hypergeometric limit function.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ivp" module_name="ivp" namespace="'special'">
    <docstring>Return the nth derivative of Iv(z) with respect to z.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.j_roots" module_name="j_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Jacobi quadrature

Computes the sample points and weights for Gauss-Jacobi quadrature. The
sample points are the roots of the `n`th degree Jacobi polynomial,
:math:`P^{\alpha, \beta}_n(x)`.  These sample points and weights
correctly integrate polynomials of degree :math:`2*n - 1` or less over the
interval :math:`[-1, 1]` with weight function
:math:`f(x) = (1 - x)^{\alpha} (1 + x)^{\beta}`.

Parameters
----------
n : int
    quadrature order
alpha : float
    alpha must be &gt; -1
beta : float
    beta must be &gt; 0
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float" show_port="True">
      <docstring>alpha must be &gt; -1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="beta" name="beta" port_type="basic:Float" show_port="True">
      <docstring>beta must be &gt; 0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.jacobi" module_name="jacobi" namespace="'special'">
    <docstring>Returns the nth order Jacobi polynomial, P^(alpha,beta)_n(x)
orthogonal over [-1,1] with weighting function
(1-x)**alpha (1+x)**beta with alpha,beta &gt; -1.</docstring>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="beta" name="beta" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.jn_zeros" module_name="jn_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Bessel function Jn(x).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.jnjnp_zeros" module_name="jnjnp_zeros" namespace="'special'" output_type="list">
    <docstring>Compute nt (&lt;=1200) zeros of the Bessel functions Jn and Jn'
and arange them in order of their magnitudes.

Returns
-------
zo[l-1] : ndarray
    Value of the lth zero of Jn(x) and Jn'(x). Of length `nt`.
n[l-1] : ndarray
    Order of the Jn(x) or Jn'(x) associated with lth zero. Of length `nt`.
m[l-1] : ndarray
    Serial number of the zeros of Jn(x) or Jn'(x) associated
    with lth zero. Of length `nt`.
t[l-1] : ndarray
    0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn'(x). Of
    length `nt`.

See Also
--------
jn_zeros, jnp_zeros : to get separated arrays of zeros.</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="zo[l-1]" name="zo[l-1]" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Value of the lth zero of Jn(x) and Jn'(x). Of length `nt`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="n[l-1]" name="n[l-1]" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Order of the Jn(x) or Jn'(x) associated with lth zero. Of length `nt`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="m[l-1]" name="m[l-1]" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>Serial number of the zeros of Jn(x) or Jn'(x) associated
with lth zero. Of length `nt`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="t[l-1]" name="t[l-1]" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn'(x). Of
length `nt`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.jnp_zeros" module_name="jnp_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Bessel function Jn'(x).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.jnyn_zeros" module_name="jnyn_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Bessel functions Jn(x), Jn'(x), Yn(x), and
Yn'(x), respectively. Returns 4 arrays of length nt.

See jn_zeros, jnp_zeros, yn_zeros, ynp_zeros to get separate arrays.</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.js_roots" module_name="js_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Jacobi (shifted) quadrature

Computes the sample points and weights for Gauss-Jacobi (shifted)
quadrature. The sample points are the roots of the `n`th degree shifted
Jacobi polynomial, :math:`G^{p,q}_n(x)`.  These sample points and weights
correctly integrate polynomials of degree :math:`2*n - 1` or less over the
interval :math:`[0, 1]` with weight function
:math:`f(x) = (1 - x)^{p-q} x^{q-1}`

Parameters
----------
n : int
    quadrature order
p1 : float
    (p1 - q1) must be &gt; -1
q1 : float
    q1 must be &gt; 0
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p1" name="p1" port_type="basic:Float" show_port="True">
      <docstring>(p1 - q1) must be &gt; -1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="q1" name="q1" port_type="basic:Float" show_port="True">
      <docstring>q1 must be &gt; 0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.jvp" module_name="jvp" namespace="'special'">
    <docstring>Return the nth derivative of Jv(z) with respect to z.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.kei_zeros" module_name="kei_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function kei x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.keip_zeros" module_name="keip_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function kei' x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.kelvin_zeros" module_name="kelvin_zeros" namespace="'special'">
    <docstring>Compute nt zeros of all the Kelvin functions returned in a
length 8 tuple of arrays of length nt.
The tuple containse the arrays of zeros of
(ber, bei, ker, kei, ber', bei', ker', kei')</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ker_zeros" module_name="ker_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function ker x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.kerp_zeros" module_name="kerp_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Kelvin function ker' x</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.kvp" module_name="kvp" namespace="'special'">
    <docstring>Return the nth derivative of Kv(z) with respect to z.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.l_roots" module_name="l_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Laguerre quadrature

Computes the sample points and weights for Gauss-Laguerre quadrature.
The sample points are the roots of the `n`th degree Laguerre polynomial,
:math:`L_n(x)`.  These sample points and weights correctly integrate
polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[0, inf]` with weight function :math:`f(x) = e^{-x}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad
numpy.polynomial.laguerre.laggauss</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.la_roots" module_name="la_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-generalized Laguerre quadrature

Computes the sample points and weights for Gauss-generalized Laguerre
quadrature. The sample points are the roots of the `n`th degree generalized
Laguerre polynomial, :math:`L^{\alpha}_n(x)`.  These sample points and
weights correctly integrate polynomials of degree :math:`2*n - 1` or less
over the interval :math:`[0, inf]` with weight function
:math:`f(x) = x^{\alpha} e^{-x}`.

Parameters
----------
n : int
    quadrature order
alpha : float
    alpha must be &gt; -1
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float" show_port="True">
      <docstring>alpha must be &gt; -1</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.laguerre" module_name="laguerre" namespace="'special'">
    <docstring>Return the nth order Laguerre polynoimal, L_n(x), orthogonal over
[0,inf) with weighting function exp(-x)</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.lambertw" module_name="lambertw" namespace="'special'">
    <docstring>lambertw(z, k=0, tol=1e-8)

Lambert W function [1]_.

The Lambert W function `W(z)` is defined as the inverse function
of ``w * exp(w)``. In other words, the value of ``W(z)`` is
such that ``z = W(z) * exp(W(z))`` for any complex number
``z``.

The Lambert W function is a multivalued function with infinitely
many branches. Each branch gives a separate solution of the
equation ``z = w exp(w)``. Here, the branches are indexed by the
integer `k`.

Parameters
----------
z : array_like
    Input argument.
k : int, optional
    Branch index.
tol : float, optional
    Evaluation tolerance.

Returns
-------
w : array
    `w` will have the same shape as `z`.

Notes
-----
All branches are supported by `lambertw`:

* ``lambertw(z)`` gives the principal solution (branch 0)
* ``lambertw(z, k)`` gives the solution on branch `k`

The Lambert W function has two partially real branches: the
principal branch (`k = 0`) is real for real ``z &gt; -1/e``, and the
``k = -1`` branch is real for ``-1/e &lt; z &lt; 0``. All branches except
``k = 0`` have a logarithmic singularity at ``z = 0``.

**Possible issues**

The evaluation can become inaccurate very close to the branch point
at ``-1/e``. In some corner cases, `lambertw` might currently
fail to converge, or can end up on the wrong branch.

**Algorithm**

Halley's iteration is used to invert ``w * exp(w)``, using a first-order
asymptotic approximation (O(log(w)) or `O(w)`) as the initial estimate.

The definition, implementation and choice of branches is based on [2]_.

References
----------
.. [1] http://en.wikipedia.org/wiki/Lambert_W_function
.. [2] Corless et al, "On the Lambert W function", Adv. Comp. Math. 5
   (1996) 329-359.
   http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf

Examples
--------
The Lambert W function is the inverse of ``w exp(w)``:

&gt;&gt;&gt; from scipy.special import lambertw
&gt;&gt;&gt; w = lambertw(1)
&gt;&gt;&gt; w
(0.56714329040978384+0j)
&gt;&gt;&gt; w * np.exp(w)
(1.0+0j)

Any branch gives a valid inverse:

&gt;&gt;&gt; w = lambertw(1, k=3)
&gt;&gt;&gt; w
(-2.8535817554090377+17.113535539412148j)
&gt;&gt;&gt; w*np.exp(w)
(1.0000000000000002+1.609823385706477e-15j)

**Applications to equation-solving**

The Lambert W function may be used to solve various kinds of
equations, such as finding the value of the infinite power
tower :math:`z^{z^{z^{\ldots}}}`:

&gt;&gt;&gt; def tower(z, n):
...     if n == 0:
...         return z
...     return z ** tower(z, n-1)
...
&gt;&gt;&gt; tower(0.5, 100)
0.641185744504986
&gt;&gt;&gt; -lambertw(-np.log(0.5)) / np.log(0.5)
(0.64118574450498589+0j)</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:List" show_port="True">
      <docstring>Input argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" name="k" port_type="basic:Integer">
      <docstring>Branch index.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tol" name="tol" port_type="basic:Float">
      <docstring>Evaluation tolerance.</docstring>
      <defaults>[1e-08]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>`w` will have the same shape as `z`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.legendre" module_name="legendre" namespace="'special'">
    <docstring>Legendre polynomial coefficients

Returns the nth-order Legendre polynomial, P_n(x), orthogonal over
[-1, 1] with weight function 1.

Parameters
----------
n
    Order of the polynomial
monic : bool, optional
    If True, output is a monic polynomial (normalized so the leading
    coefficient is 1).  Default is False.

Returns
-------
P : orthopoly1d
    The Legendre polynomial object

Examples
--------
Generate the 3rd-order Legendre polynomial 1/2*(5x^3 + 0x^2 - 3x + 0):

&gt;&gt;&gt; legendre(3)
poly1d([ 2.5,  0. , -1.5, -0. ])</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True">
      <docstring>Order of the polynomial</docstring>
    </inputPortSpec>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean">
      <docstring>If True, output is a monic polynomial (normalized so the leading
coefficient is 1).  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="P" name="P" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The Legendre polynomial object</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.lmbda" module_name="lmbda" namespace="'special'">
    <docstring>Compute sequence of lambda functions with arbitrary order v
and their derivatives.  Lv0(x)..Lv(x) are computed with v0=v-int(v).</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.lpmn" module_name="lpmn" namespace="'special'" output_type="list">
    <docstring>Associated Legendre function of the first kind, Pmn(z)

Computes the associated Legendre function of the first kind
of order m and degree n,::

    Pmn(z) = P_n^m(z)

and its derivative, ``Pmn'(z)``.  Returns two arrays of size
``(m+1, n+1)`` containing ``Pmn(z)`` and ``Pmn'(z)`` for all
orders from ``0..m`` and degrees from ``0..n``.

This function takes a real argument ``z``. For complex arguments ``z``
use clpmn instead.

Parameters
----------
m : int
   ``|m| &lt;= n``; the order of the Legendre function.
n : int
   where ``n &gt;= 0``; the degree of the Legendre function.  Often
   called ``l`` (lower case L) in descriptions of the associated
   Legendre function
z : float
    Input value.

Returns
-------
Pmn_z : (m+1, n+1) array
   Values for all orders 0..m and degrees 0..n
Pmn_d_z : (m+1, n+1) array
   Derivatives for all orders 0..m and degrees 0..n

See Also
--------
clpmn: associated Legendre functions of the first kind for complex z

Notes
-----
In the interval (-1, 1), Ferrer's function of the first kind is
returned. The phase convention used for the intervals (1, inf)
and (-inf, -1) is such that the result is always real.

References
----------
.. [1] NIST Digital Library of Mathematical Functions
       http://dlmf.nist.gov/14.3</docstring>
    <inputPortSpec arg="m" name="m" port_type="basic:Integer" show_port="True">
      <docstring>``|m| &lt;= n``; the order of the Legendre function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>where ``n &gt;= 0``; the degree of the Legendre function.  Often
called ``l`` (lower case L) in descriptions of the associated
Legendre function</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Float" show_port="True">
      <docstring>Input value.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Pmn_z" name="Pmn_z" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Values for all orders 0..m and degrees 0..n</docstring>
    </outputPortSpec>
    <outputPortSpec arg="Pmn_d_z" name="Pmn_d_z" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Derivatives for all orders 0..m and degrees 0..n</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.lpn" module_name="lpn" namespace="'special'">
    <docstring>Compute sequence of Legendre functions of the first kind (polynomials),
Pn(z) and derivatives for all degrees from 0 to n (inclusive).

See also special.legendre  for polynomial class.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.lqmn" module_name="lqmn" namespace="'special'">
    <docstring>Associated Legendre functions of the second kind, Qmn(z) and its
derivative, ``Qmn'(z)`` of order m and degree n.  Returns two
arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and ``Qmn'(z)`` for
all orders from ``0..m`` and degrees from ``0..n``.

z can be complex.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="m" name="m" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.lqn" module_name="lqn" namespace="'special'">
    <docstring>Compute sequence of Legendre functions of the second kind,
Qn(z) and derivatives for all degrees from 0 to n (inclusive).</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.mathieu_even_coef" module_name="mathieu_even_coef" namespace="'special'">
    <docstring>Compute expansion coefficients for even Mathieu functions and
modified Mathieu functions.</docstring>
    <inputPortSpec arg="q" name="q" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="m" name="m" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.mathieu_odd_coef" module_name="mathieu_odd_coef" namespace="'special'">
    <docstring>Compute expansion coefficients for even Mathieu functions and
modified Mathieu functions.</docstring>
    <inputPortSpec arg="q" name="q" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="m" name="m" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.multigammaln" module_name="multigammaln" namespace="'special'">
    <docstring>Returns the log of multivariate gamma, also sometimes called the
generalized gamma.

Parameters
----------
a : ndarray
    The multivariate gamma is computed for each item of `a`.
d : int
    The dimension of the space of integration.

Returns
-------
res : ndarray
    The values of the log multivariate gamma at the given points `a`.

Notes
-----
The formal definition of the multivariate gamma of dimension d for a real a
is::

    \Gamma_d(a) = \int_{A&gt;0}{e^{-tr(A)\cdot{|A|}^{a - (m+1)/2}dA}}

with the condition ``a &gt; (d-1)/2``, and ``A &gt; 0`` being the set of all the
positive definite matrices of dimension s.  Note that a is a scalar: the
integrand only is multivariate, the argument is not (the function is
defined over a subset of the real set).

This can be proven to be equal to the much friendlier equation::

    \Gamma_d(a) = \pi^{d(d-1)/4}\prod_{i=1}^{d}{\Gamma(a - (i-1)/2)}.

References
----------
R. J. Muirhead, Aspects of multivariate statistical theory (Wiley Series in
probability and mathematical statistics).</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The multivariate gamma is computed for each item of `a`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="d" name="d" port_type="basic:Integer" show_port="True">
      <docstring>The dimension of the space of integration.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="res" name="res" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the log multivariate gamma at the given points `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.obl_cv_seq" module_name="obl_cv_seq" namespace="'special'">
    <docstring>Compute a sequence of characteristic values for the oblate
spheroidal wave functions for mode m and n'=m..n and spheroidal
parameter c.</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="m" name="m" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.p_roots" module_name="p_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Legendre quadrature

Computes the sample points and weights for Gauss-Legendre quadrature.
The sample points are the roots of the `n`th degree Legendre polynomial
:math:`P_n(x)`.  These sample points and weights correctly integrate
polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-1, 1]` with weight function :math:`f(x) = 1.0`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad
numpy.polynomial.legendre.leggauss</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.pbdn_seq" module_name="pbdn_seq" namespace="'special'">
    <docstring>Compute sequence of parabolic cylinder functions Dn(z) and
their derivatives for D0(z)..Dn(z).</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.pbdv_seq" module_name="pbdv_seq" namespace="'special'">
    <docstring>Compute sequence of parabolic cylinder functions Dv(x) and
their derivatives for Dv0(x)..Dv(x) with v0=v-int(v).</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.pbvv_seq" module_name="pbvv_seq" namespace="'special'">
    <docstring>Compute sequence of parabolic cylinder functions Dv(x) and
their derivatives for Dv0(x)..Dv(x) with v0=v-int(v).</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.perm" module_name="perm" namespace="'special'">
    <docstring>Permutations of N things taken k at a time, i.e., k-permutations of N.

It's also known as "partial permutations".

Parameters
----------
N : int, ndarray
    Number of things.
k : int, ndarray
    Number of elements taken.
exact : bool, optional
    If `exact` is False, then floating point precision is used, otherwise
    exact long integer is computed.

Returns
-------
val : int, ndarray
    The number of k-permutations of N.

Notes
-----
- Array arguments accepted only for exact=False case.
- If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.

Examples
--------
&gt;&gt;&gt; from scipy.special import perm
&gt;&gt;&gt; k = np.array([3, 4])
&gt;&gt;&gt; n = np.array([10, 10])
&gt;&gt;&gt; perm(n, k)
array([  720.,  5040.])
&gt;&gt;&gt; perm(10, 3, exact=True)
720</docstring>
    <inputPortSpec arg="N" depth="1" name="N" port_type="basic:Integer" show_port="True">
      <docstring>Number of things.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="k" depth="1" name="k" port_type="basic:Integer" show_port="True">
      <docstring>Number of elements taken.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="exact" name="exact" port_type="basic:Boolean">
      <docstring>If `exact` is False, then floating point precision is used, otherwise
exact long integer is computed.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="val" depth="1" name="val" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>The number of k-permutations of N.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.polygamma" module_name="polygamma" namespace="'special'">
    <docstring>Polygamma function which is the nth derivative of the digamma (psi)
function.

Parameters
----------
n : array_like of int
    The order of the derivative of `psi`.
x : array_like
    Where to evaluate the polygamma function.

Returns
-------
polygamma : ndarray
    The result.

Examples
--------
&gt;&gt;&gt; from scipy import special
&gt;&gt;&gt; x = [2, 3, 25.5]
&gt;&gt;&gt; special.polygamma(1, x)
array([ 0.64493407,  0.39493407,  0.03999467])
&gt;&gt;&gt; special.polygamma(0, x) == special.psi(x)
array([ True,  True,  True], dtype=bool)</docstring>
    <inputPortSpec arg="n" depth="1" name="n" port_type="basic:Integer" show_port="True">
      <docstring>The order of the derivative of `psi`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Where to evaluate the polygamma function.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="polygamma" name="polygamma" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The result.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.pro_cv_seq" module_name="pro_cv_seq" namespace="'special'">
    <docstring>Compute a sequence of characteristic values for the prolate
spheroidal wave functions for mode m and n'=m..n and spheroidal
parameter c.</docstring>
    <inputPortSpec arg="c" name="c" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="m" name="m" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ps_roots" module_name="ps_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Legendre (shifted) quadrature

Computes the sample points and weights for Gauss-Legendre quadrature.
The sample points are the roots of the `n`th degree shifted Legendre
polynomial :math:`P^*_n(x)`.  These sample points and weights correctly
integrate polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[0, 1]` with weight function :math:`f(x) = 1.0`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.riccati_jn" module_name="riccati_jn" namespace="'special'">
    <docstring>Compute the Ricatti-Bessel function of the first kind and its
derivative for all orders up to and including n.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.riccati_yn" module_name="riccati_yn" namespace="'special'">
    <docstring>Compute the Ricatti-Bessel function of the second kind and its
derivative for all orders up to and including n.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.s_roots" module_name="s_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Chebyshev (second kind) quadrature

Computes the sample points and weights for Gauss-Chebyshev quadrature.
The sample points are the roots of the `n`th degree Chebyshev polynomial of
the second kind, :math:`S_n(x)`.  These sample points and weights correctly
integrate polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-2, 2]` with weight function :math:`f(x) = \sqrt{1 - (x/2)^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sh_chebyt" module_name="sh_chebyt" namespace="'special'">
    <docstring>Return nth order shifted Chebyshev polynomial of first kind, Tn(x).
Orthogonal over [0,1] with weight function (x-x**2)**(-1/2).</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sh_chebyu" module_name="sh_chebyu" namespace="'special'">
    <docstring>Return nth order shifted Chebyshev polynomial of second kind, Un(x).
Orthogonal over [0,1] with weight function (x-x**2)**(1/2).</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sh_jacobi" module_name="sh_jacobi" namespace="'special'">
    <docstring>Returns the nth order Jacobi polynomial, G_n(p,q,x)
orthogonal over [0,1] with weighting function
(1-x)**(p-q) (x)**(q-1) with p&gt;q-1 and q &gt; 0.</docstring>
    <inputPortSpec arg="q" name="q" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="p" name="p" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sh_legendre" module_name="sh_legendre" namespace="'special'">
    <docstring>Returns the nth order shifted Legendre polynomial, P^*_n(x), orthogonal
over [0,1] with weighting function 1.</docstring>
    <inputPortSpec arg="monic" name="monic" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sinc" module_name="sinc" namespace="'special'">
    <docstring>Return the sinc function.

The sinc function is :math:`\sin(\pi x)/(\pi x)`.

Parameters
----------
x : ndarray
    Array (possibly multi-dimensional) of values for which to to
    calculate ``sinc(x)``.

Returns
-------
out : ndarray
    ``sinc(x)``, which has the same shape as the input.

Notes
-----
``sinc(0)`` is the limit value 1.

The name sinc is short for "sine cardinal" or "sinus cardinalis".

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
.. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
       Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, "Sinc function",
       http://en.wikipedia.org/wiki/Sinc_function

Examples
--------
&gt;&gt;&gt; x = np.linspace(-4, 4, 41)
&gt;&gt;&gt; np.sinc(x)
array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])

&gt;&gt;&gt; plt.plot(x, np.sinc(x))
[&lt;matplotlib.lines.Line2D object at 0x...&gt;]
&gt;&gt;&gt; plt.title("Sinc Function")
&lt;matplotlib.text.Text object at 0x...&gt;
&gt;&gt;&gt; plt.ylabel("Amplitude")
&lt;matplotlib.text.Text object at 0x...&gt;
&gt;&gt;&gt; plt.xlabel("X")
&lt;matplotlib.text.Text object at 0x...&gt;
&gt;&gt;&gt; plt.show()

It works in 2-D as well:

&gt;&gt;&gt; x = np.linspace(-4, 4, 401)
&gt;&gt;&gt; xx = np.outer(x, x)
&gt;&gt;&gt; plt.imshow(np.sinc(xx))
&lt;matplotlib.image.AxesImage object at 0x...&gt;</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array (possibly multi-dimensional) of values for which to to
calculate ``sinc(x)``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>``sinc(x)``, which has the same shape as the input.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sph_in" module_name="sph_in" namespace="'special'">
    <docstring>Compute the spherical Bessel function in(z) and its derivative for
all orders up to and including n.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sph_inkn" module_name="sph_inkn" namespace="'special'">
    <docstring>Compute the spherical Bessel functions, in(z) and kn(z) and their
derivatives for all orders up to and including n.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sph_jn" module_name="sph_jn" namespace="'special'">
    <docstring>Compute the spherical Bessel function jn(z) and its derivative for
all orders up to and including n.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sph_jnyn" module_name="sph_jnyn" namespace="'special'">
    <docstring>Compute the spherical Bessel functions, jn(z) and yn(z) and their
derivatives for all orders up to and including n.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sph_kn" module_name="sph_kn" namespace="'special'">
    <docstring>Compute the spherical Bessel function kn(z) and its derivative for
all orders up to and including n.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.sph_yn" module_name="sph_yn" namespace="'special'">
    <docstring>Compute the spherical Bessel function yn(z) and its derivative for
all orders up to and including n.</docstring>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.t_roots" module_name="t_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Chebyshev (first kind) quadrature

Computes the sample points and weights for Gauss-Chebyshev quadrature.
The sample points are the roots of the `n`th degree Chebyshev polynomial of
the first kind, :math:`T_n(x)`.  These sample points and weights correctly
integrate polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-1, 1]` with weight function :math:`f(x) = 1/\sqrt{1 - x^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad
numpy.polynomial.chebyshev.chebgauss</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ts_roots" module_name="ts_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Chebyshev (first kind, shifted) quadrature

Computes the sample points and weights for Gauss-Chebyshev quadrature.
The sample points are the roots of the `n`th degree shifted Chebyshev
polynomial of the first kind, :math:`T_n(x)`.  These sample points and
weights correctly integrate polynomials of degree :math:`2*n - 1` or less
over the interval :math:`[0, 1]` with weight function
:math:`f(x) = 1/\sqrt{x - x^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.u_roots" module_name="u_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Chebyshev (second kind) quadrature

Computes the sample points and weights for Gauss-Chebyshev quadrature.
The sample points are the roots of the `n`th degree Chebyshev polynomial of
the second kind, :math:`U_n(x)`.  These sample points and weights correctly
integrate polynomials of degree :math:`2*n - 1` or less over the interval
:math:`[-1, 1]` with weight function :math:`f(x) = \sqrt{1 - x^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.us_roots" module_name="us_roots" namespace="'special'" output_type="list">
    <docstring>Gauss-Chebyshev (second kind, shifted) quadrature

Computes the sample points and weights for Gauss-Chebyshev quadrature.
The sample points are the roots of the `n`th degree shifted Chebyshev
polynomial of the second kind, :math:`U_n(x)`.  These sample points and
weights correctly integrate polynomials of degree :math:`2*n - 1` or less
over the interval :math:`[0, 1]` with weight function
:math:`f(x) = \sqrt{x - x^2}`.

Parameters
----------
n : int
    quadrature order
mu : bool, optional
    If True, return the sum of the weights, optional.

Returns
-------
x : ndarray
    Sample points
w : ndarray
    Weights
mu : float
    Sum of the weights

See Also
--------
integrate.quadrature
integrate.fixed_quad</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>quadrature order</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mu" name="mu" port_type="basic:Boolean">
      <docstring>If True, return the sum of the weights, optional.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="x" name="x" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Sample points</docstring>
    </outputPortSpec>
    <outputPortSpec arg="w" name="w" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Weights</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mu" name="mu" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Sum of the weights</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.y0_zeros" module_name="y0_zeros" namespace="'special'">
    <docstring>Returns nt (complex or real) zeros of Y0(z), z0, and the value
of Y0'(z0) = -Y1(z0) at each zero.</docstring>
    <inputPortSpec arg="complex" name="complex" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.y1_zeros" module_name="y1_zeros" namespace="'special'">
    <docstring>Returns nt (complex or real) zeros of Y1(z), z1, and the value
of Y1'(z1) = Y0(z1) at each zero.</docstring>
    <inputPortSpec arg="complex" name="complex" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.y1p_zeros" module_name="y1p_zeros" namespace="'special'">
    <docstring>Returns nt (complex or real) zeros of Y1'(z), z1', and the value
of Y1(z1') at each zero.</docstring>
    <inputPortSpec arg="complex" name="complex" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.yn_zeros" module_name="yn_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Bessel function Yn(x).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.ynp_zeros" module_name="ynp_zeros" namespace="'special'">
    <docstring>Compute nt zeros of the Bessel function Yn'(x).</docstring>
    <inputPortSpec arg="nt" name="nt" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="n" name="n" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.special.yvp" module_name="yvp" namespace="'special'">
    <docstring>Return the nth derivative of Yv(z) with respect to z.</docstring>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="z" name="z" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="v" name="v" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.anderson" module_name="anderson" namespace="'stats'" output_type="list">
    <docstring>Anderson-Darling test for data coming from a particular distribution

The Anderson-Darling test is a modification of the Kolmogorov-
Smirnov test `kstest` for the null hypothesis that a sample is
drawn from a population that follows a particular distribution.
For the Anderson-Darling test, the critical values depend on
which distribution is being tested against.  This function works
for normal, exponential, logistic, or Gumbel (Extreme Value
Type I) distributions.

Parameters
----------
x : array_like
    array of sample data
dist : {'norm','expon','logistic','gumbel','extreme1'}, optional
    the type of distribution to test against.  The default is 'norm'
    and 'extreme1' is a synonym for 'gumbel'

Returns
-------
statistic : float
    The Anderson-Darling test statistic
critical_values : list
    The critical values for this distribution
significance_level : list
    The significance levels for the corresponding critical values
    in percents.  The function returns critical values for a
    differing set of significance levels depending on the
    distribution that is being tested against.

Notes
-----
Critical values provided are for the following significance levels:

normal/exponenential
    15%, 10%, 5%, 2.5%, 1%
logistic
    25%, 10%, 5%, 2.5%, 1%, 0.5%
Gumbel
    25%, 10%, 5%, 2.5%, 1%

If A2 is larger than these critical values then for the corresponding
significance level, the null hypothesis that the data come from the
chosen distribution can be rejected.

References
----------
.. [1] http://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
.. [2] Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and
       Some Comparisons, Journal of the American Statistical Association,
       Vol. 69, pp. 730-737.
.. [3] Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit
       Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,
       pp. 357-369.
.. [4] Stephens, M. A. (1977). Goodness of Fit for the Extreme Value
       Distribution, Biometrika, Vol. 64, pp. 583-588.
.. [5] Stephens, M. A. (1977). Goodness of Fit with Special Reference
       to Tests for Exponentiality , Technical Report No. 262,
       Department of Statistics, Stanford University, Stanford, CA.
.. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution
       Based on the Empirical Distribution Function, Biometrika, Vol. 66,
       pp. 591-595.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>array of sample data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dist" name="dist">
      <docstring>the type of distribution to test against.  The default is 'norm'
and 'extreme1' is a synonym for 'gumbel'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['norm', 'expon', 'logistic', 'gumbel', 'extreme1']]</values>
      <defaults>['norm']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Anderson-Darling test statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="critical_values" name="critical_values" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The critical values for this distribution</docstring>
    </outputPortSpec>
    <outputPortSpec arg="significance_level" name="significance_level" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The significance levels for the corresponding critical values
in percents.  The function returns critical values for a
differing set of significance levels depending on the
distribution that is being tested against.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.anderson_ksamp" module_name="anderson_ksamp" namespace="'stats'" output_type="list">
    <docstring>The Anderson-Darling test for k-samples.

The k-sample Anderson-Darling test is a modification of the
one-sample Anderson-Darling test. It tests the null hypothesis
that k-samples are drawn from the same population without having
to specify the distribution function of that population. The
critical values depend on the number of samples.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample data in arrays.
midrank : bool, optional
    Type of Anderson-Darling test which is computed. Default
    (True) is the midrank test applicable to continuous and
    discrete populations. If False, the right side empirical
    distribution is used.

Returns
-------
statistic : float
    Normalized k-sample Anderson-Darling test statistic.
critical_values : array
    The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%.
significance_level : float
    An approximate significance level at which the null hypothesis for the
    provided samples can be rejected.

Raises
------
ValueError
    If less than 2 samples are provided, a sample is empty, or no
    distinct observations are in the samples.

See Also
--------
ks_2samp : 2 sample Kolmogorov-Smirnov test
anderson : 1 sample Anderson-Darling test

Notes
-----
[1]_ Defines three versions of the k-sample Anderson-Darling test:
one for continuous distributions and two for discrete
distributions, in which ties between samples may occur. The
default of this routine is to compute the version based on the
midrank empirical distribution function. This test is applicable
to continuous and discrete data. If midrank is set to False, the
right side empirical distribution is used for a test for discrete
data. According to [1]_, the two discrete test statistics differ
only slightly if a few collisions due to round-off errors occur in
the test not adjusted for ties between samples.

.. versionadded:: 0.14.0

References
----------
.. [1] Scholz, F. W and Stephens, M. A. (1987), K-Sample
       Anderson-Darling Tests, Journal of the American Statistical
       Association, Vol. 82, pp. 918-924.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(314159)

The null hypothesis that the two random samples come from the same
distribution can be rejected at the 5% level because the returned
test value is greater than the critical value for 5% (1.961) but
not at the 2.5% level. The interpolation gives an approximate
significance level of 3.1%:

&gt;&gt;&gt; stats.anderson_ksamp([np.random.normal(size=50),
... np.random.normal(loc=0.5, size=30)])
(2.4615796189876105,
  array([ 0.325,  1.226,  1.961,  2.718,  3.752]),
  0.03134990135800783)


The null hypothesis cannot be rejected for three samples from an
identical distribution. The approximate p-value (87%) has to be
computed by extrapolation and may not be very accurate:

&gt;&gt;&gt; stats.anderson_ksamp([np.random.normal(size=50),
... np.random.normal(size=30), np.random.normal(size=20)])
(-0.73091722665244196,
  array([ 0.44925884,  1.3052767 ,  1.9434184 ,  2.57696569,  3.41634856]),
  0.8789283903979661)</docstring>
    <inputPortSpec arg="samples" name="samples" port_type="basic:List" show_port="True">
      <docstring>Array of sample data in arrays.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="midrank" name="midrank" port_type="basic:Boolean">
      <docstring>Type of Anderson-Darling test which is computed. Default
(True) is the midrank test applicable to continuous and
discrete populations. If False, the right side empirical
distribution is used.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Normalized k-sample Anderson-Darling test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="critical_values" name="critical_values" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="significance_level" name="significance_level" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>An approximate significance level at which the null hypothesis for the
provided samples can be rejected.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ansari" module_name="ansari" namespace="'stats'" output_type="list">
    <docstring>Perform the Ansari-Bradley test for equal scale parameters

The Ansari-Bradley test is a non-parametric test for the equality
of the scale parameter of the distributions from which two
samples were drawn.

Parameters
----------
x, y : array_like
    arrays of sample data

Returns
-------
statistic : float
    The Ansari-Bradley test statistic
pvalue : float
    The p-value of the hypothesis test

See Also
--------
fligner : A non-parametric test for the equality of k variances
mood : A non-parametric test for the equality of two scale parameters

Notes
-----
The p-value given is exact when the sample sizes are both less than
55 and there are no ties, otherwise a normal approximation for the
p-value is used.

References
----------
.. [1] Sprent, Peter and N.C. Smeeton.  Applied nonparametric statistical
       methods.  3rd ed. Chapman and Hall/CRC. 2001.  Section 5.8.2.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>arrays of sample data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>arrays of sample data</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Ansari-Bradley test statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the hypothesis test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.bartlett" module_name="bartlett" namespace="'stats'" output_type="list">
    <docstring>Perform Bartlett's test for equal variances

Bartlett's test tests the null hypothesis that all input samples
are from populations with equal variances.  For samples
from significantly non-normal populations, Levene's test
`levene` is more robust.

Parameters
----------
sample1, sample2,... : array_like
    arrays of sample data.  May be different lengths.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value of the test.

References
----------
.. [1]  http://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm

.. [2]  Snedecor, George W. and Cochran, William G. (1989), Statistical
          Methods, Eighth Edition, Iowa State University Press.</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>arrays of sample data.  May be different lengths.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>arrays of sample data.  May be different lengths.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>arrays of sample data.  May be different lengths.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.bayes_mvs" module_name="bayes_mvs" namespace="'stats'" output_type="list">
    <docstring>Bayesian confidence intervals for the mean, var, and std.

Parameters
----------
data : array_like
    Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.
    Requires 2 or more data points.
alpha : float, optional
    Probability that the returned confidence interval contains
    the true parameter.

Returns
-------
mean_cntr, var_cntr, std_cntr : tuple
    The three results are for the mean, variance and standard deviation,
    respectively.  Each result is a tuple of the form::

        (center, (lower, upper))

    with `center` the mean of the conditional pdf of the value given the
    data, and `(lower, upper)` a confidence interval, centered on the
    median, containing the estimate to a probability ``alpha``.

Notes
-----
Each tuple of mean, variance, and standard deviation estimates represent
the (center, (lower, upper)) with center the mean of the conditional pdf
of the value given the data and (lower, upper) is a confidence interval
centered on the median, containing the estimate to a probability
``alpha``.

Converts data to 1-D and assumes all data has the same mean and variance.
Uses Jeffrey's prior for variance and std.

Equivalent to ``tuple((x.mean(), x.interval(alpha)) for x in mvsdist(dat))``

References
----------
T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
standard-deviation from data", http://hdl.handle.net/1877/438, 2006.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.
Requires 2 or more data points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Probability that the returned confidence interval contains
the true parameter.</docstring>
      <defaults>[0.9]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="mean_cntr" name="mean_cntr" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The three results are for the mean, variance and standard deviation,
respectively.  Each result is a tuple of the form::

    (center, (lower, upper))

with `center` the mean of the conditional pdf of the value given the
data, and `(lower, upper)` a confidence interval, centered on the
median, containing the estimate to a probability ``alpha``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="var_cntr" name="var_cntr" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The three results are for the mean, variance and standard deviation,
respectively.  Each result is a tuple of the form::

    (center, (lower, upper))

with `center` the mean of the conditional pdf of the value given the
data, and `(lower, upper)` a confidence interval, centered on the
median, containing the estimate to a probability ``alpha``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="std_cntr" name="std_cntr" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The three results are for the mean, variance and standard deviation,
respectively.  Each result is a tuple of the form::

    (center, (lower, upper))

with `center` the mean of the conditional pdf of the value given the
data, and `(lower, upper)` a confidence interval, centered on the
median, containing the estimate to a probability ``alpha``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.betai" module_name="betai" namespace="'stats'">
    <docstring>Returns the incomplete beta function.

I_x(a,b) = 1/B(a,b)*(Integral(0,x) of t^(a-1)(1-t)^(b-1) dt)

where a,b&gt;0 and B(a,b) = G(a)*G(b)/(G(a+b)) where G(a) is the gamma
function of a.

The standard broadcasting rules apply to a, b, and x.

Parameters
----------
a : array_like or float &gt; 0

b : array_like or float &gt; 0

x : array_like or float
    x will be clipped to be no greater than 1.0 .

Returns
-------
betai : ndarray
    Incomplete beta function.</docstring>
    <inputPortSpec arg="a" name="aScalar" port_type="basic:Float" show_port="True">
      <alternateSpec arg="a" name="aSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" port_type="basic:Float" show_port="True">
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Float" show_port="True">
      <docstring>x will be clipped to be no greater than 1.0 .</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="betai" name="betai" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Incomplete beta function.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.binned_statistic" module_name="binned_statistic" namespace="'stats'" output_type="list">
    <docstring>Compute a binned statistic for a set of data.

This is a generalization of a histogram function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values within each bin.

Parameters
----------
x : array_like
    A sequence of values to be binned.
values : array_like
    The values on which the statistic will be computed.  This must be
    the same shape as `x`.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : int or sequence of scalars, optional
    If `bins` is an int, it defines the number of equal-width bins in the
    given range (10 by default).  If `bins` is a sequence, it defines the
    bin edges, including the rightmost edge, allowing for non-uniform bin
    widths.  Values in `x` that are smaller than lowest bin edge are
    assigned to bin number 0, values beyond the highest bin are assigned to
    ``bins[-1]``.
range : (float, float) or [(float, float)], optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(x.min(), x.max())``.  Values outside the range are
    ignored.

Returns
-------
statistic : array
    The values of the selected statistic in each bin.
bin_edges : array of dtype float
    Return the bin edges ``(length(statistic)+1)``.
binnumber : 1-D ndarray of ints
    This assigns to each observation an integer that represents the bin
    in which this observation falls. Array has the same length as values.

See Also
--------
numpy.histogram, binned_statistic_2d, binned_statistic_dd

Notes
-----
All but the last (righthand-most) bin is half-open.  In other words, if
`bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
``[3, 4]``, which *includes* 4.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

First a basic example:

&gt;&gt;&gt; stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic='mean',
...                        bins=3)
(array([ 1.,  2.,  4.]), array([ 1.,  2.,  3.,  4.]), array([1, 2, 1, 2, 3]))

As a second example, we now generate some random data of sailing boat speed
as a function of wind speed, and then determine how fast our boat is for
certain wind speeds:

&gt;&gt;&gt; windspeed = 8 * np.random.rand(500)
&gt;&gt;&gt; boatspeed = .3 * windspeed**.5 + .2 * np.random.rand(500)
&gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed,
...                 boatspeed, statistic='median', bins=[1,2,3,4,5,6,7])
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(windspeed, boatspeed, 'b.', label='raw data')
&gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=5,
...            label='binned statistic of data')
&gt;&gt;&gt; plt.legend()

Now we can use ``binnumber`` to select all datapoints with a windspeed
below 1:

&gt;&gt;&gt; low_boatspeed = boatspeed[binnumber == 0]

As a final example, we will use ``bin_edges`` and ``binnumber`` to make a
plot of a distribution that shows the mean and distribution around that
mean per bin, on top of a regular histogram and the probability
distribution function:

&gt;&gt;&gt; x = np.linspace(0, 5, num=500)
&gt;&gt;&gt; x_pdf = stats.maxwell.pdf(x)
&gt;&gt;&gt; samples = stats.maxwell.rvs(size=10000)

&gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf,
...         statistic='mean', bins=25)
&gt;&gt;&gt; bin_width = (bin_edges[1] - bin_edges[0])
&gt;&gt;&gt; bin_centers = bin_edges[1:] - bin_width/2

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.hist(samples, bins=50, normed=True, histtype='stepfilled', alpha=0.2,
...          label='histogram of data')
&gt;&gt;&gt; plt.plot(x, x_pdf, 'r-', label='analytical pdf')
&gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=2,
...            label='binned statistic of data')
&gt;&gt;&gt; plt.plot((binnumber - 0.5) * bin_width, x_pdf, 'g.', alpha=0.5)
&gt;&gt;&gt; plt.legend(fontsize=10)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A sequence of values to be binned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>The values on which the statistic will be computed.  This must be
the same shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="statistic" name="statistic">
      <docstring>The statistic to compute (default is 'mean').
The following statistics are available:

  * 'mean' : compute the mean of values for points within each bin.
    Empty bins will be represented by NaN.
  * 'median' : compute the median of values for points within each
    bin. Empty bins will be represented by NaN.
  * 'count' : compute the count of points within each bin.  This is
    identical to an unweighted histogram.  `values` array is not
    referenced.
  * 'sum' : compute the sum of values for points within each bin.
    This is identical to a weighted histogram.
  * function : a user-defined function which takes a 1D array of
    values, and outputs a single numerical statistic. This function
    will be called on the values in each bin.  Empty bins will be
    represented by function([]), or NaN if this returns an error.
</docstring>
      <defaults>['mean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="binsScalar" port_type="basic:Integer">
      <docstring>If `bins` is an int, it defines the number of equal-width bins in the
given range (10 by default).  If `bins` is a sequence, it defines the
bin edges, including the rightmost edge, allowing for non-uniform bin
widths.  Values in `x` that are smaller than lowest bin edge are
assigned to bin number 0, values beyond the highest bin are assigned to
``bins[-1]``.</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="range" name="range" port_type="basic:Float">
      <docstring>The lower and upper range of the bins.  If not provided, range
is simply ``(x.min(), x.max())``.  Values outside the range are
ignored.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the selected statistic in each bin.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="bin_edges" depth="1" name="bin_edges" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Return the bin edges ``(length(statistic)+1)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="binnumber" depth="1" name="binnumber" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>This assigns to each observation an integer that represents the bin
in which this observation falls. Array has the same length as values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.binned_statistic_2d" module_name="binned_statistic_2d" namespace="'stats'" output_type="list">
    <docstring>Compute a bidimensional binned statistic for a set of data.

This is a generalization of a histogram2d function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values within each bin.

Parameters
----------
x : (N,) array_like
    A sequence of values to be binned along the first dimension.
y : (M,) array_like
    A sequence of values to be binned along the second dimension.
values : (N,) array_like
    The values on which the statistic will be computed.  This must be
    the same shape as `x`.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : int or [int, int] or array_like or [array, array], optional
    The bin specification:

      * the number of bins for the two dimensions (nx=ny=bins),
      * the number of bins in each dimension (nx, ny = bins),
      * the bin edges for the two dimensions (x_edges = y_edges = bins),
      * the bin edges in each dimension (x_edges, y_edges = bins).

range : (2,2) array_like, optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be
    considered outliers and not tallied in the histogram.

Returns
-------
statistic : (nx, ny) ndarray
    The values of the selected statistic in each two-dimensional bin
x_edges : (nx + 1) ndarray
    The bin edges along the first dimension.
y_edges : (ny + 1) ndarray
    The bin edges along the second dimension.
binnumber : 1-D ndarray of ints
    This assigns to each observation an integer that represents the bin
    in which this observation falls. Array has the same length as `values`.

See Also
--------
numpy.histogram2d, binned_statistic, binned_statistic_dd

Notes
-----

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>A sequence of values to be binned along the first dimension.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>A sequence of values to be binned along the second dimension.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>The values on which the statistic will be computed.  This must be
the same shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="statistic" name="statistic">
      <docstring>The statistic to compute (default is 'mean').
The following statistics are available:

  * 'mean' : compute the mean of values for points within each bin.
    Empty bins will be represented by NaN.
  * 'median' : compute the median of values for points within each
    bin. Empty bins will be represented by NaN.
  * 'count' : compute the count of points within each bin.  This is
    identical to an unweighted histogram.  `values` array is not
    referenced.
  * 'sum' : compute the sum of values for points within each bin.
    This is identical to a weighted histogram.
  * function : a user-defined function which takes a 1D array of
    values, and outputs a single numerical statistic. This function
    will be called on the values in each bin.  Empty bins will be
    represented by function([]), or NaN if this returns an error.
</docstring>
      <defaults>['mean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="binsScalar" port_type="basic:Integer">
      <docstring>The bin specification:

  * the number of bins for the two dimensions (nx=ny=bins),
  * the number of bins in each dimension (nx, ny = bins),
  * the bin edges for the two dimensions (x_edges = y_edges = bins),
  * the bin edges in each dimension (x_edges, y_edges = bins).
</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="range" name="range" port_type="basic:List">
      <docstring>The leftmost and rightmost edges of the bins along each dimension
(if not specified explicitly in the `bins` parameters):
[[xmin, xmax], [ymin, ymax]]. All values outside of this range will be
considered outliers and not tallied in the histogram.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the selected statistic in each two-dimensional bin</docstring>
    </outputPortSpec>
    <outputPortSpec arg="x_edges" name="x_edges" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The bin edges along the first dimension.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y_edges" name="y_edges" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>The bin edges along the second dimension.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="binnumber" depth="1" name="binnumber" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>This assigns to each observation an integer that represents the bin
in which this observation falls. Array has the same length as `values`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.binned_statistic_dd" module_name="binned_statistic_dd" namespace="'stats'" output_type="list">
    <docstring>Compute a multidimensional binned statistic for a set of data.

This is a generalization of a histogramdd function.  A histogram divides
the space into bins, and returns the count of the number of points in
each bin.  This function allows the computation of the sum, mean, median,
or other statistic of the values within each bin.

Parameters
----------
sample : array_like
    Data to histogram passed as a sequence of D arrays of length N, or
    as an (N,D) array.
values : array_like
    The values on which the statistic will be computed.  This must be
    the same shape as x.
statistic : string or callable, optional
    The statistic to compute (default is 'mean').
    The following statistics are available:

      * 'mean' : compute the mean of values for points within each bin.
        Empty bins will be represented by NaN.
      * 'median' : compute the median of values for points within each
        bin. Empty bins will be represented by NaN.
      * 'count' : compute the count of points within each bin.  This is
        identical to an unweighted histogram.  `values` array is not
        referenced.
      * 'sum' : compute the sum of values for points within each bin.
        This is identical to a weighted histogram.
      * function : a user-defined function which takes a 1D array of
        values, and outputs a single numerical statistic. This function
        will be called on the values in each bin.  Empty bins will be
        represented by function([]), or NaN if this returns an error.

bins : sequence or int, optional
    The bin specification:

      * A sequence of arrays describing the bin edges along each dimension.
      * The number of bins for each dimension (nx, ny, ... =bins)
      * The number of bins for all dimensions (nx=ny=...=bins).

range : sequence, optional
    A sequence of lower and upper bin edges to be used if the edges are
    not given explicitely in `bins`. Defaults to the minimum and maximum
    values along each dimension.

Returns
-------
statistic : ndarray, shape(nx1, nx2, nx3,...)
    The values of the selected statistic in each two-dimensional bin
bin_edges : list of ndarrays
    A list of D arrays describing the (nxi + 1) bin edges for each
    dimension
binnumber : 1-D ndarray of ints
    This assigns to each observation an integer that represents the bin
    in which this observation falls. Array has the same length as values.

See Also
--------
np.histogramdd, binned_statistic, binned_statistic_2d

Notes
-----

.. versionadded:: 0.11.0</docstring>
    <inputPortSpec arg="sample" name="sample" port_type="basic:List" show_port="True">
      <docstring>Data to histogram passed as a sequence of D arrays of length N, or
as an (N,D) array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" name="values" port_type="basic:List" show_port="True">
      <docstring>The values on which the statistic will be computed.  This must be
the same shape as x.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="statistic" name="statistic">
      <docstring>The statistic to compute (default is 'mean').
The following statistics are available:

  * 'mean' : compute the mean of values for points within each bin.
    Empty bins will be represented by NaN.
  * 'median' : compute the median of values for points within each
    bin. Empty bins will be represented by NaN.
  * 'count' : compute the count of points within each bin.  This is
    identical to an unweighted histogram.  `values` array is not
    referenced.
  * 'sum' : compute the sum of values for points within each bin.
    This is identical to a weighted histogram.
  * function : a user-defined function which takes a 1D array of
    values, and outputs a single numerical statistic. This function
    will be called on the values in each bin.  Empty bins will be
    represented by function([]), or NaN if this returns an error.
</docstring>
      <defaults>['mean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bins" name="binsScalar" port_type="basic:Integer">
      <docstring>The bin specification:

  * A sequence of arrays describing the bin edges along each dimension.
  * The number of bins for each dimension (nx, ny, ... =bins)
  * The number of bins for all dimensions (nx=ny=...=bins).
</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="range" name="range" port_type="basic:List">
      <docstring>A sequence of lower and upper bin edges to be used if the edges are
not given explicitely in `bins`. Defaults to the minimum and maximum
values along each dimension.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The values of the selected statistic in each two-dimensional bin</docstring>
    </outputPortSpec>
    <outputPortSpec arg="bin_edges" name="bin_edges" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>A list of D arrays describing the (nxi + 1) bin edges for each
dimension</docstring>
    </outputPortSpec>
    <outputPortSpec arg="binnumber" depth="1" name="binnumber" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>This assigns to each observation an integer that represents the bin
in which this observation falls. Array has the same length as values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.binom_test" module_name="binom_test" namespace="'stats'">
    <docstring>Perform a test that the probability of success is p.

This is an exact, two-sided test of the null hypothesis
that the probability of success in a Bernoulli experiment
is `p`.

Parameters
----------
x : integer or array_like
    the number of successes, or if x has length 2, it is the
    number of successes and the number of failures.
n : integer
    the number of trials.  This is ignored if x gives both the
    number of successes and failures
p : float, optional
    The hypothesized probability of success.  0 &lt;= p &lt;= 1. The
    default value is p = 0.5

Returns
-------
p-value : float
    The p-value of the hypothesis test

References
----------
.. [1] http://en.wikipedia.org/wiki/Binomial_test</docstring>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Integer" show_port="True">
      <docstring>the number of successes, or if x has length 2, it is the
number of successes and the number of failures.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer" show_port="True">
      <docstring>the number of trials.  This is ignored if x gives both the
number of successes and failures</docstring>
    </inputPortSpec>
    <inputPortSpec arg="p" name="p" port_type="basic:Float">
      <docstring>The hypothesized probability of success.  0 &lt;= p &lt;= 1. The
default value is p = 0.5</docstring>
      <defaults>[0.5]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="p-value" name="p-value" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The p-value of the hypothesis test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.boxcox" module_name="boxcox" namespace="'stats'" output_type="list">
    <docstring>Return a positive dataset transformed by a Box-Cox power transformation.

Parameters
----------
x : ndarray
    Input array.  Should be 1-dimensional.
lmbda : {None, scalar}, optional
    If `lmbda` is not None, do the transformation for that value.

    If `lmbda` is None, find the lambda that maximizes the log-likelihood
    function and return it as the second output argument.
alpha : {None, float}, optional
    If ``alpha`` is not None, return the ``100 * (1-alpha)%`` confidence
    interval for `lmbda` as the third output argument.
    Must be between 0.0 and 1.0.

Returns
-------
boxcox : ndarray
    Box-Cox power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the lambda that maximizes the log-likelihood function.
(min_ci, max_ci) : tuple of float, optional
    If `lmbda` parameter is None and ``alpha`` is not None, this returned
    tuple of floats represents the minimum and maximum confidence limits
    given ``alpha``.

See Also
--------
probplot, boxcox_normplot, boxcox_normmax, boxcox_llf

Notes
-----
The Box-Cox transform is given by::

    y = (x**lmbda - 1) / lmbda,  for lmbda &gt; 0
        log(x),                  for lmbda = 0

`boxcox` requires the input data to be positive.  Sometimes a Box-Cox
transformation provides a shift parameter to achieve this; `boxcox` does
not.  Such a shift parameter is equivalent to adding a positive constant to
`x` before calling `boxcox`.

The confidence limits returned when ``alpha`` is provided give the interval
where:

.. math::

    llf(\hat{\lambda}) - llf(\lambda) &lt; \frac{1}{2}\chi^2(1 - \alpha, 1),

with ``llf`` the log-likelihood function and :math:`\chi^2` the chi-squared
function.

References
----------
G.E.P. Box and D.R. Cox, "An Analysis of Transformations", Journal of the
Royal Statistical Society B, 26, 211-252 (1964).

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(211)
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; stats.probplot(x, dist=stats.norm, plot=ax1)
&gt;&gt;&gt; ax1.set_xlabel('')
&gt;&gt;&gt; ax1.set_title('Probplot against normal distribution')

We now use `boxcox` to transform the data so it's closest to normal:

&gt;&gt;&gt; ax2 = fig.add_subplot(212)
&gt;&gt;&gt; xt, _ = stats.boxcox(x)
&gt;&gt;&gt; stats.probplot(xt, dist=stats.norm, plot=ax2)
&gt;&gt;&gt; ax2.set_title('Probplot after Box-Cox transformation')

&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.  Should be 1-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lmbda" name="lmbda" port_type="basic:Float">
      <docstring>If `lmbda` is not None, do the transformation for that value.

If `lmbda` is None, find the lambda that maximizes the log-likelihood
function and return it as the second output argument.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>If ``alpha`` is not None, return the ``100 * (1-alpha)%`` confidence
interval for `lmbda` as the third output argument.
Must be between 0.0 and 1.0.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="boxcox" name="boxcox" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Box-Cox power transformed array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="maxlog" name="maxlog" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>If the `lmbda` parameter is None, the second returned argument is
the lambda that maximizes the log-likelihood function.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="(min_ci" depth="1" name="(min_ci" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>If `lmbda` parameter is None and ``alpha`` is not None, this returned
tuple of floats represents the minimum and maximum confidence limits
given ``alpha``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="max_ci)" depth="1" name="max_ci)" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>If `lmbda` parameter is None and ``alpha`` is not None, this returned
tuple of floats represents the minimum and maximum confidence limits
given ``alpha``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.boxcox_llf" module_name="boxcox_llf" namespace="'stats'">
    <docstring>The boxcox log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Box-Cox transformation.  See `boxcox` for details.
data : array_like
    Data to calculate Box-Cox log-likelihood for.  If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float or ndarray
    Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,
    an array otherwise.

See Also
--------
boxcox, probplot, boxcox_normplot, boxcox_normmax

Notes
-----
The Box-Cox log-likelihood function is defined here as

.. math::

    llf = (\lambda - 1) \sum_i(\log(x_i)) -
          N/2 \log(\sum_i (y_i - \bar{y})^2 / N),

where ``y`` is the Box-Cox transformed input data ``x``.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes
&gt;&gt;&gt; np.random.seed(1245)

Generate some random variates and calculate Box-Cox log-likelihood values
for them for a range of ``lmbda`` values:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000)
&gt;&gt;&gt; lmbdas = np.linspace(-2, 10)
&gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=np.float)
&gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.boxcox_llf(lmbda, x)

Also find the optimal lmbda value with `boxcox`:

&gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.boxcox(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(lmbdas, llf, 'b.-')
&gt;&gt;&gt; ax.axhline(stats.boxcox_llf(lmbda_optimal, x), color='r')
&gt;&gt;&gt; ax.set_xlabel('lmbda parameter')
&gt;&gt;&gt; ax.set_ylabel('Box-Cox log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `boxcox` looks closest to normal:

&gt;&gt;&gt; locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
&gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.boxcox(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title('$\lambda=%1.2f$' % lmbda)

&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="lmb" name="lmb" port_type="basic:Float" show_port="True">
      <docstring>Parameter for Box-Cox transformation.  See `boxcox` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data to calculate Box-Cox log-likelihood for.  If `data` is
multi-dimensional, the log-likelihood is calculated along the first
axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="llf" name="llf" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,
an array otherwise.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.boxcox_normmax" module_name="boxcox_normmax" namespace="'stats'">
    <docstring>Compute optimal Box-Cox transform parameter for input data.

Parameters
----------
x : array_like
    Input array.
brack : 2-tuple, optional
    The starting interval for a downhill bracket search with
    `optimize.brent`.  Note that this is in most cases not critical; the
    final result is allowed to be outside this bracket.
method : str, optional
    The method to determine the optimal transform parameter (`boxcox`
    ``lmbda`` parameter). Options are:

    'pearsonr'  (default)
        Maximizes the Pearson correlation coefficient between
        ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be
        normally-distributed.

    'mle'
        Minimizes the log-likelihood `boxcox_llf`.  This is the method used
        in `boxcox`.

    'all'
        Use all optimization methods available, and return all results.
        Useful to compare different methods.

Returns
-------
maxlog : float or ndarray
    The optimal transform parameter found.  An array instead of a scalar
    for ``method='all'``.

See Also
--------
boxcox, boxcox_llf, boxcox_normplot

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; np.random.seed(1234)  # make this example reproducible

Generate some data and determine optimal ``lmbda`` in various ways:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30) + 5
&gt;&gt;&gt; y, lmax_mle = stats.boxcox(x)
&gt;&gt;&gt; lmax_pearsonr = stats.boxcox_normmax(x)

&gt;&gt;&gt; lmax_mle
7.177...
&gt;&gt;&gt; lmax_pearsonr
7.916...
&gt;&gt;&gt; stats.boxcox_normmax(x, method='all')
array([ 7.91667384,  7.17718692])

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; stats.boxcox_normplot(x, -10, 10, plot=ax)
&gt;&gt;&gt; ax.axvline(lmax_mle, color='r')
&gt;&gt;&gt; ax.axvline(lmax_pearsonr, color='g', ls='--')

&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="brack" name="brack" port_type="basic:List">
      <docstring>The starting interval for a downhill bracket search with
`optimize.brent`.  Note that this is in most cases not critical; the
final result is allowed to be outside this bracket.</docstring>
      <defaults>[(-2.0, 2.0)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>The method to determine the optimal transform parameter (`boxcox`
``lmbda`` parameter). Options are:

'pearsonr'  (default)
    Maximizes the Pearson correlation coefficient between
    ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be
    normally-distributed.

'mle'
    Minimizes the log-likelihood `boxcox_llf`.  This is the method used
    in `boxcox`.

'all'
    Use all optimization methods available, and return all results.
    Useful to compare different methods.</docstring>
      <defaults>['pearsonr']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="maxlog" name="maxlog" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The optimal transform parameter found.  An array instead of a scalar
for ``method='all'``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.boxcox_normplot" module_name="boxcox_normplot" namespace="'stats'" output_type="list">
    <docstring>Compute parameters for a Box-Cox normality plot, optionally show it.

A Box-Cox normality plot shows graphically what the best transformation
parameter is to use in `boxcox` to obtain a distribution that is close
to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
    for Box-Cox transformations.  These are also the limits of the
    horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Box-Cox transform was done.
ppcc : ndarray
    Probability Plot Correlelation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, boxcox, boxcox_normmax, boxcox_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Box-Cox plot:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; stats.boxcox_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

&gt;&gt;&gt; _, maxlog = stats.boxcox(x)
&gt;&gt;&gt; ax.axvline(maxlog, color='r')

&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="la" name="la" port_type="basic:Float" show_port="True">
      <docstring>The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
for Box-Cox transformations.  These are also the limits of the
horizontal axis of the plot if that is generated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lb" name="lb" port_type="basic:Float" show_port="True">
      <docstring>The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
for Box-Cox transformations.  These are also the limits of the
horizontal axis of the plot if that is generated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="plot" name="plot" port_type="basic:List">
      <docstring>If given, plots the quantiles and least squares fit.
`plot` is an object that has to have methods "plot" and "text".
The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
or a custom object with the same methods.
Default is None, which means that no plot is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of points on the horizontal axis (equally distributed from
`la` to `lb`).</docstring>
      <defaults>[80]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="lmbdas" name="lmbdas" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The ``lmbda`` values for which a Box-Cox transform was done.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ppcc" name="ppcc" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Probability Plot Correlelation Coefficient, as obtained from `probplot`
when fitting the Box-Cox transformed input `x` against a normal
distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.callable" module_name="callable" namespace="'stats'">
    <docstring>callable(object) -&gt; bool

Return whether the object is callable (i.e., some kind of function).
Note that classes are callable, as are instances with a __call__() method.</docstring>
    <inputPortSpec arg="object" name="object" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Boolean" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.chi2_contingency" module_name="chi2_contingency" namespace="'stats'" output_type="list">
    <docstring>Chi-square test of independence of variables in a contingency table.

This function computes the chi-square statistic and p-value for the
hypothesis test of independence of the observed frequencies in the
contingency table [1]_ `observed`.  The expected frequencies are computed
based on the marginal sums under the assumption of independence; see
`scipy.stats.contingency.expected_freq`.  The number of degrees of
freedom is (expressed using numpy functions and attributes)::

    dof = observed.size - sum(observed.shape) + observed.ndim - 1


Parameters
----------
observed : array_like
    The contingency table. The table contains the observed frequencies
    (i.e. number of occurrences) in each category.  In the two-dimensional
    case, the table is often described as an "R x C table".
correction : bool, optional
    If True, *and* the degrees of freedom is 1, apply Yates' correction
    for continuity.  The effect of the correction is to adjust each
    observed value by 0.5 towards the corresponding expected value.
lambda_ : float or str, optional.
    By default, the statistic computed in this test is Pearson's
    chi-squared statistic [2]_.  `lambda_` allows a statistic from the
    Cressie-Read power divergence family [3]_ to be used instead.  See
    `power_divergence` for details.

Returns
-------
chi2 : float
    The test statistic.
p : float
    The p-value of the test
dof : int
    Degrees of freedom
expected : ndarray, same shape as `observed`
    The expected frequencies, based on the marginal sums of the table.

See Also
--------
contingency.expected_freq
fisher_exact
chisquare
power_divergence

Notes
-----
An often quoted guideline for the validity of this calculation is that
the test should be used only if the observed and expected frequency in
each cell is at least 5.

This is a test for the independence of different categories of a
population. The test is only meaningful when the dimension of
`observed` is two or more.  Applying the test to a one-dimensional
table will always result in `expected` equal to `observed` and a
chi-square statistic equal to 0.

This function does not handle masked arrays, because the calculation
does not make sense with missing values.

Like stats.chisquare, this function computes a chi-square statistic;
the convenience this function provides is to figure out the expected
frequencies and degrees of freedom from the given contingency table.
If these were already known, and if the Yates' correction was not
required, one could use stats.chisquare.  That is, if one calls::

    chi2, p, dof, ex = chi2_contingency(obs, correction=False)

then the following is true::

    (chi2, p) == stats.chisquare(obs.ravel(), f_exp=ex.ravel(),
                                 ddof=obs.size - 1 - dof)

The `lambda_` argument was added in version 0.13.0 of scipy.

References
----------
.. [1] "Contingency table", http://en.wikipedia.org/wiki/Contingency_table
.. [2] "Pearson's chi-squared test",
       http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
.. [3] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
       Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
       pp. 440-464.

Examples
--------
A two-way example (2 x 3):

&gt;&gt;&gt; from scipy.stats import chi2_contingency
&gt;&gt;&gt; obs = np.array([[10, 10, 20], [20, 20, 20]])
&gt;&gt;&gt; chi2_contingency(obs)
(2.7777777777777777,
 0.24935220877729619,
 2,
 array([[ 12.,  12.,  16.],
        [ 18.,  18.,  24.]]))

Perform the test using the log-likelihood ratio (i.e. the "G-test")
instead of Pearson's chi-squared statistic.

&gt;&gt;&gt; g, p, dof, expctd = chi2_contingency(obs, lambda_="log-likelihood")
&gt;&gt;&gt; g, p
(2.7688587616781319, 0.25046668010954165)

A four-way example (2 x 2 x 2 x 2):

&gt;&gt;&gt; obs = np.array(
...     [[[[12, 17],
...        [11, 16]],
...       [[11, 12],
...        [15, 16]]],
...      [[[23, 15],
...        [30, 22]],
...       [[14, 17],
...        [15, 16]]]])
&gt;&gt;&gt; chi2_contingency(obs)
(8.7584514426741897,
 0.64417725029295503,
 11,
 array([[[[ 14.15462386,  14.15462386],
          [ 16.49423111,  16.49423111]],
         [[ 11.2461395 ,  11.2461395 ],
          [ 13.10500554,  13.10500554]]],
        [[[ 19.5591166 ,  19.5591166 ],
          [ 22.79202844,  22.79202844]],
         [[ 15.54012004,  15.54012004],
          [ 18.10873492,  18.10873492]]]]))</docstring>
    <inputPortSpec arg="observed" name="observed" port_type="basic:List" show_port="True">
      <docstring>The contingency table. The table contains the observed frequencies
(i.e. number of occurrences) in each category.  In the two-dimensional
case, the table is often described as an "R x C table".</docstring>
    </inputPortSpec>
    <inputPortSpec arg="correction" name="correction" port_type="basic:Boolean">
      <docstring>If True, *and* the degrees of freedom is 1, apply Yates' correction
for continuity.  The effect of the correction is to adjust each
observed value by 0.5 towards the corresponding expected value.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lambda_" name="lambda_">
      <docstring>By default, the statistic computed in this test is Pearson's
chi-squared statistic [2]_.  `lambda_` allows a statistic from the
Cressie-Read power divergence family [3]_ to be used instead.  See
`power_divergence` for details.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="chi2" name="chi2" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the test</docstring>
    </outputPortSpec>
    <outputPortSpec arg="dof" name="dof" port_type="basic:Integer" show_port="True" sort_key="2">
      <docstring>Degrees of freedom</docstring>
    </outputPortSpec>
    <outputPortSpec arg="expected" name="expected" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>The expected frequencies, based on the marginal sums of the table.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.chisqprob" module_name="chisqprob" namespace="'stats'">
    <docstring>Probability value (1-tail) for the Chi^2 probability distribution.

Broadcasting rules apply.

Parameters
----------
chisq : array_like or float &gt; 0

df : array_like or float, probably int &gt;= 1

Returns
-------
chisqprob : ndarray
    The area from `chisq` to infinity under the Chi^2 probability
    distribution with degrees of freedom `df`.</docstring>
    <inputPortSpec arg="chisq" name="chisqScalar" port_type="basic:Float" show_port="True">
      <alternateSpec arg="chisq" name="chisqSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="df" name="dfScalar" port_type="basic:Float" show_port="True">
      <alternateSpec arg="df" name="dfSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="chisqprob" name="chisqprob" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The area from `chisq` to infinity under the Chi^2 probability
distribution with degrees of freedom `df`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.chisquare" module_name="chisquare" namespace="'stats'" output_type="list">
    <docstring>Calculates a one-way chi square test.

The chi square test tests the null hypothesis that the categorical data
has the given frequencies.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.

Returns
-------
chisq : float or ndarray
    The chi-squared test statistic.  The value is a float if `axis` is
    None or `f_obs` and `f_exp` are 1-D.
p : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `chisq` are scalars.

See Also
--------
power_divergence
mstats.chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test

Examples
--------
When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.

&gt;&gt;&gt; from scipy.stats import chisquare
&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12])
(2.0, 0.84914503608460956)

With `f_exp` the expected frequencies can be given.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])
(3.5, 0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

&gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
&gt;&gt;&gt; obs.shape
(6, 2)
&gt;&gt;&gt; chisquare(obs)
(array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

&gt;&gt;&gt; chisquare(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
&gt;&gt;&gt; chisquare(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
chi-squared statistic with `ddof`.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we use ``axis=1``:

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12],
...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],
...           axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</docstring>
    <inputPortSpec arg="f_obs" name="f_obs" port_type="basic:List" show_port="True">
      <docstring>Observed frequencies in each category.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_exp" name="f_exp" port_type="basic:List">
      <docstring>Expected frequencies in each category.  By default the categories are
assumed to be equally likely.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>"Delta degrees of freedom": adjustment to the degrees of freedom
for the p-value.  The p-value is computed using a chi-squared
distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
is the number of observed frequencies.  The default value of `ddof`
is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>The axis of the broadcast result of `f_obs` and `f_exp` along which to
apply the test.  If axis is None, all values in `f_obs` are treated
as a single data set.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="chisq" name="chisq" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The chi-squared test statistic.  The value is a float if `axis` is
None or `f_obs` and `f_exp` are 1-D.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the test.  The value is a float if `ddof` and the
return value `chisq` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.circmean" module_name="circmean" namespace="'stats'">
    <docstring>Compute the circular mean for samples in a range.

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for circular mean range.  Default is ``2*pi``.
low : float or int, optional
    Low boundary for circular mean range.  Default is 0.
axis : int, optional
    Axis along which means are computed.  The default is to compute
    the mean of the flattened array.

Returns
-------
circmean : float
    Circular mean.</docstring>
    <inputPortSpec arg="samples" name="samples" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Float">
      <docstring>High boundary for circular mean range.  Default is ``2*pi``.</docstring>
      <defaults>[6.283185307179586]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="low" name="low" port_type="basic:Float">
      <docstring>Low boundary for circular mean range.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which means are computed.  The default is to compute
the mean of the flattened array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="circmean" name="circmean" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Circular mean.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.circstd" module_name="circstd" namespace="'stats'">
    <docstring>Compute the circular standard deviation for samples assumed to be in the
range [low to high].

Parameters
----------
samples : array_like
    Input array.
low : float or int, optional
    Low boundary for circular standard deviation range.  Default is 0.
high : float or int, optional
    High boundary for circular standard deviation range.
    Default is ``2*pi``.
axis : int, optional
    Axis along which standard deviations are computed.  The default is
    to compute the standard deviation of the flattened array.

Returns
-------
circstd : float
    Circular standard deviation.

Notes
-----
This uses a definition of circular standard deviation that in the limit of
small angles returns a number close to the 'linear' standard deviation.</docstring>
    <inputPortSpec arg="samples" name="samples" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="low" name="low" port_type="basic:Float">
      <docstring>Low boundary for circular standard deviation range.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Float">
      <docstring>High boundary for circular standard deviation range.
Default is ``2*pi``.</docstring>
      <defaults>[6.283185307179586]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which standard deviations are computed.  The default is
to compute the standard deviation of the flattened array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="circstd" name="circstd" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Circular standard deviation.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.circvar" module_name="circvar" namespace="'stats'">
    <docstring>Compute the circular variance for samples assumed to be in a range

Parameters
----------
samples : array_like
    Input array.
low : float or int, optional
    Low boundary for circular variance range.  Default is 0.
high : float or int, optional
    High boundary for circular variance range.  Default is ``2*pi``.
axis : int, optional
    Axis along which variances are computed.  The default is to compute
    the variance of the flattened array.

Returns
-------
circvar : float
    Circular variance.

Notes
-----
This uses a definition of circular variance that in the limit of small
angles returns a number close to the 'linear' variance.</docstring>
    <inputPortSpec arg="samples" name="samples" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="low" name="low" port_type="basic:Float">
      <docstring>Low boundary for circular variance range.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Float">
      <docstring>High boundary for circular variance range.  Default is ``2*pi``.</docstring>
      <defaults>[6.283185307179586]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which variances are computed.  The default is to compute
the variance of the flattened array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="circvar" name="circvar" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Circular variance.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.combine_pvalues" module_name="combine_pvalues" namespace="'stats'" output_type="list">
    <docstring>Methods for combining the p-values of independent tests bearing upon the
same hypothesis.

Parameters
----------
pvalues : array_like, 1-D
    Array of p-values assumed to come from independent tests.
method : {'fisher', 'stouffer'}, optional
    Name of method to use to combine p-values. The following methods are
    available:
    - "fisher": Fisher's method (Fisher's combined probability test),
      the default.
    - "stouffer": Stouffer's Z-score method.
weights : array_like, 1-D, optional
    Optional array of weights used only for Stouffer's Z-score method.

Returns
-------
statistic: float
    The statistic calculated by the specified method:
    - "fisher": The chi-squared statistic
    - "stouffer": The Z-score
pval: float
    The combined p-value.

Notes
-----
Fisher's method (also known as Fisher's combined probability test) [1]_ uses
a chi-squared statistic to compute a combined p-value. The closely related
Stouffer's Z-score method [2]_ uses Z-scores rather than p-values. The
advantage of Stouffer's method is that it is straightforward to introduce
weights, which can make Stouffer's method more powerful than Fisher's
method when the p-values are from studies of different size [3]_ [4]_.

Fisher's method may be extended to combine p-values from dependent tests
[5]_. Extensions such as Brown's method and Kost's method are not currently
implemented.

.. versionadded:: 0.15.0

References
----------
.. [1] https://en.wikipedia.org/wiki/Fisher%27s_method
.. [2] http://en.wikipedia.org/wiki/Fisher's_method#Relation_to_Stouffer.27s_Z-score_method
.. [3] Whitlock, M. C. "Combining probability from independent tests: the
       weighted Z-method is superior to Fisher's approach." Journal of
       Evolutionary Biology 18, no. 5 (2005): 1368-1373.
.. [4] Zaykin, Dmitri V. "Optimally weighted Z-test is a powerful method
       for combining probabilities in meta-analysis." Journal of
       Evolutionary Biology 24, no. 8 (2011): 1836-1841.
.. [5] https://en.wikipedia.org/wiki/Extensions_of_Fisher%27s_method</docstring>
    <inputPortSpec arg="pvalues" name="pvalues" port_type="basic:List" show_port="True">
      <docstring>Array of p-values assumed to come from independent tests.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>Name of method to use to combine p-values. The following methods are
available:
- "fisher": Fisher's method (Fisher's combined probability test),
  the default.
- "stouffer": Stouffer's Z-score method.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['fisher', 'stouffer']]</values>
      <defaults>['fisher']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>Optional array of weights used only for Stouffer's Z-score method.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The statistic calculated by the specified method:
- "fisher": The chi-squared statistic
- "stouffer": The Z-score</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The combined p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.cumfreq" module_name="cumfreq" namespace="'stats'" output_type="list">
    <docstring>Returns a cumulative frequency histogram, using the histogram function.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
cumcount : ndarray
    Binned values of cumulative frequency.
lowerlimit : float
    Lower real limit
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = [1, 4, 2, 1, 3, 1]
&gt;&gt;&gt; cumfreqs, lowlim, binsize, extrapoints = stats.cumfreq(x, numbins=4)
&gt;&gt;&gt; cumfreqs
array([ 3.,  4.,  5.,  6.])
&gt;&gt;&gt; cumfreqs, lowlim, binsize, extrapoints =     ...     stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))
&gt;&gt;&gt; cumfreqs
array([ 1.,  2.,  3.,  3.])
&gt;&gt;&gt; extrapoints
3</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="numbins" name="numbins" port_type="basic:Integer">
      <docstring>The number of bins to use for the histogram. Default is 10.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="defaultreallimits" name="defaultreallimits" port_type="basic:List">
      <docstring>The lower and upper values for the range of the histogram.
If no value is given, a range slightly larger than the range of the
values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,
where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>The weights for each value in `a`. Default is None, which gives each
value a weight of 1.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="cumcount" name="cumcount" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Binned values of cumulative frequency.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lowerlimit" name="lowerlimit" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Lower real limit</docstring>
    </outputPortSpec>
    <outputPortSpec arg="binsize" name="binsize" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Width of each bin.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="extrapoints" name="extrapoints" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>Extra points.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.describe" module_name="describe" namespace="'stats'" output_type="list">
    <docstring>Computes several descriptive statistics of the passed array.

Parameters
----------
a : array_like
   Input data.
axis : int or None, optional
   Axis along which statistics are calculated. Default is 0.
   If None, compute over the whole array `a`.
ddof : int, optional
    Delta degrees of freedom.  Default is 1.

Returns
-------
nobs : int
   Number of observations (length of data along `axis`).
minmax: tuple of ndarrays or floats
   Minimum and maximum value of data array.
mean : ndarray or float
   Arithmetic mean of data along axis.
variance : ndarray or float
   Unbiased variance of the data along axis, denominator is number of
   observations minus one.
skewness : ndarray or float
   Biased skewness, based on moment calculations with denominator equal to
   the number of observations, i.e. no degrees of freedom correction.
kurtosis : ndarray or float
   Biased kurtosis (Fisher).  The kurtosis is normalized so that it is
   zero for the normal distribution.  No degrees of freedom or bias
   correction is used.

See Also
--------
skew, kurtosis</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which statistics are calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Delta degrees of freedom.  Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nobs" name="nobs" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>Number of observations (length of data along `axis`).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Minimum and maximum value of data array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mean" name="mean" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Arithmetic mean of data along axis.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="variance" name="variance" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Unbiased variance of the data along axis, denominator is number of
observations minus one.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="skewness" name="skewness" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Biased skewness, based on moment calculations with denominator equal to
the number of observations, i.e. no degrees of freedom correction.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="kurtosis" name="kurtosis" port_type="basic:Float" show_port="True" sort_key="5">
      <docstring>Biased kurtosis (Fisher).  The kurtosis is normalized so that it is
zero for the normal distribution.  No degrees of freedom or bias
correction is used.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.entropy" module_name="entropy" namespace="'stats'">
    <docstring>Calculate the entropy of a distribution for given probability values.

If only probabilities `pk` are given, the entropy is calculated as
``S = -sum(pk * log(pk), axis=0)``.

If `qk` is not None, then compute the Kullback-Leibler divergence
``S = sum(pk * log(pk / qk), axis=0)``.

This routine will normalize `pk` and `qk` if they don't sum to 1.

Parameters
----------
pk : sequence
    Defines the (discrete) distribution. ``pk[i]`` is the (possibly
    unnormalized) probability of event ``i``.
qk : sequence, optional
    Sequence against which the relative entropy is computed. Should be in
    the same format as `pk`.
base : float, optional
    The logarithmic base to use, defaults to ``e`` (natural logarithm).

Returns
-------
S : float
    The calculated entropy.</docstring>
    <inputPortSpec arg="pk" name="pk" port_type="basic:List" show_port="True">
      <docstring>Defines the (discrete) distribution. ``pk[i]`` is the (possibly
unnormalized) probability of event ``i``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="qk" name="qk" port_type="basic:List">
      <docstring>Sequence against which the relative entropy is computed. Should be in
the same format as `pk`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="base" name="base" port_type="basic:Float">
      <docstring>The logarithmic base to use, defaults to ``e`` (natural logarithm).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="S" name="S" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The calculated entropy.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.f_oneway" module_name="f_oneway" namespace="'stats'" output_type="list">
    <docstring>Performs a 1-way ANOVA.

The one-way ANOVA tests the null hypothesis that two or more groups have
the same population mean.  The test is applied to samples from two or
more groups, possibly with differing sizes.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group.

Returns
-------
statistic : float
    The computed F-value of the test.
pvalue : float
    The associated p-value from the F-distribution.

Notes
-----
The ANOVA test has important assumptions that must be satisfied in order
for the associated p-value to be valid.

1. The samples are independent.
2. Each sample is from a normally distributed population.
3. The population standard deviations of the groups are all equal.  This
   property is known as homoscedasticity.

If these assumptions are not true for a given set of data, it may still be
possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) although
with some loss of power.

The algorithm is from Heiman[2], pp.394-7.


References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 14.
       http://faculty.vassar.edu/lowry/ch14pt1.html

.. [2] Heiman, G.W.  Research Methods in Statistics. 2002.</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>The sample measurements for each group.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>The sample measurements for each group.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>The sample measurements for each group.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed F-value of the test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The associated p-value from the F-distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.f_value" module_name="f_value" namespace="'stats'">
    <docstring>Returns an F-statistic for a restricted vs. unrestricted model.

Parameters
----------
ER : float
     `ER` is the sum of squared residuals for the restricted model
      or null hypothesis

EF : float
     `EF` is the sum of squared residuals for the unrestricted model
      or alternate hypothesis

dfR : int
      `dfR` is the degrees of freedom in the restricted model

dfF : int
      `dfF` is the degrees of freedom in the unrestricted model

Returns
-------
F-statistic : float</docstring>
    <inputPortSpec arg="ER" name="ER" port_type="basic:Float" show_port="True">
      <docstring>`ER` is the sum of squared residuals for the restricted model
 or null hypothesis
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="EF" name="EF" port_type="basic:Float" show_port="True">
      <docstring>`EF` is the sum of squared residuals for the unrestricted model
 or alternate hypothesis
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dfR" name="dfR" port_type="basic:Integer" show_port="True">
      <docstring>`dfR` is the degrees of freedom in the restricted model
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dfF" name="dfF" port_type="basic:Integer" show_port="True">
      <docstring>`dfF` is the degrees of freedom in the unrestricted model</docstring>
    </inputPortSpec>
    <outputPortSpec arg="F-statistic" name="F-statistic" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.f_value_multivariate" module_name="f_value_multivariate" namespace="'stats'">
    <docstring>Returns a multivariate F-statistic.

Parameters
----------
ER : ndarray
    Error associated with the null hypothesis (the Restricted model).
    From a multivariate F calculation.
EF : ndarray
    Error associated with the alternate hypothesis (the Full model)
    From a multivariate F calculation.
dfnum : int
    Degrees of freedom the Restricted model.
dfden : int
    Degrees of freedom associated with the Restricted model.

Returns
-------
fstat : float
    The computed F-statistic.</docstring>
    <inputPortSpec arg="ER" name="ER" port_type="basic:List" show_port="True">
      <docstring>Error associated with the null hypothesis (the Restricted model).
From a multivariate F calculation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="EF" name="EF" port_type="basic:List" show_port="True">
      <docstring>Error associated with the alternate hypothesis (the Full model)
From a multivariate F calculation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dfnum" name="dfnum" port_type="basic:Integer" show_port="True">
      <docstring>Degrees of freedom the Restricted model.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dfden" name="dfden" port_type="basic:Integer" show_port="True">
      <docstring>Degrees of freedom associated with the Restricted model.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fstat" name="fstat" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed F-statistic.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.f_value_wilks_lambda" module_name="f_value_wilks_lambda" namespace="'stats'">
    <docstring>Calculation of Wilks lambda F-statistic for multivarite data, per
Maxwell &amp; Delaney p.657.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="dfnum" name="dfnum" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="dfden" name="dfden" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="EF" name="EF" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ER" name="ER" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.fastsort" module_name="fastsort" namespace="'stats'">
    <docstring>`fastsort` is deprecated!
scipy.stats.fastsort is deprecated in scipy 0.16.0


    Sort an array and provide the argsort.

    Parameters
    ----------
    a : array_like
        Input array.

    Returns
    -------
    fastsort : ndarray of type int
        sorted indices into the original array</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="fastsort" depth="1" name="fastsort" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>sorted indices into the original array</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.find_repeats" module_name="find_repeats" namespace="'stats'">
    <docstring>Find repeats and repeat counts.

Parameters
----------
arr : array_like
    Input array

Returns
-------
find_repeats : tuple
    Returns a tuple of two 1-D ndarrays.  The first ndarray are the repeats
    as sorted, unique values that are repeated in `arr`.  The second
    ndarray are the counts mapped one-to-one of the repeated values
    in the first ndarray.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.find_repeats([2, 1, 2, 3, 2, 2, 5])
(array([ 2. ]), array([ 4 ], dtype=int32)

&gt;&gt;&gt; stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]])
(array([ 4., 5.]), array([2, 2], dtype=int32))</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <outputPortSpec arg="find_repeats" name="find_repeats" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns a tuple of two 1-D ndarrays.  The first ndarray are the repeats
as sorted, unique values that are repeated in `arr`.  The second
ndarray are the counts mapped one-to-one of the repeated values
in the first ndarray.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.fisher_exact" module_name="fisher_exact" namespace="'stats'" output_type="list">
    <docstring>Performs a Fisher exact test on a 2x2 contingency table.

Parameters
----------
table : array_like of ints
    A 2x2 contingency table.  Elements should be non-negative integers.
alternative : {'two-sided', 'less', 'greater'}, optional
    Which alternative hypothesis to the null hypothesis the test uses.
    Default is 'two-sided'.

Returns
-------
oddsratio : float
    This is prior odds ratio and not a posterior estimate.
p_value : float
    P-value, the probability of obtaining a distribution at least as
    extreme as the one that was actually observed, assuming that the
    null hypothesis is true.

See Also
--------
chi2_contingency : Chi-square test of independence of variables in a
    contingency table.

Notes
-----
The calculated odds ratio is different from the one R uses. This scipy
implementation returns the (more common) "unconditional Maximum
Likelihood Estimate", while R uses the "conditional Maximum Likelihood
Estimate".

For tables with large numbers, the (inexact) chi-square test implemented
in the function `chi2_contingency` can also be used.

Examples
--------
Say we spend a few days counting whales and sharks in the Atlantic and
Indian oceans. In the Atlantic ocean we find 8 whales and 1 shark, in the
Indian ocean 2 whales and 5 sharks. Then our contingency table is::

            Atlantic  Indian
    whales     8        2
    sharks     1        5

We use this table to find the p-value:

&gt;&gt;&gt; import scipy.stats as stats
&gt;&gt;&gt; oddsratio, pvalue = stats.fisher_exact([[8, 2], [1, 5]])
&gt;&gt;&gt; pvalue
0.0349...

The probability that we would observe this or an even more imbalanced ratio
by chance is about 3.5%.  A commonly used significance level is 5%--if we
adopt that, we can therefore conclude that our observed imbalance is
statistically significant; whales prefer the Atlantic while sharks prefer
the Indian ocean.</docstring>
    <inputPortSpec arg="table" depth="1" name="table" port_type="basic:Integer" show_port="True">
      <docstring>A 2x2 contingency table.  Elements should be non-negative integers.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alternative" name="alternative">
      <docstring>Which alternative hypothesis to the null hypothesis the test uses.
Default is 'two-sided'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['two-sided', 'less', 'greater']]</values>
      <defaults>['two-sided']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="oddsratio" name="oddsratio" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>This is prior odds ratio and not a posterior estimate.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p_value" name="p_value" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>P-value, the probability of obtaining a distribution at least as
extreme as the one that was actually observed, assuming that the
null hypothesis is true.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.fligner" module_name="fligner" namespace="'stats'" output_type="list">
    <docstring>Perform Fligner's test for equal variances.

Fligner's test tests the null hypothesis that all input samples
are from populations with equal variances.  Fligner's test is
non-parametric in contrast to Bartlett's test `bartlett` and
Levene's test `levene`.

Parameters
----------
sample1, sample2, ... : array_like
    Arrays of sample data.  Need not be the same length.
center : {'mean', 'median', 'trimmed'}, optional
    Keyword argument controlling which function of the data is used in
    computing the test statistic.  The default is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.

Returns
-------
Xsq : float
    The test statistic.
p-value : float
    The p-value for the hypothesis test.

Notes
-----
As with Levene's test there are three variants of Fligner's test that
differ by the measure of central tendency used in the test.  See `levene`
for more information.

References
----------
.. [1] http://www.stat.psu.edu/~bgl/center/tr/TR993.ps

.. [2] Fligner, M.A. and Killeen, T.J. (1976). Distribution-free two-sample
       tests for scale. 'Journal of the American Statistical Association.'
       71(353), 210-213.</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>Arrays of sample data.  Need not be the same length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>Arrays of sample data.  Need not be the same length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>Arrays of sample data.  Need not be the same length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="center" name="center">
      <docstring>Keyword argument controlling which function of the data is used in
computing the test statistic.  The default is 'median'.</docstring>
      <defaults>['median']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float">
      <docstring>When `center` is 'trimmed', this gives the proportion of data points
to cut from each end. (See `scipy.stats.trim_mean`.)
Default is 0.05.</docstring>
      <defaults>[0.05]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Xsq" name="Xsq" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p-value" name="p-value" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the hypothesis test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.friedmanchisquare" module_name="friedmanchisquare" namespace="'stats'" output_type="list">
    <docstring>Computes the Friedman test for repeated measurements

The Friedman test tests the null hypothesis that repeated measurements of
the same individuals have the same distribution.  It is often used
to test for consistency among measurements obtained in different ways.
For example, if two measurement techniques are used on the same set of
individuals, the Friedman test can be used to determine if the two
measurement techniques are consistent.

Parameters
----------
measurements1, measurements2, measurements3... : array_like
    Arrays of measurements.  All of the arrays must have the same number
    of elements.  At least 3 sets of measurements must be given.

Returns
-------
statistic : float
    the test statistic, correcting for ties
pvalue : float
    the associated p-value assuming that the test statistic has a chi
    squared distribution

Notes
-----
Due to the assumption that the test statistic has a chi squared
distribution, the p-value is only reliable for n &gt; 10 and more than
6 repeated measurements.

References
----------
.. [1] http://en.wikipedia.org/wiki/Friedman_test</docstring>
    <inputPortSpec arg="measurements1" name="measurements1" port_type="basic:List" show_port="True">
      <docstring>Arrays of measurements.  All of the arrays must have the same number
of elements.  At least 3 sets of measurements must be given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="measurements2" name="measurements2" port_type="basic:List" show_port="True">
      <docstring>Arrays of measurements.  All of the arrays must have the same number
of elements.  At least 3 sets of measurements must be given.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="measurements3..." name="measurements3..." port_type="basic:List" show_port="True">
      <docstring>Arrays of measurements.  All of the arrays must have the same number
of elements.  At least 3 sets of measurements must be given.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>the test statistic, correcting for ties</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>the associated p-value assuming that the test statistic has a chi
squared distribution</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.gmean" module_name="gmean" namespace="'stats'">
    <docstring>Compute the geometric mean along the specified axis.

Returns the geometric average of the array elements.
That is:  n-th root of (x1 * x2 * ... * xn)

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int or None, optional
    Axis along which the geometric mean is computed. Default is 0.
    If None, compute over the whole array `a`.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If dtype is not specified, it defaults to the
    dtype of a, unless a has an integer dtype with a precision less than
    that of the default platform integer. In that case, the default
    platform integer is used.

Returns
-------
gmean : ndarray
    see dtype parameter above

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
hmean : Harmonic mean

Notes
-----
The geometric average is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

Use masked arrays to ignore any non-finite values in the input or that
arise in the calculations such as Not a Number and infinity because masked
arrays automatically mask any non-finite values.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the geometric mean is computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type of the returned array and of the accumulator in which the
elements are summed. If dtype is not specified, it defaults to the
dtype of a, unless a has an integer dtype with a precision less than
that of the default platform integer. In that case, the default
platform integer is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="gmean" name="gmean" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>see dtype parameter above</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.histogram" module_name="histogram" namespace="'stats'" output_type="list">
    <docstring>Separates the range into several bins and returns the number of instances
in each bin.

Parameters
----------
a : array_like
    Array of scores which will be put into bins.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultlimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0
printextras : bool, optional
    If True, if there are extra points (i.e. the points that fall outside
    the bin limits) a warning is raised saying how many of those points
    there are.  Default is False.

Returns
-------
count : ndarray
    Number of points (or sum of weights) in each bin.
lowerlimit : float
    Lowest value of histogram, the lower limit of the first bin.
binsize : float
    The size of the bins (all bins have the same size).
extrapoints : int
    The number of points outside the range of the histogram.

See Also
--------
numpy.histogram

Notes
-----
This histogram is based on numpy's histogram but has a larger range by
default if default limits is not set.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array of scores which will be put into bins.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="numbins" name="numbins" port_type="basic:Integer">
      <docstring>The number of bins to use for the histogram. Default is 10.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="defaultlimits" name="defaultlimits" port_type="basic:List">
      <docstring>The lower and upper values for the range of the histogram.
If no value is given, a range slightly larger than the range of the
values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>The weights for each value in `a`. Default is None, which gives each
value a weight of 1.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="printextras" name="printextras" port_type="basic:Boolean">
      <docstring>If True, if there are extra points (i.e. the points that fall outside
the bin limits) a warning is raised saying how many of those points
there are.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="count" name="count" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Number of points (or sum of weights) in each bin.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lowerlimit" name="lowerlimit" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Lowest value of histogram, the lower limit of the first bin.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="binsize" name="binsize" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>The size of the bins (all bins have the same size).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="extrapoints" name="extrapoints" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>The number of points outside the range of the histogram.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.histogram2" module_name="histogram2" namespace="'stats'">
    <docstring>`histogram2` is deprecated!
scipy.stats.histogram2 is deprecated in scipy 0.16.0; use np.histogram2d instead


    Compute histogram using divisions in bins.

    Count the number of times values from array `a` fall into
    numerical ranges defined by `bins`.  Range x is given by
    bins[x] &lt;= range_x &lt; bins[x+1] where x =0,N and N is the
    length of the `bins` array.  The last range is given by
    bins[N] &lt;= range_N &lt; infinity.  Values less than bins[0] are
    not included in the histogram.

    Parameters
    ----------
    a : array_like of rank 1
        The array of values to be assigned into bins
    bins : array_like of rank 1
        Defines the ranges of values to use during histogramming.

    Returns
    -------
    histogram2 : ndarray of rank 1
        Each value represents the occurrences for a given bin (range) of
        values.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>    The array of values to be assigned into bins
bins : array_like of rank 1
    Defines the ranges of values to use during histogramming.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="histogram2" name="histogram2" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Each value represents the occurrences for a given bin (range) of
values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.hmean" module_name="hmean" namespace="'stats'">
    <docstring>Calculates the harmonic mean along the specified axis.

That is:  n / (1/x1 + 1/x2 + ... + 1/xn)

Parameters
----------
a : array_like
    Input array, masked array or object that can be converted to an array.
axis : int or None, optional
    Axis along which the harmonic mean is computed. Default is 0.
    If None, compute over the whole array `a`.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If `dtype` is not specified, it defaults to the
    dtype of `a`, unless `a` has an integer `dtype` with a precision less
    than that of the default platform integer. In that case, the default
    platform integer is used.

Returns
-------
hmean : ndarray
    see `dtype` parameter above

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
gmean : Geometric mean

Notes
-----
The harmonic mean is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

Use masked arrays to ignore any non-finite values in the input or that
arise in the calculations such as Not a Number and infinity.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, masked array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the harmonic mean is computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type of the returned array and of the accumulator in which the
elements are summed. If `dtype` is not specified, it defaults to the
dtype of `a`, unless `a` has an integer `dtype` with a precision less
than that of the default platform integer. In that case, the default
platform integer is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="hmean" name="hmean" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>see `dtype` parameter above</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.itemfreq" module_name="itemfreq" namespace="'stats'">
    <docstring>Returns a 2-D array of item frequencies.

Parameters
----------
a : (N,) array_like
    Input array.

Returns
-------
itemfreq : (K, 2) ndarray
    A 2-D frequency table.  Column 1 contains sorted, unique values from
    `a`, column 2 contains their respective counts.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.array([1, 1, 5, 0, 1, 2, 2, 0, 1, 4])
&gt;&gt;&gt; stats.itemfreq(a)
array([[ 0.,  2.],
       [ 1.,  4.],
       [ 2.,  2.],
       [ 4.,  1.],
       [ 5.,  1.]])
&gt;&gt;&gt; np.bincount(a)
array([2, 4, 2, 0, 1, 1])

&gt;&gt;&gt; stats.itemfreq(a/10.)
array([[ 0. ,  2. ],
       [ 0.1,  4. ],
       [ 0.2,  2. ],
       [ 0.4,  1. ],
       [ 0.5,  1. ]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="itemfreq" name="itemfreq" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>A 2-D frequency table.  Column 1 contains sorted, unique values from
`a`, column 2 contains their respective counts.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.jarque_bera" module_name="jarque_bera" namespace="'stats'" output_type="list">
    <docstring>Perform the Jarque-Bera goodness of fit test on sample data.

The Jarque-Bera test tests whether the sample data has the skewness and
kurtosis matching a normal distribution.

Note that this test only works for a large enough number of data samples
(&gt;2000) as the test statistic asymptotically has a Chi-squared distribution
with 2 degrees of freedom.

Parameters
----------
x : array_like
    Observations of a random variable.

Returns
-------
jb_value : float
    The test statistic.
p : float
    The p-value for the hypothesis test.

References
----------
.. [1] Jarque, C. and Bera, A. (1980) "Efficient tests for normality,
       homoscedasticity and serial independence of regression residuals",
       6 Econometric Letters 255-259.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(987654321)
&gt;&gt;&gt; x = np.random.normal(0, 1, 100000)
&gt;&gt;&gt; y = np.random.rayleigh(1, 100000)
&gt;&gt;&gt; stats.jarque_bera(x)
(4.7165707989581342, 0.09458225503041906)
&gt;&gt;&gt; stats.jarque_bera(y)
(6713.7098548143422, 0.0)</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Observations of a random variable.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="jb_value" name="jb_value" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the hypothesis test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kendalltau" module_name="kendalltau" namespace="'stats'" output_type="list">
    <docstring>Calculates Kendall's tau, a correlation measure for ordinal data.

Kendall's tau is a measure of the correspondence between two rankings.
Values close to 1 indicate strong agreement, values close to -1 indicate
strong disagreement.  This is the tau-b version of Kendall's tau which
accounts for ties.

Parameters
----------
x, y : array_like
    Arrays of rankings, of the same shape. If arrays are not 1-D, they will
    be flattened to 1-D.
initial_lexsort : bool, optional
    Whether to use lexsort or quicksort as the sorting method for the
    initial sort of the inputs. Default is lexsort (True), for which
    `kendalltau` is of complexity O(n log(n)). If False, the complexity is
    O(n^2), but with a smaller pre-factor (so quicksort may be faster for
    small arrays).

Returns
-------
correlation : float
   The tau statistic.
pvalue : float
   The two-sided p-value for a hypothesis test whose null hypothesis is
   an absence of association, tau = 0.

Notes
-----
The definition of Kendall's tau that is used is::

  tau = (P - Q) / sqrt((P + Q + T) * (P + Q + U))

where P is the number of concordant pairs, Q the number of discordant
pairs, T the number of ties only in `x`, and U the number of ties only in
`y`.  If a tie occurs for the same pair in both `x` and `y`, it is not
added to either T or U.

References
----------
W.R. Knight, "A Computer Method for Calculating Kendall's Tau with
Ungrouped Data", Journal of the American Statistical Association, Vol. 61,
No. 314, Part 1, pp. 436-439, 1966.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x1 = [12, 2, 1, 12, 2]
&gt;&gt;&gt; x2 = [1, 4, 7, 1, 0]
&gt;&gt;&gt; tau, p_value = stats.kendalltau(x1, x2)
&gt;&gt;&gt; tau
-0.47140452079103173
&gt;&gt;&gt; p_value
0.24821309157521476</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of rankings, of the same shape. If arrays are not 1-D, they will
be flattened to 1-D.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of rankings, of the same shape. If arrays are not 1-D, they will
be flattened to 1-D.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="initial_lexsort" name="initial_lexsort" port_type="basic:Boolean">
      <docstring>Whether to use lexsort or quicksort as the sorting method for the
initial sort of the inputs. Default is lexsort (True), for which
`kendalltau` is of complexity O(n log(n)). If False, the complexity is
O(n^2), but with a smaller pre-factor (so quicksort may be faster for
small arrays).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The tau statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-sided p-value for a hypothesis test whose null hypothesis is
an absence of association, tau = 0.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kruskal" module_name="kruskal" namespace="'stats'" output_type="list">
    <docstring>Compute the Kruskal-Wallis H-test for independent samples

The Kruskal-Wallis H-test tests the null hypothesis that the population
median of all of the groups are equal.  It is a non-parametric version of
ANOVA.  The test works on 2 or more independent samples, which may have
different sizes.  Note that rejecting the null hypothesis does not
indicate which of the groups differs.  Post-hoc comparisons between
groups are required to determine which groups are different.

Parameters
----------
sample1, sample2, ... : array_like
   Two or more arrays with the sample measurements can be given as
   arguments.

Returns
-------
statistic : float
   The Kruskal-Wallis H statistic, corrected for ties
pvalue : float
   The p-value for the test using the assumption that H has a chi
   square distribution

Notes
-----
Due to the assumption that H has a chi square distribution, the number
of samples in each group must not be too small.  A typical rule is
that each sample must have at least 5 measurements.

References
----------
.. [1] http://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Kruskal-Wallis H statistic, corrected for ties</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the test using the assumption that H has a chi
square distribution</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ks_2samp" module_name="ks_2samp" namespace="'stats'" output_type="list">
    <docstring>Computes the Kolmogorov-Smirnov statistic on 2 samples.

This is a two-sided test for the null hypothesis that 2 independent samples
are drawn from the same continuous distribution.

Parameters
----------
data1, data2 : sequence of 1-D ndarrays
    two arrays of sample observations assumed to be drawn from a continuous
    distribution, sample sizes can be different

Returns
-------
statistic : float
    KS statistic
pvalue : float
    two-tailed p-value

Notes
-----
This tests whether 2 samples are drawn from the same distribution. Note
that, like in the case of the one-sample K-S test, the distribution is
assumed to be continuous.

This is the two-sided test, one-sided tests are not implemented.
The test uses the two-sided asymptotic Kolmogorov-Smirnov distribution.

If the K-S statistic is small or the p-value is high, then we cannot
reject the hypothesis that the distributions of the two samples
are the same.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(12345678)  #fix random seed to get the same result
&gt;&gt;&gt; n1 = 200  # size of first sample
&gt;&gt;&gt; n2 = 300  # size of second sample

For a different distribution, we can reject the null hypothesis since the
pvalue is below 1%:

&gt;&gt;&gt; rvs1 = stats.norm.rvs(size=n1, loc=0., scale=1)
&gt;&gt;&gt; rvs2 = stats.norm.rvs(size=n2, loc=0.5, scale=1.5)
&gt;&gt;&gt; stats.ks_2samp(rvs1, rvs2)
(0.20833333333333337, 4.6674975515806989e-005)

For a slightly different distribution, we cannot reject the null hypothesis
at a 10% or lower alpha since the p-value at 0.144 is higher than 10%

&gt;&gt;&gt; rvs3 = stats.norm.rvs(size=n2, loc=0.01, scale=1.0)
&gt;&gt;&gt; stats.ks_2samp(rvs1, rvs3)
(0.10333333333333333, 0.14498781825751686)

For an identical distribution, we cannot reject the null hypothesis since
the p-value is high, 41%:

&gt;&gt;&gt; rvs4 = stats.norm.rvs(size=n2, loc=0.0, scale=1.0)
&gt;&gt;&gt; stats.ks_2samp(rvs1, rvs4)
(0.07999999999999996, 0.41126949729859719)</docstring>
    <inputPortSpec arg="data1" name="data1" port_type="basic:List" show_port="True">
      <docstring>two arrays of sample observations assumed to be drawn from a continuous
distribution, sample sizes can be different</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data2" name="data2" port_type="basic:List" show_port="True">
      <docstring>two arrays of sample observations assumed to be drawn from a continuous
distribution, sample sizes can be different</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>KS statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>two-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kstat" module_name="kstat" namespace="'stats'">
    <docstring>Return the nth k-statistic (1&lt;=n&lt;=4 so far).

The nth k-statistic is the unique symmetric unbiased estimator of the nth
cumulant kappa_n.

Parameters
----------
data : array_like
    Input array.
n : int, {1, 2, 3, 4}, optional
    Default is equal to 2.

Returns
-------
kstat : float
    The nth k-statistic.

See Also
--------
kstatvar: Returns an unbiased estimator of the variance of the k-statistic.

Notes
-----
The cumulants are related to central moments but are specifically defined
using a power series expansion of the logarithm of the characteristic
function (which is the Fourier transform of the PDF).
In particular let phi(t) be the characteristic function, then::

    ln phi(t) = &gt; kappa_n (it)^n / n!    (sum from n=0 to inf)

The first few cumulants (kappa_n)  in terms of central moments (mu_n) are::

    kappa_1 = mu_1
    kappa_2 = mu_2
    kappa_3 = mu_3
    kappa_4 = mu_4 - 3*mu_2**2
    kappa_5 = mu_5 - 10*mu_2 * mu_3

References
----------
http://mathworld.wolfram.com/k-Statistic.html

http://mathworld.wolfram.com/Cumulant.html</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Default is equal to 2.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2, 3, 4]]</values>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="kstat" name="kstat" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The nth k-statistic.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kstatvar" module_name="kstatvar" namespace="'stats'">
    <docstring>Returns an unbiased estimator of the variance of the k-statistic.

See `kstat` for more details of the k-statistic.

Parameters
----------
data : array_like
    Input array.
n : int, {1, 2}, optional
    Default is equal to 2.

Returns
-------
kstatvar : float
    The nth k-statistic variance.

See Also
--------
kstat</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="n" name="n" port_type="basic:Integer">
      <docstring>Default is equal to 2.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 2]]</values>
      <defaults>[2]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="kstatvar" name="kstatvar" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The nth k-statistic variance.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kstest" module_name="kstest" namespace="'stats'" output_type="list">
    <docstring>Perform the Kolmogorov-Smirnov test for goodness of fit.

This performs a test of the distribution G(x) of an observed
random variable against a given distribution F(x). Under the null
hypothesis the two distributions are identical, G(x)=F(x). The
alternative hypothesis can be either 'two-sided' (default), 'less'
or 'greater'. The KS test is only valid for continuous distributions.

Parameters
----------
rvs : str, array or callable
    If a string, it should be the name of a distribution in `scipy.stats`.
    If an array, it should be a 1-D array of observations of random
    variables.
    If a callable, it should be a function to generate random variables;
    it is required to have a keyword argument `size`.
cdf : str or callable
    If a string, it should be the name of a distribution in `scipy.stats`.
    If `rvs` is a string then `cdf` can be False or the same as `rvs`.
    If a callable, that callable is used to calculate the cdf.
args : tuple, sequence, optional
    Distribution parameters, used if `rvs` or `cdf` are strings.
N : int, optional
    Sample size if `rvs` is string or callable.  Default is 20.
alternative : {'two-sided', 'less','greater'}, optional
    Defines the alternative hypothesis (see explanation above).
    Default is 'two-sided'.
mode : 'approx' (default) or 'asymp', optional
    Defines the distribution used for calculating the p-value.

      - 'approx' : use approximation to exact distribution of test statistic
      - 'asymp' : use asymptotic distribution of test statistic

Returns
-------
statistic : float
    KS test statistic, either D, D+ or D-.
pvalue :  float
    One-tailed or two-tailed p-value.

Notes
-----
In the one-sided test, the alternative is that the empirical
cumulative distribution function of the random variable is "less"
or "greater" than the cumulative distribution function F(x) of the
hypothesis, ``G(x)&lt;=F(x)``, resp. ``G(x)&gt;=F(x)``.

Examples
--------
&gt;&gt;&gt; from scipy import stats

&gt;&gt;&gt; x = np.linspace(-15, 15, 9)
&gt;&gt;&gt; stats.kstest(x, 'norm')
(0.44435602715924361, 0.038850142705171065)

&gt;&gt;&gt; np.random.seed(987654321) # set random seed to get the same result
&gt;&gt;&gt; stats.kstest('norm', False, N=100)
(0.058352892479417884, 0.88531190944151261)

The above lines are equivalent to:

&gt;&gt;&gt; np.random.seed(987654321)
&gt;&gt;&gt; stats.kstest(stats.norm.rvs(size=100), 'norm')
(0.058352892479417884, 0.88531190944151261)

*Test against one-sided alternative hypothesis*

Shift distribution to larger values, so that ``cdf_dgp(x) &lt; norm.cdf(x)``:

&gt;&gt;&gt; np.random.seed(987654321)
&gt;&gt;&gt; x = stats.norm.rvs(loc=0.2, size=100)
&gt;&gt;&gt; stats.kstest(x,'norm', alternative = 'less')
(0.12464329735846891, 0.040989164077641749)

Reject equal distribution against alternative hypothesis: less

&gt;&gt;&gt; stats.kstest(x,'norm', alternative = 'greater')
(0.0072115233216311081, 0.98531158590396395)

Don't reject equal distribution against alternative hypothesis: greater

&gt;&gt;&gt; stats.kstest(x,'norm', mode='asymp')
(0.12464329735846891, 0.08944488871182088)

*Testing t distributed random variables against normal distribution*

With 100 degrees of freedom the t distribution looks close to the normal
distribution, and the K-S test does not reject the hypothesis that the
sample came from the normal distribution:

&gt;&gt;&gt; np.random.seed(987654321)
&gt;&gt;&gt; stats.kstest(stats.t.rvs(100,size=100),'norm')
(0.072018929165471257, 0.67630062862479168)

With 3 degrees of freedom the t distribution looks sufficiently different
from the normal distribution, that we can reject the hypothesis that the
sample came from the normal distribution at the 10% level:

&gt;&gt;&gt; np.random.seed(987654321)
&gt;&gt;&gt; stats.kstest(stats.t.rvs(3,size=100),'norm')
(0.131016895759829, 0.058826222555312224)</docstring>
    <inputPortSpec arg="rvs" depth="1" name="rvs" show_port="True">
      <docstring>If a string, it should be the name of a distribution in `scipy.stats`.
If an array, it should be a 1-D array of observations of random
variables.
If a callable, it should be a function to generate random variables;
it is required to have a keyword argument `size`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cdf" name="cdf" show_port="True">
      <docstring>If a string, it should be the name of a distribution in `scipy.stats`.
If `rvs` is a string then `cdf` can be False or the same as `rvs`.
If a callable, that callable is used to calculate the cdf.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="args" name="args" port_type="basic:List">
      <docstring>Distribution parameters, used if `rvs` or `cdf` are strings.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Sample size if `rvs` is string or callable.  Default is 20.</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="alternative" name="alternative">
      <docstring>Defines the alternative hypothesis (see explanation above).
Default is 'two-sided'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['two-sided', 'less', 'greater']]</values>
      <defaults>['two-sided']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>Defines the distribution used for calculating the p-value.

  - 'approx' : use approximation to exact distribution of test statistic
  - 'asymp' : use asymptotic distribution of test statistic</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['approx']]</values>
      <defaults>['approx']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>KS test statistic, either D, D+ or D-.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>One-tailed or two-tailed p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kurtosis" module_name="kurtosis" namespace="'stats'">
    <docstring>Computes the kurtosis (Fisher or Pearson) of a dataset.

Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.

If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators

Use `kurtosistest` to see if result is close enough to normal.

Parameters
----------
a : array
    data for which the kurtosis is calculated
axis : int or None, optional
    Axis along which the kurtosis is calculated. Default is 0.
    If None, compute over the whole array `a`.
fisher : bool, optional
    If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
    Pearson's definition is used (normal ==&gt; 3.0).
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.

Returns
-------
kurtosis : array
    The kurtosis of values along an axis. If all values are equal,
    return -3 for Fisher's definition and 0 for Pearson's definition.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>data for which the kurtosis is calculated</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the kurtosis is calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fisher" name="fisher" port_type="basic:Boolean">
      <docstring>If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
Pearson's definition is used (normal ==&gt; 3.0).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Boolean">
      <docstring>If False, then the calculations are corrected for statistical bias.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="kurtosis" name="kurtosis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The kurtosis of values along an axis. If all values are equal,
return -3 for Fisher's definition and 0 for Pearson's definition.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.kurtosistest" module_name="kurtosistest" namespace="'stats'" output_type="list">
    <docstring>Tests whether a dataset has normal kurtosis

This function tests the null hypothesis that the kurtosis
of the population from which the sample was drawn is that
of the normal distribution: ``kurtosis = 3(n-1)/(n+1)``.

Parameters
----------
a : array
    array of the sample data
axis : int or None, optional
   Axis along which to compute test. Default is 0. If None,
   compute over the whole array `a`.

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    The 2-sided p-value for the hypothesis test

Notes
-----
Valid only for n&gt;20.  The Z-score is set to 0 for bad entries.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of the sample data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. Default is 0. If None,
compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed z-score for this test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The 2-sided p-value for the hypothesis test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.levene" module_name="levene" namespace="'stats'" output_type="list">
    <docstring>Perform Levene test for equal variances.

The Levene test tests the null hypothesis that all input samples
are from populations with equal variances.  Levene's test is an
alternative to Bartlett's test `bartlett` in the case where
there are significant deviations from normality.

Parameters
----------
sample1, sample2, ... : array_like
    The sample data, possibly with different lengths
center : {'mean', 'median', 'trimmed'}, optional
    Which function of the data to use in the test.  The default
    is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value for the test.

Notes
-----
Three variations of Levene's test are possible.  The possibilities
and their recommended usages are:

  * 'median' : Recommended for skewed (non-normal) distributions&gt;
  * 'mean' : Recommended for symmetric, moderate-tailed distributions.
  * 'trimmed' : Recommended for heavy-tailed distributions.

References
----------
.. [1]  http://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm
.. [2]   Levene, H. (1960). In Contributions to Probability and Statistics:
           Essays in Honor of Harold Hotelling, I. Olkin et al. eds.,
           Stanford University Press, pp. 278-292.
.. [3]  Brown, M. B. and Forsythe, A. B. (1974), Journal of the American
          Statistical Association, 69, 364-367</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>The sample data, possibly with different lengths</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>The sample data, possibly with different lengths</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>The sample data, possibly with different lengths</docstring>
    </inputPortSpec>
    <inputPortSpec arg="center" name="center">
      <docstring>Which function of the data to use in the test.  The default
is 'median'.</docstring>
      <defaults>['median']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float">
      <docstring>When `center` is 'trimmed', this gives the proportion of data points
to cut from each end. (See `scipy.stats.trim_mean`.)
Default is 0.05.</docstring>
      <defaults>[0.05]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.linregress" module_name="linregress" namespace="'stats'" output_type="list">
    <docstring>Calculate a regression line

This computes a least-squares regression for two sets of measurements.

Parameters
----------
x, y : array_like
    two sets of measurements.  Both arrays should have the same length.
    If only x is given (and y=None), then it must be a two-dimensional
    array where one dimension has length 2.  The two sets of measurements
    are then found by splitting the array along the length-2 dimension.

Returns
-------
slope : float
    slope of the regression line
intercept : float
    intercept of the regression line
rvalue : float
    correlation coefficient
pvalue : float
    two-sided p-value for a hypothesis test whose null hypothesis is
    that the slope is zero.
stderr : float
    Standard error of the estimate


Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.random.random(10)
&gt;&gt;&gt; y = np.random.random(10)
&gt;&gt;&gt; slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)

# To get coefficient of determination (r_squared)

&gt;&gt;&gt; print("r-squared:", r_value**2)
r-squared: 0.15286643777</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>two sets of measurements.  Both arrays should have the same length.
If only x is given (and y=None), then it must be a two-dimensional
array where one dimension has length 2.  The two sets of measurements
are then found by splitting the array along the length-2 dimension.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>two sets of measurements.  Both arrays should have the same length.
If only x is given (and y=None), then it must be a two-dimensional
array where one dimension has length 2.  The two sets of measurements
are then found by splitting the array along the length-2 dimension.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="slope" name="slope" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>slope of the regression line</docstring>
    </outputPortSpec>
    <outputPortSpec arg="intercept" name="intercept" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>intercept of the regression line</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rvalue" name="rvalue" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>correlation coefficient</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>two-sided p-value for a hypothesis test whose null hypothesis is
that the slope is zero.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="stderr" name="stderr" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Standard error of the estimate</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mannwhitneyu" module_name="mannwhitneyu" namespace="'stats'" output_type="list">
    <docstring>Computes the Mann-Whitney rank test on samples x and y.

Parameters
----------
x, y : array_like
    Array of samples, should be one-dimensional.
use_continuity : bool, optional
        Whether a continuity correction (1/2.) should be taken into
        account. Default is True.

Returns
-------
statistic : float
    The Mann-Whitney statistics.
pvalue : float
    One-sided p-value assuming a asymptotic normal distribution.

Notes
-----
Use only when the number of observation in each sample is &gt; 20 and
you have 2 independent samples of ranks. Mann-Whitney U is
significant if the u-obtained is LESS THAN or equal to the critical
value of U.

This test corrects for ties and by default uses a continuity correction.
The reported p-value is for a one-sided hypothesis, to get the two-sided
p-value multiply the returned p-value by 2.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of samples, should be one-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Array of samples, should be one-dimensional.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_continuity" name="use_continuity" port_type="basic:Boolean">
      <docstring>Whether a continuity correction (1/2.) should be taken into
account. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Mann-Whitney statistics.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>One-sided p-value assuming a asymptotic normal distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.median_test" module_name="median_test" namespace="'stats'" output_type="list">
    <docstring>Mood's median test.

Test that two or more samples come from populations with the same median.

Let ``n = len(args)`` be the number of samples.  The "grand median" of
all the data is computed, and a contingency table is formed by
classifying the values in each sample as being above or below the grand
median.  The contingency table, along with `correction` and `lambda_`,
are passed to `scipy.stats.chi2_contingency` to compute the test statistic
and p-value.

Parameters
----------
sample1, sample2, ... : array_like
    The set of samples.  There must be at least two samples.
    Each sample must be a one-dimensional sequence containing at least
    one value.  The samples are not required to have the same length.
ties : str, optional
    Determines how values equal to the grand median are classified in
    the contingency table.  The string must be one of::

        "below":
            Values equal to the grand median are counted as "below".
        "above":
            Values equal to the grand median are counted as "above".
        "ignore":
            Values equal to the grand median are not counted.

    The default is "below".
correction : bool, optional
    If True, *and* there are just two samples, apply Yates' correction
    for continuity when computing the test statistic associated with
    the contingency table.  Default is True.
lambda_ : float or str, optional.
    By default, the statistic computed in this test is Pearson's
    chi-squared statistic.  `lambda_` allows a statistic from the
    Cressie-Read power divergence family to be used instead.  See
    `power_divergence` for details.
    Default is 1 (Pearson's chi-squared statistic).

Returns
-------
stat : float
    The test statistic.  The statistic that is returned is determined by
    `lambda_`.  The default is Pearson's chi-squared statistic.
p : float
    The p-value of the test.
m : float
    The grand median.
table : ndarray
    The contingency table.  The shape of the table is (2, n), where
    n is the number of samples.  The first row holds the counts of the
    values above the grand median, and the second row holds the counts
    of the values below the grand median.  The table allows further
    analysis with, for example, `scipy.stats.chi2_contingency`, or with
    `scipy.stats.fisher_exact` if there are two samples, without having
    to recompute the table.

See Also
--------
kruskal : Compute the Kruskal-Wallis H-test for independent samples.
mannwhitneyu : Computes the Mann-Whitney rank test on samples x and y.

Notes
-----
.. versionadded:: 0.15.0

References
----------
.. [1] Mood, A. M., Introduction to the Theory of Statistics. McGraw-Hill
    (1950), pp. 394-399.
.. [2] Zar, J. H., Biostatistical Analysis, 5th ed. Prentice Hall (2010).
    See Sections 8.12 and 10.15.

Examples
--------
A biologist runs an experiment in which there are three groups of plants.
Group 1 has 16 plants, group 2 has 15 plants, and group 3 has 17 plants.
Each plant produces a number of seeds.  The seed counts for each group
are::

    Group 1: 10 14 14 18 20 22 24 25 31 31 32 39 43 43 48 49
    Group 2: 28 30 31 33 34 35 36 40 44 55 57 61 91 92 99
    Group 3:  0  3  9 22 23 25 25 33 34 34 40 45 46 48 62 67 84

The following code applies Mood's median test to these samples.

&gt;&gt;&gt; g1 = [10, 14, 14, 18, 20, 22, 24, 25, 31, 31, 32, 39, 43, 43, 48, 49]
&gt;&gt;&gt; g2 = [28, 30, 31, 33, 34, 35, 36, 40, 44, 55, 57, 61, 91, 92, 99]
&gt;&gt;&gt; g3 = [0, 3, 9, 22, 23, 25, 25, 33, 34, 34, 40, 45, 46, 48, 62, 67, 84]
&gt;&gt;&gt; from scipy.stats import median_test
&gt;&gt;&gt; stat, p, med, tbl = median_test(g1, g2, g3)

The median is

&gt;&gt;&gt; med
34.0

and the contingency table is

&gt;&gt;&gt; tbl
array([[ 5, 10,  7],
       [11,  5, 10]])

`p` is too large to conclude that the medians are not the same:

&gt;&gt;&gt; p
0.12609082774093244

The "G-test" can be performed by passing ``lambda_="log-likelihood"`` to
`median_test`.

&gt;&gt;&gt; g, p, med, tbl = median_test(g1, g2, g3, lambda_="log-likelihood")
&gt;&gt;&gt; p
0.12224779737117837

The median occurs several times in the data, so we'll get a different
result if, for example, ``ties="above"`` is used:

&gt;&gt;&gt; stat, p, med, tbl = median_test(g1, g2, g3, ties="above")
&gt;&gt;&gt; p
0.063873276069553273

&gt;&gt;&gt; tbl
array([[ 5, 11,  9],
       [11,  4,  8]])

This example demonstrates that if the data set is not large and there
are values equal to the median, the p-value can be sensitive to the
choice of `ties`.</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>The set of samples.  There must be at least two samples.
Each sample must be a one-dimensional sequence containing at least
one value.  The samples are not required to have the same length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>The set of samples.  There must be at least two samples.
Each sample must be a one-dimensional sequence containing at least
one value.  The samples are not required to have the same length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>The set of samples.  There must be at least two samples.
Each sample must be a one-dimensional sequence containing at least
one value.  The samples are not required to have the same length.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ties" name="ties">
      <docstring>Determines how values equal to the grand median are classified in
the contingency table.  The string must be one of::

    "below":
        Values equal to the grand median are counted as "below".
    "above":
        Values equal to the grand median are counted as "above".
    "ignore":
        Values equal to the grand median are not counted.

The default is "below".</docstring>
      <defaults>['below']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="correction" name="correction" port_type="basic:Boolean">
      <docstring>If True, *and* there are just two samples, apply Yates' correction
for continuity when computing the test statistic associated with
the contingency table.  Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lambda_" name="lambda_">
      <docstring>By default, the statistic computed in this test is Pearson's
chi-squared statistic.  `lambda_` allows a statistic from the
Cressie-Read power divergence family to be used instead.  See
`power_divergence` for details.
Default is 1 (Pearson's chi-squared statistic).</docstring>
    </inputPortSpec>
    <outputPortSpec arg="stat" name="stat" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.  The statistic that is returned is determined by
`lambda_`.  The default is Pearson's chi-squared statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="m" name="m" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>The grand median.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="table" name="table" port_type="basic:List" show_port="True" sort_key="3">
      <docstring>The contingency table.  The shape of the table is (2, n), where
n is the number of samples.  The first row holds the counts of the
values above the grand median, and the second row holds the counts
of the values below the grand median.  The table allows further
analysis with, for example, `scipy.stats.chi2_contingency`, or with
`scipy.stats.fisher_exact` if there are two samples, without having
to recompute the table.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mode" module_name="mode" namespace="'stats'" output_type="list">
    <docstring>Returns an array of the modal (most common) value in the passed array.

If there is more than one such value, only the first is returned.
The bin-count for the modal bins is also returned.

Parameters
----------
a : array_like
    n-dimensional array of which to find mode(s).
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
mode : ndarray
    Array of modal values.
count : ndarray
    Array of counts for each mode.

Examples
--------
&gt;&gt;&gt; a = np.array([[6, 8, 3, 0],
...               [3, 2, 1, 7],
...               [8, 1, 8, 4],
...               [5, 3, 0, 5],
...               [4, 7, 5, 9]])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.mode(a)
(array([[3, 1, 0, 0]]), array([[1, 1, 1, 1]]))

To get mode of whole array, specify ``axis=None``:

&gt;&gt;&gt; stats.mode(a, axis=None)
(array([3]), array([3]))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>n-dimensional array of which to find mode(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="mode" name="mode" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of modal values.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="count" name="count" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Array of counts for each mode.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.moment" module_name="moment" namespace="'stats'">
    <docstring>Calculates the nth moment about the mean for a sample.

Generally used to calculate coefficients of skewness and
kurtosis.

Parameters
----------
a : array_like
   data
moment : int, optional
   order of central moment that is returned
axis : int or None, optional
   Axis along which the central moment is computed. Default is 0.
   If None, compute over the whole array `a`.

Returns
-------
n-th central moment : ndarray or float
   The appropriate moment along the given axis or over all values if axis
   is None. The denominator for the moment calculation is the number of
   observations, no degrees of freedom correction is done.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="moment" name="moment" port_type="basic:Integer">
      <docstring>order of central moment that is returned</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the central moment is computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="n-th central moment" name="n-th central moment" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The appropriate moment along the given axis or over all values if axis
is None. The denominator for the moment calculation is the number of
observations, no degrees of freedom correction is done.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mood" module_name="mood" namespace="'stats'" output_type="list">
    <docstring>Perform Mood's test for equal scale parameters.

Mood's two-sample test for scale parameters is a non-parametric
test for the null hypothesis that two samples are drawn from the
same distribution with the same scale parameter.

Parameters
----------
x, y : array_like
    Arrays of sample data.
axis : int, optional
    The axis along which the samples are tested.  `x` and `y` can be of
    different length along `axis`.
    If `axis` is None, `x` and `y` are flattened and the test is done on
    all values in the flattened arrays.

Returns
-------
z : scalar or ndarray
    The z-score for the hypothesis test.  For 1-D inputs a scalar is
    returned.
p-value : scalar ndarray
    The p-value for the hypothesis test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
ansari : A non-parametric test for the equality of 2 variances
bartlett : A parametric test for equality of k variances in normal samples
levene : A parametric test for equality of k variances

Notes
-----
The data are assumed to be drawn from probability distributions ``f(x)``
and ``f(x/s) / s`` respectively, for some probability density function f.
The null hypothesis is that ``s == 1``.

For multi-dimensional arrays, if the inputs are of shapes
``(n0, n1, n2, n3)``  and ``(n0, m1, n2, n3)``, then if ``axis=1``, the
resulting z and p values will have shape ``(n0, n2, n3)``.  Note that
``n1`` and ``m1`` don't have to be equal, but the other dimensions do.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x2 = np.random.randn(2, 45, 6, 7)
&gt;&gt;&gt; x1 = np.random.randn(2, 30, 6, 7)
&gt;&gt;&gt; z, p = stats.mood(x1, x2, axis=1)
&gt;&gt;&gt; p.shape
(2, 6, 7)

Find the number of points where the difference in scale is not significant:

&gt;&gt;&gt; (p &gt; 0.1).sum()
74

Perform the test with different scales:

&gt;&gt;&gt; x1 = np.random.randn(2, 30)
&gt;&gt;&gt; x2 = np.random.randn(2, 35) * 10.0
&gt;&gt;&gt; stats.mood(x1, x2, axis=1)
(array([-5.84332354, -5.6840814 ]), array([5.11694980e-09, 1.31517628e-08]))</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays of sample data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays of sample data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>The axis along which the samples are tested.  `x` and `y` can be of
different length along `axis`.
If `axis` is None, `x` and `y` are flattened and the test is done on
all values in the flattened arrays.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="z" name="z" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The z-score for the hypothesis test.  For 1-D inputs a scalar is
returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p-value" name="p-value" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The p-value for the hypothesis test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mvsdist" module_name="mvsdist" namespace="'stats'" output_type="list">
    <docstring>'Frozen' distributions for mean, variance, and standard deviation of data.

Parameters
----------
data : array_like
    Input array. Converted to 1-D using ravel.
    Requires 2 or more data-points.

Returns
-------
mdist : "frozen" distribution object
    Distribution object representing the mean of the data
vdist : "frozen" distribution object
    Distribution object representing the variance of the data
sdist : "frozen" distribution object
    Distribution object representing the standard deviation of the data

Notes
-----
The return values from bayes_mvs(data) is equivalent to
``tuple((x.mean(), x.interval(0.90)) for x in mvsdist(data))``.

In other words, calling ``&lt;dist&gt;.mean()`` and ``&lt;dist&gt;.interval(0.90)``
on the three distribution objects returned from this function will give
the same results that are returned from `bayes_mvs`.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]
&gt;&gt;&gt; mean, var, std = stats.mvsdist(data)

We now have frozen distribution objects "mean", "var" and "std" that we can
examine:

&gt;&gt;&gt; mean.mean()
9.0
&gt;&gt;&gt; mean.interval(0.95)
(6.6120585482655692, 11.387941451734431)
&gt;&gt;&gt; mean.std()
1.1952286093343936</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input array. Converted to 1-D using ravel.
Requires 2 or more data-points.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="mdist" depth="1" name="mdist" show_port="True" sort_key="0">
      <docstring>Distribution object representing the mean of the data</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vdist" depth="1" name="vdist" show_port="True" sort_key="1">
      <docstring>Distribution object representing the variance of the data</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sdist" depth="1" name="sdist" show_port="True" sort_key="2">
      <docstring>Distribution object representing the standard deviation of the data</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.namedtuple" module_name="namedtuple" namespace="'stats'">
    <docstring>Returns a new subclass of tuple with named fields.

&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; Point.__doc__                   # docstring for the new class
'Point(x, y)'
&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords
&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple
33
&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple
&gt;&gt;&gt; x, y
(11, 22)
&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name
33
&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary
&gt;&gt;&gt; d['x']
11
&gt;&gt;&gt; Point(**d)                      # convert from a dictionary
Point(x=11, y=22)
&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields
Point(x=100, y=22)</docstring>
    <inputPortSpec arg="rename" name="rename" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="typename" name="typename" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="field_names" name="field_names" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Boolean" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.nanmean" module_name="nanmean" namespace="'stats'">
    <docstring>`nanmean` is deprecated!
scipy.stats.nanmean is deprecated in scipy 0.15.0 in favour of numpy.nanmean.


    Compute the mean over the given axis ignoring nans.

    Parameters
    ----------
    x : ndarray
        Input array.
    axis : int or None, optional
        Axis along which the mean is computed. Default is 0.
        If None, compute over the whole array `x`.

    Returns
    -------
    m : float
        The mean of `x`, ignoring nans.

    See Also
    --------
    nanstd, nanmedian

    Examples
    --------
    &gt;&gt;&gt; from scipy import stats
    &gt;&gt;&gt; a = np.linspace(0, 4, 3)
    &gt;&gt;&gt; a
    array([ 0.,  2.,  4.])
    &gt;&gt;&gt; a[-1] = np.nan
    &gt;&gt;&gt; stats.nanmean(a)
    1.0</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>    Input array.
axis : int or None, optional
    Axis along which the mean is computed. Default is 0.
    If None, compute over the whole array `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="m" name="m" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The mean of `x`, ignoring nans.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.nanmedian" module_name="nanmedian" namespace="'stats'">
    <docstring>`nanmedian` is deprecated!
scipy.stats.nanmedian is deprecated in scipy 0.15 in favour of numpy.nanmedian.


    Compute the median along the given axis ignoring nan values.

    Parameters
    ----------
    x : array_like
        Input array.
    axis : int or None, optional
        Axis along which the median is computed. Default is 0.
        If None, compute over the whole array `x`.

    Returns
    -------
    m : float
        The median of `x` along `axis`.

    See Also
    --------
    nanstd, nanmean, numpy.nanmedian

    Examples
    --------
    &gt;&gt;&gt; from scipy import stats
    &gt;&gt;&gt; a = np.array([0, 3, 1, 5, 5, np.nan])
    &gt;&gt;&gt; stats.nanmedian(a)
    array(3.0)

    &gt;&gt;&gt; b = np.array([0, 3, 1, 5, 5, np.nan, 5])
    &gt;&gt;&gt; stats.nanmedian(b)
    array(4.0)

    Example with axis:

    &gt;&gt;&gt; c = np.arange(30.).reshape(5,6)
    &gt;&gt;&gt; idx = np.array([False, False, False, True, False] * 6).reshape(5,6)
    &gt;&gt;&gt; c[idx] = np.nan
    &gt;&gt;&gt; c
    array([[  0.,   1.,   2.,  nan,   4.,   5.],
           [  6.,   7.,  nan,   9.,  10.,  11.],
           [ 12.,  nan,  14.,  15.,  16.,  17.],
           [ nan,  19.,  20.,  21.,  22.,  nan],
           [ 24.,  25.,  26.,  27.,  nan,  29.]])
    &gt;&gt;&gt; stats.nanmedian(c, axis=1)
    array([  2. ,   9. ,  15. ,  20.5,  26. ])</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>    Input array.
axis : int or None, optional
    Axis along which the median is computed. Default is 0.
    If None, compute over the whole array `x`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="m" name="m" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The median of `x` along `axis`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.nanstd" module_name="nanstd" namespace="'stats'">
    <docstring>`nanstd` is deprecated!
scipy.stats.nanstd is deprecated in scipy 0.15 in favour of numpy.nanstd.
Note that numpy.nanstd has a different signature.


    Compute the standard deviation over the given axis, ignoring nans.

    Parameters
    ----------
    x : array_like
        Input array.
    axis : int or None, optional
        Axis along which the standard deviation is computed. Default is 0.
        If None, compute over the whole array `x`.
    bias : bool, optional
        If True, the biased (normalized by N) definition is used. If False
        (default), the unbiased definition is used.

    Returns
    -------
    s : float
        The standard deviation.

    See Also
    --------
    nanmean, nanmedian

    Examples
    --------
    &gt;&gt;&gt; from scipy import stats
    &gt;&gt;&gt; a = np.arange(10, dtype=float)
    &gt;&gt;&gt; a[1:3] = np.nan
    &gt;&gt;&gt; np.std(a)
    nan
    &gt;&gt;&gt; stats.nanstd(a)
    2.9154759474226504
    &gt;&gt;&gt; stats.nanstd(a.reshape(2, 5), axis=1)
    array([ 2.0817,  1.5811])
    &gt;&gt;&gt; stats.nanstd(a.reshape(2, 5), axis=None)
    2.9154759474226504</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>    Input array.
axis : int or None, optional
    Axis along which the standard deviation is computed. Default is 0.
    If None, compute over the whole array `x`.
bias : bool, optional
    If True, the biased (normalized by N) definition is used. If False
    (default), the unbiased definition is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The standard deviation.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.normaltest" module_name="normaltest" namespace="'stats'" output_type="list">
    <docstring>Tests whether a sample differs from a normal distribution.

This function tests the null hypothesis that a sample comes
from a normal distribution.  It is based on D'Agostino and
Pearson's [1]_, [2]_ test that combines skew and kurtosis to
produce an omnibus test of normality.


Parameters
----------
a : array_like
    The array containing the data to be tested.
axis : int or None, optional
    Axis along which to compute test. Default is 0. If None,
    compute over the whole array `a`.

Returns
-------
statistic : float or array
    `s^2 + k^2`, where `s` is the z-score returned by `skewtest` and
    `k` is the z-score returned by `kurtosistest`.
pvalue : float or array
   A 2-sided chi squared probability for the hypothesis test.

References
----------
.. [1] D'Agostino, R. B. (1971), "An omnibus test of normality for
       moderate and large sample size," Biometrika, 58, 341-348

.. [2] D'Agostino, R. and Pearson, E. S. (1973), "Testing for
       departures from normality," Biometrika, 60, 613-622</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array containing the data to be tested.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. Default is 0. If None,
compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>`s^2 + k^2`, where `s` is the z-score returned by `skewtest` and
`k` is the z-score returned by `kurtosistest`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>A 2-sided chi squared probability for the hypothesis test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.obrientransform" module_name="obrientransform" namespace="'stats'">
    <docstring>Computes the O'Brien transform on input data (any number of arrays).

Used to test for homogeneity of variance prior to running one-way stats.
Each array in ``*args`` is one level of a factor.
If `f_oneway` is run on the transformed data and found significant,
the variances are unequal.  From Maxwell and Delaney [1]_, p.112.

Parameters
----------
args : tuple of array_like
    Any number of arrays.

Returns
-------
obrientransform : ndarray
    Transformed data for use in an ANOVA.  The first dimension
    of the result corresponds to the sequence of transformed
    arrays.  If the arrays given are all 1-D of the same length,
    the return value is a 2-D array; otherwise it is a 1-D array
    of type object, with each element being an ndarray.

References
----------
.. [1] S. E. Maxwell and H. D. Delaney, "Designing Experiments and
       Analyzing Data: A Model Comparison Perspective", Wadsworth, 1990.

Examples
--------
We'll test the following data sets for differences in their variance.

&gt;&gt;&gt; x = [10, 11, 13, 9, 7, 12, 12, 9, 10]
&gt;&gt;&gt; y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]

Apply the O'Brien transform to the data.

&gt;&gt;&gt; from scipy.stats import obrientransform
&gt;&gt;&gt; tx, ty = obrientransform(x, y)

Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the
transformed data.

&gt;&gt;&gt; from scipy.stats import f_oneway
&gt;&gt;&gt; F, p = f_oneway(tx, ty)
&gt;&gt;&gt; p
0.1314139477040335

If we require that ``p &lt; 0.05`` for significance, we cannot conclude
that the variances are different.</docstring>
    <inputPortSpec arg="args" name="args" port_type="basic:List" show_port="True">
      <docstring>Any number of arrays.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="obrientransform" name="obrientransform" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Transformed data for use in an ANOVA.  The first dimension
of the result corresponds to the sequence of transformed
arrays.  If the arrays given are all 1-D of the same length,
the return value is a 2-D array; otherwise it is a 1-D array
of type object, with each element being an ndarray.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.pdf_fromgamma" module_name="pdf_fromgamma" namespace="'stats'">
    <docstring>`pdf_fromgamma` is deprecated!
scipy.stats.pdf_fromgamma is deprecated in scipy 0.16.0 in favour of statsmodels.distributions.ExpandedNormal.</docstring>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.pearsonr" module_name="pearsonr" namespace="'stats'" output_type="list">
    <docstring>Calculates a Pearson correlation coefficient and the p-value for testing
non-correlation.

The Pearson correlation coefficient measures the linear relationship
between two datasets. Strictly speaking, Pearson's correlation requires
that each dataset be normally distributed. Like other correlation
coefficients, this one varies between -1 and +1 with 0 implying no
correlation. Correlations of -1 or +1 imply an exact linear
relationship. Positive correlations imply that as x increases, so does
y. Negative correlations imply that as x increases, y decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Pearson correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
x : (N,) array_like
    Input
y : (N,) array_like
    Input

Returns
-------
(Pearson's correlation coefficient,
 2-tailed p-value)

References
----------
http://www.statsoft.com/textbook/glosp.html#Pearson%20Correlation</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>2-tailed p-value)</docstring>
    </outputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="1">
      <docstring>2-tailed p-value)</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.percentileofscore" module_name="percentileofscore" namespace="'stats'">
    <docstring>The percentile rank of a score relative to a list of scores.

A `percentileofscore` of, for example, 80% means that 80% of the
scores in `a` are below the given score. In the case of gaps or
ties, the exact definition depends on the optional keyword, `kind`.

Parameters
----------
a : array_like
    Array of scores to which `score` is compared.
score : int or float
    Score that is compared to the elements in `a`.
kind : {'rank', 'weak', 'strict', 'mean'}, optional
    This optional parameter specifies the interpretation of the
    resulting score:

    - "rank": Average percentage ranking of score.  In case of
              multiple matches, average the percentage rankings of
              all matching scores.
    - "weak": This kind corresponds to the definition of a cumulative
              distribution function.  A percentileofscore of 80%
              means that 80% of values are less than or equal
              to the provided score.
    - "strict": Similar to "weak", except that only values that are
                strictly less than the given score are counted.
    - "mean": The average of the "weak" and "strict" scores, often used in
              testing.  See

              http://en.wikipedia.org/wiki/Percentile_rank

Returns
-------
pcos : float
    Percentile-position of score (0-100) relative to `a`.

See Also
--------
numpy.percentile

Examples
--------
Three-quarters of the given values lie below a given score:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 4], 3)
75.0

With multiple matches, note how the scores of the two matches, 0.6
and 0.8 respectively, are averaged:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3)
70.0

Only 2/5 values are strictly less than 3:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='strict')
40.0

But 4/5 values are less than or equal to 3:

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='weak')
80.0

The average between the weak and the strict scores is

&gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='mean')
60.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array of scores to which `score` is compared.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="score" name="score" port_type="basic:Float" show_port="True">
      <docstring>Score that is compared to the elements in `a`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kind" name="kind">
      <docstring>This optional parameter specifies the interpretation of the
resulting score:

- "rank": Average percentage ranking of score.  In case of
          multiple matches, average the percentage rankings of
          all matching scores.
- "weak": This kind corresponds to the definition of a cumulative
          distribution function.  A percentileofscore of 80%
          means that 80% of values are less than or equal
          to the provided score.
- "strict": Similar to "weak", except that only values that are
            strictly less than the given score are counted.
- "mean": The average of the "weak" and "strict" scores, often used in
          testing.  See

          http://en.wikipedia.org/wiki/Percentile_rank</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['rank', 'weak', 'mean']]</values>
      <defaults>['rank']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="pcos" name="pcos" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Percentile-position of score (0-100) relative to `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.pointbiserialr" module_name="pointbiserialr" namespace="'stats'" output_type="list">
    <docstring>Calculates a point biserial correlation coefficient and the associated
p-value.

The point biserial correlation is used to measure the relationship
between a binary variable, x, and a continuous variable, y. Like other
correlation coefficients, this one varies between -1 and +1 with 0
implying no correlation. Correlations of -1 or +1 imply a determinative
relationship.

This function uses a shortcut formula but produces the same result as
`pearsonr`.

Parameters
----------
x : array_like of bools
    Input array.
y : array_like
    Input array.

Returns
-------
correlation : float
    R value
pvalue : float
    2-tailed p-value

References
----------
http://en.wikipedia.org/wiki/Point-biserial_correlation_coefficient

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.array([0, 0, 0, 1, 1, 1, 1])
&gt;&gt;&gt; b = np.arange(7)
&gt;&gt;&gt; stats.pointbiserialr(a, b)
(0.8660254037844386, 0.011724811003954652)
&gt;&gt;&gt; stats.pearsonr(a, b)
(0.86602540378443871, 0.011724811003954626)
&gt;&gt;&gt; np.corrcoef(a, b)
array([[ 1.       ,  0.8660254],
       [ 0.8660254,  1.       ]])</docstring>
    <inputPortSpec arg="x" depth="1" name="x" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>R value</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>2-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.power_divergence" module_name="power_divergence" namespace="'stats'" output_type="list">
    <docstring>Cressie-Read power divergence statistic and goodness of fit test.

This function tests the null hypothesis that the categorical data
has the given frequencies, using the Cressie-Read power divergence
statistic.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.
lambda_ : float or str, optional
    `lambda_` gives the power in the Cressie-Read power divergence
    statistic.  The default is 1.  For convenience, `lambda_` may be
    assigned one of the following strings, in which case the
    corresponding numerical value is used::

        String              Value   Description
        "pearson"             1     Pearson's chi-squared statistic.
                                    In this case, the function is
                                    equivalent to `stats.chisquare`.
        "log-likelihood"      0     Log-likelihood ratio. Also known as
                                    the G-test [3]_.
        "freeman-tukey"      -1/2   Freeman-Tukey statistic.
        "mod-log-likelihood" -1     Modified log-likelihood ratio.
        "neyman"             -2     Neyman's statistic.
        "cressie-read"        2/3   The power recommended in [5]_.

Returns
-------
statistic : float or ndarray
    The Cressie-Read power divergence test statistic.  The value is
    a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.
pvalue : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `stat` are scalars.

See Also
--------
chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

When `lambda_` is less than zero, the formula for the statistic involves
dividing by `f_obs`, so a warning or error may be generated if any value
in `f_obs` is 0.

Similarly, a warning or error may be generated if any value in `f_exp` is
zero when `lambda_` &gt;= 0.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

This function handles masked arrays.  If an element of `f_obs` or `f_exp`
is masked, then data at that position is ignored, and does not count
towards the size of the data set.

.. versionadded:: 0.13.0

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test
.. [3] "G-test", http://en.wikipedia.org/wiki/G-test
.. [4] Sokal, R. R. and Rohlf, F. J. "Biometry: the principles and
       practice of statistics in biological research", New York: Freeman
       (1981)
.. [5] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
       Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
       pp. 440-464.

Examples
--------

(See `chisquare` for more examples.)

When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.  Here we
perform a G-test (i.e. use the log-likelihood ratio statistic):

&gt;&gt;&gt; from scipy.stats import power_divergence
&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], lambda_='log-likelihood')
(2.006573162632538, 0.84823476779463769)

The expected frequencies can be given with the `f_exp` argument:

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[16, 16, 16, 16, 16, 8],
...                  lambda_='log-likelihood')
(3.5, 0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

&gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
&gt;&gt;&gt; obs.shape
(6, 2)
&gt;&gt;&gt; power_divergence(obs, lambda_="log-likelihood")
(array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

&gt;&gt;&gt; power_divergence(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
&gt;&gt;&gt; power_divergence(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
test statistic with `ddof`.

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we must use ``axis=1``:

&gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[[16, 16, 16, 16, 16, 8],
...                         [8, 20, 20, 16, 12, 12]],
...                  axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</docstring>
    <inputPortSpec arg="f_obs" name="f_obs" port_type="basic:List" show_port="True">
      <docstring>Observed frequencies in each category.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_exp" name="f_exp" port_type="basic:List">
      <docstring>Expected frequencies in each category.  By default the categories are
assumed to be equally likely.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>"Delta degrees of freedom": adjustment to the degrees of freedom
for the p-value.  The p-value is computed using a chi-squared
distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
is the number of observed frequencies.  The default value of `ddof`
is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>The axis of the broadcast result of `f_obs` and `f_exp` along which to
apply the test.  If axis is None, all values in `f_obs` are treated
as a single data set.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="lambda_" name="lambda_">
      <docstring>`lambda_` gives the power in the Cressie-Read power divergence
statistic.  The default is 1.  For convenience, `lambda_` may be
assigned one of the following strings, in which case the
corresponding numerical value is used::

    String              Value   Description
    "pearson"             1     Pearson's chi-squared statistic.
                                In this case, the function is
                                equivalent to `stats.chisquare`.
    "log-likelihood"      0     Log-likelihood ratio. Also known as
                                the G-test [3]_.
    "freeman-tukey"      -1/2   Freeman-Tukey statistic.
    "mod-log-likelihood" -1     Modified log-likelihood ratio.
    "neyman"             -2     Neyman's statistic.
    "cressie-read"        2/3   The power recommended in [5]_.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Cressie-Read power divergence test statistic.  The value is
a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the test.  The value is a float if `ddof` and the
return value `stat` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ppcc_max" module_name="ppcc_max" namespace="'stats'">
    <docstring>Returns the shape parameter that maximizes the probability plot
correlation coefficient for the given data to a one-parameter
family of distributions.

See also ppcc_plot</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="brack" name="brack" port_type="basic:List">
      <defaults>[(0.0, 1.0)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dist" name="dist">
      <defaults>['tukeylambda']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ppcc_plot" module_name="ppcc_plot" namespace="'stats'" output_type="list">
    <docstring>Calculate and optionally plot probability plot correlation coefficient.

The probability plot correlation coefficient (PPCC) plot can be used to
determine the optimal shape parameter for a one-parameter family of
distributions.  It cannot be used for distributions without shape parameters
(like the normal distribution) or with multiple shape parameters.

By default a Tukey-Lambda distribution (`stats.tukeylambda`) is used. A
Tukey-Lambda PPCC plot interpolates from long-tailed to short-tailed
distributions via an approximately normal one, and is therefore particularly
useful in practice.

Parameters
----------
x : array_like
    Input array.
a, b: scalar
    Lower and upper bounds of the shape parameter to use.
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.
plot : object, optional
    If given, plots PPCC against the shape parameter.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `a` to `b`).

Returns
-------
svals : ndarray
    The shape values for which `ppcc` was calculated.
ppcc : ndarray
    The calculated probability plot correlation coefficient values.

See also
--------
ppcc_max, probplot, boxcox_normplot, tukeylambda

References
----------
J.J. Filliben, "The Probability Plot Correlation Coefficient Test for
Normality", Technometrics, Vol. 17, pp. 111-117, 1975.

Examples
--------
First we generate some random data from a Tukey-Lambda distribution,
with shape parameter -0.7:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; np.random.seed(1234567)
&gt;&gt;&gt; x = stats.tukeylambda.rvs(-0.7, loc=2, scale=0.5, size=10000) + 1e4

Now we explore this data with a PPCC plot as well as the related
probability plot and Box-Cox normplot.  A red line is drawn where we
expect the PPCC value to be maximal (at the shape parameter -0.7 used
above):

&gt;&gt;&gt; fig = plt.figure(figsize=(12, 4))
&gt;&gt;&gt; ax1 = fig.add_subplot(131)
&gt;&gt;&gt; ax2 = fig.add_subplot(132)
&gt;&gt;&gt; ax3 = fig.add_subplot(133)
&gt;&gt;&gt; stats.probplot(x, plot=ax1)
&gt;&gt;&gt; stats.boxcox_normplot(x, -5, 5, plot=ax2)
&gt;&gt;&gt; stats.ppcc_plot(x, -5, 5, plot=ax3)
&gt;&gt;&gt; ax3.vlines(-0.7, 0, 1, colors='r', label='Expected shape value')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True">
      <docstring>Lower and upper bounds of the shape parameter to use.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="dist" name="dist">
      <docstring>Distribution or distribution function name.  Objects that look enough
like a stats.distributions instance (i.e. they have a ``ppf`` method)
are also accepted.  The default is ``'tukeylambda'``.</docstring>
      <defaults>['tukeylambda']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="plot" name="plot" port_type="basic:List">
      <docstring>If given, plots PPCC against the shape parameter.
`plot` is an object that has to have methods "plot" and "text".
The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
or a custom object with the same methods.
Default is None, which means that no plot is created.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="N" name="N" port_type="basic:Integer">
      <docstring>Number of points on the horizontal axis (equally distributed from
`a` to `b`).</docstring>
      <defaults>[80]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="svals" name="svals" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The shape values for which `ppcc` was calculated.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ppcc" name="ppcc" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>The calculated probability plot correlation coefficient values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.probplot" module_name="probplot" namespace="'stats'" output_type="list">
    <docstring>Calculate quantiles for a probability plot, and optionally show the plot.

Generates a probability plot of sample data against the quantiles of a
specified theoretical distribution (the normal distribution by default).
`probplot` optionally calculates a best-fit line for the data and plots the
results using Matplotlib or a given plot function.

Parameters
----------
x : array_like
    Sample/response data from which `probplot` creates the plot.
sparams : tuple, optional
    Distribution-specific shape parameters (shape parameters plus location
    and scale).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name. The default is 'norm' for a
    normal probability plot.  Objects that look enough like a
    stats.distributions instance (i.e. they have a ``ppf`` method) are also
    accepted.
fit : bool, optional
    Fit a least-squares regression (best-fit) line to the sample data if
    True (default).
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.

Returns
-------
(osm, osr) : tuple of ndarrays
    Tuple of theoretical quantiles (osm, or order statistic medians) and
    ordered responses (osr).  `osr` is simply sorted input `x`.
    For details on how `osm` is calculated see the Notes section.
(slope, intercept, r) : tuple of floats, optional
    Tuple  containing the result of the least-squares fit, if that is
    performed by `probplot`. `r` is the square root of the coefficient of
    determination.  If ``fit=False`` and ``plot=None``, this tuple is not
    returned.

Notes
-----
Even if `plot` is given, the figure is not shown or saved by `probplot`;
``plt.show()`` or ``plt.savefig('figname.png')`` should be used after
calling `probplot`.

`probplot` generates a probability plot, which should not be confused with
a Q-Q or a P-P plot.  Statsmodels has more extensive functionality of this
type, see ``statsmodels.api.ProbPlot``.

The formula used for the theoretical quantiles (horizontal axis of the
probability plot) is Filliben's estimate::

    quantiles = dist.ppf(val), for

            0.5**(1/n),                  for i = n
      val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1
            1 - 0.5**(1/n),              for i = 1

where ``i`` indicates the i-th ordered value and ``n`` is the total number
of values.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; nsample = 100
&gt;&gt;&gt; np.random.seed(7654321)

A t distribution with small degrees of freedom:

&gt;&gt;&gt; ax1 = plt.subplot(221)
&gt;&gt;&gt; x = stats.t.rvs(3, size=nsample)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A t distribution with larger degrees of freedom:

&gt;&gt;&gt; ax2 = plt.subplot(222)
&gt;&gt;&gt; x = stats.t.rvs(25, size=nsample)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A mixture of two normal distributions with broadcasting:

&gt;&gt;&gt; ax3 = plt.subplot(223)
&gt;&gt;&gt; x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],
...                    size=(nsample/2.,2)).ravel()
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A standard normal distribution:

&gt;&gt;&gt; ax4 = plt.subplot(224)
&gt;&gt;&gt; x = stats.norm.rvs(loc=0, scale=1, size=nsample)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

Produce a new figure with a loggamma distribution, using the ``dist`` and
``sparams`` keywords:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; x = stats.loggamma.rvs(c=2.5, size=500)
&gt;&gt;&gt; stats.probplot(x, dist=stats.loggamma, sparams=(2.5,), plot=ax)
&gt;&gt;&gt; ax.set_title("Probplot for loggamma dist with shape parameter 2.5")

Show the results with Matplotlib:

&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Sample/response data from which `probplot` creates the plot.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sparams" name="sparams" port_type="basic:List">
      <docstring>Distribution-specific shape parameters (shape parameters plus location
and scale).</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dist" name="dist">
      <docstring>Distribution or distribution function name. The default is 'norm' for a
normal probability plot.  Objects that look enough like a
stats.distributions instance (i.e. they have a ``ppf`` method) are also
accepted.</docstring>
      <defaults>['norm']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fit" name="fit" port_type="basic:Boolean">
      <docstring>Fit a least-squares regression (best-fit) line to the sample data if
True (default).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="plot" name="plot" port_type="basic:List">
      <docstring>If given, plots the quantiles and least squares fit.
`plot` is an object that has to have methods "plot" and "text".
The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
or a custom object with the same methods.
Default is None, which means that no plot is created.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="(osm" name="(osm" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Tuple of theoretical quantiles (osm, or order statistic medians) and
ordered responses (osr).  `osr` is simply sorted input `x`.
For details on how `osm` is calculated see the Notes section.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="osr)" name="osr)" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Tuple of theoretical quantiles (osm, or order statistic medians) and
ordered responses (osr).  `osr` is simply sorted input `x`.
For details on how `osm` is calculated see the Notes section.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="(slope" depth="1" name="(slope" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Tuple  containing the result of the least-squares fit, if that is
performed by `probplot`. `r` is the square root of the coefficient of
determination.  If ``fit=False`` and ``plot=None``, this tuple is not
returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="intercept" depth="1" name="intercept" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Tuple  containing the result of the least-squares fit, if that is
performed by `probplot`. `r` is the square root of the coefficient of
determination.  If ``fit=False`` and ``plot=None``, this tuple is not
returned.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="r)" depth="1" name="r)" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Tuple  containing the result of the least-squares fit, if that is
performed by `probplot`. `r` is the square root of the coefficient of
determination.  If ``fit=False`` and ``plot=None``, this tuple is not
returned.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.rankdata" module_name="rankdata" namespace="'stats'">
    <docstring>rankdata(a, method='average')

Assign ranks to data, dealing with ties appropriately.

Ranks begin at 1.  The `method` argument controls how ranks are assigned
to equal values.  See [1]_ for further discussion of ranking methods.

Parameters
----------
a : array_like
    The array of values to be ranked.  The array is first flattened.
method : str, optional
    The method used to assign ranks to tied elements.
    The options are 'average', 'min', 'max', 'dense' and 'ordinal'.

    'average':
        The average of the ranks that would have been assigned to
        all the tied values is assigned to each value.
    'min':
        The minimum of the ranks that would have been assigned to all
        the tied values is assigned to each value.  (This is also
        referred to as "competition" ranking.)
    'max':
        The maximum of the ranks that would have been assigned to all
        the tied values is assigned to each value.
    'dense':
        Like 'min', but the rank of the next highest element is assigned
        the rank immediately after those assigned to the tied elements.
    'ordinal':
        All values are given a distinct rank, corresponding to the order
        that the values occur in `a`.

    The default is 'average'.

Returns
-------
ranks : ndarray
     An array of length equal to the size of `a`, containing rank
     scores.

Notes
-----
All floating point types are converted to numpy.float64 before ranking.
This may result in spurious ties if an input array of floats has a wider
data type than numpy.float64 (e.g. numpy.float128).

References
----------
.. [1] "Ranking", http://en.wikipedia.org/wiki/Ranking

Examples
--------
&gt;&gt;&gt; from scipy.stats import rankdata
&gt;&gt;&gt; rankdata([0, 2, 3, 2])
array([ 1. ,  2.5,  4. ,  2.5])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='min')
array([ 1.,  2.,  4.,  2.])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='max')
array([ 1.,  3.,  4.,  3.])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='dense')
array([ 1.,  2.,  3.,  2.])
&gt;&gt;&gt; rankdata([0, 2, 3, 2], method='ordinal')
array([ 1.,  2.,  4.,  3.])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array of values to be ranked.  The array is first flattened.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" name="method">
      <docstring>The method used to assign ranks to tied elements.
The options are 'average', 'min', 'max', 'dense' and 'ordinal'.

'average':
    The average of the ranks that would have been assigned to
    all the tied values is assigned to each value.
'min':
    The minimum of the ranks that would have been assigned to all
    the tied values is assigned to each value.  (This is also
    referred to as "competition" ranking.)
'max':
    The maximum of the ranks that would have been assigned to all
    the tied values is assigned to each value.
'dense':
    Like 'min', but the rank of the next highest element is assigned
    the rank immediately after those assigned to the tied elements.
'ordinal':
    All values are given a distinct rank, corresponding to the order
    that the values occur in `a`.

The default is 'average'.</docstring>
      <defaults>['average']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ranks" name="ranks" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>An array of length equal to the size of `a`, containing rank
scores.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ranksums" module_name="ranksums" namespace="'stats'" output_type="list">
    <docstring>Compute the Wilcoxon rank-sum statistic for two samples.

The Wilcoxon rank-sum test tests the null hypothesis that two sets
of measurements are drawn from the same distribution.  The alternative
hypothesis is that values in one sample are more likely to be
larger than the values in the other sample.

This test should be used to compare two samples from continuous
distributions.  It does not handle ties between measurements
in x and y.  For tie-handling and an optional continuity correction
see `scipy.stats.mannwhitneyu`.

Parameters
----------
x,y : array_like
    The data from the two samples

Returns
-------
statistic : float
    The test statistic under the large-sample approximation that the
    rank sum statistic is normally distributed
pvalue : float
    The two-sided p-value of the test

References
----------
.. [1] http://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The data from the two samples</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The data from the two samples</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic under the large-sample approximation that the
rank sum statistic is normally distributed</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-sided p-value of the test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.relfreq" module_name="relfreq" namespace="'stats'" output_type="list">
    <docstring>Returns a relative frequency histogram, using the histogram function.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
frequency : ndarray
    Binned values of relative frequency.
lowerlimit : float
    Lower real limit
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.array([1, 4, 2, 1, 3, 1])
&gt;&gt;&gt; relfreqs, lowlim, binsize, extrapoints = stats.relfreq(a, numbins=4)
&gt;&gt;&gt; relfreqs
array([ 0.5       ,  0.16666667,  0.16666667,  0.16666667])
&gt;&gt;&gt; np.sum(relfreqs)  # relative frequencies should add up to 1
0.99999999999999989</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="numbins" name="numbins" port_type="basic:Integer">
      <docstring>The number of bins to use for the histogram. Default is 10.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="defaultreallimits" name="defaultreallimits" port_type="basic:List">
      <docstring>The lower and upper values for the range of the histogram.
If no value is given, a range slightly larger than the range of the
values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" name="weights" port_type="basic:List">
      <docstring>The weights for each value in `a`. Default is None, which gives each
value a weight of 1.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="frequency" name="frequency" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Binned values of relative frequency.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lowerlimit" name="lowerlimit" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Lower real limit</docstring>
    </outputPortSpec>
    <outputPortSpec arg="binsize" name="binsize" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Width of each bin.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="extrapoints" name="extrapoints" port_type="basic:Integer" show_port="True" sort_key="3">
      <docstring>Extra points.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.scoreatpercentile" module_name="scoreatpercentile" namespace="'stats'">
    <docstring>Calculate the score at a given percentile of the input sequence.

For example, the score at `per=50` is the median. If the desired quantile
lies between two data points, we interpolate between them, according to
the value of `interpolation`. If the parameter `limit` is provided, it
should be a tuple (lower, upper) of two values.

Parameters
----------
a : array_like
    A 1-D array of values from which to extract score.
per : array_like
    Percentile(s) at which to extract score.  Values should be in range
    [0,100].
limit : tuple, optional
    Tuple of two scalars, the lower and upper limits within which to
    compute the percentile. Values of `a` outside
    this (closed) interval will be ignored.
interpolation_method : {'fraction', 'lower', 'higher'}, optional
    This optional parameter specifies the interpolation method to use,
    when the desired quantile lies between two data points `i` and `j`

      - fraction: ``i + (j - i) * fraction`` where ``fraction`` is the
        fractional part of the index surrounded by ``i`` and ``j``.
      - lower: ``i``.
      - higher: ``j``.

axis : int, optional
    Axis along which the percentiles are computed. Default is None. If
    None, compute over the whole array `a`.

Returns
-------
score : float or ndarray
    Score at percentile(s).

See Also
--------
percentileofscore, numpy.percentile

Notes
-----
This function will become obsolete in the future.
For Numpy 1.9 and higher, `numpy.percentile` provides all the functionality
that `scoreatpercentile` provides.  And it's significantly faster.
Therefore it's recommended to use `numpy.percentile` for users that have
numpy &gt;= 1.9.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(100)
&gt;&gt;&gt; stats.scoreatpercentile(a, 50)
49.5</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of values from which to extract score.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="per" name="per" port_type="basic:List" show_port="True">
      <docstring>Percentile(s) at which to extract score.  Values should be in range
[0,100].</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limit" name="limit" port_type="basic:List">
      <docstring>Tuple of two scalars, the lower and upper limits within which to
compute the percentile. Values of `a` outside
this (closed) interval will be ignored.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="interpolation_method" name="interpolation_method">
      <docstring>This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points `i` and `j`

  - fraction: ``i + (j - i) * fraction`` where ``fraction`` is the
    fractional part of the index surrounded by ``i`` and ``j``.
  - lower: ``i``.
  - higher: ``j``.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['fraction', 'lower', 'higher']]</values>
      <defaults>['fraction']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the percentiles are computed. Default is None. If
None, compute over the whole array `a`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="score" name="score" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Score at percentile(s).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.sem" module_name="sem" namespace="'stats'">
    <docstring>Calculates the standard error of the mean (or standard error of
measurement) of the values in the input array.

Parameters
----------
a : array_like
    An array containing the values for which the standard error is
    returned.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Delta degrees-of-freedom. How many degrees of freedom to adjust
    for bias in limited samples relative to the population estimate
    of variance. Defaults to 1.

Returns
-------
s : ndarray or float
    The standard error of the mean in the sample(s), along the input axis.

Notes
-----
The default value for `ddof` is different to the default (0) used by other
ddof containing routines, such as np.std nd stats.nanstd.

Examples
--------
Find standard error along the first axis:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(20).reshape(5,4)
&gt;&gt;&gt; stats.sem(a)
array([ 2.8284,  2.8284,  2.8284,  2.8284])

Find standard error across the whole array, using n degrees of freedom:

&gt;&gt;&gt; stats.sem(a, axis=None, ddof=0)
1.2893796958227628</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>An array containing the values for which the standard error is
returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Delta degrees-of-freedom. How many degrees of freedom to adjust
for bias in limited samples relative to the population estimate
of variance. Defaults to 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The standard error of the mean in the sample(s), along the input axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.shapiro" module_name="shapiro" namespace="'stats'" output_type="list">
    <docstring>Perform the Shapiro-Wilk test for normality.

The Shapiro-Wilk test tests the null hypothesis that the
data was drawn from a normal distribution.

Parameters
----------
x : array_like
    Array of sample data.
a : array_like, optional
    Array of internal parameters used in the calculation.  If these
    are not given, they will be computed internally.  If x has length
    n, then a must have length n/2.
reta : bool, optional
    Whether or not to return the internally computed a values.  The
    default is False.

Returns
-------
W : float
    The test statistic.
p-value : float
    The p-value for the hypothesis test.
a : array_like, optional
    If `reta` is True, then these are the internally computed "a"
    values that may be passed into this function on future calls.

See Also
--------
anderson : The Anderson-Darling test for normality

References
----------
.. [1] http://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of sample data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="a" name="a" port_type="basic:List">
      <docstring>Array of internal parameters used in the calculation.  If these
are not given, they will be computed internally.  If x has length
n, then a must have length n/2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="reta" name="reta" port_type="basic:Boolean">
      <docstring>Whether or not to return the internally computed a values.  The
default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="W" name="W" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p-value" name="p-value" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the hypothesis test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="a" name="a" port_type="basic:List" show_port="True" sort_key="2">
      <docstring>If `reta` is True, then these are the internally computed "a"
values that may be passed into this function on future calls.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.sigmaclip" module_name="sigmaclip" namespace="'stats'" output_type="list">
    <docstring>Iterative sigma-clipping of array elements.

The output array contains only those elements of the input array `c`
that satisfy the conditions ::

    mean(c) - std(c)*low &lt; c &lt; mean(c) + std(c)*high

Starting from the full sample, all elements outside the critical range are
removed. The iteration continues with a new critical range until no
elements are outside the range.

Parameters
----------
a : array_like
    Data array, will be raveled if not 1-D.
low : float, optional
    Lower bound factor of sigma clipping. Default is 4.
high : float, optional
    Upper bound factor of sigma clipping. Default is 4.

Returns
-------
clipped : ndarray
    Input array with clipped elements removed.
lower : float
    Lower threshold value use for clipping.
upper : float
    Upper threshold value use for clipping.

Examples
--------
&gt;&gt;&gt; from scipy.stats import sigmaclip
&gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 31),
...                     np.linspace(0, 20, 5)))
&gt;&gt;&gt; fact = 1.5
&gt;&gt;&gt; c, low, upp = sigmaclip(a, fact, fact)
&gt;&gt;&gt; c
array([  9.96666667,  10.        ,  10.03333333,  10.        ])
&gt;&gt;&gt; c.var(), c.std()
(0.00055555555555555165, 0.023570226039551501)
&gt;&gt;&gt; low, c.mean() - fact*c.std(), c.min()
(9.9646446609406727, 9.9646446609406727, 9.9666666666666668)
&gt;&gt;&gt; upp, c.mean() + fact*c.std(), c.max()
(10.035355339059327, 10.035355339059327, 10.033333333333333)

&gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 11),
...                     np.linspace(-100, -50, 3)))
&gt;&gt;&gt; c, low, upp = sigmaclip(a, 1.8, 1.8)
&gt;&gt;&gt; (c == np.linspace(9.5, 10.5, 11)).all()
True</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Data array, will be raveled if not 1-D.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="low" name="low" port_type="basic:Float">
      <docstring>Lower bound factor of sigma clipping. Default is 4.</docstring>
      <defaults>[4.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="high" name="high" port_type="basic:Float">
      <docstring>Upper bound factor of sigma clipping. Default is 4.</docstring>
      <defaults>[4.0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="clipped" name="clipped" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Input array with clipped elements removed.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lower" name="lower" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Lower threshold value use for clipping.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="upper" name="upper" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Upper threshold value use for clipping.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.signaltonoise" module_name="signaltonoise" namespace="'stats'">
    <docstring>`signaltonoise` is deprecated!
scipy.stats.signaltonoise is deprecated in scipy 0.16.0


    The signal-to-noise ratio of the input data.

    Returns the signal-to-noise ratio of `a`, here defined as the mean
    divided by the standard deviation.

    Parameters
    ----------
    a : array_like
        An array_like object containing the sample data.
    axis : int or None, optional
        Axis along which to operate. Default is 0. If None, compute over
        the whole array `a`.
    ddof : int, optional
        Degrees of freedom correction for standard deviation. Default is 0.

    Returns
    -------
    s2n : ndarray
        The mean to standard deviation ratio(s) along `axis`, or 0 where the
        standard deviation is 0.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>    An array_like object containing the sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction for standard deviation. Default is 0.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="s2n" name="s2n" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The mean to standard deviation ratio(s) along `axis`, or 0 where the
standard deviation is 0.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.skew" module_name="skew" namespace="'stats'">
    <docstring>Computes the skewness of a data set.

For normally distributed data, the skewness should be about 0. A skewness
value &gt; 0 means that there is more weight in the left tail of the
distribution. The function `skewtest` can be used to determine if the
skewness value is close enough to 0, statistically speaking.

Parameters
----------
a : ndarray
    data
axis : int or None, optional
    Axis along which skewness is calculated. Default is 0.
    If None, compute over the whole array `a`.
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.

Returns
-------
skewness : ndarray
    The skewness of values along an axis, returning 0 where all values are
    equal.

References
----------

.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.
   Section 2.2.24.1</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which skewness is calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Boolean">
      <docstring>If False, then the calculations are corrected for statistical bias.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="skewness" name="skewness" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The skewness of values along an axis, returning 0 where all values are
equal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.skewtest" module_name="skewtest" namespace="'stats'" output_type="list">
    <docstring>Tests whether the skew is different from the normal distribution.

This function tests the null hypothesis that the skewness of
the population that the sample was drawn from is the same
as that of a corresponding normal distribution.

Parameters
----------
a : array
    The data to be tested
axis : int or None, optional
   Axis along which statistics are calculated. Default is 0.
   If None, compute over the whole array `a`.

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    a 2-sided p-value for the hypothesis test

Notes
-----
The sample size must be at least 8.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The data to be tested</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which statistics are calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed z-score for this test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>a 2-sided p-value for the hypothesis test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.spearmanr" module_name="spearmanr" namespace="'stats'" output_type="list">
    <docstring>Calculates a Spearman rank-order correlation coefficient and the p-value
to test for non-correlation.

The Spearman correlation is a nonparametric measure of the monotonicity
of the relationship between two datasets. Unlike the Pearson correlation,
the Spearman correlation does not assume that both datasets are normally
distributed. Like other correlation coefficients, this one varies
between -1 and +1 with 0 implying no correlation. Correlations of -1 or
+1 imply an exact monotonic relationship. Positive correlations imply that
as x increases, so does y. Negative correlations imply that as x
increases, y decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Spearman correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
a, b : 1D or 2D array_like, b is optional
    One or two 1-D or 2-D arrays containing multiple variables and
    observations. Each column of `a` and `b` represents a variable, and
    each row entry a single observation of those variables. See also
    `axis`. Both arrays need to have the same length in the `axis`
    dimension.
axis : int or None, optional
    If axis=0 (default), then each column represents a variable, with
    observations in the rows. If axis=0, the relationship is transposed:
    each row represents a variable, while the columns contain observations.
    If axis=None, then both arrays will be raveled.

Returns
-------
correlation : float or ndarray (2-D square)
    Spearman correlation matrix or correlation coefficient (if only 2
    variables are given as parameters. Correlation matrix is square with
    length equal to total number of variables (columns or rows) in a and b
    combined.
pvalue : float
    The two-sided p-value for a hypothesis test whose null hypothesis is
    that two sets of data are uncorrelated, has same dimension as rho.

Notes
-----
Changes in scipy 0.8.0: rewrite to add tie-handling, and axis.

References
----------

.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.
   Section  14.7

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.spearmanr([1,2,3,4,5], [5,6,7,8,7])
(0.82078268166812329, 0.088587005313543798)
&gt;&gt;&gt; np.random.seed(1234321)
&gt;&gt;&gt; x2n = np.random.randn(100, 2)
&gt;&gt;&gt; y2n = np.random.randn(100, 2)
&gt;&gt;&gt; stats.spearmanr(x2n)
(0.059969996999699973, 0.55338590803773591)
&gt;&gt;&gt; stats.spearmanr(x2n[:,0], x2n[:,1])
(0.059969996999699973, 0.55338590803773591)
&gt;&gt;&gt; rho, pval = stats.spearmanr(x2n, y2n)
&gt;&gt;&gt; rho
array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],
       [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],
       [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],
       [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])
&gt;&gt;&gt; pval
array([[ 0.        ,  0.55338591,  0.06435364,  0.53617935],
       [ 0.55338591,  0.        ,  0.27592895,  0.80234077],
       [ 0.06435364,  0.27592895,  0.        ,  0.73039992],
       [ 0.53617935,  0.80234077,  0.73039992,  0.        ]])
&gt;&gt;&gt; rho, pval = stats.spearmanr(x2n.T, y2n.T, axis=1)
&gt;&gt;&gt; rho
array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],
       [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],
       [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],
       [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])
&gt;&gt;&gt; stats.spearmanr(x2n, y2n, axis=None)
(0.10816770419260482, 0.1273562188027364)
&gt;&gt;&gt; stats.spearmanr(x2n.ravel(), y2n.ravel())
(0.10816770419260482, 0.1273562188027364)

&gt;&gt;&gt; xint = np.random.randint(10, size=(100, 2))
&gt;&gt;&gt; stats.spearmanr(xint)
(0.052760927029710199, 0.60213045837062351)</docstring>
    <inputPortSpec arg="a" name="aScalar">
      <docstring>One or two 1-D or 2-D arrays containing multiple variables and
observations. Each column of `a` and `b` represents a variable, and
each row entry a single observation of those variables. See also
`axis`. Both arrays need to have the same length in the `axis`
dimension.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['1D']]</values>
      <alternateSpec arg="a" name="aSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar">
      <docstring>One or two 1-D or 2-D arrays containing multiple variables and
observations. Each column of `a` and `b` represents a variable, and
each row entry a single observation of those variables. See also
`axis`. Both arrays need to have the same length in the `axis`
dimension.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['1D']]</values>
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>If axis=0 (default), then each column represents a variable, with
observations in the rows. If axis=0, the relationship is transposed:
each row represents a variable, while the columns contain observations.
If axis=None, then both arrays will be raveled.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Spearman correlation matrix or correlation coefficient (if only 2
variables are given as parameters. Correlation matrix is square with
length equal to total number of variables (columns or rows) in a and b
combined.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-sided p-value for a hypothesis test whose null hypothesis is
that two sets of data are uncorrelated, has same dimension as rho.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.square_of_sums" module_name="square_of_sums" namespace="'stats'">
    <docstring>Sums elements of the input array, and returns the square(s) of that sum.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    Axis along which to calculate. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
square_of_sums : float or ndarray
    The square of the sum over `axis`.

See also
--------
ss : The sum of squares (the opposite of `square_of_sums`).

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(20).reshape(5,4)
&gt;&gt;&gt; stats.square_of_sums(a)
array([ 1600.,  2025.,  2500.,  3025.])
&gt;&gt;&gt; stats.square_of_sums(a, axis=None)
36100.0</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to calculate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="square_of_sums" name="square_of_sums" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The square of the sum over `axis`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ss" module_name="ss" namespace="'stats'">
    <docstring>Squares each element of the input array, and returns the sum(s) of that.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    Axis along which to calculate. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
ss : ndarray
    The sum along the given axis for (a**2).

See also
--------
square_of_sums : The square(s) of the sum(s) (the opposite of `ss`).

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.array([1., 2., 5.])
&gt;&gt;&gt; stats.ss(a)
30.0

And calculating along an axis:

&gt;&gt;&gt; b = np.array([[1., 2., 5.], [2., 5., 6.]])
&gt;&gt;&gt; stats.ss(b, axis=1)
array([ 30., 65.])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to calculate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="ss" name="ss" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The sum along the given axis for (a**2).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.theilslopes" module_name="theilslopes" namespace="'stats'" output_type="list">
    <docstring>Computes the Theil-Sen estimator for a set of points (x, y).

`theilslopes` implements a method for robust linear regression.  It
computes the slope as the median of all slopes between paired values.

Parameters
----------
y : array_like
    Dependent variable.
x : array_like or None, optional
    Independent variable. If None, use ``arange(len(y))`` instead.
alpha : float, optional
    Confidence degree between 0 and 1. Default is 95% confidence.
    Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are
    interpreted as "find the 90% confidence interval".

Returns
-------
medslope : float
    Theil slope.
medintercept : float
    Intercept of the Theil line, as ``median(y) - medslope*median(x)``.
lo_slope : float
    Lower bound of the confidence interval on `medslope`.
up_slope : float
    Upper bound of the confidence interval on `medslope`.

Notes
-----
The implementation of `theilslopes` follows [1]_. The intercept is
not defined in [1]_, and here it is defined as ``median(y) -
medslope*median(x)``, which is given in [3]_. Other definitions of
the intercept exist in the literature. A confidence interval for
the intercept is not given as this question is not addressed in
[1]_.

References
----------
.. [1] P.K. Sen, "Estimates of the regression coefficient based on Kendall's tau",
       J. Am. Stat. Assoc., Vol. 63, pp. 1379-1389, 1968.
.. [2] H. Theil, "A rank-invariant method of linear and polynomial
       regression analysis I, II and III",  Nederl. Akad. Wetensch., Proc.
       53:, pp. 386-392, pp. 521-525, pp. 1397-1412, 1950.
.. [3] W.L. Conover, "Practical nonparametric statistics", 2nd ed.,
       John Wiley and Sons, New York, pp. 493.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; x = np.linspace(-5, 5, num=150)
&gt;&gt;&gt; y = x + np.random.normal(size=x.size)
&gt;&gt;&gt; y[11:15] += 10  # add outliers
&gt;&gt;&gt; y[-5:] -= 7

Compute the slope, intercept and 90% confidence interval.  For comparison,
also compute the least-squares fit with `linregress`:

&gt;&gt;&gt; res = stats.theilslopes(y, x, 0.90)
&gt;&gt;&gt; lsq_res = stats.linregress(x, y)

Plot the results. The Theil-Sen regression line is shown in red, with the
dashed red lines illustrating the confidence interval of the slope (note
that the dashed red lines are not the confidence interval of the regression
as the confidence interval of the intercept is not included). The green
line shows the least-squares fit for comparison.

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(x, y, 'b.')
&gt;&gt;&gt; ax.plot(x, res[1] + res[0] * x, 'r-')
&gt;&gt;&gt; ax.plot(x, res[1] + res[2] * x, 'r--')
&gt;&gt;&gt; ax.plot(x, res[1] + res[3] * x, 'r--')
&gt;&gt;&gt; ax.plot(x, lsq_res[1] + lsq_res[0] * x, 'g-')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Dependent variable.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar">
      <docstring>Independent variable. If None, use ``arange(len(y))`` instead.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Confidence degree between 0 and 1. Default is 95% confidence.
Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are
interpreted as "find the 90% confidence interval".</docstring>
      <defaults>[0.95]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="medslope" name="medslope" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Theil slope.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="medintercept" name="medintercept" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Intercept of the Theil line, as ``median(y) - medslope*median(x)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lo_slope" name="lo_slope" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Lower bound of the confidence interval on `medslope`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="up_slope" name="up_slope" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Upper bound of the confidence interval on `medslope`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.threshold" module_name="threshold" namespace="'stats'">
    <docstring>Clip array to a given value.

Similar to numpy.clip(), except that values less than `threshmin` or
greater than `threshmax` are replaced by `newval`, instead of by
`threshmin` and `threshmax` respectively.

Parameters
----------
a : array_like
    Data to threshold.
threshmin : float, int or None, optional
    Minimum threshold, defaults to None.
threshmax : float, int or None, optional
    Maximum threshold, defaults to None.
newval : float or int, optional
    Value to put in place of values in `a` outside of bounds.
    Defaults to 0.

Returns
-------
out : ndarray
    The clipped input array, with values less than `threshmin` or
    greater than `threshmax` replaced with `newval`.

Examples
--------
&gt;&gt;&gt; a = np.array([9, 9, 6, 3, 1, 6, 1, 0, 0, 8])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.threshold(a, threshmin=2, threshmax=8, newval=-1)
array([-1, -1,  6,  3, -1,  6, -1, -1, -1,  8])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Data to threshold.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="threshmin" name="threshmin">
      <docstring>Minimum threshold, defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="threshmax" name="threshmax">
      <docstring>Maximum threshold, defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="newval" name="newval" port_type="basic:Float">
      <docstring>Value to put in place of values in `a` outside of bounds.
Defaults to 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The clipped input array, with values less than `threshmin` or
greater than `threshmax` replaced with `newval`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tiecorrect" module_name="tiecorrect" namespace="'stats'">
    <docstring>tiecorrect(rankvals)

Tie correction factor for ties in the Mann-Whitney U and
Kruskal-Wallis H tests.

Parameters
----------
rankvals : array_like
    A 1-D sequence of ranks.  Typically this will be the array
    returned by `stats.rankdata`.

Returns
-------
factor : float
    Correction factor for U or H.

See Also
--------
rankdata : Assign ranks to the data
mannwhitneyu : Mann-Whitney rank test
kruskal : Kruskal-Wallis H test

References
----------
.. [1] Siegel, S. (1956) Nonparametric Statistics for the Behavioral
       Sciences.  New York: McGraw-Hill.

Examples
--------
&gt;&gt;&gt; from scipy.stats import tiecorrect, rankdata
&gt;&gt;&gt; tiecorrect([1, 2.5, 2.5, 4])
0.9
&gt;&gt;&gt; ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4])
&gt;&gt;&gt; ranks
array([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5])
&gt;&gt;&gt; tiecorrect(ranks)
0.9833333333333333</docstring>
    <inputPortSpec arg="rankvals" name="rankvals" port_type="basic:List" show_port="True">
      <docstring>A 1-D sequence of ranks.  Typically this will be the array
returned by `stats.rankdata`.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="factor" name="factor" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Correction factor for U or H.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tmax" module_name="tmax" namespace="'stats'">
    <docstring>Compute the trimmed maximum

This function computes the maximum value of an array along a given axis,
while ignoring values larger than a specified upper limit.

Parameters
----------
a : array_like
    array of values
upperlimit : None or float, optional
    Values in the input array greater than the given limit will be ignored.
    When upperlimit is None, then all values are used. The default value
    is None.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the upper limit
    are included.  The default value is True.

Returns
-------
tmax : float</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="upperlimit" name="upperlimit" port_type="basic:Float">
      <docstring>Values in the input array greater than the given limit will be ignored.
When upperlimit is None, then all values are used. The default value
is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over the
whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:Boolean">
      <docstring>This flag determines whether values exactly equal to the upper limit
are included.  The default value is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tmax" name="tmax" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tmean" module_name="tmean" namespace="'stats'">
    <docstring>Compute the trimmed mean.

This function finds the arithmetic mean of given values, ignoring values
outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored.  When limits is None (default), then all
    values are used.  Either of the limit values in the tuple can also be
    None representing a half-open interval.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tmean : float</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored.  When limits is None (default), then all
values are used.  Either of the limit values in the tuple can also be
None representing a half-open interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tmean" name="tmean" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tmin" module_name="tmin" namespace="'stats'">
    <docstring>Compute the trimmed minimum

This function finds the miminum value of an array `a` along the
specified axis, but only considering values greater than a specified
lower limit.

Parameters
----------
a : array_like
    array of values
lowerlimit : None or float, optional
    Values in the input array less than the given limit will be ignored.
    When lowerlimit is None, then all values are used. The default value
    is None.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the whole
    array `a`.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the lower limit
    are included.  The default value is True.

Returns
-------
tmin : float</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lowerlimit" name="lowerlimit" port_type="basic:Float">
      <docstring>Values in the input array less than the given limit will be ignored.
When lowerlimit is None, then all values are used. The default value
is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over the whole
array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:Boolean">
      <docstring>This flag determines whether values exactly equal to the lower limit
are included.  The default value is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tmin" name="tmin" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.trim1" module_name="trim1" namespace="'stats'">
    <docstring>Slices off a proportion of items from ONE end of the passed array
distribution.

If `proportiontocut` = 0.1, slices off 'leftmost' or 'rightmost'
10% of scores.  Slices off LESS if proportion results in a non-integer
slice index (i.e., conservatively slices off `proportiontocut` ).

Parameters
----------
a : array_like
    Input array
proportiontocut : float
    Fraction to cut off of 'left' or 'right' of distribution
tail : {'left', 'right'}, optional
    Defaults to 'right'.

Returns
-------
trim1 : ndarray
    Trimmed version of array `a`</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float" show_port="True">
      <docstring>Fraction to cut off of 'left' or 'right' of distribution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tail" name="tail">
      <docstring>Defaults to 'right'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['left', 'right']]</values>
      <defaults>['right']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trim1" name="trim1" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Trimmed version of array `a`</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.trim_mean" module_name="trim_mean" namespace="'stats'">
    <docstring>Return mean of array after trimming distribution from both lower and upper
tails.

If `proportiontocut` = 0.1, slices off 'leftmost' and 'rightmost' 10% of
scores. Slices off LESS if proportion results in a non-integer slice
index (i.e., conservatively slices off `proportiontocut` ).

Parameters
----------
a : array_like
    Input array
proportiontocut : float
    Fraction to cut off of both tails of the distribution
axis : int or None, optional
    Axis along which the trimmed means are computed. Default is 0.
    If None, compute over the whole array `a`.

Returns
-------
trim_mean : ndarray
    Mean of trimmed array.

See Also
--------
trimboth

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.arange(20)
&gt;&gt;&gt; stats.trim_mean(x, 0.1)
9.5
&gt;&gt;&gt; x2 = x.reshape(5, 4)
&gt;&gt;&gt; x2
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
&gt;&gt;&gt; stats.trim_mean(x2, 0.25)
array([  8.,   9.,  10.,  11.])
&gt;&gt;&gt; stats.trim_mean(x2, 0.25, axis=1)
array([  1.5,   5.5,   9.5,  13.5,  17.5])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float" show_port="True">
      <docstring>Fraction to cut off of both tails of the distribution</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the trimmed means are computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="trim_mean" name="trim_mean" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Mean of trimmed array.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.trimboth" module_name="trimboth" namespace="'stats'">
    <docstring>Slices off a proportion of items from both ends of an array.

Slices off the passed proportion of items from both ends of the passed
array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and**
rightmost 10% of scores).  You must pre-sort the array if you want
'proper' trimming.  Slices off less if proportion results in a
non-integer slice index (i.e., conservatively slices off
`proportiontocut`).

Parameters
----------
a : array_like
    Data to trim.
proportiontocut : float
    Proportion (in range 0-1) of total data set to trim of each end.
axis : int or None, optional
    Axis along which to trim data. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
out : ndarray
    Trimmed version of array `a`.

See Also
--------
trim_mean

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(20)
&gt;&gt;&gt; b = stats.trimboth(a, 0.1)
&gt;&gt;&gt; b.shape
(16,)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Data to trim.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float" show_port="True">
      <docstring>Proportion (in range 0-1) of total data set to trim of each end.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to trim data. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="out" name="out" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Trimmed version of array `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tsem" module_name="tsem" namespace="'stats'">
    <docstring>Compute the trimmed standard error of the mean.

This function finds the standard error of the mean for given
values, ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    array of values
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tsem : float

Notes
-----
`tsem` uses unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored. When limits is None, then all values are
used. Either of the limit values in the tuple can also be None
representing a half-open interval.  The default value is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tsem" name="tsem" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tstd" module_name="tstd" namespace="'stats'">
    <docstring>Compute the trimmed sample standard deviation

This function finds the sample standard deviation of given values,
ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    array of values
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tstd : float

Notes
-----
`tstd` computes the unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored. When limits is None, then all values are
used. Either of the limit values in the tuple can also be None
representing a half-open interval.  The default value is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tstd" name="tstd" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ttest_1samp" module_name="ttest_1samp" namespace="'stats'" output_type="list">
    <docstring>Calculates the T-test for the mean of ONE group of scores.

This is a two-sided test for the null hypothesis that the expected value
(mean) of a sample of independent observations `a` is equal to the given
population mean, `popmean`.

Parameters
----------
a : array_like
    sample observation
popmean : float or array_like
    expected value in null hypothesis, if array_like than it must have the
    same shape as `a` excluding the axis dimension
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    array `a`.

Returns
-------
statistic : float or array
    t-statistic
pvalue : float or array
    two-tailed p-value

Examples
--------
&gt;&gt;&gt; from scipy import stats

&gt;&gt;&gt; np.random.seed(7654567)  # fix seed to get the same result
&gt;&gt;&gt; rvs = stats.norm.rvs(loc=5, scale=10, size=(50,2))

Test if mean of random sample is equal to true mean, and different mean.
We reject the null hypothesis in the second case and don't reject it in
the first case.

&gt;&gt;&gt; stats.ttest_1samp(rvs,5.0)
(array([-0.68014479, -0.04323899]), array([ 0.49961383,  0.96568674]))
&gt;&gt;&gt; stats.ttest_1samp(rvs,0.0)
(array([ 2.77025808,  4.11038784]), array([ 0.00789095,  0.00014999]))

Examples using axis and non-scalar dimension for population mean.

&gt;&gt;&gt; stats.ttest_1samp(rvs,[5.0,0.0])
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
&gt;&gt;&gt; stats.ttest_1samp(rvs.T,[5.0,0.0],axis=1)
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
&gt;&gt;&gt; stats.ttest_1samp(rvs,[[5.0],[0.0]])
(array([[-0.68014479, -0.04323899],
       [ 2.77025808,  4.11038784]]), array([[  4.99613833e-01,   9.65686743e-01],
       [  7.89094663e-03,   1.49986458e-04]]))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>sample observation</docstring>
    </inputPortSpec>
    <inputPortSpec arg="popmean" name="popmeanScalar" port_type="basic:Float" show_port="True">
      <docstring>expected value in null hypothesis, if array_like than it must have the
same shape as `a` excluding the axis dimension</docstring>
      <alternateSpec arg="popmean" name="popmeanSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>t-statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>two-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ttest_ind" module_name="ttest_ind" namespace="'stats'" output_type="list">
    <docstring>Calculates the T-test for the means of TWO INDEPENDENT samples of scores.

This is a two-sided test for the null hypothesis that 2 independent samples
have identical average (expected) values. This test assumes that the
populations have identical variances by default.

Parameters
----------
a, b : array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    arrays, `a`, and `b`.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.
    .. versionadded:: 0.11.0


Returns
-------
statistic : float or array
    The calculated t-statistic.
pvalue : float or array
    The two-tailed p-value.

Notes
-----
We can use this test, if we observe two independent samples from
the same or different population, e.g. exam scores of boys and
girls or of two ethnic groups. The test measures whether the
average (expected) value differs significantly across samples. If
we observe a large p-value, for example larger than 0.05 or 0.1,
then we cannot reject the null hypothesis of identical average scores.
If the p-value is smaller than the threshold, e.g. 1%, 5% or 10%,
then we reject the null hypothesis of equal averages.

References
----------
.. [1] http://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] http://en.wikipedia.org/wiki/Welch%27s_t_test

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(12345678)

Test with sample with identical means:

&gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
&gt;&gt;&gt; rvs2 = stats.norm.rvs(loc=5,scale=10,size=500)
&gt;&gt;&gt; stats.ttest_ind(rvs1,rvs2)
(0.26833823296239279, 0.78849443369564776)
&gt;&gt;&gt; stats.ttest_ind(rvs1,rvs2, equal_var = False)
(0.26833823296239279, 0.78849452749500748)

`ttest_ind` underestimates p for unequal variances:

&gt;&gt;&gt; rvs3 = stats.norm.rvs(loc=5, scale=20, size=500)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3)
(-0.46580283298287162, 0.64145827413436174)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3, equal_var = False)
(-0.46580283298287162, 0.64149646246569292)

When n1 != n2, the equal variance t-statistic is no longer equal to the
unequal variance t-statistic:

&gt;&gt;&gt; rvs4 = stats.norm.rvs(loc=5, scale=20, size=100)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4)
(-0.99882539442782481, 0.3182832709103896)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4, equal_var = False)
(-0.69712570584654099, 0.48716927725402048)

T-test with different means, variance, and n:

&gt;&gt;&gt; rvs5 = stats.norm.rvs(loc=8, scale=20, size=100)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5)
(-1.4679669854490653, 0.14263895620529152)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, equal_var = False)
(-0.94365973617132992, 0.34744170334794122)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
arrays, `a`, and `b`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="equal_var" name="equal_var" port_type="basic:Boolean">
      <docstring>If True (default), perform a standard independent 2 sample test
that assumes equal population variances [1]_.
If False, perform Welch's t-test, which does not assume equal
population variance [2]_.
.. versionadded:: 0.11.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The calculated t-statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-tailed p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ttest_ind_from_stats" module_name="ttest_ind_from_stats" namespace="'stats'" output_type="list">
    <docstring>T-test for means of two independent samples from descriptive statistics.

This is a two-sided test for the null hypothesis that 2 independent samples
have identical average (expected) values.

Parameters
----------
mean1 : array_like
    The mean(s) of sample 1.
std1 : array_like
    The standard deviation(s) of sample 1.
nobs1 : array_like
    The number(s) of observations of sample 1.
mean2 : array_like
    The mean(s) of sample 2
std2 : array_like
    The standard deviations(s) of sample 2.
nobs2 : array_like
    The number(s) of observations of sample 2.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.

Returns
-------
statistic : float or array
    The calculated t-statistics
pvalue : float or array
    The two-tailed p-value.

See also
--------
scipy.stats.ttest_ind

Notes
-----

.. versionadded:: 0.16.0

References
----------
.. [1] http://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] http://en.wikipedia.org/wiki/Welch%27s_t_test</docstring>
    <inputPortSpec arg="mean1" name="mean1" port_type="basic:List" show_port="True">
      <docstring>The mean(s) of sample 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="std1" name="std1" port_type="basic:List" show_port="True">
      <docstring>The standard deviation(s) of sample 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nobs1" name="nobs1" port_type="basic:List" show_port="True">
      <docstring>The number(s) of observations of sample 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mean2" name="mean2" port_type="basic:List" show_port="True">
      <docstring>The mean(s) of sample 2</docstring>
    </inputPortSpec>
    <inputPortSpec arg="std2" name="std2" port_type="basic:List" show_port="True">
      <docstring>The standard deviations(s) of sample 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nobs2" name="nobs2" port_type="basic:List" show_port="True">
      <docstring>The number(s) of observations of sample 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="equal_var" name="equal_var" port_type="basic:Boolean">
      <docstring>If True (default), perform a standard independent 2 sample test
that assumes equal population variances [1]_.
If False, perform Welch's t-test, which does not assume equal
population variance [2]_.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The calculated t-statistics</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-tailed p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.ttest_rel" module_name="ttest_rel" namespace="'stats'" output_type="list">
    <docstring>Calculates the T-test on TWO RELATED samples of scores, a and b.

This is a two-sided test for the null hypothesis that 2 related or
repeated samples have identical average (expected) values.

Parameters
----------
a, b : array_like
    The arrays must have the same shape.
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    arrays, `a`, and `b`.

Returns
-------
statistic : float or array
    t-statistic
pvalue : float or array
    two-tailed p-value

Notes
-----
Examples for the use are scores of the same set of student in
different exams, or repeated sampling from the same units. The
test measures whether the average score differs significantly
across samples (e.g. exams). If we observe a large p-value, for
example greater than 0.05 or 0.1 then we cannot reject the null
hypothesis of identical average scores. If the p-value is smaller
than the threshold, e.g. 1%, 5% or 10%, then we reject the null
hypothesis of equal averages. Small p-values are associated with
large t-statistics.

References
----------
http://en.wikipedia.org/wiki/T-test#Dependent_t-test

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(12345678) # fix random seed to get same numbers

&gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
&gt;&gt;&gt; rvs2 = (stats.norm.rvs(loc=5,scale=10,size=500) +
...         stats.norm.rvs(scale=0.2,size=500))
&gt;&gt;&gt; stats.ttest_rel(rvs1,rvs2)
(0.24101764965300962, 0.80964043445811562)
&gt;&gt;&gt; rvs3 = (stats.norm.rvs(loc=8,scale=10,size=500) +
...         stats.norm.rvs(scale=0.2,size=500))
&gt;&gt;&gt; stats.ttest_rel(rvs1,rvs3)
(-3.9995108708727933, 7.3082402191726459e-005)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
arrays, `a`, and `b`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>t-statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>two-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.tvar" module_name="tvar" namespace="'stats'">
    <docstring>Compute the trimmed variance

This function computes the sample variance of an array of values,
while ignoring values which are outside of given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tvar : float
    Trimmed variance.

Notes
-----
`tvar` computes the unbiased sample variance, i.e. it uses a correction
factor ``n / (n - 1)``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored. When limits is None, then all values are
used. Either of the limit values in the tuple can also be None
representing a half-open interval.  The default value is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tvar" name="tvar" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Trimmed variance.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.variation" module_name="variation" namespace="'stats'">
    <docstring>Computes the coefficient of variation, the ratio of the biased standard
deviation to the mean.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    Axis along which to calculate the coefficient of variation. Default
    is 0. If None, compute over the whole array `a`.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to calculate the coefficient of variation. Default
is 0. If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.wilcoxon" module_name="wilcoxon" namespace="'stats'" output_type="list">
    <docstring>Calculate the Wilcoxon signed-rank test.

The Wilcoxon signed-rank test tests the null hypothesis that two
related paired samples come from the same distribution. In particular,
it tests whether the distribution of the differences x - y is symmetric
about zero. It is a non-parametric version of the paired T-test.

Parameters
----------
x : array_like
    The first set of measurements.
y : array_like, optional
    The second set of measurements.  If `y` is not given, then the `x`
    array is considered to be the differences between the two sets of
    measurements.
zero_method : string, {"pratt", "wilcox", "zsplit"}, optional
    "pratt":
        Pratt treatment: includes zero-differences in the ranking process
        (more conservative)
    "wilcox":
        Wilcox treatment: discards all zero-differences
    "zsplit":
        Zero rank split: just like Pratt, but spliting the zero rank
        between positive and negative ones
correction : bool, optional
    If True, apply continuity correction by adjusting the Wilcoxon rank
    statistic by 0.5 towards the mean value when computing the
    z-statistic.  Default is False.

Returns
-------
statistic : float
    The sum of the ranks of the differences above or below zero, whichever
    is smaller.
pvalue : float
    The two-sided p-value for the test.

Notes
-----
Because the normal approximation is used for the calculations, the
samples used should be large.  A typical rule is to require that
n &gt; 20.

References
----------
.. [1] http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The first set of measurements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List">
      <docstring>The second set of measurements.  If `y` is not given, then the `x`
array is considered to be the differences between the two sets of
measurements.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="zero_method" name="zero_method">
      <docstring>"pratt":
    Pratt treatment: includes zero-differences in the ranking process
    (more conservative)
"wilcox":
    Wilcox treatment: discards all zero-differences
"zsplit":
    Zero rank split: just like Pratt, but spliting the zero rank
    between positive and negative ones</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['pratt', 'wilcox', 'zsplit']]</values>
      <defaults>['wilcox']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="correction" name="correction" port_type="basic:Boolean">
      <docstring>If True, apply continuity correction by adjusting the Wilcoxon rank
statistic by 0.5 towards the mean value when computing the
z-statistic.  Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The sum of the ranks of the differences above or below zero, whichever
is smaller.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-sided p-value for the test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.zmap" module_name="zmap" namespace="'stats'">
    <docstring>Calculates the relative z-scores.

Returns an array of z-scores, i.e., scores that are standardized to zero
mean and unit variance, where mean and variance are calculated from the
comparison array.

Parameters
----------
scores : array_like
    The input for which z-scores are calculated.
compare : array_like
    The input from which the mean and standard deviation of the
    normalization are taken; assumed to have the same dimension as
    `scores`.
axis : int or None, optional
    Axis over which mean and variance of `compare` are calculated.
    Default is 0. If None, compute over the whole array `scores`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.

Returns
-------
zscore : array_like
    Z-scores, in the same shape as `scores`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of `asarray`
for parameters).

Examples
--------
&gt;&gt;&gt; from scipy.stats import zmap
&gt;&gt;&gt; a = [0.5, 2.0, 2.5, 3]
&gt;&gt;&gt; b = [0, 1, 2, 3, 4]
&gt;&gt;&gt; zmap(a, b)
array([-1.06066017,  0.        ,  0.35355339,  0.70710678])</docstring>
    <inputPortSpec arg="scores" name="scores" port_type="basic:List" show_port="True">
      <docstring>The input for which z-scores are calculated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="compare" name="compare" port_type="basic:List" show_port="True">
      <docstring>The input from which the mean and standard deviation of the
normalization are taken; assumed to have the same dimension as
`scores`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis over which mean and variance of `compare` are calculated.
Default is 0. If None, compute over the whole array `scores`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Degrees of freedom correction in the calculation of the
standard deviation. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="zscore" name="zscore" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Z-scores, in the same shape as `scores`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.zscore" module_name="zscore" namespace="'stats'">
    <docstring>Calculates the z score of each value in the sample, relative to the sample
mean and standard deviation.

Parameters
----------
a : array_like
    An array like object containing the sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.

Returns
-------
zscore : array_like
    The z-scores, standardized by mean and standard deviation of input
    array `a`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of `asarray`
for parameters).

Examples
--------
&gt;&gt;&gt; a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,  0.1954,
...                0.6307, 0.6599,  0.1065,  0.0508])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.zscore(a)
array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,
        0.6748, -1.1488, -1.3324])

Computing along a specified axis, using n-1 degrees of freedom (``ddof=1``)
to calculate the standard deviation:

&gt;&gt;&gt; b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
...               [ 0.7149,  0.0775,  0.6072,  0.9656],
...               [ 0.6341,  0.1403,  0.9759,  0.4064],
...               [ 0.5918,  0.6948,  0.904 ,  0.3721],
...               [ 0.0921,  0.2481,  0.1188,  0.1366]])
&gt;&gt;&gt; stats.zscore(b, axis=1, ddof=1)
array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],
       [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],
       [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],
       [-0.22095197,  0.24468594,  1.19042819, -1.21416216],
       [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>An array like object containing the sample data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Degrees of freedom correction in the calculation of the
standard deviation. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="zscore" name="zscore" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The z-scores, standardized by mean and standard deviation of input
array `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.argstoarray" module_name="argstoarray" namespace="'stats|mstats'">
    <docstring>Constructs a 2D array from a group of sequences.

Sequences are filled with missing values to match the length of the longest
sequence.

Parameters
----------
args : sequences
    Group of sequences.

Returns
-------
argstoarray : MaskedArray
    A ( `m` x `n` ) masked array, where `m` is the number of arguments and
    `n` the length of the longest argument.

Notes
-----
`numpy.ma.row_stack` has identical behavior, but is called with a sequence
of sequences.</docstring>
    <inputPortSpec arg="args" name="args" port_type="basic:List" show_port="True">
      <docstring>Group of sequences.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="argstoarray" name="argstoarray" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A ( `m` x `n` ) masked array, where `m` is the number of arguments and
`n` the length of the longest argument.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.betai" module_name="betai" namespace="'stats|mstats'">
    <docstring>Returns the incomplete beta function.

I_x(a,b) = 1/B(a,b)*(Integral(0,x) of t^(a-1)(1-t)^(b-1) dt)

where a,b&gt;0 and B(a,b) = G(a)*G(b)/(G(a+b)) where G(a) is the gamma
function of a.

The standard broadcasting rules apply to a, b, and x.

Parameters
----------
a : array_like or float &gt; 0

b : array_like or float &gt; 0

x : array_like or float
    x will be clipped to be no greater than 1.0 .

Returns
-------
betai : ndarray
    Incomplete beta function.</docstring>
    <inputPortSpec arg="a" name="aScalar" port_type="basic:Float" show_port="True">
      <alternateSpec arg="a" name="aSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="b" name="bScalar" port_type="basic:Float" show_port="True">
      <alternateSpec arg="b" name="bSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar" port_type="basic:Float" show_port="True">
      <docstring>x will be clipped to be no greater than 1.0 .</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="betai" name="betai" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Incomplete beta function.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.chisquare" module_name="chisquare" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates a one-way chi square test.

The chi square test tests the null hypothesis that the categorical data
has the given frequencies.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.

Returns
-------
chisq : float or ndarray
    The chi-squared test statistic.  The value is a float if `axis` is
    None or `f_obs` and `f_exp` are 1-D.
p : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `chisq` are scalars.

See Also
--------
power_divergence
mstats.chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test

Examples
--------
When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.

&gt;&gt;&gt; from scipy.stats import chisquare
&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12])
(2.0, 0.84914503608460956)

With `f_exp` the expected frequencies can be given.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])
(3.5, 0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

&gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
&gt;&gt;&gt; obs.shape
(6, 2)
&gt;&gt;&gt; chisquare(obs)
(array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

&gt;&gt;&gt; chisquare(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
&gt;&gt;&gt; chisquare(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
chi-squared statistic with `ddof`.

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we use ``axis=1``:

&gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12],
...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],
...           axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))</docstring>
    <inputPortSpec arg="f_obs" name="f_obs" port_type="basic:List" show_port="True">
      <docstring>Observed frequencies in each category.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="f_exp" name="f_exp" port_type="basic:List">
      <docstring>Expected frequencies in each category.  By default the categories are
assumed to be equally likely.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>"Delta degrees of freedom": adjustment to the degrees of freedom
for the p-value.  The p-value is computed using a chi-squared
distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
is the number of observed frequencies.  The default value of `ddof`
is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>The axis of the broadcast result of `f_obs` and `f_exp` along which to
apply the test.  If axis is None, all values in `f_obs` are treated
as a single data set.  Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="chisq" name="chisq" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The chi-squared test statistic.  The value is a float if `axis` is
None or `f_obs` and `f_exp` are 1-D.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value of the test.  The value is a float if `ddof` and the
return value `chisq` are scalars.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.compare_medians_ms" module_name="compare_medians_ms" namespace="'stats|mstats'">
    <docstring>Compares the medians from two independent groups along the given axis.

The comparison is performed using the McKean-Schrader estimate of the
standard error of the medians.

Parameters
----------
group_1 : array_like
    First dataset.
group_2 : array_like
    Second dataset.
axis : int, optional
    Axis along which the medians are estimated. If None, the arrays are
    flattened.  If `axis` is not None, then `group_1` and `group_2`
    should have the same shape.

Returns
-------
compare_medians_ms : {float, ndarray}
    If `axis` is None, then returns a float, otherwise returns a 1-D
    ndarray of floats with a length equal to the length of `group_1`
    along `axis`.</docstring>
    <inputPortSpec arg="group_1" name="group_1" port_type="basic:List" show_port="True">
      <docstring>First dataset.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="group_2" name="group_2" port_type="basic:List" show_port="True">
      <docstring>Second dataset.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the medians are estimated. If None, the arrays are
flattened.  If `axis` is not None, then `group_1` and `group_2`
should have the same shape.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="compare_medians_ms" name="compare_medians_ms" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>If `axis` is None, then returns a float, otherwise returns a 1-D
ndarray of floats with a length equal to the length of `group_1`
along `axis`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.count_tied_groups" module_name="count_tied_groups" namespace="'stats|mstats'">
    <docstring>Counts the number of tied values.

Parameters
----------
x : sequence
    Sequence of data on which to counts the ties
use_missing : bool, optional
    Whether to consider missing values as tied.

Returns
-------
count_tied_groups : dict
    Returns a dictionary (nb of ties: nb of groups).

Examples
--------
&gt;&gt;&gt; from scipy.stats import mstats
&gt;&gt;&gt; z = [0, 0, 0, 2, 2, 2, 3, 3, 4, 5, 6]
&gt;&gt;&gt; mstats.count_tied_groups(z)
{2: 1, 3: 2}

In the above example, the ties were 0 (3x), 2 (3x) and 3 (2x).

&gt;&gt;&gt; z = np.ma.array([0, 0, 1, 2, 2, 2, 3, 3, 4, 5, 6])
&gt;&gt;&gt; mstats.count_tied_groups(z)
{2: 2, 3: 1}
&gt;&gt;&gt; z[[1,-1]] = np.ma.masked
&gt;&gt;&gt; mstats.count_tied_groups(z, use_missing=True)
{2: 2, 3: 1}</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Sequence of data on which to counts the ties</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_missing" name="use_missing" port_type="basic:Boolean">
      <docstring>Whether to consider missing values as tied.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="count_tied_groups" name="count_tied_groups" port_type="basic:Dictionary" show_port="True" sort_key="0">
      <docstring>Returns a dictionary (nb of ties: nb of groups).</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.describe" module_name="describe" namespace="'stats|mstats'" output_type="list">
    <docstring>Computes several descriptive statistics of the passed array.

Parameters
----------
a : array_like
    Data array
axis : int or None, optional
    Axis along which to calculate statistics. Default 0. If None,
    compute over the whole array `a`.
ddof : int, optional
    degree of freedom (default 0); note that default ddof is different
    from the same routine in stats.describe

Returns
-------
nobs : int
    (size of the data (discarding missing values)

minmax : (int, int)
    min, max

mean : float
    arithmetic mean

variance : float
    unbiased variance

skewness : float
    biased skewness

kurtosis : float
    biased kurtosis

Examples
--------

&gt;&gt;&gt; ma = np.ma.array(range(6), mask=[0, 0, 0, 1, 1, 1])
&gt;&gt;&gt; describe(ma)
(array(3),
 (0, 2),
 1.0,
 1.0,
 masked_array(data = 0.0,
             mask = False,
       fill_value = 1e+20)
,
 -1.5)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Data array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to calculate statistics. Default 0. If None,
compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>degree of freedom (default 0); note that default ddof is different
from the same routine in stats.describe</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="nobs" name="nobs" port_type="basic:Integer" show_port="True" sort_key="0">
      <docstring>(size of the data (discarding missing values)
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="minmax" name="minmax" port_type="basic:Integer" show_port="True" sort_key="1">
      <docstring>min, max
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="mean" name="mean" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>arithmetic mean
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="variance" name="variance" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>unbiased variance
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="skewness" name="skewness" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>biased skewness
</docstring>
    </outputPortSpec>
    <outputPortSpec arg="kurtosis" name="kurtosis" port_type="basic:Float" show_port="True" sort_key="5">
      <docstring>biased kurtosis</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.f_oneway" module_name="f_oneway" namespace="'stats|mstats'" output_type="list">
    <docstring>Performs a 1-way ANOVA, returning an F-value and probability given
any number of groups.  From Heiman, pp.394-7.

Usage: ``f_oneway(*args)``, where ``*args`` is 2 or more arrays,
one per treatment group.

Returns
-------
statistic : float
    The computed F-value of the test.
pvalue : float
    The associated p-value from the F-distribution.</docstring>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed F-value of the test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The associated p-value from the F-distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.f_value_wilks_lambda" module_name="f_value_wilks_lambda" namespace="'stats|mstats'">
    <docstring>Calculation of Wilks lambda F-statistic for multivariate data, per
Maxwell &amp; Delaney p.657.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="b" name="b" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="dfnum" name="dfnum" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="dfden" name="dfden" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="EF" name="EF" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="ER" name="ER" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.find_repeats" module_name="find_repeats" namespace="'stats|mstats'" output_type="list">
    <docstring>Find repeats in arr and return a tuple (repeats, repeat_count).
Masked values are discarded.

Parameters
----------
arr : sequence
    Input array. The array is flattened if it is not 1D.

Returns
-------
repeats : ndarray
    Array of repeated values.
counts : ndarray
    Array of counts.</docstring>
    <inputPortSpec arg="arr" name="arr" port_type="basic:List" show_port="True">
      <docstring>Input array. The array is flattened if it is not 1D.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="repeats" name="repeats" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of repeated values.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="counts" name="counts" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Array of counts.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.friedmanchisquare" module_name="friedmanchisquare" namespace="'stats|mstats'" output_type="list">
    <docstring>Friedman Chi-Square is a non-parametric, one-way within-subjects ANOVA.
This function calculates the Friedman Chi-square test for repeated measures
and returns the result, along with the associated probability value.

Each input is considered a given group. Ideally, the number of treatments
among each group should be equal. If this is not the case, only the first
n treatments are taken into account, where n is the number of treatments
of the smallest group.
If a group has some missing values, the corresponding treatments are masked
in the other groups.
The test statistic is corrected for ties.

Masked values in one group are propagated to the other groups.

Returns
-------
statistic : float
    the test statistic.
pvalue : float
    the associated p-value.</docstring>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>the test statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>the associated p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.gmean" module_name="gmean" namespace="'stats|mstats'">
    <docstring>Compute the geometric mean along the specified axis.

Returns the geometric average of the array elements.
That is:  n-th root of (x1 * x2 * ... * xn)

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int or None, optional
    Axis along which the geometric mean is computed. Default is 0.
    If None, compute over the whole array `a`.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If dtype is not specified, it defaults to the
    dtype of a, unless a has an integer dtype with a precision less than
    that of the default platform integer. In that case, the default
    platform integer is used.

Returns
-------
gmean : ndarray
    see dtype parameter above

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
hmean : Harmonic mean

Notes
-----
The geometric average is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

Use masked arrays to ignore any non-finite values in the input or that
arise in the calculations such as Not a Number and infinity because masked
arrays automatically mask any non-finite values.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the geometric mean is computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type of the returned array and of the accumulator in which the
elements are summed. If dtype is not specified, it defaults to the
dtype of a, unless a has an integer dtype with a precision less than
that of the default platform integer. In that case, the default
platform integer is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="gmean" name="gmean" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>see dtype parameter above</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.hdmedian" module_name="hdmedian" namespace="'stats|mstats'">
    <docstring>Returns the Harrell-Davis estimate of the median along the given axis.

Parameters
----------
data : ndarray
    Data array.
axis : int, optional
    Axis along which to compute the quantiles. If None, use a flattened
    array.
var : bool, optional
    Whether to return the variance of the estimate.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to compute the quantiles. If None, use a flattened
array.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="var" name="var" port_type="basic:Boolean">
      <docstring>Whether to return the variance of the estimate.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.hdquantiles" module_name="hdquantiles" namespace="'stats|mstats'">
    <docstring>Computes quantile estimates with the Harrell-Davis method.

The quantile estimates are calculated as a weighted linear combination
of order statistics.

Parameters
----------
data : array_like
    Data array.
prob : sequence, optional
    Sequence of quantiles to compute.
axis : int or None, optional
    Axis along which to compute the quantiles. If None, use a flattened
    array.
var : bool, optional
    Whether to return the variance of the estimate.

Returns
-------
hdquantiles : MaskedArray
    A (p,) array of quantiles (if `var` is False), or a (2,p) array of
    quantiles and variances (if `var` is True), where ``p`` is the
    number of quantiles.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="prob" name="prob" port_type="basic:List">
      <docstring>Sequence of quantiles to compute.</docstring>
      <defaults>[[0.25, 0.5, 0.75]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute the quantiles. If None, use a flattened
array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="var" name="var" port_type="basic:Boolean">
      <docstring>Whether to return the variance of the estimate.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="hdquantiles" name="hdquantiles" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>A (p,) array of quantiles (if `var` is False), or a (2,p) array of
quantiles and variances (if `var` is True), where ``p`` is the
number of quantiles.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.hdquantiles_sd" module_name="hdquantiles_sd" namespace="'stats|mstats'">
    <docstring>The standard error of the Harrell-Davis quantile estimates by jackknife.

Parameters
----------
data : array_like
    Data array.
prob : sequence, optional
    Sequence of quantiles to compute.
axis : int, optional
    Axis along which to compute the quantiles. If None, use a flattened
    array.

Returns
-------
hdquantiles_sd : MaskedArray
    Standard error of the Harrell-Davis quantile estimates.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="prob" name="prob" port_type="basic:List">
      <docstring>Sequence of quantiles to compute.</docstring>
      <defaults>[[0.25, 0.5, 0.75]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to compute the quantiles. If None, use a flattened
array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="hdquantiles_sd" name="hdquantiles_sd" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Standard error of the Harrell-Davis quantile estimates.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.hmean" module_name="hmean" namespace="'stats|mstats'">
    <docstring>Calculates the harmonic mean along the specified axis.

That is:  n / (1/x1 + 1/x2 + ... + 1/xn)

Parameters
----------
a : array_like
    Input array, masked array or object that can be converted to an array.
axis : int or None, optional
    Axis along which the harmonic mean is computed. Default is 0.
    If None, compute over the whole array `a`.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If `dtype` is not specified, it defaults to the
    dtype of `a`, unless `a` has an integer `dtype` with a precision less
    than that of the default platform integer. In that case, the default
    platform integer is used.

Returns
-------
hmean : ndarray
    see `dtype` parameter above

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
gmean : Geometric mean

Notes
-----
The harmonic mean is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

Use masked arrays to ignore any non-finite values in the input or that
arise in the calculations such as Not a Number and infinity.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array, masked array or object that can be converted to an array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the harmonic mean is computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="dtype" name="dtype" port_type="basic:Variant">
      <docstring>Type of the returned array and of the accumulator in which the
elements are summed. If `dtype` is not specified, it defaults to the
dtype of `a`, unless `a` has an integer `dtype` with a precision less
than that of the default platform integer. In that case, the default
platform integer is used.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="hmean" name="hmean" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>see `dtype` parameter above</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.idealfourths" module_name="idealfourths" namespace="'stats|mstats'">
    <docstring>Returns an estimate of the lower and upper quartiles.

Uses the ideal fourths algorithm.

Parameters
----------
data : array_like
    Input array.
axis : int, optional
    Axis along which the quartiles are estimated. If None, the arrays are
    flattened.

Returns
-------
idealfourths : {list of floats, masked array}
    Returns the two internal values that divide `data` into four parts
    using the ideal fourths algorithm either along the flattened array
    (if `axis` is None) or along `axis` of `data`.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which the quartiles are estimated. If None, the arrays are
flattened.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="idealfourths" depth="1" name="idealfourths" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Returns the two internal values that divide `data` into four parts
using the ideal fourths algorithm either along the flattened array
(if `axis` is None) or along `axis` of `data`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.kendalltau" module_name="kendalltau" namespace="'stats|mstats'" output_type="list">
    <docstring>Computes Kendall's rank correlation tau on two variables *x* and *y*.

Parameters
----------
x : sequence
    First data list (for example, time).
y : sequence
    Second data list.
use_ties : {True, False}, optional
    Whether ties correction should be performed.
use_missing : {False, True}, optional
    Whether missing data should be allocated a rank of 0 (False) or the
    average rank (True)

Returns
-------
correlation : float
    Kendall tau
pvalue : float
    Approximate 2-side p-value.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>First data list (for example, time).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Second data list.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_ties" name="use_ties" port_type="basic:Boolean">
      <docstring>Whether ties correction should be performed.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="use_missing" name="use_missing" port_type="basic:Boolean">
      <docstring>Whether missing data should be allocated a rank of 0 (False) or the
average rank (True)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Kendall tau</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Approximate 2-side p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.kendalltau_seasonal" module_name="kendalltau_seasonal" namespace="'stats|mstats'">
    <docstring>Computes a multivariate Kendall's rank correlation tau, for seasonal data.

Parameters
----------
x : 2-D ndarray
    Array of seasonal data, with seasons in columns.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Array of seasonal data, with seasons in columns.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.kruskal" module_name="kruskal" namespace="'stats|mstats'" output_type="list">
    <docstring>Compute the Kruskal-Wallis H-test for independent samples

The Kruskal-Wallis H-test tests the null hypothesis that the population
median of all of the groups are equal.  It is a non-parametric version of
ANOVA.  The test works on 2 or more independent samples, which may have
different sizes.  Note that rejecting the null hypothesis does not
indicate which of the groups differs.  Post-hoc comparisons between
groups are required to determine which groups are different.

Parameters
----------
sample1, sample2, ... : array_like
   Two or more arrays with the sample measurements can be given as
   arguments.

Returns
-------
statistic : float
   The Kruskal-Wallis H statistic, corrected for ties
pvalue : float
   The p-value for the test using the assumption that H has a chi
   square distribution

Notes
-----
Due to the assumption that H has a chi square distribution, the number
of samples in each group must not be too small.  A typical rule is
that each sample must have at least 5 measurements.

References
----------
.. [1] http://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Kruskal-Wallis H statistic, corrected for ties</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the test using the assumption that H has a chi
square distribution</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.kruskalwallis" module_name="kruskalwallis" namespace="'stats|mstats'" output_type="list">
    <docstring>Compute the Kruskal-Wallis H-test for independent samples

The Kruskal-Wallis H-test tests the null hypothesis that the population
median of all of the groups are equal.  It is a non-parametric version of
ANOVA.  The test works on 2 or more independent samples, which may have
different sizes.  Note that rejecting the null hypothesis does not
indicate which of the groups differs.  Post-hoc comparisons between
groups are required to determine which groups are different.

Parameters
----------
sample1, sample2, ... : array_like
   Two or more arrays with the sample measurements can be given as
   arguments.

Returns
-------
statistic : float
   The Kruskal-Wallis H statistic, corrected for ties
pvalue : float
   The p-value for the test using the assumption that H has a chi
   square distribution

Notes
-----
Due to the assumption that H has a chi square distribution, the number
of samples in each group must not be too small.  A typical rule is
that each sample must have at least 5 measurements.

References
----------
.. [1] http://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance</docstring>
    <inputPortSpec arg="sample1" name="sample1" port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sample2" name="sample2" port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="..." name="..." port_type="basic:List" show_port="True">
      <docstring>Two or more arrays with the sample measurements can be given as
arguments.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Kruskal-Wallis H statistic, corrected for ties</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The p-value for the test using the assumption that H has a chi
square distribution</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.ks_2samp" module_name="ks_2samp" namespace="'stats|mstats'" output_type="list">
    <docstring>Computes the Kolmogorov-Smirnov test on two samples.

Missing values are discarded.

Parameters
----------
data1 : array_like
    First data set
data2 : array_like
    Second data set
alternative : {'two-sided', 'less', 'greater'}, optional
    Indicates the alternative hypothesis.  Default is 'two-sided'.

Returns
-------
d : float
    Value of the Kolmogorov Smirnov test
p : float
    Corresponding p-value.</docstring>
    <inputPortSpec arg="data1" name="data1" port_type="basic:List" show_port="True">
      <docstring>First data set</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data2" name="data2" port_type="basic:List" show_port="True">
      <docstring>Second data set</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alternative" name="alternative">
      <docstring>Indicates the alternative hypothesis.  Default is 'two-sided'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['two-sided', 'less', 'greater']]</values>
      <defaults>['two-sided']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="d" name="d" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Value of the Kolmogorov Smirnov test</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Corresponding p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.ks_twosamp" module_name="ks_twosamp" namespace="'stats|mstats'" output_type="list">
    <docstring>Computes the Kolmogorov-Smirnov test on two samples.

Missing values are discarded.

Parameters
----------
data1 : array_like
    First data set
data2 : array_like
    Second data set
alternative : {'two-sided', 'less', 'greater'}, optional
    Indicates the alternative hypothesis.  Default is 'two-sided'.

Returns
-------
d : float
    Value of the Kolmogorov Smirnov test
p : float
    Corresponding p-value.</docstring>
    <inputPortSpec arg="data1" name="data1" port_type="basic:List" show_port="True">
      <docstring>First data set</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data2" name="data2" port_type="basic:List" show_port="True">
      <docstring>Second data set</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alternative" name="alternative">
      <docstring>Indicates the alternative hypothesis.  Default is 'two-sided'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['two-sided', 'less', 'greater']]</values>
      <defaults>['two-sided']</defaults>
    </inputPortSpec>
    <outputPortSpec arg="d" name="d" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Value of the Kolmogorov Smirnov test</docstring>
    </outputPortSpec>
    <outputPortSpec arg="p" name="p" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Corresponding p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.kurtosis" module_name="kurtosis" namespace="'stats|mstats'">
    <docstring>Computes the kurtosis (Fisher or Pearson) of a dataset.

Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.

If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators

Use `kurtosistest` to see if result is close enough to normal.

Parameters
----------
a : array
    data for which the kurtosis is calculated
axis : int or None, optional
    Axis along which the kurtosis is calculated. Default is 0.
    If None, compute over the whole array `a`.
fisher : bool, optional
    If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
    Pearson's definition is used (normal ==&gt; 3.0).
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.

Returns
-------
kurtosis : array
    The kurtosis of values along an axis. If all values are equal,
    return -3 for Fisher's definition and 0 for Pearson's definition.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>data for which the kurtosis is calculated</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the kurtosis is calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fisher" name="fisher" port_type="basic:Boolean">
      <docstring>If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
Pearson's definition is used (normal ==&gt; 3.0).</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Boolean">
      <docstring>If False, then the calculations are corrected for statistical bias.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="kurtosis" name="kurtosis" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The kurtosis of values along an axis. If all values are equal,
return -3 for Fisher's definition and 0 for Pearson's definition.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.kurtosistest" module_name="kurtosistest" namespace="'stats|mstats'" output_type="list">
    <docstring>Tests whether a dataset has normal kurtosis

This function tests the null hypothesis that the kurtosis
of the population from which the sample was drawn is that
of the normal distribution: ``kurtosis = 3(n-1)/(n+1)``.

Parameters
----------
a : array
    array of the sample data
axis : int or None, optional
   Axis along which to compute test. Default is 0. If None,
   compute over the whole array `a`.

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    The 2-sided p-value for the hypothesis test

Notes
-----
Valid only for n&gt;20.  The Z-score is set to 0 for bad entries.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of the sample data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. Default is 0. If None,
compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed z-score for this test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The 2-sided p-value for the hypothesis test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.linregress" module_name="linregress" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculate a regression line

This computes a least-squares regression for two sets of measurements.

Parameters
----------
x, y : array_like
    two sets of measurements.  Both arrays should have the same length.
    If only x is given (and y=None), then it must be a two-dimensional
    array where one dimension has length 2.  The two sets of measurements
    are then found by splitting the array along the length-2 dimension.

Returns
-------
slope : float
    slope of the regression line
intercept : float
    intercept of the regression line
rvalue : float
    correlation coefficient
pvalue : float
    two-sided p-value for a hypothesis test whose null hypothesis is
    that the slope is zero.
stderr : float
    Standard error of the estimate


Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; x = np.random.random(10)
&gt;&gt;&gt; y = np.random.random(10)
&gt;&gt;&gt; slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)

# To get coefficient of determination (r_squared)

&gt;&gt;&gt; print("r-squared:", r_value**2)
r-squared: 0.15286643777



Notes
-----
Missing values are considered pair-wise: if a value is missing in x,
the corresponding value in y is masked.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>two sets of measurements.  Both arrays should have the same length.
If only x is given (and y=None), then it must be a two-dimensional
array where one dimension has length 2.  The two sets of measurements
are then found by splitting the array along the length-2 dimension.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>two sets of measurements.  Both arrays should have the same length.
If only x is given (and y=None), then it must be a two-dimensional
array where one dimension has length 2.  The two sets of measurements
are then found by splitting the array along the length-2 dimension.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="slope" name="slope" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>slope of the regression line</docstring>
    </outputPortSpec>
    <outputPortSpec arg="intercept" name="intercept" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>intercept of the regression line</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rvalue" name="rvalue" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>correlation coefficient</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>two-sided p-value for a hypothesis test whose null hypothesis is
that the slope is zero.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="stderr" name="stderr" port_type="basic:Float" show_port="True" sort_key="4">
      <docstring>Standard error of the estimate</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.mannwhitneyu" module_name="mannwhitneyu" namespace="'stats|mstats'" output_type="list">
    <docstring>Computes the Mann-Whitney statistic

Missing values in `x` and/or `y` are discarded.

Parameters
----------
x : sequence
    Input
y : sequence
    Input
use_continuity : {True, False}, optional
    Whether a continuity correction (1/2.) should be taken into account.

Returns
-------
statistic : float
    The Mann-Whitney statistics
pvalue : float
    Approximate p-value assuming a normal distribution.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_continuity" name="use_continuity" port_type="basic:Boolean">
      <docstring>Whether a continuity correction (1/2.) should be taken into account.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The Mann-Whitney statistics</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Approximate p-value assuming a normal distribution.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.median_cihs" module_name="median_cihs" namespace="'stats|mstats'">
    <docstring>Computes the alpha-level confidence interval for the median of the data.

Uses the Hettmasperger-Sheather method.

Parameters
----------
data : array_like
    Input data. Masked values are discarded. The input should be 1D only,
    or `axis` should be set to None.
alpha : float, optional
    Confidence level of the intervals.
axis : int or None, optional
    Axis along which to compute the quantiles. If None, use a flattened
    array.

Returns
-------
median_cihs :
    Alpha level confidence interval.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data. Masked values are discarded. The input should be 1D only,
or `axis` should be set to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Confidence level of the intervals.</docstring>
      <defaults>[0.05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute the quantiles. If None, use a flattened
array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>Alpha level confidence interval.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.meppf" module_name="meppf" namespace="'stats|mstats'">
    <docstring>Returns plotting positions (or empirical percentile points) for the data.

Plotting positions are defined as ``(i-alpha)/(n+1-alpha-beta)``, where:
    - i is the rank order statistics
    - n is the number of unmasked values along the given axis
    - `alpha` and `beta` are two parameters.

Typical values for `alpha` and `beta` are:
    - (0,1)    : ``p(k) = k/n``, linear interpolation of cdf (R, type 4)
    - (.5,.5)  : ``p(k) = (k-1/2.)/n``, piecewise linear function
      (R, type 5)
    - (0,0)    : ``p(k) = k/(n+1)``, Weibull (R type 6)
    - (1,1)    : ``p(k) = (k-1)/(n-1)``, in this case,
      ``p(k) = mode[F(x[k])]``. That's R default (R type 7)
    - (1/3,1/3): ``p(k) = (k-1/3)/(n+1/3)``, then
      ``p(k) ~ median[F(x[k])]``.
      The resulting quantile estimates are approximately median-unbiased
      regardless of the distribution of x. (R type 8)
    - (3/8,3/8): ``p(k) = (k-3/8)/(n+1/4)``, Blom.
      The resulting quantile estimates are approximately unbiased
      if x is normally distributed (R type 9)
    - (.4,.4)  : approximately quantile unbiased (Cunnane)
    - (.35,.35): APL, used with PWM
    - (.3175, .3175): used in scipy.stats.probplot

Parameters
----------
data : array_like
    Input data, as a sequence or array of dimension at most 2.
alpha : float, optional
    Plotting positions parameter. Default is 0.4.
beta : float, optional
    Plotting positions parameter. Default is 0.4.

Returns
-------
positions : MaskedArray
    The calculated plotting positions.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data, as a sequence or array of dimension at most 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Plotting positions parameter. Default is 0.4.</docstring>
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="beta" name="beta" port_type="basic:Float">
      <docstring>Plotting positions parameter. Default is 0.4.</docstring>
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="positions" name="positions" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The calculated plotting positions.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.mjci" module_name="mjci" namespace="'stats|mstats'">
    <docstring>Returns the Maritz-Jarrett estimators of the standard error of selected
experimental quantiles of the data.

Parameters
----------
data : ndarray
    Data array.
prob : sequence, optional
    Sequence of quantiles to compute.
axis : int or None, optional
    Axis along which to compute the quantiles. If None, use a flattened
    array.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="prob" name="prob" port_type="basic:List">
      <docstring>Sequence of quantiles to compute.</docstring>
      <defaults>[[0.25, 0.5, 0.75]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute the quantiles. If None, use a flattened
array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.mode" module_name="mode" namespace="'stats|mstats'" output_type="list">
    <docstring>Returns an array of the modal (most common) value in the passed array.

If there is more than one such value, only the first is returned.
The bin-count for the modal bins is also returned.

Parameters
----------
a : array_like
    n-dimensional array of which to find mode(s).
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.

Returns
-------
mode : ndarray
    Array of modal values.
count : ndarray
    Array of counts for each mode.

Examples
--------
&gt;&gt;&gt; a = np.array([[6, 8, 3, 0],
...               [3, 2, 1, 7],
...               [8, 1, 8, 4],
...               [5, 3, 0, 5],
...               [4, 7, 5, 9]])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.mode(a)
(array([[3, 1, 0, 0]]), array([[1, 1, 1, 1]]))

To get mode of whole array, specify ``axis=None``:

&gt;&gt;&gt; stats.mode(a, axis=None)
(array([3]), array([3]))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>n-dimensional array of which to find mode(s).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="mode" name="mode" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Array of modal values.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="count" name="count" port_type="basic:List" show_port="True" sort_key="1">
      <docstring>Array of counts for each mode.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.moment" module_name="moment" namespace="'stats|mstats'">
    <docstring>Calculates the nth moment about the mean for a sample.

Generally used to calculate coefficients of skewness and
kurtosis.

Parameters
----------
a : array_like
   data
moment : int, optional
   order of central moment that is returned
axis : int or None, optional
   Axis along which the central moment is computed. Default is 0.
   If None, compute over the whole array `a`.

Returns
-------
n-th central moment : ndarray or float
   The appropriate moment along the given axis or over all values if axis
   is None. The denominator for the moment calculation is the number of
   observations, no degrees of freedom correction is done.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="moment" name="moment" port_type="basic:Integer">
      <docstring>order of central moment that is returned</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which the central moment is computed. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="n-th central moment" name="n-th central moment" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The appropriate moment along the given axis or over all values if axis
is None. The denominator for the moment calculation is the number of
observations, no degrees of freedom correction is done.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.mquantiles" module_name="mquantiles" namespace="'stats|mstats'">
    <docstring>Computes empirical quantiles for a data array.

Samples quantile are defined by ``Q(p) = (1-gamma)*x[j] + gamma*x[j+1]``,
where ``x[j]`` is the j-th order statistic, and gamma is a function of
``j = floor(n*p + m)``, ``m = alphap + p*(1 - alphap - betap)`` and
``g = n*p + m - j``.

Reinterpreting the above equations to compare to **R** lead to the
equation: ``p(k) = (k - alphap)/(n + 1 - alphap - betap)``

Typical values of (alphap,betap) are:
    - (0,1)    : ``p(k) = k/n`` : linear interpolation of cdf
      (**R** type 4)
    - (.5,.5)  : ``p(k) = (k - 1/2.)/n`` : piecewise linear function
      (**R** type 5)
    - (0,0)    : ``p(k) = k/(n+1)`` :
      (**R** type 6)
    - (1,1)    : ``p(k) = (k-1)/(n-1)``: p(k) = mode[F(x[k])].
      (**R** type 7, **R** default)
    - (1/3,1/3): ``p(k) = (k-1/3)/(n+1/3)``: Then p(k) ~ median[F(x[k])].
      The resulting quantile estimates are approximately median-unbiased
      regardless of the distribution of x.
      (**R** type 8)
    - (3/8,3/8): ``p(k) = (k-3/8)/(n+1/4)``: Blom.
      The resulting quantile estimates are approximately unbiased
      if x is normally distributed
      (**R** type 9)
    - (.4,.4)  : approximately quantile unbiased (Cunnane)
    - (.35,.35): APL, used with PWM

Parameters
----------
a : array_like
    Input data, as a sequence or array of dimension at most 2.
prob : array_like, optional
    List of quantiles to compute.
alphap : float, optional
    Plotting positions parameter, default is 0.4.
betap : float, optional
    Plotting positions parameter, default is 0.4.
axis : int, optional
    Axis along which to perform the trimming.
    If None (default), the input array is first flattened.
limit : tuple, optional
    Tuple of (lower, upper) values.
    Values of `a` outside this open interval are ignored.

Returns
-------
mquantiles : MaskedArray
    An array containing the calculated quantiles.

Notes
-----
This formulation is very similar to **R** except the calculation of
``m`` from ``alphap`` and ``betap``, where in **R** ``m`` is defined
with each type.

References
----------
.. [1] *R* statistical software: http://www.r-project.org/
.. [2] *R* ``quantile`` function:
        http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html

Examples
--------
&gt;&gt;&gt; from scipy.stats.mstats import mquantiles
&gt;&gt;&gt; a = np.array([6., 47., 49., 15., 42., 41., 7., 39., 43., 40., 36.])
&gt;&gt;&gt; mquantiles(a)
array([ 19.2,  40. ,  42.8])

Using a 2D array, specifying axis and limit.

&gt;&gt;&gt; data = np.array([[   6.,    7.,    1.],
                     [  47.,   15.,    2.],
                     [  49.,   36.,    3.],
                     [  15.,   39.,    4.],
                     [  42.,   40., -999.],
                     [  41.,   41., -999.],
                     [   7., -999., -999.],
                     [  39., -999., -999.],
                     [  43., -999., -999.],
                     [  40., -999., -999.],
                     [  36., -999., -999.]])
&gt;&gt;&gt; mquantiles(data, axis=0, limit=(0, 50))
array([[ 19.2 ,  14.6 ,   1.45],
       [ 40.  ,  37.5 ,   2.5 ],
       [ 42.8 ,  40.05,   3.55]])

&gt;&gt;&gt; data[:, 2] = -999.
&gt;&gt;&gt; mquantiles(data, axis=0, limit=(0, 50))
masked_array(data =
 [[19.2 14.6 --]
 [40.0 37.5 --]
 [42.8 40.05 --]],
             mask =
 [[False False  True]
  [False False  True]
  [False False  True]],
       fill_value = 1e+20)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data, as a sequence or array of dimension at most 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="prob" name="prob" port_type="basic:List">
      <docstring>List of quantiles to compute.</docstring>
      <defaults>[[0.25, 0.5, 0.75]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="alphap" name="alphap" port_type="basic:Float">
      <docstring>Plotting positions parameter, default is 0.4.</docstring>
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="betap" name="betap" port_type="basic:Float">
      <docstring>Plotting positions parameter, default is 0.4.</docstring>
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the trimming.
If None (default), the input array is first flattened.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limit" name="limit" port_type="basic:List">
      <docstring>Tuple of (lower, upper) values.
Values of `a` outside this open interval are ignored.</docstring>
      <defaults>[()]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="mquantiles" name="mquantiles" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>An array containing the calculated quantiles.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.mquantiles_cimj" module_name="mquantiles_cimj" namespace="'stats|mstats'">
    <docstring>Computes the alpha confidence interval for the selected quantiles of the
data, with Maritz-Jarrett estimators.

Parameters
----------
data : ndarray
    Data array.
prob : sequence, optional
    Sequence of quantiles to compute.
alpha : float, optional
    Confidence level of the intervals.
axis : int or None, optional
    Axis along which to compute the quantiles.
    If None, use a flattened array.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="prob" name="prob" port_type="basic:List">
      <docstring>Sequence of quantiles to compute.</docstring>
      <defaults>[[0.25, 0.5, 0.75]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Confidence level of the intervals.</docstring>
      <defaults>[0.05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute the quantiles.
If None, use a flattened array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.msign" module_name="msign" namespace="'stats|mstats'">
    <docstring>Returns the sign of x, or 0 if x is masked.</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.normaltest" module_name="normaltest" namespace="'stats|mstats'" output_type="list">
    <docstring>Tests whether a sample differs from a normal distribution.

This function tests the null hypothesis that a sample comes
from a normal distribution.  It is based on D'Agostino and
Pearson's [1]_, [2]_ test that combines skew and kurtosis to
produce an omnibus test of normality.


Parameters
----------
a : array_like
    The array containing the data to be tested.
axis : int or None, optional
    Axis along which to compute test. Default is 0. If None,
    compute over the whole array `a`.

Returns
-------
statistic : float or array
    `s^2 + k^2`, where `s` is the z-score returned by `skewtest` and
    `k` is the z-score returned by `kurtosistest`.
pvalue : float or array
   A 2-sided chi squared probability for the hypothesis test.

References
----------
.. [1] D'Agostino, R. B. (1971), "An omnibus test of normality for
       moderate and large sample size," Biometrika, 58, 341-348

.. [2] D'Agostino, R. and Pearson, E. S. (1973), "Testing for
       departures from normality," Biometrika, 60, 613-622</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The array containing the data to be tested.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. Default is 0. If None,
compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>`s^2 + k^2`, where `s` is the z-score returned by `skewtest` and
`k` is the z-score returned by `kurtosistest`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>A 2-sided chi squared probability for the hypothesis test.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.obrientransform" module_name="obrientransform" namespace="'stats|mstats'">
    <docstring>Computes a transform on input data (any number of columns).  Used to
test for homogeneity of variance prior to running one-way stats.  Each
array in ``*args`` is one level of a factor.  If an `f_oneway()` run on
the transformed data and found significant, variances are unequal.   From
Maxwell and Delaney, p.112.

Returns: transformed data for use in an ANOVA</docstring>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.pearsonr" module_name="pearsonr" namespace="'stats|mstats'">
    <docstring>Calculates a Pearson correlation coefficient and the p-value for testing
non-correlation.

The Pearson correlation coefficient measures the linear relationship
between two datasets. Strictly speaking, Pearson's correlation requires
that each dataset be normally distributed. Like other correlation
coefficients, this one varies between -1 and +1 with 0 implying no
correlation. Correlations of -1 or +1 imply an exact linear
relationship. Positive correlations imply that as `x` increases, so does
`y`. Negative correlations imply that as `x` increases, `y` decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Pearson correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
x : 1-D array_like
    Input
y : 1-D array_like
    Input

Returns
-------
pearsonr : float
    Pearson's correlation coefficient, 2-tailed p-value.

References
----------
http://www.statsoft.com/textbook/glosp.html#Pearson%20Correlation</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pearsonr" name="pearsonr" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Pearson's correlation coefficient, 2-tailed p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.plotting_positions" module_name="plotting_positions" namespace="'stats|mstats'">
    <docstring>Returns plotting positions (or empirical percentile points) for the data.

Plotting positions are defined as ``(i-alpha)/(n+1-alpha-beta)``, where:
    - i is the rank order statistics
    - n is the number of unmasked values along the given axis
    - `alpha` and `beta` are two parameters.

Typical values for `alpha` and `beta` are:
    - (0,1)    : ``p(k) = k/n``, linear interpolation of cdf (R, type 4)
    - (.5,.5)  : ``p(k) = (k-1/2.)/n``, piecewise linear function
      (R, type 5)
    - (0,0)    : ``p(k) = k/(n+1)``, Weibull (R type 6)
    - (1,1)    : ``p(k) = (k-1)/(n-1)``, in this case,
      ``p(k) = mode[F(x[k])]``. That's R default (R type 7)
    - (1/3,1/3): ``p(k) = (k-1/3)/(n+1/3)``, then
      ``p(k) ~ median[F(x[k])]``.
      The resulting quantile estimates are approximately median-unbiased
      regardless of the distribution of x. (R type 8)
    - (3/8,3/8): ``p(k) = (k-3/8)/(n+1/4)``, Blom.
      The resulting quantile estimates are approximately unbiased
      if x is normally distributed (R type 9)
    - (.4,.4)  : approximately quantile unbiased (Cunnane)
    - (.35,.35): APL, used with PWM
    - (.3175, .3175): used in scipy.stats.probplot

Parameters
----------
data : array_like
    Input data, as a sequence or array of dimension at most 2.
alpha : float, optional
    Plotting positions parameter. Default is 0.4.
beta : float, optional
    Plotting positions parameter. Default is 0.4.

Returns
-------
positions : MaskedArray
    The calculated plotting positions.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data, as a sequence or array of dimension at most 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Plotting positions parameter. Default is 0.4.</docstring>
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="beta" name="beta" port_type="basic:Float">
      <docstring>Plotting positions parameter. Default is 0.4.</docstring>
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="positions" name="positions" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The calculated plotting positions.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.pointbiserialr" module_name="pointbiserialr" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates a point biserial correlation coefficient and the associated
p-value.

The point biserial correlation is used to measure the relationship
between a binary variable, x, and a continuous variable, y. Like other
correlation coefficients, this one varies between -1 and +1 with 0
implying no correlation. Correlations of -1 or +1 imply a determinative
relationship.

This function uses a shortcut formula but produces the same result as
`pearsonr`.

Parameters
----------
x : array_like of bools
    Input array.
y : array_like
    Input array.

Returns
-------
correlation : float
    R value
pvalue : float
    2-tailed p-value

References
----------
http://en.wikipedia.org/wiki/Point-biserial_correlation_coefficient

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.array([0, 0, 0, 1, 1, 1, 1])
&gt;&gt;&gt; b = np.arange(7)
&gt;&gt;&gt; stats.pointbiserialr(a, b)
(0.8660254037844386, 0.011724811003954652)
&gt;&gt;&gt; stats.pearsonr(a, b)
(0.86602540378443871, 0.011724811003954626)
&gt;&gt;&gt; np.corrcoef(a, b)
array([[ 1.       ,  0.8660254],
       [ 0.8660254,  1.       ]])



Notes
-----
Missing values are considered pair-wise: if a value is missing in x,
the corresponding value in y is masked.</docstring>
    <inputPortSpec arg="x" depth="1" name="x" port_type="basic:Boolean" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>R value</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>2-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.rankdata" module_name="rankdata" namespace="'stats|mstats'">
    <docstring>Returns the rank (also known as order statistics) of each data point
along the given axis.

If some values are tied, their rank is averaged.
If some values are masked, their rank is set to 0 if use_missing is False,
or set to the average rank of the unmasked values if use_missing is True.

Parameters
----------
data : sequence
    Input data. The data is transformed to a masked array
axis : {None,int}, optional
    Axis along which to perform the ranking.
    If None, the array is first flattened. An exception is raised if
    the axis is specified for arrays with a dimension larger than 2
use_missing : bool, optional
    Whether the masked values have a rank of 0 (False) or equal to the
    average rank of the unmasked values (True).</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data. The data is transformed to a masked array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the ranking.
If None, the array is first flattened. An exception is raised if
the axis is specified for arrays with a dimension larger than 2</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_missing" name="use_missing" port_type="basic:Boolean">
      <docstring>Whether the masked values have a rank of 0 (False) or equal to the
average rank of the unmasked values (True).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.rsh" module_name="rsh" namespace="'stats|mstats'">
    <docstring>Evaluates Rosenblatt's shifted histogram estimators for each point
on the dataset 'data'.

Parameters
----------
data : sequence
    Input data. Masked values are ignored.
points : sequence or None, optional
    Sequence of points where to evaluate Rosenblatt shifted histogram.
    If None, use the data.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data. Masked values are ignored.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" name="pointsScalar">
      <docstring>Sequence of points where to evaluate Rosenblatt shifted histogram.
If None, use the data.</docstring>
      <alternateSpec arg="points" name="pointsSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.scoreatpercentile" module_name="scoreatpercentile" namespace="'stats|mstats'">
    <docstring>Calculate the score at the given 'per' percentile of the
sequence a.  For example, the score at per=50 is the median.

This function is a shortcut to mquantile</docstring>
    <inputPortSpec arg="limit" name="limit" port_type="basic:List" show_port="True" />
    <inputPortSpec arg="alphap" name="alphap" port_type="basic:Float">
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="data" name="data" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="per" name="per" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="betap" name="betap" port_type="basic:Float">
      <defaults>[0.4]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.sem" module_name="sem" namespace="'stats|mstats'">
    <docstring>Calculates the standard error of the mean of the input array.

Also sometimes called standard error of measurement.

Parameters
----------
a : array_like
    An array containing the values for which the standard error is
    returned.
axis : int or None, optional
    If axis is None, ravel `a` first. If axis is an integer, this will be
    the axis over which to operate. Defaults to 0.
ddof : int, optional
    Delta degrees-of-freedom. How many degrees of freedom to adjust
    for bias in limited samples relative to the population estimate
    of variance. Defaults to 1.

Returns
-------
s : ndarray or float
    The standard error of the mean in the sample(s), along the input axis.

Notes
-----
The default value for `ddof` changed in scipy 0.15.0 to be consistent with
`stats.sem` as well as with the most common definition used (like in the R
documentation).

Examples
--------
Find standard error along the first axis:

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; a = np.arange(20).reshape(5,4)
&gt;&gt;&gt; stats.sem(a)
array([ 2.8284,  2.8284,  2.8284,  2.8284])

Find standard error across the whole array, using n degrees of freedom:

&gt;&gt;&gt; stats.sem(a, axis=None, ddof=0)
1.2893796958227628</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>An array containing the values for which the standard error is
returned.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>If axis is None, ravel `a` first. If axis is an integer, this will be
the axis over which to operate. Defaults to 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Delta degrees-of-freedom. How many degrees of freedom to adjust
for bias in limited samples relative to the population estimate
of variance. Defaults to 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="s" name="s" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The standard error of the mean in the sample(s), along the input axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.sen_seasonal_slopes" module_name="sen_seasonal_slopes" namespace="'stats|mstats'">
    <inputPortSpec arg="x" name="x" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.signaltonoise" module_name="signaltonoise" namespace="'stats|mstats'">
    <docstring>`signaltonoise` is deprecated!
mstats.signaltonoise is deprecated in scipy 0.16.0

Calculates the signal-to-noise ratio, as the ratio of the mean over
    standard deviation along the given axis.

    Parameters
    ----------
    data : sequence
        Input data
    axis : {0, int}, optional
        Axis along which to compute. If None, the computation is performed
        on a flat version of the array.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>    Input data
axis : {0, int}, optional
    Axis along which to compute. If None, the computation is performed
    on a flat version of the array.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.skew" module_name="skew" namespace="'stats|mstats'">
    <docstring>Computes the skewness of a data set.

For normally distributed data, the skewness should be about 0. A skewness
value &gt; 0 means that there is more weight in the left tail of the
distribution. The function `skewtest` can be used to determine if the
skewness value is close enough to 0, statistically speaking.

Parameters
----------
a : ndarray
    data
axis : int or None, optional
    Axis along which skewness is calculated. Default is 0.
    If None, compute over the whole array `a`.
bias : bool, optional
    If False, then the calculations are corrected for statistical bias.

Returns
-------
skewness : ndarray
    The skewness of values along an axis, returning 0 where all values are
    equal.

References
----------

.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.
   Section 2.2.24.1</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which skewness is calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bias" name="bias" port_type="basic:Boolean">
      <docstring>If False, then the calculations are corrected for statistical bias.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="skewness" name="skewness" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The skewness of values along an axis, returning 0 where all values are
equal.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.skewtest" module_name="skewtest" namespace="'stats|mstats'" output_type="list">
    <docstring>Tests whether the skew is different from the normal distribution.

This function tests the null hypothesis that the skewness of
the population that the sample was drawn from is the same
as that of a corresponding normal distribution.

Parameters
----------
a : array
    The data to be tested
axis : int or None, optional
   Axis along which statistics are calculated. Default is 0.
   If None, compute over the whole array `a`.

Returns
-------
statistic : float
    The computed z-score for this test.
pvalue : float
    a 2-sided p-value for the hypothesis test

Notes
-----
The sample size must be at least 8.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The data to be tested</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which statistics are calculated. Default is 0.
If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The computed z-score for this test.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>a 2-sided p-value for the hypothesis test</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.spearmanr" module_name="spearmanr" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates a Spearman rank-order correlation coefficient and the p-value
to test for non-correlation.

The Spearman correlation is a nonparametric measure of the linear
relationship between two datasets. Unlike the Pearson correlation, the
Spearman correlation does not assume that both datasets are normally
distributed. Like other correlation coefficients, this one varies
between -1 and +1 with 0 implying no correlation. Correlations of -1 or
+1 imply an exact linear relationship. Positive correlations imply that
as `x` increases, so does `y`. Negative correlations imply that as `x`
increases, `y` decreases.

Missing values are discarded pair-wise: if a value is missing in `x`, the
corresponding value in `y` is masked.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Spearman correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
x : array_like
    The length of `x` must be &gt; 2.
y : array_like
    The length of `y` must be &gt; 2.
use_ties : bool, optional
    Whether the correction for ties should be computed.

Returns
-------
correlation : float
    Spearman correlation coefficient
pvalue : float
    2-tailed p-value.

References
----------
[CRCProbStat2000] section 14.7</docstring>
    <inputPortSpec arg="x" name="x" port_type="basic:List" show_port="True">
      <docstring>The length of `x` must be &gt; 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>The length of `y` must be &gt; 2.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_ties" name="use_ties" port_type="basic:Boolean">
      <docstring>Whether the correction for ties should be computed.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="correlation" name="correlation" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Spearman correlation coefficient</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>2-tailed p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.theilslopes" module_name="theilslopes" namespace="'stats|mstats'" output_type="list">
    <docstring>Computes the Theil-Sen estimator for a set of points (x, y).

`theilslopes` implements a method for robust linear regression.  It
computes the slope as the median of all slopes between paired values.

Parameters
----------
y : array_like
    Dependent variable.
x : array_like or None, optional
    Independent variable. If None, use ``arange(len(y))`` instead.
alpha : float, optional
    Confidence degree between 0 and 1. Default is 95% confidence.
    Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are
    interpreted as "find the 90% confidence interval".

Returns
-------
medslope : float
    Theil slope.
medintercept : float
    Intercept of the Theil line, as ``median(y) - medslope*median(x)``.
lo_slope : float
    Lower bound of the confidence interval on `medslope`.
up_slope : float
    Upper bound of the confidence interval on `medslope`.

Notes
-----
The implementation of `theilslopes` follows [1]_. The intercept is
not defined in [1]_, and here it is defined as ``median(y) -
medslope*median(x)``, which is given in [3]_. Other definitions of
the intercept exist in the literature. A confidence interval for
the intercept is not given as this question is not addressed in
[1]_.

References
----------
.. [1] P.K. Sen, "Estimates of the regression coefficient based on Kendall's tau",
       J. Am. Stat. Assoc., Vol. 63, pp. 1379-1389, 1968.
.. [2] H. Theil, "A rank-invariant method of linear and polynomial
       regression analysis I, II and III",  Nederl. Akad. Wetensch., Proc.
       53:, pp. 386-392, pp. 521-525, pp. 1397-1412, 1950.
.. [3] W.L. Conover, "Practical nonparametric statistics", 2nd ed.,
       John Wiley and Sons, New York, pp. 493.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; x = np.linspace(-5, 5, num=150)
&gt;&gt;&gt; y = x + np.random.normal(size=x.size)
&gt;&gt;&gt; y[11:15] += 10  # add outliers
&gt;&gt;&gt; y[-5:] -= 7

Compute the slope, intercept and 90% confidence interval.  For comparison,
also compute the least-squares fit with `linregress`:

&gt;&gt;&gt; res = stats.theilslopes(y, x, 0.90)
&gt;&gt;&gt; lsq_res = stats.linregress(x, y)

Plot the results. The Theil-Sen regression line is shown in red, with the
dashed red lines illustrating the confidence interval of the slope (note
that the dashed red lines are not the confidence interval of the regression
as the confidence interval of the intercept is not included). The green
line shows the least-squares fit for comparison.

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(x, y, 'b.')
&gt;&gt;&gt; ax.plot(x, res[1] + res[0] * x, 'r-')
&gt;&gt;&gt; ax.plot(x, res[1] + res[2] * x, 'r--')
&gt;&gt;&gt; ax.plot(x, res[1] + res[3] * x, 'r--')
&gt;&gt;&gt; ax.plot(x, lsq_res[1] + lsq_res[0] * x, 'g-')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="y" name="y" port_type="basic:List" show_port="True">
      <docstring>Dependent variable.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" name="xScalar">
      <docstring>Independent variable. If None, use ``arange(len(y))`` instead.</docstring>
      <alternateSpec arg="x" name="xSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Confidence degree between 0 and 1. Default is 95% confidence.
Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are
interpreted as "find the 90% confidence interval".</docstring>
      <defaults>[0.95]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="medslope" name="medslope" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Theil slope.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="medintercept" name="medintercept" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>Intercept of the Theil line, as ``median(y) - medslope*median(x)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="lo_slope" name="lo_slope" port_type="basic:Float" show_port="True" sort_key="2">
      <docstring>Lower bound of the confidence interval on `medslope`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="up_slope" name="up_slope" port_type="basic:Float" show_port="True" sort_key="3">
      <docstring>Upper bound of the confidence interval on `medslope`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.threshold" module_name="threshold" namespace="'stats|mstats'">
    <docstring>Clip array to a given value.

Similar to numpy.clip(), except that values less than `threshmin` or
greater than `threshmax` are replaced by `newval`, instead of by
`threshmin` and `threshmax` respectively.

Parameters
----------
a : ndarray
    Input data
threshmin : {None, float}, optional
    Lower threshold. If None, set to the minimum value.
threshmax : {None, float}, optional
    Upper threshold. If None, set to the maximum value.
newval : {0, float}, optional
    Value outside the thresholds.

Returns
-------
threshold : ndarray
    Returns `a`, with values less then `threshmin` and values greater
    `threshmax` replaced with `newval`.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="threshmin" name="threshmin" port_type="basic:Float">
      <docstring>Lower threshold. If None, set to the minimum value.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="threshmax" name="threshmax" port_type="basic:Float">
      <docstring>Upper threshold. If None, set to the maximum value.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="newval" name="newval" port_type="basic:Float">
      <docstring>Value outside the thresholds.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="threshold" name="threshold" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returns `a`, with values less then `threshmin` and values greater
`threshmax` replaced with `newval`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.tmax" module_name="tmax" namespace="'stats|mstats'">
    <docstring>Compute the trimmed maximum

This function computes the maximum value of an array along a given axis,
while ignoring values larger than a specified upper limit.

Parameters
----------
a : array_like
    array of values
upperlimit : None or float, optional
    Values in the input array greater than the given limit will be ignored.
    When upperlimit is None, then all values are used. The default value
    is None.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the
    whole array `a`.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the upper limit
    are included.  The default value is True.

Returns
-------
tmax : float</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="upperlimit" name="upperlimit" port_type="basic:Float">
      <docstring>Values in the input array greater than the given limit will be ignored.
When upperlimit is None, then all values are used. The default value
is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over the
whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:Boolean">
      <docstring>This flag determines whether values exactly equal to the upper limit
are included.  The default value is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tmax" name="tmax" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.tmean" module_name="tmean" namespace="'stats|mstats'">
    <docstring>Compute the trimmed mean.

This function finds the arithmetic mean of given values, ignoring values
outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored.  When limits is None (default), then all
    values are used.  Either of the limit values in the tuple can also be
    None representing a half-open interval.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tmean : float</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored.  When limits is None (default), then all
values are used.  Either of the limit values in the tuple can also be
None representing a half-open interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tmean" name="tmean" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.tmin" module_name="tmin" namespace="'stats|mstats'">
    <docstring>Compute the trimmed minimum

This function finds the miminum value of an array `a` along the
specified axis, but only considering values greater than a specified
lower limit.

Parameters
----------
a : array_like
    array of values
lowerlimit : None or float, optional
    Values in the input array less than the given limit will be ignored.
    When lowerlimit is None, then all values are used. The default value
    is None.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over the whole
    array `a`.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the lower limit
    are included.  The default value is True.

Returns
-------
tmin : float</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="lowerlimit" name="lowerlimit" port_type="basic:Float">
      <docstring>Values in the input array less than the given limit will be ignored.
When lowerlimit is None, then all values are used. The default value
is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over the whole
array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:Boolean">
      <docstring>This flag determines whether values exactly equal to the lower limit
are included.  The default value is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="tmin" name="tmin" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trim" module_name="trim" namespace="'stats|mstats'">
    <docstring>Trims an array by masking the data outside some given limits.

Returns a masked version of the input array.


Parameters
----------
a : sequence
    Input array
limits : {None, tuple}, optional
    If `relative` is False, tuple (lower limit, upper limit) in absolute values.
    Values of the input array lower (greater) than the lower (upper) limit are
    masked.

    If `relative` is True, tuple (lower percentage, upper percentage) to cut
    on each side of the  array, with respect to the number of unmasked data.

    Noting n the number of unmasked data before trimming, the (n*limits[0])th
    smallest data and the (n*limits[1])th largest data are masked, and the
    total number of unmasked data after trimming is n*(1.-sum(limits))
    In each case, the value of one limit can be set to None to indicate an
    open interval.

    If limits is None, no trimming is performed
inclusive : {(bool, bool) tuple}, optional
    If `relative` is False, tuple indicating whether values exactly equal
    to the absolute limits are allowed.
    If `relative` is True, tuple indicating whether the number of data
    being masked on each side should be rounded (True) or truncated
    (False).
relative : bool, optional
    Whether to consider the limits as absolute values (False) or proportions
    to cut (True).
axis : int, optional
    Axis along which to trim.


Examples
--------
&gt;&gt;&gt; z = [ 1, 2, 3, 4, 5, 6, 7, 8, 9,10]
&gt;&gt;&gt; trim(z,(3,8))
[--,--, 3, 4, 5, 6, 7, 8,--,--]
&gt;&gt;&gt; trim(z,(0.1,0.2),relative=True)
[--, 2, 3, 4, 5, 6, 7, 8,--,--]</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <docstring>If `relative` is False, tuple (lower limit, upper limit) in absolute values.
Values of the input array lower (greater) than the lower (upper) limit are
masked.

If `relative` is True, tuple (lower percentage, upper percentage) to cut
on each side of the  array, with respect to the number of unmasked data.

Noting n the number of unmasked data before trimming, the (n*limits[0])th
smallest data and the (n*limits[1])th largest data are masked, and the
total number of unmasked data after trimming is n*(1.-sum(limits))
In each case, the value of one limit can be set to None to indicate an
open interval.

If limits is None, no trimming is performed</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>If `relative` is False, tuple indicating whether values exactly equal
to the absolute limits are allowed.
If `relative` is True, tuple indicating whether the number of data
being masked on each side should be rounded (True) or truncated
(False).</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="relative" name="relative" port_type="basic:Boolean">
      <docstring>Whether to consider the limits as absolute values (False) or proportions
to cut (True).</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to trim.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trima" module_name="trima" namespace="'stats|mstats'">
    <docstring>Trims an array by masking the data outside some given limits.

Returns a masked version of the input array.

Parameters
----------
a : array_like
    Input array.
limits : {None, tuple}, optional
    Tuple of (lower limit, upper limit) in absolute values.
    Values of the input array lower (greater) than the lower (upper) limit
    will be masked.  A limit is None indicates an open interval.
inclusive : (bool, bool) tuple, optional
    Tuple of (lower flag, upper flag), indicating whether values exactly
    equal to the lower (upper) limit are allowed.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <docstring>Tuple of (lower limit, upper limit) in absolute values.
Values of the input array lower (greater) than the lower (upper) limit
will be masked.  A limit is None indicates an open interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>Tuple of (lower flag, upper flag), indicating whether values exactly
equal to the lower (upper) limit are allowed.</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimboth" module_name="trimboth" namespace="'stats|mstats'">
    <docstring>Trims the smallest and largest data values.

Trims the `data` by masking the ``int(proportiontocut * n)`` smallest and
``int(proportiontocut * n)`` largest values of data along the given axis,
where n is the number of unmasked values before trimming.

Parameters
----------
data : ndarray
    Data to trim.
proportiontocut : float, optional
    Percentage of trimming (as a float between 0 and 1).
    If n is the number of unmasked values before trimming, the number of
    values after trimming is ``(1 - 2*proportiontocut) * n``.
    Default is 0.2.
inclusive : {(bool, bool) tuple}, optional
    Tuple indicating whether the number of data being masked on each side
    should be rounded (True) or truncated (False).
axis : int, optional
    Axis along which to perform the trimming.
    If None, the input array is first flattened.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data to trim.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float">
      <docstring>Percentage of trimming (as a float between 0 and 1).
If n is the number of unmasked values before trimming, the number of
values after trimming is ``(1 - 2*proportiontocut) * n``.
Default is 0.2.</docstring>
      <defaults>[0.2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>Tuple indicating whether the number of data being masked on each side
should be rounded (True) or truncated (False).</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the trimming.
If None, the input array is first flattened.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimmed_mean" module_name="trimmed_mean" namespace="'stats|mstats'">
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="relative" name="relative" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <defaults>[(0.1, 0.1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <defaults>[(1, 1)]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimmed_mean_ci" module_name="trimmed_mean_ci" namespace="'stats|mstats'">
    <docstring>Selected confidence interval of the trimmed mean along the given axis.

Parameters
----------
data : array_like
    Input data.
limits : {None, tuple}, optional
    None or a two item tuple.
    Tuple of the percentages to cut on each side of the array, with respect
    to the number of unmasked data, as floats between 0. and 1. If ``n``
    is the number of unmasked data before trimming, then
    (``n * limits[0]``)th smallest data and (``n * limits[1]``)th
    largest data are masked.  The total number of unmasked data after
    trimming is ``n * (1. - sum(limits))``.
    The value of one limit can be set to None to indicate an open interval.

    Defaults to (0.2, 0.2).
inclusive : (2,) tuple of boolean, optional
    If relative==False, tuple indicating whether values exactly equal to
    the absolute limits are allowed.
    If relative==True, tuple indicating whether the number of data being
    masked on each side should be rounded (True) or truncated (False).

    Defaults to (True, True).
alpha : float, optional
    Confidence level of the intervals.

    Defaults to 0.05.
axis : int, optional
    Axis along which to cut. If None, uses a flattened version of `data`.

    Defaults to None.

Returns
-------
trimmed_mean_ci : (2,) ndarray
    The lower and upper confidence intervals of the trimmed data.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Input data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <docstring>None or a two item tuple.
Tuple of the percentages to cut on each side of the array, with respect
to the number of unmasked data, as floats between 0. and 1. If ``n``
is the number of unmasked data before trimming, then
(``n * limits[0]``)th smallest data and (``n * limits[1]``)th
largest data are masked.  The total number of unmasked data after
trimming is ``n * (1. - sum(limits))``.
The value of one limit can be set to None to indicate an open interval.

Defaults to (0.2, 0.2).</docstring>
      <defaults>[(0.2, 0.2)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>If relative==False, tuple indicating whether values exactly equal to
the absolute limits are allowed.
If relative==True, tuple indicating whether the number of data being
masked on each side should be rounded (True) or truncated (False).

Defaults to (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>Confidence level of the intervals.

Defaults to 0.05.</docstring>
      <defaults>[0.05]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to cut. If None, uses a flattened version of `data`.

Defaults to None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="trimmed_mean_ci" name="trimmed_mean_ci" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The lower and upper confidence intervals of the trimmed data.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimmed_std" module_name="trimmed_std" namespace="'stats|mstats'">
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <defaults>[(0.1, 0.1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <defaults>[(1, 1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="relative" name="relative" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimmed_stde" module_name="trimmed_stde" namespace="'stats|mstats'">
    <docstring>Returns the standard error of the trimmed mean along the given axis.

Parameters
----------
a : sequence
    Input array
limits : {(0.1,0.1), tuple of float}, optional
    tuple (lower percentage, upper percentage) to cut  on each side of the
    array, with respect to the number of unmasked data.

    If n is the number of unmasked data before trimming, the values
    smaller than ``n * limits[0]`` and the values larger than
    ``n * `limits[1]`` are masked, and the total number of unmasked
    data after trimming is ``n * (1.-sum(limits))``.  In each case,
    the value of one limit can be set to None to indicate an open interval.
    If `limits` is None, no trimming is performed.
inclusive : {(bool, bool) tuple} optional
    Tuple indicating whether the number of data being masked on each side
    should be rounded (True) or truncated (False).
axis : int, optional
    Axis along which to trim.

Returns
-------
trimmed_stde : scalar or ndarray</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <docstring>tuple (lower percentage, upper percentage) to cut  on each side of the
array, with respect to the number of unmasked data.

If n is the number of unmasked data before trimming, the values
smaller than ``n * limits[0]`` and the values larger than
``n * `limits[1]`` are masked, and the total number of unmasked
data after trimming is ``n * (1.-sum(limits))``.  In each case,
the value of one limit can be set to None to indicate an open interval.
If `limits` is None, no trimming is performed.</docstring>
      <defaults>[(0.1, 0.1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>Tuple indicating whether the number of data being masked on each side
should be rounded (True) or truncated (False).</docstring>
      <defaults>[(1, 1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to trim.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="trimmed_stde" name="trimmed_stde" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimmed_var" module_name="trimmed_var" namespace="'stats|mstats'">
    <inputPortSpec arg="a" name="a" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <defaults>[(0.1, 0.1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer" show_port="True" />
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <defaults>[(1, 1)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="relative" name="relative" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimr" module_name="trimr" namespace="'stats|mstats'">
    <docstring>Trims an array by masking some proportion of the data on each end.
Returns a masked version of the input array.

Parameters
----------
a : sequence
    Input array.
limits : {None, tuple}, optional
    Tuple of the percentages to cut on each side of the array, with respect
    to the number of unmasked data, as floats between 0. and 1.
    Noting n the number of unmasked data before trimming, the
    (n*limits[0])th smallest data and the (n*limits[1])th largest data are
    masked, and the total number of unmasked data after trimming is
    n*(1.-sum(limits)).  The value of one limit can be set to None to
    indicate an open interval.
inclusive : {(True,True) tuple}, optional
    Tuple of flags indicating whether the number of data being masked on
    the left (right) end should be truncated (True) or rounded (False) to
    integers.
axis : {None,int}, optional
    Axis along which to trim. If None, the whole array is trimmed, but its
    shape is maintained.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits" port_type="basic:List">
      <docstring>Tuple of the percentages to cut on each side of the array, with respect
to the number of unmasked data, as floats between 0. and 1.
Noting n the number of unmasked data before trimming, the
(n*limits[0])th smallest data and the (n*limits[1])th largest data are
masked, and the total number of unmasked data after trimming is
n*(1.-sum(limits)).  The value of one limit can be set to None to
indicate an open interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>Tuple of flags indicating whether the number of data being masked on
the left (right) end should be truncated (True) or rounded (False) to
integers.</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to trim. If None, the whole array is trimmed, but its
shape is maintained.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.trimtail" module_name="trimtail" namespace="'stats|mstats'">
    <docstring>Trims the data by masking values from one tail.

Parameters
----------
data : array_like
    Data to trim.
proportiontocut : float, optional
    Percentage of trimming. If n is the number of unmasked values
    before trimming, the number of values after trimming is
    ``(1 - proportiontocut) * n``.  Default is 0.2.
tail : {'left','right'}, optional
    If 'left' the `proportiontocut` lowest values will be masked.
    If 'right' the `proportiontocut` highest values will be masked.
    Default is 'left'.
inclusive : {(bool, bool) tuple}, optional
    Tuple indicating whether the number of data being masked on each side
    should be rounded (True) or truncated (False).  Default is
    (True, True).
axis : int, optional
    Axis along which to perform the trimming.
    If None, the input array is first flattened.  Default is None.

Returns
-------
trimtail : ndarray
    Returned array of same shape as `data` with masked tail values.</docstring>
    <inputPortSpec arg="data" name="data" port_type="basic:List" show_port="True">
      <docstring>Data to trim.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="proportiontocut" name="proportiontocut" port_type="basic:Float">
      <docstring>Percentage of trimming. If n is the number of unmasked values
before trimming, the number of values after trimming is
``(1 - proportiontocut) * n``.  Default is 0.2.</docstring>
      <defaults>[0.2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="tail" name="tail">
      <docstring>If 'left' the `proportiontocut` lowest values will be masked.
If 'right' the `proportiontocut` highest values will be masked.
Default is 'left'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['left', 'right']]</values>
      <defaults>['left']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>Tuple indicating whether the number of data being masked on each side
should be rounded (True) or truncated (False).  Default is
(True, True).</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to perform the trimming.
If None, the input array is first flattened.  Default is None.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="trimtail" name="trimtail" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Returned array of same shape as `data` with masked tail values.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.tsem" module_name="tsem" namespace="'stats|mstats'">
    <docstring>Compute the trimmed standard error of the mean.

This function finds the standard error of the mean for given
values, ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    array of values
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tsem : float

Notes
-----
`tsem` uses unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>array of values</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored. When limits is None, then all values are
used. Either of the limit values in the tuple can also be None
representing a half-open interval.  The default value is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tsem" name="tsem" port_type="basic:Float" show_port="True" sort_key="0" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.ttest_1samp" module_name="ttest_1samp" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates the T-test for the mean of ONE group of scores.

This is a two-sided test for the null hypothesis that the expected value
(mean) of a sample of independent observations `a` is equal to the given
population mean, `popmean`.

Parameters
----------
a : array_like
    sample observation
popmean : float or array_like
    expected value in null hypothesis, if array_like than it must have the
    same shape as `a` excluding the axis dimension
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    array `a`.

Returns
-------
statistic : float or array
    t-statistic
pvalue : float or array
    two-tailed p-value

Examples
--------
&gt;&gt;&gt; from scipy import stats

&gt;&gt;&gt; np.random.seed(7654567)  # fix seed to get the same result
&gt;&gt;&gt; rvs = stats.norm.rvs(loc=5, scale=10, size=(50,2))

Test if mean of random sample is equal to true mean, and different mean.
We reject the null hypothesis in the second case and don't reject it in
the first case.

&gt;&gt;&gt; stats.ttest_1samp(rvs,5.0)
(array([-0.68014479, -0.04323899]), array([ 0.49961383,  0.96568674]))
&gt;&gt;&gt; stats.ttest_1samp(rvs,0.0)
(array([ 2.77025808,  4.11038784]), array([ 0.00789095,  0.00014999]))

Examples using axis and non-scalar dimension for population mean.

&gt;&gt;&gt; stats.ttest_1samp(rvs,[5.0,0.0])
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
&gt;&gt;&gt; stats.ttest_1samp(rvs.T,[5.0,0.0],axis=1)
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
&gt;&gt;&gt; stats.ttest_1samp(rvs,[[5.0],[0.0]])
(array([[-0.68014479, -0.04323899],
       [ 2.77025808,  4.11038784]]), array([[  4.99613833e-01,   9.65686743e-01],
       [  7.89094663e-03,   1.49986458e-04]]))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>sample observation</docstring>
    </inputPortSpec>
    <inputPortSpec arg="popmean" name="popmeanScalar" port_type="basic:Float" show_port="True">
      <docstring>expected value in null hypothesis, if array_like than it must have the
same shape as `a` excluding the axis dimension</docstring>
      <alternateSpec arg="popmean" name="popmeanSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>t-statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>two-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.ttest_ind" module_name="ttest_ind" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates the T-test for the means of TWO INDEPENDENT samples of scores.

This is a two-sided test for the null hypothesis that 2 independent samples
have identical average (expected) values. This test assumes that the
populations have identical variances by default.

Parameters
----------
a, b : array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    arrays, `a`, and `b`.
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.
    .. versionadded:: 0.11.0


Returns
-------
statistic : float or array
    The calculated t-statistic.
pvalue : float or array
    The two-tailed p-value.

Notes
-----
We can use this test, if we observe two independent samples from
the same or different population, e.g. exam scores of boys and
girls or of two ethnic groups. The test measures whether the
average (expected) value differs significantly across samples. If
we observe a large p-value, for example larger than 0.05 or 0.1,
then we cannot reject the null hypothesis of identical average scores.
If the p-value is smaller than the threshold, e.g. 1%, 5% or 10%,
then we reject the null hypothesis of equal averages.

References
----------
.. [1] http://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] http://en.wikipedia.org/wiki/Welch%27s_t_test

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(12345678)

Test with sample with identical means:

&gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
&gt;&gt;&gt; rvs2 = stats.norm.rvs(loc=5,scale=10,size=500)
&gt;&gt;&gt; stats.ttest_ind(rvs1,rvs2)
(0.26833823296239279, 0.78849443369564776)
&gt;&gt;&gt; stats.ttest_ind(rvs1,rvs2, equal_var = False)
(0.26833823296239279, 0.78849452749500748)

`ttest_ind` underestimates p for unequal variances:

&gt;&gt;&gt; rvs3 = stats.norm.rvs(loc=5, scale=20, size=500)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3)
(-0.46580283298287162, 0.64145827413436174)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3, equal_var = False)
(-0.46580283298287162, 0.64149646246569292)

When n1 != n2, the equal variance t-statistic is no longer equal to the
unequal variance t-statistic:

&gt;&gt;&gt; rvs4 = stats.norm.rvs(loc=5, scale=20, size=100)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4)
(-0.99882539442782481, 0.3182832709103896)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4, equal_var = False)
(-0.69712570584654099, 0.48716927725402048)

T-test with different means, variance, and n:

&gt;&gt;&gt; rvs5 = stats.norm.rvs(loc=8, scale=20, size=100)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5)
(-1.4679669854490653, 0.14263895620529152)
&gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, equal_var = False)
(-0.94365973617132992, 0.34744170334794122)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape, except in the dimension
corresponding to `axis` (the first, by default).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
arrays, `a`, and `b`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="equal_var" name="equal_var" port_type="basic:Boolean">
      <docstring>If True (default), perform a standard independent 2 sample test
that assumes equal population variances [1]_.
If False, perform Welch's t-test, which does not assume equal
population variance [2]_.
.. versionadded:: 0.11.0</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>The calculated t-statistic.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>The two-tailed p-value.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.ttest_onesamp" module_name="ttest_onesamp" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates the T-test for the mean of ONE group of scores.

This is a two-sided test for the null hypothesis that the expected value
(mean) of a sample of independent observations `a` is equal to the given
population mean, `popmean`.

Parameters
----------
a : array_like
    sample observation
popmean : float or array_like
    expected value in null hypothesis, if array_like than it must have the
    same shape as `a` excluding the axis dimension
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    array `a`.

Returns
-------
statistic : float or array
    t-statistic
pvalue : float or array
    two-tailed p-value

Examples
--------
&gt;&gt;&gt; from scipy import stats

&gt;&gt;&gt; np.random.seed(7654567)  # fix seed to get the same result
&gt;&gt;&gt; rvs = stats.norm.rvs(loc=5, scale=10, size=(50,2))

Test if mean of random sample is equal to true mean, and different mean.
We reject the null hypothesis in the second case and don't reject it in
the first case.

&gt;&gt;&gt; stats.ttest_1samp(rvs,5.0)
(array([-0.68014479, -0.04323899]), array([ 0.49961383,  0.96568674]))
&gt;&gt;&gt; stats.ttest_1samp(rvs,0.0)
(array([ 2.77025808,  4.11038784]), array([ 0.00789095,  0.00014999]))

Examples using axis and non-scalar dimension for population mean.

&gt;&gt;&gt; stats.ttest_1samp(rvs,[5.0,0.0])
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
&gt;&gt;&gt; stats.ttest_1samp(rvs.T,[5.0,0.0],axis=1)
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
&gt;&gt;&gt; stats.ttest_1samp(rvs,[[5.0],[0.0]])
(array([[-0.68014479, -0.04323899],
       [ 2.77025808,  4.11038784]]), array([[  4.99613833e-01,   9.65686743e-01],
       [  7.89094663e-03,   1.49986458e-04]]))</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>sample observation</docstring>
    </inputPortSpec>
    <inputPortSpec arg="popmean" name="popmeanScalar" port_type="basic:Float" show_port="True">
      <docstring>expected value in null hypothesis, if array_like than it must have the
same shape as `a` excluding the axis dimension</docstring>
      <alternateSpec arg="popmean" name="popmeanSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>t-statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>two-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.ttest_rel" module_name="ttest_rel" namespace="'stats|mstats'" output_type="list">
    <docstring>Calculates the T-test on TWO RELATED samples of scores, a and b.

This is a two-sided test for the null hypothesis that 2 related or
repeated samples have identical average (expected) values.

Parameters
----------
a, b : array_like
    The arrays must have the same shape.
axis : int or None, optional
    Axis along which to compute test. If None, compute over the whole
    arrays, `a`, and `b`.

Returns
-------
statistic : float or array
    t-statistic
pvalue : float or array
    two-tailed p-value

Notes
-----
Examples for the use are scores of the same set of student in
different exams, or repeated sampling from the same units. The
test measures whether the average score differs significantly
across samples (e.g. exams). If we observe a large p-value, for
example greater than 0.05 or 0.1 then we cannot reject the null
hypothesis of identical average scores. If the p-value is smaller
than the threshold, e.g. 1%, 5% or 10%, then we reject the null
hypothesis of equal averages. Small p-values are associated with
large t-statistics.

References
----------
http://en.wikipedia.org/wiki/T-test#Dependent_t-test

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; np.random.seed(12345678) # fix random seed to get same numbers

&gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
&gt;&gt;&gt; rvs2 = (stats.norm.rvs(loc=5,scale=10,size=500) +
...         stats.norm.rvs(scale=0.2,size=500))
&gt;&gt;&gt; stats.ttest_rel(rvs1,rvs2)
(0.24101764965300962, 0.80964043445811562)
&gt;&gt;&gt; rvs3 = (stats.norm.rvs(loc=8,scale=10,size=500) +
...         stats.norm.rvs(scale=0.2,size=500))
&gt;&gt;&gt; stats.ttest_rel(rvs1,rvs3)
(-3.9995108708727933, 7.3082402191726459e-005)</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="b" name="b" port_type="basic:List" show_port="True">
      <docstring>The arrays must have the same shape.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to compute test. If None, compute over the whole
arrays, `a`, and `b`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="statistic" name="statistic" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>t-statistic</docstring>
    </outputPortSpec>
    <outputPortSpec arg="pvalue" name="pvalue" port_type="basic:Float" show_port="True" sort_key="1">
      <docstring>two-tailed p-value</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.tvar" module_name="tvar" namespace="'stats|mstats'">
    <docstring>Compute the trimmed variance

This function computes the sample variance of an array of values,
while ignoring values which are outside of given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tvar : float
    Trimmed variance.

Notes
-----
`tvar` computes the unbiased sample variance, i.e. it uses a correction
factor ``n / (n - 1)``.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Array of values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" name="limits">
      <docstring>Values in the input array less than the lower limit or greater than the
upper limit will be ignored. When limits is None, then all values are
used. Either of the limit values in the tuple can also be None
representing a half-open interval.  The default value is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusiveSequence" port_type="basic:List">
      <docstring>A tuple consisting of the (lower flag, upper flag).  These flags
determine whether values exactly equal to the lower or upper limits
are included.  The default value is (True, True).</docstring>
      <defaults>[(True, True)]</defaults>
      <alternateSpec arg="inclusive" name="inclusiveBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <outputPortSpec arg="tvar" name="tvar" port_type="basic:Float" show_port="True" sort_key="0">
      <docstring>Trimmed variance.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.variation" module_name="variation" namespace="'stats|mstats'">
    <docstring>Computes the coefficient of variation, the ratio of the biased standard
deviation to the mean.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    Axis along which to calculate the coefficient of variation. Default
    is 0. If None, compute over the whole array `a`.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New
   York. 2000.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to calculate the coefficient of variation. Default
is 0. If None, compute over the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.winsorize" module_name="winsorize" namespace="'stats|mstats'">
    <docstring>Returns a Winsorized version of the input array.

The (limits[0])th lowest values are set to the (limits[0])th percentile,
and the (limits[1])th highest values are set to the (1 - limits[1])th
percentile.
Masked values are skipped.


Parameters
----------
a : sequence
    Input array.
limits : {None, tuple of float}, optional
    Tuple of the percentages to cut on each side of the array, with respect
    to the number of unmasked data, as floats between 0. and 1.
    Noting n the number of unmasked data before trimming, the
    (n*limits[0])th smallest data and the (n*limits[1])th largest data are
    masked, and the total number of unmasked data after trimming
    is n*(1.-sum(limits)) The value of one limit can be set to None to
    indicate an open interval.
inclusive : {(True, True) tuple}, optional
    Tuple indicating whether the number of data being masked on each side
    should be rounded (True) or truncated (False).
inplace : {False, True}, optional
    Whether to winsorize in place (True) or to use a copy (False)
axis : {None, int}, optional
    Axis along which to trim. If None, the whole array is trimmed, but its
    shape is maintained.

Notes
-----
This function is applied to reduce the effect of possibly spurious outliers
by limiting the extreme values.</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>Input array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="limits" depth="1" name="limits" port_type="basic:Float">
      <docstring>Tuple of the percentages to cut on each side of the array, with respect
to the number of unmasked data, as floats between 0. and 1.
Noting n the number of unmasked data before trimming, the
(n*limits[0])th smallest data and the (n*limits[1])th largest data are
masked, and the total number of unmasked data after trimming
is n*(1.-sum(limits)) The value of one limit can be set to None to
indicate an open interval.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inclusive" name="inclusive" port_type="basic:List">
      <docstring>Tuple indicating whether the number of data being masked on each side
should be rounded (True) or truncated (False).</docstring>
      <defaults>[(True, True)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inplace" name="inplace" port_type="basic:Boolean">
      <docstring>Whether to winsorize in place (True) or to use a copy (False)</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis" port_type="basic:Integer">
      <docstring>Axis along which to trim. If None, the whole array is trimmed, but its
shape is maintained.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.zmap" module_name="zmap" namespace="'stats|mstats'">
    <docstring>Calculates the relative z-scores.

Returns an array of z-scores, i.e., scores that are standardized to zero
mean and unit variance, where mean and variance are calculated from the
comparison array.

Parameters
----------
scores : array_like
    The input for which z-scores are calculated.
compare : array_like
    The input from which the mean and standard deviation of the
    normalization are taken; assumed to have the same dimension as
    `scores`.
axis : int or None, optional
    Axis over which mean and variance of `compare` are calculated.
    Default is 0. If None, compute over the whole array `scores`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.

Returns
-------
zscore : array_like
    Z-scores, in the same shape as `scores`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of `asarray`
for parameters).

Examples
--------
&gt;&gt;&gt; from scipy.stats import zmap
&gt;&gt;&gt; a = [0.5, 2.0, 2.5, 3]
&gt;&gt;&gt; b = [0, 1, 2, 3, 4]
&gt;&gt;&gt; zmap(a, b)
array([-1.06066017,  0.        ,  0.35355339,  0.70710678])</docstring>
    <inputPortSpec arg="scores" name="scores" port_type="basic:List" show_port="True">
      <docstring>The input for which z-scores are calculated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="compare" name="compare" port_type="basic:List" show_port="True">
      <docstring>The input from which the mean and standard deviation of the
normalization are taken; assumed to have the same dimension as
`scores`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis over which mean and variance of `compare` are calculated.
Default is 0. If None, compute over the whole array `scores`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Degrees of freedom correction in the calculation of the
standard deviation. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="zscore" name="zscore" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>Z-scores, in the same shape as `scores`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.stats.mstats.zscore" module_name="zscore" namespace="'stats|mstats'">
    <docstring>Calculates the z score of each value in the sample, relative to the sample
mean and standard deviation.

Parameters
----------
a : array_like
    An array like object containing the sample data.
axis : int or None, optional
    Axis along which to operate. Default is 0. If None, compute over
    the whole array `a`.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.

Returns
-------
zscore : array_like
    The z-scores, standardized by mean and standard deviation of input
    array `a`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of `asarray`
for parameters).

Examples
--------
&gt;&gt;&gt; a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,  0.1954,
...                0.6307, 0.6599,  0.1065,  0.0508])
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.zscore(a)
array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,
        0.6748, -1.1488, -1.3324])

Computing along a specified axis, using n-1 degrees of freedom (``ddof=1``)
to calculate the standard deviation:

&gt;&gt;&gt; b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
...               [ 0.7149,  0.0775,  0.6072,  0.9656],
...               [ 0.6341,  0.1403,  0.9759,  0.4064],
...               [ 0.5918,  0.6948,  0.904 ,  0.3721],
...               [ 0.0921,  0.2481,  0.1188,  0.1366]])
&gt;&gt;&gt; stats.zscore(b, axis=1, ddof=1)
array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],
       [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],
       [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],
       [-0.22095197,  0.24468594,  1.19042819, -1.21416216],
       [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])</docstring>
    <inputPortSpec arg="a" name="a" port_type="basic:List" show_port="True">
      <docstring>An array like object containing the sample data.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" name="axis">
      <docstring>Axis along which to operate. Default is 0. If None, compute over
the whole array `a`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ddof" name="ddof" port_type="basic:Integer">
      <docstring>Degrees of freedom correction in the calculation of the
standard deviation. Default is 0.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="zscore" name="zscore" port_type="basic:List" show_port="True" sort_key="0">
      <docstring>The z-scores, standardized by mean and standard deviation of input
array `a`.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.weave.blitz" module_name="blitz" namespace="'weave'">
    <inputPortSpec arg="expr" name="expr" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="global_dict" name="global_dict" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="check_size" name="check_size" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="local_dict" name="local_dict" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Integer" show_port="True" />
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
  <moduleSpec code_ref="scipy.weave.deprecate" module_name="deprecate" namespace="'weave'">
    <docstring>Issues a DeprecationWarning, adds warning to `old_name`'s
docstring, rebinds ``old_name.__name__`` and returns the new
function object.

This function may also be used as a decorator.

Parameters
----------
func : function
    The function to be deprecated.
old_name : str, optional
    The name of the function to be deprecated. Default is None, in
    which case the name of `func` is used.
new_name : str, optional
    The new name for the function. Default is None, in which case the
    deprecation message is that `old_name` is deprecated. If given, the
    deprecation message is that `old_name` is deprecated and `new_name`
    should be used instead.
message : str, optional
    Additional explanation of the deprecation.  Displayed in the
    docstring after the warning.

Returns
-------
old_func : function
    The deprecated function.

Examples
--------
Note that ``olduint`` returns a value after printing Deprecation
Warning:

&gt;&gt;&gt; olduint = np.deprecate(np.uint)
&gt;&gt;&gt; olduint(6)
/usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:
DeprecationWarning: uint32 is deprecated
  warnings.warn(str1, DeprecationWarning)
6</docstring>
    <inputPortSpec arg="func" name="func" port_type="basic:Variant" show_port="True">
      <docstring>The function to be deprecated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="old_name" name="old_name">
      <docstring>The name of the function to be deprecated. Default is None, in
which case the name of `func` is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="new_name" name="new_name">
      <docstring>The new name for the function. Default is None, in which case the
deprecation message is that `old_name` is deprecated. If given, the
deprecation message is that `old_name` is deprecated and `new_name`
should be used instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="message" name="message">
      <docstring>Additional explanation of the deprecation.  Displayed in the
docstring after the warning.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="old_func" name="old_func" port_type="basic:Variant" show_port="True" sort_key="0">
      <docstring>The deprecated function.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.weave.inline" module_name="inline" namespace="'weave'">
    <docstring>Inline C/C++ code within Python scripts.

``inline()`` compiles and executes C/C++ code on the fly.  Variables
in the local and global Python scope are also available in the
C/C++ code.  Values are passed to the C/C++ code by assignment
much like variables passed are passed into a standard Python
function.  Values are returned from the C/C++ code through a
special argument called return_val.  Also, the contents of
mutable objects can be changed within the C/C++ code and the
changes remain after the C code exits and returns to Python.

inline has quite a few options as listed below.  Also, the keyword
arguments for distutils extension modules are accepted to
specify extra information needed for compiling.

Parameters
----------
code : string
    A string of valid C++ code.  It should not specify a return
    statement.  Instead it should assign results that need to be
    returned to Python in the `return_val`.
arg_names : [str], optional
    A list of Python variable names that should be transferred from
    Python into the C/C++ code.  It defaults to an empty string.
local_dict : dict, optional
    If specified, it is a dictionary of values that should be used as
    the local scope for the C/C++ code.  If local_dict is not
    specified the local dictionary of the calling function is used.
global_dict : dict, optional
    If specified, it is a dictionary of values that should be used as
    the global scope for the C/C++ code.  If `global_dict` is not
    specified, the global dictionary of the calling function is used.
force : {0, 1}, optional
    If 1, the C++ code is compiled every time inline is called.  This
    is really only useful for debugging, and probably only useful if
    your editing `support_code` a lot.
compiler : str, optional
    The name of compiler to use when compiling.  On windows, it
    understands 'msvc' and 'gcc' as well as all the compiler names
    understood by distutils.  On Unix, it'll only understand the
    values understood by distutils. (I should add 'gcc' though to
    this).

    On windows, the compiler defaults to the Microsoft C++ compiler.
    If this isn't available, it looks for mingw32 (the gcc compiler).

    On Unix, it'll probably use the same compiler that was used when
    compiling Python. Cygwin's behavior should be similar.
verbose : {0,1,2}, optional
    Specifies how much information is printed during the compile
    phase of inlining code.  0 is silent (except on windows with msvc
    where it still prints some garbage). 1 informs you when compiling
    starts, finishes, and how long it took.  2 prints out the command
    lines for the compilation process and can be useful if your having
    problems getting code to work.  Its handy for finding the name of
    the .cpp file if you need to examine it.  verbose has no effect if
    the compilation isn't necessary.
support_code : str, optional
    A string of valid C++ code declaring extra code that might be
    needed by your compiled function.  This could be declarations of
    functions, classes, or structures.
headers : [str], optional
    A list of strings specifying header files to use when compiling
    the code.  The list might look like ``["&lt;vector&gt;","'my_header'"]``.
    Note that the header strings need to be in a form than can be
    pasted at the end of a ``#include`` statement in the C++ code.
customize : base_info.custom_info, optional
    An alternative way to specify `support_code`, `headers`, etc. needed
    by the function.  See :mod:`scipy.weave.base_info` for more
    details. (not sure this'll be used much).
type_converters : [type converters], optional
    These guys are what convert Python data types to C/C++ data types.
    If you'd like to use a different set of type conversions than the
    default, specify them here. Look in the type conversions section
    of the main documentation for examples.
auto_downcast : {1,0}, optional
    This only affects functions that have numpy arrays as input
    variables.  Setting this to 1 will cause all floating point values
    to be cast as float instead of double if all the Numeric arrays
    are of type float.  If even one of the arrays has type double or
    double complex, all variables maintain their standard
    types.
newarr_converter : int, optional
    Unused.

Other Parameters
----------------
Relevant :mod:`distutils` keywords.  These are duplicated from Greg Ward's
:class:`distutils.extension.Extension` class for convenience:

sources : [string]
    List of source filenames, relative to the distribution root
    (where the setup script lives), in Unix form (slash-separated)
    for portability.  Source files may be C, C++, SWIG (.i),
    platform-specific resource files, or whatever else is recognized
    by the "build_ext" command as source for a Python extension.

    .. note:: The `module_path` file is always appended to the front of
       this list
include_dirs : [string]
    List of directories to search for C/C++ header files (in Unix
    form for portability).
define_macros : [(name : string, value : string|None)]
    List of macros to define; each macro is defined using a 2-tuple,
    where 'value' is either the string to define it to or None to
    define it without a particular value (equivalent of "#define
    FOO" in source or -DFOO on Unix C compiler command line).
undef_macros : [string]
    List of macros to undefine explicitly.
library_dirs : [string]
    List of directories to search for C/C++ libraries at link time.
libraries : [string]
    List of library names (not filenames or paths) to link against.
runtime_library_dirs : [string]
    List of directories to search for C/C++ libraries at run time
    (for shared extensions, this is when the extension is loaded).
extra_objects : [string]
    List of extra files to link with (e.g. object files not implied
    by 'sources', static libraries that must be explicitly specified,
    binary resource files, etc.)
extra_compile_args : [string]
    Any extra platform- and compiler-specific information to use
    when compiling the source files in 'sources'.  For platforms and
    compilers where "command line" makes sense, this is typically a
    list of command-line arguments, but for other platforms it could
    be anything.
extra_link_args : [string]
    Any extra platform- and compiler-specific information to use
    when linking object files together to create the extension (or
    to create a new static Python interpreter).  Similar
    interpretation as for 'extra_compile_args'.
export_symbols : [string]
    List of symbols to be exported from a shared extension.  Not
    used on all platforms, and not generally necessary for Python
    extensions, which typically export exactly one symbol: "init" +
    extension_name.
swig_opts : [string]
    Any extra options to pass to SWIG if a source file has the .i
    extension.
depends : [string]
    List of files that the extension depends on.
language : string
    Extension language (i.e. "c", "c++", "objc").  Will be detected
    from the source extensions if not provided.

See Also
--------
distutils.extension.Extension : Describes additional parameters.</docstring>
    <inputPortSpec arg="code" name="code" show_port="True">
      <docstring>A string of valid C++ code.  It should not specify a return
statement.  Instead it should assign results that need to be
returned to Python in the `return_val`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arg_names" name="arg_namesSequence" port_type="basic:List">
      <docstring>A list of Python variable names that should be transferred from
Python into the C/C++ code.  It defaults to an empty string.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="arg_names" name="arg_namesScalar" />
    </inputPortSpec>
    <inputPortSpec arg="local_dict" name="local_dict" port_type="basic:Dictionary">
      <docstring>If specified, it is a dictionary of values that should be used as
the local scope for the C/C++ code.  If local_dict is not
specified the local dictionary of the calling function is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="global_dict" name="global_dict" port_type="basic:Dictionary">
      <docstring>If specified, it is a dictionary of values that should be used as
the global scope for the C/C++ code.  If `global_dict` is not
specified, the global dictionary of the calling function is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="force" name="force" port_type="basic:Integer">
      <docstring>If 1, the C++ code is compiled every time inline is called.  This
is really only useful for debugging, and probably only useful if
your editing `support_code` a lot.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1]]</values>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="compiler" name="compiler">
      <docstring>The name of compiler to use when compiling.  On windows, it
understands 'msvc' and 'gcc' as well as all the compiler names
understood by distutils.  On Unix, it'll only understand the
values understood by distutils. (I should add 'gcc' though to
this).

On windows, the compiler defaults to the Microsoft C++ compiler.
If this isn't available, it looks for mingw32 (the gcc compiler).

On Unix, it'll probably use the same compiler that was used when
compiling Python. Cygwin's behavior should be similar.</docstring>
      <defaults>['']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="verbose" name="verbose" port_type="basic:Integer">
      <docstring>Specifies how much information is printed during the compile
phase of inlining code.  0 is silent (except on windows with msvc
where it still prints some garbage). 1 informs you when compiling
starts, finishes, and how long it took.  2 prints out the command
lines for the compilation process and can be useful if your having
problems getting code to work.  Its handy for finding the name of
the .cpp file if you need to examine it.  verbose has no effect if
the compilation isn't necessary.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0, 1, 2]]</values>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="support_code" name="support_code">
      <docstring>A string of valid C++ code declaring extra code that might be
needed by your compiled function.  This could be declarations of
functions, classes, or structures.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="headers" name="headersSequence" port_type="basic:List">
      <docstring>A list of strings specifying header files to use when compiling
the code.  The list might look like ``["&lt;vector&gt;","'my_header'"]``.
Note that the header strings need to be in a form than can be
pasted at the end of a ``#include`` statement in the C++ code.</docstring>
      <defaults>[[]]</defaults>
      <alternateSpec arg="headers" name="headersScalar" />
    </inputPortSpec>
    <inputPortSpec arg="customize" name="customize" port_type="basic:Variant">
      <docstring>An alternative way to specify `support_code`, `headers`, etc. needed
by the function.  See :mod:`scipy.weave.base_info` for more
details. (not sure this'll be used much).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="type_converters" name="type_converters" port_type="basic:Variant">
      <docstring>These guys are what convert Python data types to C/C++ data types.
If you'd like to use a different set of type conversions than the
default, specify them here. Look in the type conversions section
of the main documentation for examples.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="auto_downcast" name="auto_downcast" port_type="basic:Integer">
      <docstring>This only affects functions that have numpy arrays as input
variables.  Setting this to 1 will cause all floating point values
to be cast as float instead of double if all the Numeric arrays
are of type float.  If even one of the arrays has type double or
double complex, all variables maintain their standard
types.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, 0]]</values>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="newarr_converter" name="newarr_converter" port_type="basic:Integer">
      <docstring>Unused.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="sources" name="sources" show_port="True">
      <docstring>List of source filenames, relative to the distribution root
(where the setup script lives), in Unix form (slash-separated)
for portability.  Source files may be C, C++, SWIG (.i),
platform-specific resource files, or whatever else is recognized
by the "build_ext" command as source for a Python extension.

.. note:: The `module_path` file is always appended to the front of
   this list</docstring>
    </inputPortSpec>
    <inputPortSpec arg="include_dirs" name="include_dirs" show_port="True">
      <docstring>List of directories to search for C/C++ header files (in Unix
form for portability).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="define_macros" name="define_macros" port_type="basic:Variant" show_port="True">
      <docstring>List of macros to define; each macro is defined using a 2-tuple,
where 'value' is either the string to define it to or None to
define it without a particular value (equivalent of "#define
FOO" in source or -DFOO on Unix C compiler command line).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="undef_macros" name="undef_macros" show_port="True">
      <docstring>List of macros to undefine explicitly.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="library_dirs" name="library_dirs" show_port="True">
      <docstring>List of directories to search for C/C++ libraries at link time.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="libraries" name="libraries" show_port="True">
      <docstring>List of library names (not filenames or paths) to link against.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="runtime_library_dirs" name="runtime_library_dirs" show_port="True">
      <docstring>List of directories to search for C/C++ libraries at run time
(for shared extensions, this is when the extension is loaded).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extra_objects" name="extra_objects" show_port="True">
      <docstring>List of extra files to link with (e.g. object files not implied
by 'sources', static libraries that must be explicitly specified,
binary resource files, etc.)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extra_compile_args" name="extra_compile_args" show_port="True">
      <docstring>Any extra platform- and compiler-specific information to use
when compiling the source files in 'sources'.  For platforms and
compilers where "command line" makes sense, this is typically a
list of command-line arguments, but for other platforms it could
be anything.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extra_link_args" name="extra_link_args" show_port="True">
      <docstring>Any extra platform- and compiler-specific information to use
when linking object files together to create the extension (or
to create a new static Python interpreter).  Similar
interpretation as for 'extra_compile_args'.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="export_symbols" name="export_symbols" show_port="True">
      <docstring>List of symbols to be exported from a shared extension.  Not
used on all platforms, and not generally necessary for Python
extensions, which typically export exactly one symbol: "init" +
extension_name.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="swig_opts" name="swig_opts" show_port="True">
      <docstring>Any extra options to pass to SWIG if a source file has the .i
extension.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="depends" name="depends" show_port="True">
      <docstring>List of files that the extension depends on.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="language" name="language" show_port="True">
      <docstring>Extension language (i.e. "c", "c++", "objc").  Will be detected
from the source extensions if not provided.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="value" name="value" port_type="basic:Variant" show_port="True" />
  </moduleSpec>
</specs>
