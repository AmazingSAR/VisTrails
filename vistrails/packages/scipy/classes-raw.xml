<specs>
  <moduleSpec code_ref="scipy.interpolate.Akima1DInterpolator" module_name="Akima1DInterpolator" namespace="'interpolate'">
    <docstring>Akima interpolator

Fit piecewise cubic polynomials, given vectors x and y. The interpolation
method by Akima uses a continuously differentiable sub-spline built from
piecewise cubic polynomials. The resultant curve passes through the given
data points and will appear smooth and natural.

Parameters
----------
x : ndarray, shape (m, )
    1-D array of monotonically increasing real values.
y : ndarray, shape (m, ...)
    N-D array of real values. The length of `y` along the first axis must
    be equal to the length of `x`.
axis : int, optional
    Specifies the axis of `y` along which to interpolate. Interpolation
    defaults to the first axis of `y`.

Methods
-------
__call__
derivative
antiderivative
roots

See Also
--------
PchipInterpolator

Notes
-----
.. versionadded:: 0.14

Use only for precise data, as the fitted curve passes through the given
points exactly. This routine is useful for plotting a pleasingly smooth
curve through a few given points for purposes of plotting.

References
----------
[1] A new method of interpolation and smooth curve fitting based
    on local procedures. Hiroshi Akima, J. ACM, October 1970, 17(4),
    589-602.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D array of monotonically increasing real values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>N-D array of real values. The length of `y` along the first axis must
be equal to the length of `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Specifies the axis of `y` along which to interpolate. Interpolation
defaults to the first axis of `y`.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.BPoly" module_name="BPoly" namespace="'interpolate'">
    <docstring>Piecewise polynomial in terms of coefficients and breakpoints

The polynomial in the ``i``-th interval ``x[i] &lt;= xp &lt; x[i+1]``
is written in the Bernstein polynomial basis::

    S = sum(c[a, i] * b(a, k; x) for a in range(k+1))

where ``k`` is the degree of the polynomial, and::

    b(a, k; x) = comb(k, a) * t**k * (1 - t)**(k - a)

with ``t = (x - x[i]) / (x[i+1] - x[i])``.

Parameters
----------
c : ndarray, shape (k, m, ...)
    Polynomial coefficients, order `k` and `m` intervals
x : ndarray, shape (m+1,)
    Polynomial breakpoints. These must be sorted in
    increasing order.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.
axis : int, optional
    Interpolation axis. Default is zero.

Attributes
----------
x : ndarray
    Breakpoints.
c : ndarray
    Coefficients of the polynomials. They are reshaped
    to a 3-dimensional array with the last dimension representing
    the trailing dimensions of the original coefficient array.
axis : int
    Interpolation axis.

Methods
-------
__call__
extend
derivative
antiderivative
integrate
construct_fast
from_power_basis
from_derivatives

See also
--------
PPoly : piecewise polynomials in the power basis

Notes
-----
Properties of Bernstein polynomials are well documented in the literature.
Here's a non-exhaustive list:

.. [1] http://en.wikipedia.org/wiki/Bernstein_polynomial

.. [2] Kenneth I. Joy, Bernstein polynomials,
  http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf

.. [3] E. H. Doha, A. H. Bhrawy, and M. A. Saker, Boundary Value Problems,
     vol 2011, article ID 829546, doi:10.1155/2011/829543

Examples
--------

&gt;&gt;&gt; x = [0, 1]
&gt;&gt;&gt; c = [[1], [2], [3]]
&gt;&gt;&gt; bp = BPoly(c, x)

This creates a 2nd order polynomial

.. math::

    B(x) = 1 \times b_{0, 2}(x) + 2 \times b_{1, 2}(x) + 3 \times b_{2, 2}(x) \\
         = 1 \times (1-x)^2 + 2 \times 2 x (1 - x) + 3 \times x^2</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" method_type="argument" name="c" port_type="basic:List" show_port="True">
      <docstring>Polynomial coefficients, order `k` and `m` intervals</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>Polynomial breakpoints. These must be sorted in
increasing order.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" method_type="argument" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs. Default: True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Interpolation axis. Default is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.BPoly" module_name="BPolyInspector" namespace="'interpolate'">
    <docstring>Piecewise polynomial in terms of coefficients and breakpoints

The polynomial in the ``i``-th interval ``x[i] &lt;= xp &lt; x[i+1]``
is written in the Bernstein polynomial basis::

    S = sum(c[a, i] * b(a, k; x) for a in range(k+1))

where ``k`` is the degree of the polynomial, and::

    b(a, k; x) = comb(k, a) * t**k * (1 - t)**(k - a)

with ``t = (x - x[i]) / (x[i+1] - x[i])``.

Parameters
----------
c : ndarray, shape (k, m, ...)
    Polynomial coefficients, order `k` and `m` intervals
x : ndarray, shape (m+1,)
    Polynomial breakpoints. These must be sorted in
    increasing order.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.
axis : int, optional
    Interpolation axis. Default is zero.

Attributes
----------
x : ndarray
    Breakpoints.
c : ndarray
    Coefficients of the polynomials. They are reshaped
    to a 3-dimensional array with the last dimension representing
    the trailing dimensions of the original coefficient array.
axis : int
    Interpolation axis.

Methods
-------
__call__
extend
derivative
antiderivative
integrate
construct_fast
from_power_basis
from_derivatives

See also
--------
PPoly : piecewise polynomials in the power basis

Notes
-----
Properties of Bernstein polynomials are well documented in the literature.
Here's a non-exhaustive list:

.. [1] http://en.wikipedia.org/wiki/Bernstein_polynomial

.. [2] Kenneth I. Joy, Bernstein polynomials,
  http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf

.. [3] E. H. Doha, A. H. Bhrawy, and M. A. Saker, Boundary Value Problems,
     vol 2011, article ID 829546, doi:10.1155/2011/829543

Examples
--------

&gt;&gt;&gt; x = [0, 1]
&gt;&gt;&gt; c = [[1], [2], [3]]
&gt;&gt;&gt; bp = BPoly(c, x)

This creates a 2nd order polynomial

.. math::

    B(x) = 1 \times b_{0, 2}(x) + 2 \times b_{1, 2}(x) + 3 \times b_{2, 2}(x) \\
         = 1 \times (1-x)^2 + 2 \times 2 x (1 - x) + 3 \times x^2</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="attribute" name="x" port_type="basic:List" sort_key="1000">
      <docstring>Breakpoints.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" method_type="attribute" name="c" port_type="basic:List" sort_key="1001">
      <docstring>Coefficients of the polynomials. They are reshaped
to a 3-dimensional array with the last dimension representing
the trailing dimensions of the original coefficient array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="attribute" name="axis" port_type="basic:Integer" sort_key="1002">
      <docstring>Interpolation axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="x" method_type="attribute" name="x" port_type="basic:List" sort_key="1000">
      <docstring>Breakpoints.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="c" method_type="attribute" name="c" port_type="basic:List" sort_key="1001">
      <docstring>Coefficients of the polynomials. They are reshaped
to a 3-dimensional array with the last dimension representing
the trailing dimensions of the original coefficient array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="axis" method_type="attribute" name="axis" port_type="basic:Integer" sort_key="1002">
      <docstring>Interpolation axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.BarycentricInterpolator" module_name="BarycentricInterpolator" namespace="'interpolate'">
    <docstring>The interpolating polynomial for a set of points

Constructs a polynomial that passes through a given set of points.
Allows evaluation of the polynomial, efficient changing of the y
values to be interpolated, and updating by adding more x values.
For reasons of numerical stability, this function does not compute
the coefficients of the polynomial.

The values yi need to be provided before the function is
evaluated, but none of the preprocessing depends on them, so rapid
updates are possible.

Parameters
----------
xi : array_like
    1-d array of x coordinates of the points the polynomial
    should pass through
yi : array_like, optional
    The y coordinates of the points the polynomial should pass through.
    If None, the y values will be supplied later via the `set_y` method.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

Notes
-----
This class uses a "barycentric interpolation" method that treats
the problem as a special case of rational function interpolation.
This algorithm is quite stable, numerically, but even in a world of
exact computation, unless the x coordinates are chosen very
carefully - Chebyshev zeros (e.g. cos(i*pi/n)) are a good choice -
polynomial interpolation itself is a very ill-conditioned process
due to the Runge phenomenon.

Based on Berrut and Trefethen 2004, "Barycentric Lagrange Interpolation".</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xi" method_type="argument" name="xi" port_type="basic:List" show_port="True">
      <docstring>1-d array of x coordinates of the points the polynomial
should pass through</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" method_type="argument" name="yi" port_type="basic:List">
      <docstring>The y coordinates of the points the polynomial should pass through.
If None, the y values will be supplied later via the `set_y` method.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Axis in the yi array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.BivariateSpline" module_name="BivariateSpline" namespace="'interpolate'">
    <docstring>Base class for bivariate splines.

This describes a spline ``s(x, y)`` of degrees ``kx`` and ``ky`` on
the rectangle ``[xb, xe] * [yb, ye]`` calculated from a given set
of data points ``(x, y, z)``.

This class is meant to be subclassed, not instantiated directly.
To construct these splines, call either `SmoothBivariateSpline` or
`LSQBivariateSpline`.

See Also
--------
UnivariateSpline : a similar class for univariate spline interpolation
SmoothBivariateSpline :
    to create a BivariateSpline through the given points
LSQBivariateSpline :
    to create a BivariateSpline using weighted least-squares fitting
SphereBivariateSpline :
    bivariate spline interpolation in spherical cooridinates
bisplrep : older wrapping of FITPACK
bisplev : older wrapping of FITPACK</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.CloughTocher2DInterpolator" module_name="CloughTocher2DInterpolator" namespace="'interpolate'">
    <docstring>CloughTocher2DInterpolator(points, values, tol=1e-6)

Piecewise cubic, C1 smooth, curvature-minimizing interpolant in 2D.

.. versionadded:: 0.9

Methods
-------
__call__

Parameters
----------
points : ndarray of floats, shape (npoints, ndims); or Delaunay
    Data point coordinates, or a precomputed Delaunay triangulation.
values : ndarray of float or complex, shape (npoints, ...)
    Data values.
fill_value : float, optional
    Value used to fill in for requested points outside of the
    convex hull of the input points.  If not provided, then
    the default is ``nan``.
tol : float, optional
    Absolute/relative tolerance for gradient estimation.
maxiter : int, optional
    Maximum number of iterations in gradient estimation.
rescale : bool, optional
    Rescale points to unit cube before performing interpolation.
    This is useful if some of the input dimensions have
    incommensurable units and differ by many orders of magnitude.

Notes
-----
The interpolant is constructed by triangulating the input data
with Qhull [1]_, and constructing a piecewise cubic
interpolating Bezier polynomial on each triangle, using a
Clough-Tocher scheme [CT]_.  The interpolant is guaranteed to be
continuously differentiable.

The gradients of the interpolant are chosen so that the curvature
of the interpolating surface is approximatively minimized. The
gradients necessary for this are estimated using the global
algorithm described in [Nielson83,Renka84]_.

References
----------
.. [1] http://www.qhull.org/

.. [CT] See, for example,
   P. Alfeld,
   ''A trivariate Clough-Tocher scheme for tetrahedral data''.
   Computer Aided Geometric Design, 1, 169 (1984);
   G. Farin,
   ''Triangular Bernstein-Bezier patches''.
   Computer Aided Geometric Design, 3, 83 (1986).

.. [Nielson83] G. Nielson,
   ''A method for interpolating scattered data based upon a minimum norm
   network''.
   Math. Comp., 40, 253 (1983).

.. [Renka84] R. J. Renka and A. K. Cline.
   ''A Triangle-based C1 interpolation method.'',
   Rocky Mountain J. Math., 14, 223 (1984).</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" method_type="argument" name="pointsScalar" show_port="True">
      <docstring>Data point coordinates, or a precomputed Delaunay triangulation.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['Delaunay']]</values>
      <alternateSpec arg="points" depth="1" method_type="argument" name="pointsSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="values" method_type="argument" name="valuesScalar" port_type="basic:Integer" show_port="True">
      <docstring>Data values.</docstring>
      <alternateSpec arg="values" depth="1" method_type="argument" name="valuesSequence" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Float">
      <docstring>Value used to fill in for requested points outside of the
convex hull of the input points.  If not provided, then
the default is ``nan``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tol" method_type="argument" name="tol" port_type="basic:Float">
      <docstring>Absolute/relative tolerance for gradient estimation.</docstring>
      <defaults>[1e-06]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxiter" method_type="argument" name="maxiter" port_type="basic:Integer">
      <docstring>Maximum number of iterations in gradient estimation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rescale" method_type="argument" name="rescale" port_type="basic:Boolean">
      <docstring>Rescale points to unit cube before performing interpolation.
This is useful if some of the input dimensions have
incommensurable units and differ by many orders of magnitude.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.InterpolatedUnivariateSpline" module_name="InterpolatedUnivariateSpline" namespace="'interpolate'">
    <docstring>One-dimensional interpolating spline for a given set of data points.

Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data. Spline
function passes through all provided points. Equivalent to
`UnivariateSpline` with  s=0.

Parameters
----------
x : (N,) array_like
    Input dimension of data points -- must be increasing
y : (N,) array_like
    input dimension of data points
w : (N,) array_like, optional
    Weights for spline fitting.  Must be positive.  If None (default),
    weights are all equal.
bbox : (2,) array_like, optional
    2-sequence specifying the boundary of the approximation interval. If
    None (default), ``bbox=[x[0], x[-1]]``.
k : int, optional
    Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5.
ext : int or str, optional
    Controls the extrapolation mode for elements
    not in the interval defined by the knot sequence.

    * if ext=0 or 'extrapolate', return the extrapolated value.
    * if ext=1 or 'zeros', return 0
    * if ext=2 or 'raise', raise a ValueError
    * if ext=3 of 'const', return the boundary value.

    The default value is 0.

check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination or non-sensical results) if the inputs
    do contain infinities or NaNs.
    Default is False.

See Also
--------
UnivariateSpline : Superclass -- allows knots to be selected by a
    smoothing condition
LSQUnivariateSpline : spline for which knots are user-selected
splrep : An older, non object-oriented wrapping of FITPACK
splev, sproot, splint, spalde
BivariateSpline : A similar class for two-dimensional spline interpolation

Notes
-----
The number of data points must be larger than the spline degree `k`.

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy.interpolate import InterpolatedUnivariateSpline
&gt;&gt;&gt; x = np.linspace(-3, 3, 50)
&gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * np.random.randn(50)
&gt;&gt;&gt; spl = InterpolatedUnivariateSpline(x, y)
&gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5)
&gt;&gt;&gt; xs = np.linspace(-3, 3, 1000)
&gt;&gt;&gt; plt.plot(xs, spl(xs), 'g', lw=3, alpha=0.7)
&gt;&gt;&gt; plt.show()

Notice that the ``spl(x)`` interpolates `y`:

&gt;&gt;&gt; spl.get_residual()
0.0</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>Input dimension of data points -- must be increasing</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>input dimension of data points</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>Weights for spline fitting.  Must be positive.  If None (default),
weights are all equal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox" method_type="argument" name="bbox" port_type="basic:List">
      <docstring>2-sequence specifying the boundary of the approximation interval. If
None (default), ``bbox=[x[0], x[-1]]``.</docstring>
      <defaults>[[None, None]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" method_type="argument" name="k" port_type="basic:Integer">
      <docstring>Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ext" method_type="argument" name="ext">
      <docstring>Controls the extrapolation mode for elements
not in the interval defined by the knot sequence.

* if ext=0 or 'extrapolate', return the extrapolated value.
* if ext=1 or 'zeros', return 0
* if ext=2 or 'raise', raise a ValueError
* if ext=3 of 'const', return the boundary value.

The default value is 0.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" method_type="argument" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input arrays contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination or non-sensical results) if the inputs
do contain infinities or NaNs.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.KroghInterpolator" module_name="KroghInterpolator" namespace="'interpolate'">
    <docstring>Interpolating polynomial for a set of points.

The polynomial passes through all the pairs (xi,yi). One may
additionally specify a number of derivatives at each point xi;
this is done by repeating the value xi and specifying the
derivatives as successive yi values.

Allows evaluation of the polynomial and all its derivatives.
For reasons of numerical stability, this function does not compute
the coefficients of the polynomial, although they can be obtained
by evaluating all the derivatives.

Parameters
----------
xi : array_like, length N
    Known x-coordinates. Must be sorted in increasing order.
yi : array_like
    Known y-coordinates. When an xi occurs two or more times in
    a row, the corresponding yi's represent derivative values.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

Notes
-----
Be aware that the algorithms implemented here are not necessarily
the most numerically stable known. Moreover, even in a world of
exact computation, unless the x coordinates are chosen very
carefully - Chebyshev zeros (e.g. cos(i*pi/n)) are a good choice -
polynomial interpolation itself is a very ill-conditioned process
due to the Runge phenomenon. In general, even with well-chosen
x values, degrees higher than about thirty cause problems with
numerical instability in this code.

Based on [1]_.

References
----------
.. [1] Krogh, "Efficient Algorithms for Polynomial Interpolation
    and Numerical Differentiation", 1970.

Examples
--------
To produce a polynomial that is zero at 0 and 1 and has
derivative 2 at 0, call

&gt;&gt;&gt; KroghInterpolator([0,0,1],[0,2,0])

This constructs the quadratic 2*X**2-2*X. The derivative condition
is indicated by the repeated zero in the xi array; the corresponding
yi values are 0, the function value, and 2, the derivative value.

For another example, given xi, yi, and a derivative ypi for each
point, appropriate arrays can be constructed as:

&gt;&gt;&gt; xi_k, yi_k = np.repeat(xi, 2), np.ravel(np.dstack((yi,ypi)))
&gt;&gt;&gt; KroghInterpolator(xi_k, yi_k)

To produce a vector-valued polynomial, supply a higher-dimensional
array for yi:

&gt;&gt;&gt; KroghInterpolator([0,1],[[2,3],[4,5]])

This constructs a linear polynomial giving (2,3) at 0 and (4,5) at 1.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xi" method_type="argument" name="xi" port_type="basic:List" show_port="True">
      <docstring>Known x-coordinates. Must be sorted in increasing order.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" method_type="argument" name="yi" port_type="basic:List" show_port="True">
      <docstring>Known y-coordinates. When an xi occurs two or more times in
a row, the corresponding yi's represent derivative values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Axis in the yi array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.LSQBivariateSpline" module_name="LSQBivariateSpline" namespace="'interpolate'">
    <docstring>Weighted least-squares bivariate spline approximation.

Parameters
----------
x, y, z : array_like
    1-D sequences of data points (order is not important).
tx, ty : array_like
    Strictly ordered 1-D sequences of knots coordinates.
w : array_like, optional
    Positive 1-D array of weights, of the same length as `x`, `y` and `z`.
bbox : (4,) array_like, optional
    Sequence of length 4 specifying the boundary of the rectangular
    approximation domain.  By default,
    ``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.
kx, ky : ints, optional
    Degrees of the bivariate spline. Default is 3.
eps : float, optional
    A threshold for determining the effective rank of an over-determined
    linear system of equations. `eps` should have a value between 0 and 1,
    the default is 1e-16.

See Also
--------
bisplrep : an older wrapping of FITPACK
bisplev : an older wrapping of FITPACK
UnivariateSpline : a similar class for univariate spline interpolation
SmoothBivariateSpline : create a smoothing BivariateSpline

Notes
-----
The length of `x`, `y` and `z` should be at least ``(kx+1) * (ky+1)``.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" method_type="argument" name="z" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tx" method_type="argument" name="tx" port_type="basic:List" show_port="True">
      <docstring>Strictly ordered 1-D sequences of knots coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ty" method_type="argument" name="ty" port_type="basic:List" show_port="True">
      <docstring>Strictly ordered 1-D sequences of knots coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>Positive 1-D array of weights, of the same length as `x`, `y` and `z`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox" method_type="argument" name="bbox" port_type="basic:List">
      <docstring>Sequence of length 4 specifying the boundary of the rectangular
approximation domain.  By default,
``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.</docstring>
      <defaults>[[None, None, None, None]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kx" method_type="argument" name="kx" port_type="basic:Integer">
      <docstring>Degrees of the bivariate spline. Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ky" method_type="argument" name="ky" port_type="basic:Integer">
      <docstring>Degrees of the bivariate spline. Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="eps" method_type="argument" name="eps" port_type="basic:Float">
      <docstring>A threshold for determining the effective rank of an over-determined
linear system of equations. `eps` should have a value between 0 and 1,
the default is 1e-16.</docstring>
      <defaults>[1e-16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.LSQSphereBivariateSpline" module_name="LSQSphereBivariateSpline" namespace="'interpolate'">
    <docstring>Weighted least-squares bivariate spline approximation in spherical
coordinates.

.. versionadded:: 0.11.0

Parameters
----------
theta, phi, r : array_like
    1-D sequences of data points (order is not important). Coordinates
    must be given in radians. Theta must lie within the interval (0, pi),
    and phi must lie within the interval (0, 2pi).
tt, tp : array_like
    Strictly ordered 1-D sequences of knots coordinates.
    Coordinates must satisfy ``0 &lt; tt[i] &lt; pi``, ``0 &lt; tp[i] &lt; 2*pi``.
w : array_like, optional
    Positive 1-D sequence of weights, of the same length as `theta`, `phi`
    and `r`.
eps : float, optional
    A threshold for determining the effective rank of an over-determined
    linear system of equations. `eps` should have a value between 0 and 1,
    the default is 1e-16.

Notes
-----
For more information, see the FITPACK_ site about this function.

.. _FITPACK: http://www.netlib.org/dierckx/sphere.f

Examples
--------
Suppose we have global data on a coarse grid (the input data does not
have to be on a grid):

&gt;&gt;&gt; theta = np.linspace(0., np.pi, 7)
&gt;&gt;&gt; phi = np.linspace(0., 2*np.pi, 9)
&gt;&gt;&gt; data = np.empty((theta.shape[0], phi.shape[0]))
&gt;&gt;&gt; data[:,0], data[0,:], data[-1,:] = 0., 0., 0.
&gt;&gt;&gt; data[1:-1,1], data[1:-1,-1] = 1., 1.
&gt;&gt;&gt; data[1,1:-1], data[-2,1:-1] = 1., 1.
&gt;&gt;&gt; data[2:-2,2], data[2:-2,-2] = 2., 2.
&gt;&gt;&gt; data[2,2:-2], data[-3,2:-2] = 2., 2.
&gt;&gt;&gt; data[3,3:-2] = 3.
&gt;&gt;&gt; data = np.roll(data, 4, 1)

We need to set up the interpolator object. Here, we must also specify the
coordinates of the knots to use.

&gt;&gt;&gt; lats, lons = np.meshgrid(theta, phi)
&gt;&gt;&gt; knotst, knotsp = theta.copy(), phi.copy()
&gt;&gt;&gt; knotst[0] += .0001
&gt;&gt;&gt; knotst[-1] -= .0001
&gt;&gt;&gt; knotsp[0] += .0001
&gt;&gt;&gt; knotsp[-1] -= .0001
&gt;&gt;&gt; from scipy.interpolate import LSQSphereBivariateSpline
&gt;&gt;&gt; lut = LSQSphereBivariateSpline(lats.ravel(), lons.ravel(),
...                                data.T.ravel(), knotst, knotsp)

As a first test, we'll see what the algorithm returns when run on the
input coordinates

&gt;&gt;&gt; data_orig = lut(theta, phi)

Finally we interpolate the data to a finer grid

&gt;&gt;&gt; fine_lats = np.linspace(0., np.pi, 70)
&gt;&gt;&gt; fine_lons = np.linspace(0., 2*np.pi, 90)

&gt;&gt;&gt; data_lsq = lut(fine_lats, fine_lons)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(131)
&gt;&gt;&gt; ax1.imshow(data, interpolation='nearest')
&gt;&gt;&gt; ax2 = fig.add_subplot(132)
&gt;&gt;&gt; ax2.imshow(data_orig, interpolation='nearest')
&gt;&gt;&gt; ax3 = fig.add_subplot(133)
&gt;&gt;&gt; ax3.imshow(data_lsq, interpolation='nearest')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="theta" method_type="argument" name="theta" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important). Coordinates
must be given in radians. Theta must lie within the interval (0, pi),
and phi must lie within the interval (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="phi" method_type="argument" name="phi" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important). Coordinates
must be given in radians. Theta must lie within the interval (0, pi),
and phi must lie within the interval (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" method_type="argument" name="r" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important). Coordinates
must be given in radians. Theta must lie within the interval (0, pi),
and phi must lie within the interval (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tt" method_type="argument" name="tt" port_type="basic:List" show_port="True">
      <docstring>Strictly ordered 1-D sequences of knots coordinates.
Coordinates must satisfy ``0 &lt; tt[i] &lt; pi``, ``0 &lt; tp[i] &lt; 2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="tp" method_type="argument" name="tp" port_type="basic:List" show_port="True">
      <docstring>Strictly ordered 1-D sequences of knots coordinates.
Coordinates must satisfy ``0 &lt; tt[i] &lt; pi``, ``0 &lt; tp[i] &lt; 2*pi``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>Positive 1-D sequence of weights, of the same length as `theta`, `phi`
and `r`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="eps" method_type="argument" name="eps" port_type="basic:Float">
      <docstring>A threshold for determining the effective rank of an over-determined
linear system of equations. `eps` should have a value between 0 and 1,
the default is 1e-16.</docstring>
      <defaults>[1e-16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.LSQUnivariateSpline" module_name="LSQUnivariateSpline" namespace="'interpolate'">
    <docstring>One-dimensional spline with explicit internal knots.

Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.  `t`
specifies the internal knots of the spline

Parameters
----------
x : (N,) array_like
    Input dimension of data points -- must be increasing
y : (N,) array_like
    Input dimension of data points
t : (M,) array_like
    interior knots of the spline.  Must be in ascending order and::

        bbox[0] &lt; t[0] &lt; ... &lt; t[-1] &lt; bbox[-1]

w : (N,) array_like, optional
    weights for spline fitting.  Must be positive.  If None (default),
    weights are all equal.
bbox : (2,) array_like, optional
    2-sequence specifying the boundary of the approximation interval. If
    None (default), ``bbox = [x[0], x[-1]]``.
k : int, optional
    Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5.
    Default is k=3, a cubic spline.
ext : int or str, optional
    Controls the extrapolation mode for elements
    not in the interval defined by the knot sequence.

    * if ext=0 or 'extrapolate', return the extrapolated value.
    * if ext=1 or 'zeros', return 0
    * if ext=2 or 'raise', raise a ValueError
    * if ext=3 of 'const', return the boundary value.

    The default value is 0.

check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination or non-sensical results) if the inputs
    do contain infinities or NaNs.
    Default is False.

Raises
------
ValueError
    If the interior knots do not satisfy the Schoenberg-Whitney conditions

See Also
--------
UnivariateSpline : Superclass -- knots are specified by setting a
    smoothing condition
InterpolatedUnivariateSpline : spline passing through all points
splrep : An older, non object-oriented wrapping of FITPACK
splev, sproot, splint, spalde
BivariateSpline : A similar class for two-dimensional spline interpolation

Notes
-----
The number of data points must be larger than the spline degree `k`.

Knots `t` must satisfy the Schoenberg-Whitney conditions,
i.e., there must be a subset of data points ``x[j]`` such that
``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``.

Examples
--------
&gt;&gt;&gt; from scipy.interpolate import LSQUnivariateSpline
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(-3, 3, 50)
&gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * np.random.randn(50)

Fit a smoothing spline with a pre-defined internal knots:

&gt;&gt;&gt; t = [-1, 0, 1]
&gt;&gt;&gt; spl = LSQUnivariateSpline(x, y, t)

&gt;&gt;&gt; xs = np.linspace(-3, 3, 1000)
&gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5)
&gt;&gt;&gt; plt.plot(xs, spl(xs), 'g-', lw=3)
&gt;&gt;&gt; plt.show()

Check the knot vector:

&gt;&gt;&gt; spl.get_knots()
array([-3., -1., 0., 1., 3.])</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>Input dimension of data points -- must be increasing</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>Input dimension of data points</docstring>
    </inputPortSpec>
    <inputPortSpec arg="t" method_type="argument" name="t" port_type="basic:List" show_port="True">
      <docstring>interior knots of the spline.  Must be in ascending order and::

    bbox[0] &lt; t[0] &lt; ... &lt; t[-1] &lt; bbox[-1]
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>weights for spline fitting.  Must be positive.  If None (default),
weights are all equal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox" method_type="argument" name="bbox" port_type="basic:List">
      <docstring>2-sequence specifying the boundary of the approximation interval. If
None (default), ``bbox = [x[0], x[-1]]``.</docstring>
      <defaults>[[None, None]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" method_type="argument" name="k" port_type="basic:Integer">
      <docstring>Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5.
Default is k=3, a cubic spline.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ext" method_type="argument" name="ext">
      <docstring>Controls the extrapolation mode for elements
not in the interval defined by the knot sequence.

* if ext=0 or 'extrapolate', return the extrapolated value.
* if ext=1 or 'zeros', return 0
* if ext=2 or 'raise', raise a ValueError
* if ext=3 of 'const', return the boundary value.

The default value is 0.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" method_type="argument" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input arrays contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination or non-sensical results) if the inputs
do contain infinities or NaNs.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.LinearNDInterpolator" module_name="LinearNDInterpolator" namespace="'interpolate'">
    <docstring>LinearNDInterpolator(points, values, fill_value=np.nan, rescale=False)

Piecewise linear interpolant in N dimensions.

.. versionadded:: 0.9

Methods
-------
__call__

Parameters
----------
points : ndarray of floats, shape (npoints, ndims); or Delaunay
    Data point coordinates, or a precomputed Delaunay triangulation.
values : ndarray of float or complex, shape (npoints, ...)
    Data values.
fill_value : float, optional
    Value used to fill in for requested points outside of the
    convex hull of the input points.  If not provided, then
    the default is ``nan``.
rescale : bool, optional
    Rescale points to unit cube before performing interpolation.
    This is useful if some of the input dimensions have
    incommensurable units and differ by many orders of magnitude.

Notes
-----
The interpolant is constructed by triangulating the input data
with Qhull [1]_, and on each triangle performing linear
barycentric interpolation.

References
----------
.. [1] http://www.qhull.org/</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" method_type="argument" name="pointsScalar" show_port="True">
      <docstring>Data point coordinates, or a precomputed Delaunay triangulation.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['Delaunay']]</values>
      <alternateSpec arg="points" depth="1" method_type="argument" name="pointsSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="values" method_type="argument" name="valuesScalar" port_type="basic:Integer" show_port="True">
      <docstring>Data values.</docstring>
      <alternateSpec arg="values" depth="1" method_type="argument" name="valuesSequence" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Float">
      <docstring>Value used to fill in for requested points outside of the
convex hull of the input points.  If not provided, then
the default is ``nan``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rescale" method_type="argument" name="rescale" port_type="basic:Boolean">
      <docstring>Rescale points to unit cube before performing interpolation.
This is useful if some of the input dimensions have
incommensurable units and differ by many orders of magnitude.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.NearestNDInterpolator" module_name="NearestNDInterpolator" namespace="'interpolate'">
    <docstring>NearestNDInterpolator(points, values)

Nearest-neighbour interpolation in N dimensions.

.. versionadded:: 0.9

Methods
-------
__call__

Parameters
----------
x : (Npoints, Ndims) ndarray of floats
    Data point coordinates.
y : (Npoints,) ndarray of float or complex
    Data values.
rescale : boolean, optional
    Rescale points to unit cube before performing interpolation.
    This is useful if some of the input dimensions have
    incommensurable units and differ by many orders of magnitude.

    .. versionadded:: 0.14.0

Notes
-----
Uses ``scipy.spatial.cKDTree``</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" depth="1" method_type="argument" name="x" port_type="basic:Integer" show_port="True">
      <docstring>Data point coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" depth="1" method_type="argument" name="y" port_type="basic:Integer" show_port="True">
      <docstring>Data values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rescale" method_type="argument" name="rescale" port_type="basic:Boolean">
      <docstring>Rescale points to unit cube before performing interpolation.
This is useful if some of the input dimensions have
incommensurable units and differ by many orders of magnitude.

.. versionadded:: 0.14.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" method_type="argument" name="points" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="values" method_type="argument" name="values" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.PPoly" module_name="PPoly" namespace="'interpolate'">
    <docstring>Piecewise polynomial in terms of coefficients and breakpoints

The polynomial in the ith interval is ``x[i] &lt;= xp &lt; x[i+1]``::

    S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1))

where ``k`` is the degree of the polynomial. This representation
is the local power basis.

Parameters
----------
c : ndarray, shape (k, m, ...)
    Polynomial coefficients, order `k` and `m` intervals
x : ndarray, shape (m+1,)
    Polynomial breakpoints. These must be sorted in
    increasing order.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.
axis : int, optional
    Interpolation axis. Default is zero.

Attributes
----------
x : ndarray
    Breakpoints.
c : ndarray
    Coefficients of the polynomials. They are reshaped
    to a 3-dimensional array with the last dimension representing
    the trailing dimensions of the original coefficient array.
axis : int
    Interpolation axis.

Methods
-------
__call__
derivative
antiderivative
integrate
roots
extend
from_spline
from_bernstein_basis
construct_fast

See also
--------
BPoly : piecewise polynomials in the Bernstein basis

Notes
-----
High-order polynomials in the power basis can be numerically
unstable.  Precision problems can start to appear for orders
larger than 20-30.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" method_type="argument" name="c" port_type="basic:List" show_port="True">
      <docstring>Polynomial coefficients, order `k` and `m` intervals</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>Polynomial breakpoints. These must be sorted in
increasing order.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" method_type="argument" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs. Default: True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Interpolation axis. Default is zero.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.PPoly" module_name="PPolyInspector" namespace="'interpolate'">
    <docstring>Piecewise polynomial in terms of coefficients and breakpoints

The polynomial in the ith interval is ``x[i] &lt;= xp &lt; x[i+1]``::

    S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1))

where ``k`` is the degree of the polynomial. This representation
is the local power basis.

Parameters
----------
c : ndarray, shape (k, m, ...)
    Polynomial coefficients, order `k` and `m` intervals
x : ndarray, shape (m+1,)
    Polynomial breakpoints. These must be sorted in
    increasing order.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs. Default: True.
axis : int, optional
    Interpolation axis. Default is zero.

Attributes
----------
x : ndarray
    Breakpoints.
c : ndarray
    Coefficients of the polynomials. They are reshaped
    to a 3-dimensional array with the last dimension representing
    the trailing dimensions of the original coefficient array.
axis : int
    Interpolation axis.

Methods
-------
__call__
derivative
antiderivative
integrate
roots
extend
from_spline
from_bernstein_basis
construct_fast

See also
--------
BPoly : piecewise polynomials in the Bernstein basis

Notes
-----
High-order polynomials in the power basis can be numerically
unstable.  Precision problems can start to appear for orders
larger than 20-30.</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="attribute" name="x" port_type="basic:List" sort_key="1000">
      <docstring>Breakpoints.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" method_type="attribute" name="c" port_type="basic:List" sort_key="1001">
      <docstring>Coefficients of the polynomials. They are reshaped
to a 3-dimensional array with the last dimension representing
the trailing dimensions of the original coefficient array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="attribute" name="axis" port_type="basic:Integer" sort_key="1002">
      <docstring>Interpolation axis.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="x" method_type="attribute" name="x" port_type="basic:List" sort_key="1000">
      <docstring>Breakpoints.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="c" method_type="attribute" name="c" port_type="basic:List" sort_key="1001">
      <docstring>Coefficients of the polynomials. They are reshaped
to a 3-dimensional array with the last dimension representing
the trailing dimensions of the original coefficient array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="axis" method_type="attribute" name="axis" port_type="basic:Integer" sort_key="1002">
      <docstring>Interpolation axis.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.PchipInterpolator" module_name="PchipInterpolator" namespace="'interpolate'">
    <docstring>PCHIP 1-d monotonic cubic interpolation

x and y are arrays of values used to approximate some function f,
with ``y = f(x)``.  The interpolant uses monotonic cubic splines
to find the value of new points. (PCHIP stands for Piecewise Cubic
Hermite Interpolating Polynomial).

Parameters
----------
x : ndarray
    A 1-D array of monotonically increasing real values.  `x` cannot
    include duplicate values (otherwise f is overspecified)
y : ndarray
    A 1-D array of real values.  `y`'s length along the interpolation
    axis must be equal to the length of `x`. If N-D array, use axis
    parameter to select correct axis.
axis : int, optional
    Axis in the y array corresponding to the x-coordinate values.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Methods
-------
__call__
derivative
antiderivative

See Also
--------
Akima1DInterpolator

Notes
-----
The first derivatives are guaranteed to be continuous, but the second
derivatives may jump at x_k.

Preserves monotonicity in the interpolation data and does not overshoot
if the data is not smooth.

Determines the derivatives at the points x_k, d_k, by using PCHIP
algorithm:

Let m_k be the slope of the kth segment (between k and k+1)
If m_k=0 or m_{k-1}=0 or sgn(m_k) != sgn(m_{k-1}) then d_k == 0
else use weighted harmonic mean:

   w_1 = 2h_k + h_{k-1}, w_2 = h_k + 2h_{k-1}
   1/d_k = 1/(w_1 + w_2)*(w_1 / m_k + w_2 / m_{k-1})

where h_k is the spacing between x_k and x_{k+1}.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of monotonically increasing real values.  `x` cannot
include duplicate values (otherwise f is overspecified)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of real values.  `y`'s length along the interpolation
axis must be equal to the length of `x`. If N-D array, use axis
parameter to select correct axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Axis in the y array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" method_type="argument" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.PiecewisePolynomial" module_name="PiecewisePolynomial" namespace="'interpolate'">
    <docstring>Piecewise polynomial curve specified by points and derivatives

This class represents a curve that is a piecewise polynomial. It
passes through a list of points and has specified derivatives at
each point. The degree of the polynomial may vary from segment to
segment, as may the number of derivatives available. The degree
should not exceed about thirty.

Appending points to the end of the curve is efficient.

Parameters
----------
xi : array_like
    A sorted 1-d array of x-coordinates.
yi : array_like or list of array_likes
    ``yi[i][j]`` is the j-th derivative known at ``xi[i]`` (for ``axis=0``).
orders : list of int, or int, optional
    A list of polynomial orders, or a single universal order.
direction : {None, 1, -1}, optional
    Indicates whether the `xi` are increasing or decreasing:

      +1 : increasing values

      -1 : decreasing values

      None : direction will be deduced from the first two elements of `xi`

axis : int, optional
    Axis in the `yi` array corresponding to the x-coordinate values.

Notes
-----
If orders is None, or ``orders[i]`` is None, then the degree of the
polynomial segment is exactly the degree required to match all ``i``
available derivatives at both endpoints.  If ``orders[i]`` is not None,
then some derivatives will be ignored. The code will try to use an
equal number of derivatives from each end; if the total number of
derivatives needed is odd, it will prefer the rightmost endpoint. If
not enough derivatives are available, an exception is raised.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xi" method_type="argument" name="xi" port_type="basic:List" show_port="True">
      <docstring>A sorted 1-d array of x-coordinates.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="yi" method_type="argument" name="yi" port_type="basic:List" show_port="True">
      <docstring>``yi[i][j]`` is the j-th derivative known at ``xi[i]`` (for ``axis=0``).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="orders" method_type="argument" name="ordersScalar" port_type="basic:Integer">
      <docstring>A list of polynomial orders, or a single universal order.</docstring>
      <alternateSpec arg="orders" depth="1" method_type="argument" name="ordersSequence" port_type="basic:Integer" />
    </inputPortSpec>
    <inputPortSpec arg="direction" method_type="argument" name="direction" port_type="basic:Integer">
      <docstring>Indicates whether the `xi` are increasing or decreasing:

  +1 : increasing values

  -1 : decreasing values

  None : direction will be deduced from the first two elements of `xi`
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[1, -1]]</values>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Axis in the `yi` array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.Rbf" module_name="Rbf" namespace="'interpolate'">
    <docstring>Rbf(*args)

A class for radial basis function approximation/interpolation of
n-dimensional scattered data.

Parameters
----------
*args : arrays
    x, y, z, ..., d, where x, y, z, ... are the coordinates of the nodes
    and d is the array of values at the nodes
function : str or callable, optional
    The radial basis function, based on the radius, r, given by the norm
    (default is Euclidean distance); the default is 'multiquadric'::

        'multiquadric': sqrt((r/self.epsilon)**2 + 1)
        'inverse': 1.0/sqrt((r/self.epsilon)**2 + 1)
        'gaussian': exp(-(r/self.epsilon)**2)
        'linear': r
        'cubic': r**3
        'quintic': r**5
        'thin_plate': r**2 * log(r)

    If callable, then it must take 2 arguments (self, r).  The epsilon
    parameter will be available as self.epsilon.  Other keyword
    arguments passed in will be available as well.

epsilon : float, optional
    Adjustable constant for gaussian or multiquadrics functions
    - defaults to approximate average distance between nodes (which is
    a good start).
smooth : float, optional
    Values greater than zero increase the smoothness of the
    approximation.  0 is for interpolation (default), the function will
    always go through the nodal points in this case.
norm : callable, optional
    A function that returns the 'distance' between two points, with
    inputs as arrays of positions (x, y, z, ...), and an output as an
    array of distance.  E.g, the default::

        def euclidean_norm(x1, x2):
            return sqrt( ((x1 - x2)**2).sum(axis=0) )

    which is called with x1=x1[ndims,newaxis,:] and
    x2=x2[ndims,:,newaxis] such that the result is a matrix of the
    distances from each point in x1 to each point in x2.

Examples
--------
&gt;&gt;&gt; rbfi = Rbf(x, y, z, d)  # radial basis function interpolator instance
&gt;&gt;&gt; di = rbfi(xi, yi, zi)   # interpolated values</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="*args" method_type="argument" name="*args" port_type="basic:List" show_port="True">
      <docstring>x, y, z, ..., d, where x, y, z, ... are the coordinates of the nodes
and d is the array of values at the nodes</docstring>
    </inputPortSpec>
    <inputPortSpec arg="function" method_type="argument" name="function">
      <docstring>The radial basis function, based on the radius, r, given by the norm
(default is Euclidean distance); the default is 'multiquadric'::

    'multiquadric': sqrt((r/self.epsilon)**2 + 1)
    'inverse': 1.0/sqrt((r/self.epsilon)**2 + 1)
    'gaussian': exp(-(r/self.epsilon)**2)
    'linear': r
    'cubic': r**3
    'quintic': r**5
    'thin_plate': r**2 * log(r)

If callable, then it must take 2 arguments (self, r).  The epsilon
parameter will be available as self.epsilon.  Other keyword
arguments passed in will be available as well.
</docstring>
      <defaults>['Euclidean']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="epsilon" method_type="argument" name="epsilon" port_type="basic:Float">
      <docstring>Adjustable constant for gaussian or multiquadrics functions
- defaults to approximate average distance between nodes (which is
a good start).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="smooth" method_type="argument" name="smooth" port_type="basic:Float">
      <docstring>Values greater than zero increase the smoothness of the
approximation.  0 is for interpolation (default), the function will
always go through the nodal points in this case.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" method_type="argument" name="norm" port_type="basic:Variant">
      <docstring>A function that returns the 'distance' between two points, with
inputs as arrays of positions (x, y, z, ...), and an output as an
array of distance.  E.g, the default::

    def euclidean_norm(x1, x2):
        return sqrt( ((x1 - x2)**2).sum(axis=0) )

which is called with x1=x1[ndims,newaxis,:] and
x2=x2[ndims,:,newaxis] such that the result is a matrix of the
distances from each point in x1 to each point in x2.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.RectBivariateSpline" module_name="RectBivariateSpline" namespace="'interpolate'">
    <docstring>Bivariate spline approximation over a rectangular mesh.

Can be used for both smoothing and interpolating data.

Parameters
----------
x,y : array_like
    1-D arrays of coordinates in strictly ascending order.
z : array_like
    2-D array of data with shape (x.size,y.size).
bbox : array_like, optional
    Sequence of length 4 specifying the boundary of the rectangular
    approximation domain.  By default,
    ``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.
kx, ky : ints, optional
    Degrees of the bivariate spline. Default is 3.
s : float, optional
    Positive smoothing factor defined for estimation condition:
    ``sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) &lt;= s``
    Default is ``s=0``, which is for interpolation.

See Also
--------
SmoothBivariateSpline : a smoothing bivariate spline for scattered data
bisplrep : an older wrapping of FITPACK
bisplev : an older wrapping of FITPACK
UnivariateSpline : a similar class for univariate spline interpolation</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of coordinates in strictly ascending order.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>1-D arrays of coordinates in strictly ascending order.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" method_type="argument" name="z" port_type="basic:List" show_port="True">
      <docstring>2-D array of data with shape (x.size,y.size).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox" method_type="argument" name="bbox" port_type="basic:List">
      <docstring>Sequence of length 4 specifying the boundary of the rectangular
approximation domain.  By default,
``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.</docstring>
      <defaults>[[None, None, None, None]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kx" method_type="argument" name="kx" port_type="basic:Integer">
      <docstring>Degrees of the bivariate spline. Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ky" method_type="argument" name="ky" port_type="basic:Integer">
      <docstring>Degrees of the bivariate spline. Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" method_type="argument" name="s" port_type="basic:Float">
      <docstring>Positive smoothing factor defined for estimation condition:
``sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) &lt;= s``
Default is ``s=0``, which is for interpolation.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.RectSphereBivariateSpline" module_name="RectSphereBivariateSpline" namespace="'interpolate'">
    <docstring>Bivariate spline approximation over a rectangular mesh on a sphere.

Can be used for smoothing data.

.. versionadded:: 0.11.0

Parameters
----------
u : array_like
    1-D array of latitude coordinates in strictly ascending order.
    Coordinates must be given in radians and lie within the interval
    (0, pi).
v : array_like
    1-D array of longitude coordinates in strictly ascending order.
    Coordinates must be given in radians, and must lie within (0, 2pi).
r : array_like
    2-D array of data with shape ``(u.size, v.size)``.
s : float, optional
    Positive smoothing factor defined for estimation condition
    (``s=0`` is for interpolation).
pole_continuity : bool or (bool, bool), optional
    Order of continuity at the poles ``u=0`` (``pole_continuity[0]``) and
    ``u=pi`` (``pole_continuity[1]``).  The order of continuity at the pole
    will be 1 or 0 when this is True or False, respectively.
    Defaults to False.
pole_values : float or (float, float), optional
    Data values at the poles ``u=0`` and ``u=pi``.  Either the whole
    parameter or each individual element can be None.  Defaults to None.
pole_exact : bool or (bool, bool), optional
    Data value exactness at the poles ``u=0`` and ``u=pi``.  If True, the
    value is considered to be the right function value, and it will be
    fitted exactly. If False, the value will be considered to be a data
    value just like the other data values.  Defaults to False.
pole_flat : bool or (bool, bool), optional
    For the poles at ``u=0`` and ``u=pi``, specify whether or not the
    approximation has vanishing derivatives.  Defaults to False.

See Also
--------
RectBivariateSpline : bivariate spline approximation over a rectangular
    mesh

Notes
-----
Currently, only the smoothing spline approximation (``iopt[0] = 0`` and
``iopt[0] = 1`` in the FITPACK routine) is supported.  The exact
least-squares spline approximation is not implemented yet.

When actually performing the interpolation, the requested `v` values must
lie within the same length 2pi interval that the original `v` values were
chosen from.

For more information, see the FITPACK_ site about this function.

.. _FITPACK: http://www.netlib.org/dierckx/spgrid.f

Examples
--------
Suppose we have global data on a coarse grid

&gt;&gt;&gt; lats = np.linspace(10, 170, 9) * np.pi / 180.
&gt;&gt;&gt; lons = np.linspace(0, 350, 18) * np.pi / 180.
&gt;&gt;&gt; data = np.dot(np.atleast_2d(90. - np.linspace(-80., 80., 18)).T,
...               np.atleast_2d(180. - np.abs(np.linspace(0., 350., 9)))).T

We want to interpolate it to a global one-degree grid

&gt;&gt;&gt; new_lats = np.linspace(1, 180, 180) * np.pi / 180
&gt;&gt;&gt; new_lons = np.linspace(1, 360, 360) * np.pi / 180
&gt;&gt;&gt; new_lats, new_lons = np.meshgrid(new_lats, new_lons)

We need to set up the interpolator object

&gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline
&gt;&gt;&gt; lut = RectSphereBivariateSpline(lats, lons, data)

Finally we interpolate the data.  The `RectSphereBivariateSpline` object
only takes 1-D arrays as input, therefore we need to do some reshaping.

&gt;&gt;&gt; data_interp = lut.ev(new_lats.ravel(),
...                      new_lons.ravel()).reshape((360, 180)).T

Looking at the original and the interpolated data, one can see that the
interpolant reproduces the original data very well:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(211)
&gt;&gt;&gt; ax1.imshow(data, interpolation='nearest')
&gt;&gt;&gt; ax2 = fig.add_subplot(212)
&gt;&gt;&gt; ax2.imshow(data_interp, interpolation='nearest')
&gt;&gt;&gt; plt.show()

Chosing the optimal value of ``s`` can be a delicate task. Recommended
values for ``s`` depend on the accuracy of the data values.  If the user
has an idea of the statistical errors on the data, she can also find a
proper estimate for ``s``. By assuming that, if she specifies the
right ``s``, the interpolator will use a spline ``f(u,v)`` which exactly
reproduces the function underlying the data, she can evaluate
``sum((r(i,j)-s(u(i),v(j)))**2)`` to find a good estimate for this ``s``.
For example, if she knows that the statistical errors on her
``r(i,j)``-values are not greater than 0.1, she may expect that a good
``s`` should have a value not larger than ``u.size * v.size * (0.1)**2``.

If nothing is known about the statistical error in ``r(i,j)``, ``s`` must
be determined by trial and error.  The best is then to start with a very
large value of ``s`` (to determine the least-squares polynomial and the
corresponding upper bound ``fp0`` for ``s``) and then to progressively
decrease the value of ``s`` (say by a factor 10 in the beginning, i.e.
``s = fp0 / 10, fp0 / 100, ...``  and more carefully as the approximation
shows more detail) to obtain closer fits.

The interpolation results for different values of ``s`` give some insight
into this process:

&gt;&gt;&gt; fig2 = plt.figure()
&gt;&gt;&gt; s = [3e9, 2e9, 1e9, 1e8]
&gt;&gt;&gt; for ii in xrange(len(s)):
...     lut = RectSphereBivariateSpline(lats, lons, data, s=s[ii])
...     data_interp = lut.ev(new_lats.ravel(),
...                          new_lons.ravel()).reshape((360, 180)).T
...     ax = fig2.add_subplot(2, 2, ii+1)
...     ax.imshow(data_interp, interpolation='nearest')
...     ax.set_title("s = %g" % s[ii])
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="u" method_type="argument" name="u" port_type="basic:List" show_port="True">
      <docstring>1-D array of latitude coordinates in strictly ascending order.
Coordinates must be given in radians and lie within the interval
(0, pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="v" method_type="argument" name="v" port_type="basic:List" show_port="True">
      <docstring>1-D array of longitude coordinates in strictly ascending order.
Coordinates must be given in radians, and must lie within (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" method_type="argument" name="r" port_type="basic:List" show_port="True">
      <docstring>2-D array of data with shape ``(u.size, v.size)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" method_type="argument" name="s" port_type="basic:Float">
      <docstring>Positive smoothing factor defined for estimation condition
(``s=0`` is for interpolation).</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pole_continuity" method_type="argument" name="pole_continuity" port_type="basic:Boolean">
      <docstring>Order of continuity at the poles ``u=0`` (``pole_continuity[0]``) and
``u=pi`` (``pole_continuity[1]``).  The order of continuity at the pole
will be 1 or 0 when this is True or False, respectively.
Defaults to False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pole_values" method_type="argument" name="pole_values" port_type="basic:Float">
      <docstring>Data values at the poles ``u=0`` and ``u=pi``.  Either the whole
parameter or each individual element can be None.  Defaults to None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="pole_exact" method_type="argument" name="pole_exact" port_type="basic:Boolean">
      <docstring>Data value exactness at the poles ``u=0`` and ``u=pi``.  If True, the
value is considered to be the right function value, and it will be
fitted exactly. If False, the value will be considered to be a data
value just like the other data values.  Defaults to False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pole_flat" method_type="argument" name="pole_flat" port_type="basic:Boolean">
      <docstring>For the poles at ``u=0`` and ``u=pi``, specify whether or not the
approximation has vanishing derivatives.  Defaults to False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.RegularGridInterpolator" module_name="RegularGridInterpolator" namespace="'interpolate'">
    <docstring>Interpolation on a regular grid in arbitrary dimensions

The data must be defined on a regular grid; the grid spacing however may be
uneven.  Linear and nearest-neighbour interpolation are supported. After
setting up the interpolator object, the interpolation method (*linear* or
*nearest*) may be chosen at each evaluation.

Parameters
----------
points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )
    The points defining the regular grid in n dimensions.

values : array_like, shape (m1, ..., mn, ...)
    The data on the regular grid in n dimensions.

method : str, optional
    The method of interpolation to perform. Supported are "linear" and
    "nearest". This parameter will become the default for the object's
    ``__call__`` method. Default is "linear".

bounds_error : bool, optional
    If True, when interpolated values are requested outside of the
    domain of the input data, a ValueError is raised.
    If False, then `fill_value` is used.

fill_value : number, optional
    If provided, the value to use for points outside of the
    interpolation domain. If None, values outside
    the domain are extrapolated.

Methods
-------
__call__

Notes
-----
Contrary to LinearNDInterpolator and NearestNDInterpolator, this class
avoids expensive triangulation of the input data by taking advantage of the
regular grid structure.

.. versionadded:: 0.14

Examples
--------
Evaluate a simple example function on the points of a 3D grid:

&gt;&gt;&gt; from scipy.interpolate import RegularGridInterpolator
&gt;&gt;&gt; def f(x,y,z):
...     return 2 * x**3 + 3 * y**2 - z
&gt;&gt;&gt; x = np.linspace(1, 4, 11)
&gt;&gt;&gt; y = np.linspace(4, 7, 22)
&gt;&gt;&gt; z = np.linspace(7, 9, 33)
&gt;&gt;&gt; data = f(*np.meshgrid(x, y, z, indexing='ij', sparse=True))

``data`` is now a 3D array with ``data[i,j,k] = f(x[i], y[j], z[k])``.
Next, define an interpolating function from this data:

&gt;&gt;&gt; my_interpolating_function = RegularGridInterpolator((x, y, z), data)

Evaluate the interpolating function at the two points
``(x,y,z) = (2.1, 6.2, 8.3)`` and ``(3.3, 5.2, 7.1)``:

&gt;&gt;&gt; pts = np.array([[2.1, 6.2, 8.3], [3.3, 5.2, 7.1]])
&gt;&gt;&gt; my_interpolating_function(pts)
array([ 125.80469388,  146.30069388])

which is indeed a close approximation to
``[f(2.1, 6.2, 8.3), f(3.3, 5.2, 7.1)]``.

See also
--------
NearestNDInterpolator : Nearest neighbour interpolation on unstructured
                        data in N dimensions

LinearNDInterpolator : Piecewise linear interpolant on unstructured data
                       in N dimensions

References
----------
.. [1] Python package *regulargrid* by Johannes Buchner, see
       https://pypi.python.org/pypi/regulargrid/
.. [2] Trilinear interpolation. (2013, January 17). In Wikipedia, The Free
       Encyclopedia. Retrieved 27 Feb 2013 01:28.
       http://en.wikipedia.org/w/index.php?title=Trilinear_interpolation&amp;oldid=533448871
.. [3] Weiser, Alan, and Sergio E. Zarantonello. "A note on piecewise linear
       and multilinear table interpolation in many dimensions." MATH.
       COMPUT. 50.181 (1988): 189-196.
       http://www.ams.org/journals/mcom/1988-50-181/S0025-5718-1988-0917826-0/S0025-5718-1988-0917826-0.pdf</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="argument" name="points" port_type="basic:Float" show_port="True">
      <docstring>The points defining the regular grid in n dimensions.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="values" method_type="argument" name="values" port_type="basic:List" show_port="True">
      <docstring>The data on the regular grid in n dimensions.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="method" method_type="argument" name="method">
      <docstring>The method of interpolation to perform. Supported are "linear" and
"nearest". This parameter will become the default for the object's
``__call__`` method. Default is "linear".
</docstring>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bounds_error" method_type="argument" name="bounds_error" port_type="basic:Boolean">
      <docstring>If True, when interpolated values are requested outside of the
domain of the input data, a ValueError is raised.
If False, then `fill_value` is used.
</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Variant">
      <docstring>If provided, the value to use for points outside of the
interpolation domain. If None, values outside
the domain are extrapolated.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.SmoothBivariateSpline" module_name="SmoothBivariateSpline" namespace="'interpolate'">
    <docstring>Smooth bivariate spline approximation.

Parameters
----------
x, y, z : array_like
    1-D sequences of data points (order is not important).
w : array_like, optional
    Positive 1-D sequence of weights, of same length as `x`, `y` and `z`.
bbox : array_like, optional
    Sequence of length 4 specifying the boundary of the rectangular
    approximation domain.  By default,
    ``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.
kx, ky : ints, optional
    Degrees of the bivariate spline. Default is 3.
s : float, optional
    Positive smoothing factor defined for estimation condition:
    ``sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) &lt;= s``
    Default ``s=len(w)`` which should be a good value if ``1/w[i]`` is an
    estimate of the standard deviation of ``z[i]``.
eps : float, optional
    A threshold for determining the effective rank of an over-determined
    linear system of equations. `eps` should have a value between 0 and 1,
    the default is 1e-16.

See Also
--------
bisplrep : an older wrapping of FITPACK
bisplev : an older wrapping of FITPACK
UnivariateSpline : a similar class for univariate spline interpolation
LSQUnivariateSpline : to create a BivariateSpline using weighted

Notes
-----
The length of `x`, `y` and `z` should be at least ``(kx+1) * (ky+1)``.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" method_type="argument" name="z" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>Positive 1-D sequence of weights, of same length as `x`, `y` and `z`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox" method_type="argument" name="bbox" port_type="basic:List">
      <docstring>Sequence of length 4 specifying the boundary of the rectangular
approximation domain.  By default,
``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.</docstring>
      <defaults>[[None, None, None, None]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="kx" method_type="argument" name="kx" port_type="basic:Integer">
      <docstring>Degrees of the bivariate spline. Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ky" method_type="argument" name="ky" port_type="basic:Integer">
      <docstring>Degrees of the bivariate spline. Default is 3.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" method_type="argument" name="s" port_type="basic:Float">
      <docstring>Positive smoothing factor defined for estimation condition:
``sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) &lt;= s``
Default ``s=len(w)`` which should be a good value if ``1/w[i]`` is an
estimate of the standard deviation of ``z[i]``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="eps" method_type="argument" name="eps" port_type="basic:Float">
      <docstring>A threshold for determining the effective rank of an over-determined
linear system of equations. `eps` should have a value between 0 and 1,
the default is 1e-16.</docstring>
      <defaults>[1e-16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.SmoothSphereBivariateSpline" module_name="SmoothSphereBivariateSpline" namespace="'interpolate'">
    <docstring>Smooth bivariate spline approximation in spherical coordinates.

.. versionadded:: 0.11.0

Parameters
----------
theta, phi, r : array_like
    1-D sequences of data points (order is not important). Coordinates
    must be given in radians. Theta must lie within the interval (0, pi),
    and phi must lie within the interval (0, 2pi).
w : array_like, optional
    Positive 1-D sequence of weights.
s : float, optional
    Positive smoothing factor defined for estimation condition:
    ``sum((w(i)*(r(i) - s(theta(i), phi(i))))**2, axis=0) &lt;= s``
    Default ``s=len(w)`` which should be a good value if 1/w[i] is an
    estimate of the standard deviation of r[i].
eps : float, optional
    A threshold for determining the effective rank of an over-determined
    linear system of equations. `eps` should have a value between 0 and 1,
    the default is 1e-16.

Notes
-----
For more information, see the FITPACK_ site about this function.

.. _FITPACK: http://www.netlib.org/dierckx/sphere.f

Examples
--------
Suppose we have global data on a coarse grid (the input data does not
have to be on a grid):

&gt;&gt;&gt; theta = np.linspace(0., np.pi, 7)
&gt;&gt;&gt; phi = np.linspace(0., 2*np.pi, 9)
&gt;&gt;&gt; data = np.empty((theta.shape[0], phi.shape[0]))
&gt;&gt;&gt; data[:,0], data[0,:], data[-1,:] = 0., 0., 0.
&gt;&gt;&gt; data[1:-1,1], data[1:-1,-1] = 1., 1.
&gt;&gt;&gt; data[1,1:-1], data[-2,1:-1] = 1., 1.
&gt;&gt;&gt; data[2:-2,2], data[2:-2,-2] = 2., 2.
&gt;&gt;&gt; data[2,2:-2], data[-3,2:-2] = 2., 2.
&gt;&gt;&gt; data[3,3:-2] = 3.
&gt;&gt;&gt; data = np.roll(data, 4, 1)

We need to set up the interpolator object

&gt;&gt;&gt; lats, lons = np.meshgrid(theta, phi)
&gt;&gt;&gt; from scipy.interpolate import SmoothSphereBivariateSpline
&gt;&gt;&gt; lut = SmoothSphereBivariateSpline(lats.ravel(), lons.ravel(),
...                                   data.T.ravel(), s=3.5)

As a first test, we'll see what the algorithm returns when run on the
input coordinates

&gt;&gt;&gt; data_orig = lut(theta, phi)

Finally we interpolate the data to a finer grid

&gt;&gt;&gt; fine_lats = np.linspace(0., np.pi, 70)
&gt;&gt;&gt; fine_lons = np.linspace(0., 2 * np.pi, 90)

&gt;&gt;&gt; data_smth = lut(fine_lats, fine_lons)

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(131)
&gt;&gt;&gt; ax1.imshow(data, interpolation='nearest')
&gt;&gt;&gt; ax2 = fig.add_subplot(132)
&gt;&gt;&gt; ax2.imshow(data_orig, interpolation='nearest')
&gt;&gt;&gt; ax3 = fig.add_subplot(133)
&gt;&gt;&gt; ax3.imshow(data_smth, interpolation='nearest')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="theta" method_type="argument" name="theta" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important). Coordinates
must be given in radians. Theta must lie within the interval (0, pi),
and phi must lie within the interval (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="phi" method_type="argument" name="phi" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important). Coordinates
must be given in radians. Theta must lie within the interval (0, pi),
and phi must lie within the interval (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="r" method_type="argument" name="r" port_type="basic:List" show_port="True">
      <docstring>1-D sequences of data points (order is not important). Coordinates
must be given in radians. Theta must lie within the interval (0, pi),
and phi must lie within the interval (0, 2pi).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>Positive 1-D sequence of weights.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" method_type="argument" name="s" port_type="basic:Float">
      <docstring>Positive smoothing factor defined for estimation condition:
``sum((w(i)*(r(i) - s(theta(i), phi(i))))**2, axis=0) &lt;= s``
Default ``s=len(w)`` which should be a good value if 1/w[i] is an
estimate of the standard deviation of r[i].</docstring>
      <defaults>[0.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="eps" method_type="argument" name="eps" port_type="basic:Float">
      <docstring>A threshold for determining the effective rank of an over-determined
linear system of equations. `eps` should have a value between 0 and 1,
the default is 1e-16.</docstring>
      <defaults>[1e-16]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.UnivariateSpline" module_name="UnivariateSpline" namespace="'interpolate'">
    <docstring>One-dimensional smoothing spline fit to a given set of data points.

Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.  `s`
specifies the number of knots by specifying a smoothing condition.

Parameters
----------
x : (N,) array_like
    1-D array of independent input data. Must be increasing.
y : (N,) array_like
    1-D array of dependent input data, of the same length as `x`.
w : (N,) array_like, optional
    Weights for spline fitting.  Must be positive.  If None (default),
    weights are all equal.
bbox : (2,) array_like, optional
    2-sequence specifying the boundary of the approximation interval. If
    None (default), ``bbox=[x[0], x[-1]]``.
k : int, optional
    Degree of the smoothing spline.  Must be &lt;= 5.
    Default is k=3, a cubic spline.
s : float or None, optional
    Positive smoothing factor used to choose the number of knots.  Number
    of knots will be increased until the smoothing condition is satisfied::

        sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) &lt;= s

    If None (default), ``s = len(w)`` which should be a good value if
    ``1/w[i]`` is an estimate of the standard deviation of ``y[i]``.
    If 0, spline will interpolate through all data points.
ext : int or str, optional
    Controls the extrapolation mode for elements
    not in the interval defined by the knot sequence.

    * if ext=0 or 'extrapolate', return the extrapolated value.
    * if ext=1 or 'zeros', return 0
    * if ext=2 or 'raise', raise a ValueError
    * if ext=3 of 'const', return the boundary value.

    The default value is 0.

check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination or non-sensical results) if the inputs
    do contain infinities or NaNs.
    Default is False.

See Also
--------
InterpolatedUnivariateSpline : Subclass with smoothing forced to 0
LSQUnivariateSpline : Subclass in which knots are user-selected instead of
    being set by smoothing condition
splrep : An older, non object-oriented wrapping of FITPACK
splev, sproot, splint, spalde
BivariateSpline : A similar class for two-dimensional spline interpolation

Notes
-----
The number of data points must be larger than the spline degree `k`.

**NaN handling**: If the input arrays contain ``nan`` values, the result
is not useful, since the underlying spline fitting routines cannot deal
with ``nan`` . A workaround is to use zero weights for not-a-number
data points:

&gt;&gt;&gt; w = np.isnan(y)
&gt;&gt;&gt; y[w] = 0.
&gt;&gt;&gt; spl = UnivariateSpline(x, y, w=~w)

Notice the need to replace a ``nan`` by a numerical value (precise value
does not matter as long as the corresponding weight is zero.)

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy.interpolate import UnivariateSpline
&gt;&gt;&gt; x = np.linspace(-3, 3, 50)
&gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * np.random.randn(50)
&gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5)

Use the default value for the smoothing parameter:

&gt;&gt;&gt; spl = UnivariateSpline(x, y)
&gt;&gt;&gt; xs = np.linspace(-3, 3, 1000)
&gt;&gt;&gt; plt.plot(xs, spl(xs), 'g', lw=3)

Manually change the amount of smoothing:

&gt;&gt;&gt; spl.set_smoothing_factor(0.5)
&gt;&gt;&gt; plt.plot(xs, spl(xs), 'b', lw=3)
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>1-D array of independent input data. Must be increasing.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>1-D array of dependent input data, of the same length as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="w" method_type="argument" name="w" port_type="basic:List">
      <docstring>Weights for spline fitting.  Must be positive.  If None (default),
weights are all equal.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox" method_type="argument" name="bbox" port_type="basic:List">
      <docstring>2-sequence specifying the boundary of the approximation interval. If
None (default), ``bbox=[x[0], x[-1]]``.</docstring>
      <defaults>[[None, None]]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="k" method_type="argument" name="k" port_type="basic:Integer">
      <docstring>Degree of the smoothing spline.  Must be &lt;= 5.
Default is k=3, a cubic spline.</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" method_type="argument" name="s">
      <docstring>Positive smoothing factor used to choose the number of knots.  Number
of knots will be increased until the smoothing condition is satisfied::

    sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) &lt;= s

If None (default), ``s = len(w)`` which should be a good value if
``1/w[i]`` is an estimate of the standard deviation of ``y[i]``.
If 0, spline will interpolate through all data points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ext" method_type="argument" name="ext">
      <docstring>Controls the extrapolation mode for elements
not in the interval defined by the knot sequence.

* if ext=0 or 'extrapolate', return the extrapolated value.
* if ext=1 or 'zeros', return 0
* if ext=2 or 'raise', raise a ValueError
* if ext=3 of 'const', return the boundary value.

The default value is 0.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="check_finite" method_type="argument" name="check_finite" port_type="basic:Boolean">
      <docstring>Whether to check that the input arrays contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination or non-sensical results) if the inputs
do contain infinities or NaNs.
Default is False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interp1d" module_name="interp1d" namespace="'interpolate'">
    <docstring>Interpolate a 1-D function.

`x` and `y` are arrays of values used to approximate some function f:
``y = f(x)``.  This class returns a function whose call method uses
interpolation to find the value of new points.

Parameters
----------
x : (N,) array_like
    A 1-D array of real values.
y : (...,N,...) array_like
    A N-D array of real values. The length of `y` along the interpolation
    axis must be equal to the length of `x`.
kind : str or int, optional
    Specifies the kind of interpolation as a string
    ('linear', 'nearest', 'zero', 'slinear', 'quadratic, 'cubic'
    where 'slinear', 'quadratic' and 'cubic' refer to a spline
    interpolation of first, second or third order) or as an integer
    specifying the order of the spline interpolator to use.
    Default is 'linear'.
axis : int, optional
    Specifies the axis of `y` along which to interpolate.
    Interpolation defaults to the last axis of `y`.
copy : bool, optional
    If True, the class makes internal copies of x and y.
    If False, references to `x` and `y` are used. The default is to copy.
bounds_error : bool, optional
    If True, a ValueError is raised any time interpolation is attempted on
    a value outside of the range of x (where extrapolation is
    necessary). If False, out of bounds values are assigned `fill_value`.
    By default, an error is raised.
fill_value : float, optional
    If provided, then this value will be used to fill in for requested
    points outside of the data range. If not provided, then the default
    is NaN.
assume_sorted : bool, optional
    If False, values of `x` can be in any order and they are sorted first.
    If True, `x` has to be an array of monotonically increasing values.

Methods
-------
__call__

See Also
--------
splrep, splev
    Spline interpolation/smoothing based on FITPACK.
UnivariateSpline : An object-oriented wrapper of the FITPACK routines.
interp2d : 2-D interpolation

Examples
--------
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy import interpolate
&gt;&gt;&gt; x = np.arange(0, 10)
&gt;&gt;&gt; y = np.exp(-x/3.0)
&gt;&gt;&gt; f = interpolate.interp1d(x, y)

&gt;&gt;&gt; xnew = np.arange(0, 9, 0.1)
&gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d`
&gt;&gt;&gt; plt.plot(x, y, 'o', xnew, ynew, '-')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of real values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>A N-D array of real values. The length of `y` along the interpolation
axis must be equal to the length of `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kind" method_type="argument" name="kind">
      <docstring>Specifies the kind of interpolation as a string
('linear', 'nearest', 'zero', 'slinear', 'quadratic, 'cubic'
where 'slinear', 'quadratic' and 'cubic' refer to a spline
interpolation of first, second or third order) or as an integer
specifying the order of the spline interpolator to use.
Default is 'linear'.</docstring>
      <defaults>['linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Specifies the axis of `y` along which to interpolate.
Interpolation defaults to the last axis of `y`.</docstring>
      <defaults>[-1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="copy" method_type="argument" name="copy" port_type="basic:Boolean">
      <docstring>If True, the class makes internal copies of x and y.
If False, references to `x` and `y` are used. The default is to copy.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bounds_error" method_type="argument" name="bounds_error" port_type="basic:Boolean">
      <docstring>If True, a ValueError is raised any time interpolation is attempted on
a value outside of the range of x (where extrapolation is
necessary). If False, out of bounds values are assigned `fill_value`.
By default, an error is raised.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Float">
      <docstring>If provided, then this value will be used to fill in for requested
points outside of the data range. If not provided, then the default
is NaN.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="assume_sorted" method_type="argument" name="assume_sorted" port_type="basic:Boolean">
      <docstring>If False, values of `x` can be in any order and they are sorted first.
If True, `x` has to be an array of monotonically increasing values.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.interp2d" module_name="interp2d" namespace="'interpolate'">
    <docstring>interp2d(x, y, z, kind='linear', copy=True, bounds_error=False,
         fill_value=nan)

Interpolate over a 2-D grid.

`x`, `y` and `z` are arrays of values used to approximate some function
f: ``z = f(x, y)``. This class returns a function whose call method uses
spline interpolation to find the value of new points.

If `x` and `y` represent a regular grid, consider using
RectBivariateSpline.

Methods
-------
__call__

Parameters
----------
x, y : array_like
    Arrays defining the data point coordinates.

    If the points lie on a regular grid, `x` can specify the column
    coordinates and `y` the row coordinates, for example::

      &gt;&gt;&gt; x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]

    Otherwise, `x` and `y` must specify the full coordinates for each
    point, for example::

      &gt;&gt;&gt; x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,2,3,4,5,6]

    If `x` and `y` are multi-dimensional, they are flattened before use.
z : array_like
    The values of the function to interpolate at the data points. If
    `z` is a multi-dimensional array, it is flattened before use.  The
    length of a flattened `z` array is either
    len(`x`)*len(`y`) if `x` and `y` specify the column and row coordinates
    or ``len(z) == len(x) == len(y)`` if `x` and `y` specify coordinates
    for each point.
kind : {'linear', 'cubic', 'quintic'}, optional
    The kind of spline interpolation to use. Default is 'linear'.
copy : bool, optional
    If True, the class makes internal copies of x, y and z.
    If False, references may be used. The default is to copy.
bounds_error : bool, optional
    If True, when interpolated values are requested outside of the
    domain of the input data (x,y), a ValueError is raised.
    If False, then `fill_value` is used.
fill_value : number, optional
    If provided, the value to use for points outside of the
    interpolation domain. If omitted (None), values outside
    the domain are extrapolated.

Returns
-------
values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]
    Interpolated values at input coordinates.

See Also
--------
RectBivariateSpline :
    Much faster 2D interpolation if your input data is on a grid
bisplrep, bisplev :
    Spline interpolation based on FITPACK
BivariateSpline : a more recent wrapper of the FITPACK routines
interp1d : one dimension version of this function

Notes
-----
The minimum number of data points required along the interpolation
axis is ``(k+1)**2``, with k=1 for linear, k=3 for cubic and k=5 for
quintic interpolation.

The interpolator is constructed by `bisplrep`, with a smoothing factor
of 0. If more control over smoothing is needed, `bisplrep` should be
used directly.

Examples
--------
Construct a 2-D grid and interpolate on it:

&gt;&gt;&gt; from scipy import interpolate
&gt;&gt;&gt; x = np.arange(-5.01, 5.01, 0.25)
&gt;&gt;&gt; y = np.arange(-5.01, 5.01, 0.25)
&gt;&gt;&gt; xx, yy = np.meshgrid(x, y)
&gt;&gt;&gt; z = np.sin(xx**2+yy**2)
&gt;&gt;&gt; f = interpolate.interp2d(x, y, z, kind='cubic')

Now use the obtained interpolation function and plot the result:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; xnew = np.arange(-5.01, 5.01, 1e-2)
&gt;&gt;&gt; ynew = np.arange(-5.01, 5.01, 1e-2)
&gt;&gt;&gt; znew = f(xnew, ynew)
&gt;&gt;&gt; plt.plot(x, z[0, :], 'ro-', xnew, znew[0, :], 'b-')
&gt;&gt;&gt; plt.show()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>Arrays defining the data point coordinates.

If the points lie on a regular grid, `x` can specify the column
coordinates and `y` the row coordinates, for example::

  &gt;&gt;&gt; x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]

Otherwise, `x` and `y` must specify the full coordinates for each
point, for example::

  &gt;&gt;&gt; x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,2,3,4,5,6]

If `x` and `y` are multi-dimensional, they are flattened before use.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>Arrays defining the data point coordinates.

If the points lie on a regular grid, `x` can specify the column
coordinates and `y` the row coordinates, for example::

  &gt;&gt;&gt; x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]

Otherwise, `x` and `y` must specify the full coordinates for each
point, for example::

  &gt;&gt;&gt; x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,2,3,4,5,6]

If `x` and `y` are multi-dimensional, they are flattened before use.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="z" method_type="argument" name="z" port_type="basic:List" show_port="True">
      <docstring>The values of the function to interpolate at the data points. If
`z` is a multi-dimensional array, it is flattened before use.  The
length of a flattened `z` array is either
len(`x`)*len(`y`) if `x` and `y` specify the column and row coordinates
or ``len(z) == len(x) == len(y)`` if `x` and `y` specify coordinates
for each point.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kind" method_type="argument" name="kind">
      <docstring>The kind of spline interpolation to use. Default is 'linear'.</docstring>
      <entry_types>['enum']</entry_types>
      <defaults>['linear']</defaults>
      <values>[['linear', 'cubic']]</values>
    </inputPortSpec>
    <inputPortSpec arg="copy" method_type="argument" name="copy" port_type="basic:Boolean">
      <docstring>If True, the class makes internal copies of x, y and z.
If False, references may be used. The default is to copy.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bounds_error" method_type="argument" name="bounds_error" port_type="basic:Boolean">
      <docstring>If True, when interpolated values are requested outside of the
domain of the input data (x,y), a ValueError is raised.
If False, then `fill_value` is used.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fill_value" method_type="argument" name="fill_value" port_type="basic:Variant">
      <docstring>If provided, the value to use for points outside of the
interpolation domain. If omitted (None), values outside
the domain are extrapolated.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.pchip" module_name="pchip" namespace="'interpolate'">
    <docstring>PCHIP 1-d monotonic cubic interpolation

x and y are arrays of values used to approximate some function f,
with ``y = f(x)``.  The interpolant uses monotonic cubic splines
to find the value of new points. (PCHIP stands for Piecewise Cubic
Hermite Interpolating Polynomial).

Parameters
----------
x : ndarray
    A 1-D array of monotonically increasing real values.  `x` cannot
    include duplicate values (otherwise f is overspecified)
y : ndarray
    A 1-D array of real values.  `y`'s length along the interpolation
    axis must be equal to the length of `x`. If N-D array, use axis
    parameter to select correct axis.
axis : int, optional
    Axis in the y array corresponding to the x-coordinate values.
extrapolate : bool, optional
    Whether to extrapolate to ouf-of-bounds points based on first
    and last intervals, or to return NaNs.

Methods
-------
__call__
derivative
antiderivative

See Also
--------
Akima1DInterpolator

Notes
-----
The first derivatives are guaranteed to be continuous, but the second
derivatives may jump at x_k.

Preserves monotonicity in the interpolation data and does not overshoot
if the data is not smooth.

Determines the derivatives at the points x_k, d_k, by using PCHIP
algorithm:

Let m_k be the slope of the kth segment (between k and k+1)
If m_k=0 or m_{k-1}=0 or sgn(m_k) != sgn(m_{k-1}) then d_k == 0
else use weighted harmonic mean:

   w_1 = 2h_k + h_{k-1}, w_2 = h_k + 2h_{k-1}
   1/d_k = 1/(w_1 + w_2)*(w_1 / m_k + w_2 / m_{k-1})

where h_k is the spacing between x_k and x_{k+1}.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of monotonically increasing real values.  `x` cannot
include duplicate values (otherwise f is overspecified)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List" show_port="True">
      <docstring>A 1-D array of real values.  `y`'s length along the interpolation
axis must be equal to the length of `x`. If N-D array, use axis
parameter to select correct axis.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="axis" method_type="argument" name="axis" port_type="basic:Integer">
      <docstring>Axis in the y array corresponding to the x-coordinate values.</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="extrapolate" method_type="argument" name="extrapolate" port_type="basic:Boolean">
      <docstring>Whether to extrapolate to ouf-of-bounds points based on first
and last intervals, or to return NaNs.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.interpolate.ppform" module_name="ppform" namespace="'interpolate'">
    <docstring>Deprecated piecewise polynomial class.

New code should use the `PPoly` class instead.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coeffs" method_type="argument" name="coeffs" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="sort" method_type="argument" name="sort" port_type="basic:Boolean" show_port="True" />
    <inputPortSpec arg="breaks" method_type="argument" name="breaks" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="fill" method_type="argument" name="fill" port_type="basic:Float" show_port="True" />
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.Data" module_name="Data" namespace="'odr'">
    <docstring>The data to fit.

Parameters
----------
x : array_like
    Input data for regression.
y : array_like, optional
    Input data for regression.
we : array_like, optional
    If `we` is a scalar, then that value is used for all data points (and
    all dimensions of the response variable).
    If `we` is a rank-1 array of length q (the dimensionality of the
    response variable), then this vector is the diagonal of the covariant
    weighting matrix for all data points.
    If `we` is a rank-1 array of length n (the number of data points), then
    the i'th element is the weight for the i'th response variable
    observation (single-dimensional only).
    If `we` is a rank-2 array of shape (q, q), then this is the full
    covariant weighting matrix broadcast to each observation.
    If `we` is a rank-2 array of shape (q, n), then `we[:,i]` is the
    diagonal of the covariant weighting matrix for the i'th observation.
    If `we` is a rank-3 array of shape (q, q, n), then `we[:,:,i]` is the
    full specification of the covariant weighting matrix for each
    observation.
    If the fit is implicit, then only a positive scalar value is used.
wd : array_like, optional
    If `wd` is a scalar, then that value is used for all data points
    (and all dimensions of the input variable). If `wd` = 0, then the
    covariant weighting matrix for each observation is set to the identity
    matrix (so each dimension of each observation has the same weight).
    If `wd` is a rank-1 array of length m (the dimensionality of the input
    variable), then this vector is the diagonal of the covariant weighting
    matrix for all data points.
    If `wd` is a rank-1 array of length n (the number of data points), then
    the i'th element is the weight for the i'th input variable observation
    (single-dimensional only).
    If `wd` is a rank-2 array of shape (m, m), then this is the full
    covariant weighting matrix broadcast to each observation.
    If `wd` is a rank-2 array of shape (m, n), then `wd[:,i]` is the
    diagonal of the covariant weighting matrix for the i'th observation.
    If `wd` is a rank-3 array of shape (m, m, n), then `wd[:,:,i]` is the
    full specification of the covariant weighting matrix for each
    observation.
fix : array_like of ints, optional
    The `fix` argument is the same as ifixx in the class ODR. It is an
    array of integers with the same shape as data.x that determines which
    input observations are treated as fixed. One can use a sequence of
    length m (the dimensionality of the input observations) to fix some
    dimensions for all observations. A value of 0 fixes the observation,
    a value &gt; 0 makes it free.
meta : dict, optional
    Free-form dictionary for metadata.

Notes
-----
Each argument is attached to the member of the instance of the same name.
The structures of `x` and `y` are described in the Model class docstring.
If `y` is an integer, then the Data instance can only be used to fit with
implicit models where the dimensionality of the response is equal to the
specified value of `y`.

The `we` argument weights the effect a deviation in the response variable
has on the fit.  The `wd` argument weights the effect a deviation in the
input variable has on the fit. To handle multidimensional inputs and
responses easily, the structure of these arguments has the n'th
dimensional axis first. These arguments heavily use the structured
arguments feature of ODRPACK to conveniently and flexibly support all
options. See the ODRPACK User's Guide for a full explanation of how these
weights are used in the algorithm. Basically, a higher value of the weight
for a particular data point makes a deviation at that point more
detrimental to the fit.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>Input data for regression.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List">
      <docstring>Input data for regression.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="we" method_type="argument" name="we" port_type="basic:List">
      <docstring>If `we` is a scalar, then that value is used for all data points (and
all dimensions of the response variable).
If `we` is a rank-1 array of length q (the dimensionality of the
response variable), then this vector is the diagonal of the covariant
weighting matrix for all data points.
If `we` is a rank-1 array of length n (the number of data points), then
the i'th element is the weight for the i'th response variable
observation (single-dimensional only).
If `we` is a rank-2 array of shape (q, q), then this is the full
covariant weighting matrix broadcast to each observation.
If `we` is a rank-2 array of shape (q, n), then `we[:,i]` is the
diagonal of the covariant weighting matrix for the i'th observation.
If `we` is a rank-3 array of shape (q, q, n), then `we[:,:,i]` is the
full specification of the covariant weighting matrix for each
observation.
If the fit is implicit, then only a positive scalar value is used.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="wd" method_type="argument" name="wd" port_type="basic:List">
      <docstring>If `wd` is a scalar, then that value is used for all data points
(and all dimensions of the input variable). If `wd` = 0, then the
covariant weighting matrix for each observation is set to the identity
matrix (so each dimension of each observation has the same weight).
If `wd` is a rank-1 array of length m (the dimensionality of the input
variable), then this vector is the diagonal of the covariant weighting
matrix for all data points.
If `wd` is a rank-1 array of length n (the number of data points), then
the i'th element is the weight for the i'th input variable observation
(single-dimensional only).
If `wd` is a rank-2 array of shape (m, m), then this is the full
covariant weighting matrix broadcast to each observation.
If `wd` is a rank-2 array of shape (m, n), then `wd[:,i]` is the
diagonal of the covariant weighting matrix for the i'th observation.
If `wd` is a rank-3 array of shape (m, m, n), then `wd[:,:,i]` is the
full specification of the covariant weighting matrix for each
observation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fix" depth="1" method_type="argument" name="fix" port_type="basic:Integer">
      <docstring>The `fix` argument is the same as ifixx in the class ODR. It is an
array of integers with the same shape as data.x that determines which
input observations are treated as fixed. One can use a sequence of
length m (the dimensionality of the input observations) to fix some
dimensions for all observations. A value of 0 fixes the observation,
a value &gt; 0 makes it free.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="meta" method_type="argument" name="meta">
      <docstring>Free-form dictionary for metadata.</docstring>
      <defaults>[{}]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.Model" module_name="Model" namespace="'odr'">
    <docstring>The Model class stores information about the function you wish to fit.

It stores the function itself, at the least, and optionally stores
functions which compute the Jacobians used during fitting. Also, one
can provide a function that will provide reasonable starting values
for the fit parameters possibly given the set of data.

Parameters
----------
fcn : function
      fcn(beta, x) --&gt; y
fjacb : function
      Jacobian of fcn wrt the fit parameters beta.

      fjacb(beta, x) --&gt; @f_i(x,B)/@B_j
fjacd : function
      Jacobian of fcn wrt the (possibly multidimensional) input
      variable.

      fjacd(beta, x) --&gt; @f_i(x,B)/@x_j
extra_args : tuple, optional
      If specified, `extra_args` should be a tuple of extra
      arguments to pass to `fcn`, `fjacb`, and `fjacd`. Each will be called
      by `apply(fcn, (beta, x) + extra_args)`
estimate : array_like of rank-1
      Provides estimates of the fit parameters from the data

      estimate(data) --&gt; estbeta
implicit : boolean
      If TRUE, specifies that the model
      is implicit; i.e `fcn(beta, x)` ~= 0 and there is no y data to fit
      against
meta : dict, optional
      freeform dictionary of metadata for the model

Notes
-----
Note that the `fcn`, `fjacb`, and `fjacd` operate on NumPy arrays and
return a NumPy array. The `estimate` object takes an instance of the
Data class.

Here are the rules for the shapes of the argument and return
arrays of the callback functions:

`x`
    if the input data is single-dimensional, then `x` is rank-1
    array; i.e. ``x = array([1, 2, 3, ...]); x.shape = (n,)``
    If the input data is multi-dimensional, then `x` is a rank-2 array;
    i.e., ``x = array([[1, 2, ...], [2, 4, ...]]); x.shape = (m, n)``.
    In all cases, it has the same shape as the input data array passed to
    `odr`. `m` is the dimensionality of the input data, `n` is the number
    of observations.
`y`
    if the response variable is single-dimensional, then `y` is a
    rank-1 array, i.e., ``y = array([2, 4, ...]); y.shape = (n,)``.
    If the response variable is multi-dimensional, then `y` is a rank-2
    array, i.e., ``y = array([[2, 4, ...], [3, 6, ...]]); y.shape =
    (q, n)`` where `q` is the dimensionality of the response variable.
`beta`
    rank-1 array of length `p` where `p` is the number of parameters;
    i.e. ``beta = array([B_1, B_2, ..., B_p])``
`fjacb`
    if the response variable is multi-dimensional, then the
    return array's shape is `(q, p, n)` such that ``fjacb(x,beta)[l,k,i] =
    d f_l(X,B)/d B_k`` evaluated at the i'th data point.  If `q == 1`, then
    the return array is only rank-2 and with shape `(p, n)`.
`fjacd`
    as with fjacb, only the return array's shape is `(q, m, n)`
    such that ``fjacd(x,beta)[l,j,i] = d f_l(X,B)/d X_j`` at the i'th data
    point.  If `q == 1`, then the return array's shape is `(m, n)`. If
    `m == 1`, the shape is (q, n). If `m == q == 1`, the shape is `(n,)`.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fcn" method_type="argument" name="fcn" port_type="basic:Variant" show_port="True">
      <docstring>fcn(beta, x) --&gt; y</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fjacb" method_type="argument" name="fjacb" port_type="basic:Variant" show_port="True">
      <docstring>Jacobian of fcn wrt the fit parameters beta.

fjacb(beta, x) --&gt; @f_i(x,B)/@B_j</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fjacd" method_type="argument" name="fjacd" port_type="basic:Variant" show_port="True">
      <docstring>Jacobian of fcn wrt the (possibly multidimensional) input
variable.

fjacd(beta, x) --&gt; @f_i(x,B)/@x_j</docstring>
    </inputPortSpec>
    <inputPortSpec arg="extra_args" method_type="argument" name="extra_args" port_type="basic:List">
      <docstring>If specified, `extra_args` should be a tuple of extra
arguments to pass to `fcn`, `fjacb`, and `fjacd`. Each will be called
by `apply(fcn, (beta, x) + extra_args)`</docstring>
    </inputPortSpec>
    <inputPortSpec arg="estimate" method_type="argument" name="estimate" port_type="basic:List" show_port="True">
      <docstring>Provides estimates of the fit parameters from the data

estimate(data) --&gt; estbeta</docstring>
    </inputPortSpec>
    <inputPortSpec arg="implicit" method_type="argument" name="implicitScalar" port_type="basic:Integer">
      <docstring>If TRUE, specifies that the model
is implicit; i.e `fcn(beta, x)` ~= 0 and there is no y data to fit
against</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="implicit" method_type="argument" name="implicitBool" port_type="basic:Boolean" />
    </inputPortSpec>
    <inputPortSpec arg="meta" method_type="argument" name="meta" port_type="basic:Dictionary">
      <docstring>freeform dictionary of metadata for the model</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.ODR" module_name="ODR" namespace="'odr'">
    <docstring>The ODR class gathers all information and coordinates the running of the
main fitting routine.

Members of instances of the ODR class have the same names as the arguments
to the initialization routine.

Parameters
----------
data : Data class instance
    instance of the Data class
model : Model class instance
    instance of the Model class

Other Parameters
----------------
beta0 : array_like of rank-1
    a rank-1 sequence of initial parameter values. Optional if
    model provides an "estimate" function to estimate these values.
delta0 : array_like of floats of rank-1, optional
    a (double-precision) float array to hold the initial values of
    the errors in the input variables. Must be same shape as data.x
ifixb : array_like of ints of rank-1, optional
    sequence of integers with the same length as beta0 that determines
    which parameters are held fixed. A value of 0 fixes the parameter,
    a value &gt; 0 makes the parameter free.
ifixx : array_like of ints with same shape as data.x, optional
    an array of integers with the same shape as data.x that determines
    which input observations are treated as fixed. One can use a sequence
    of length m (the dimensionality of the input observations) to fix some
    dimensions for all observations. A value of 0 fixes the observation,
    a value &gt; 0 makes it free.
job : int, optional
    an integer telling ODRPACK what tasks to perform. See p. 31 of the
    ODRPACK User's Guide if you absolutely must set the value here. Use the
    method set_job post-initialization for a more readable interface.
iprint : int, optional
    an integer telling ODRPACK what to print. See pp. 33-34 of the
    ODRPACK User's Guide if you absolutely must set the value here. Use the
    method set_iprint post-initialization for a more readable interface.
errfile : str, optional
    string with the filename to print ODRPACK errors to. *Do Not Open
    This File Yourself!*
rptfile : str, optional
    string with the filename to print ODRPACK summaries to. *Do Not
    Open This File Yourself!*
ndigit : int, optional
    integer specifying the number of reliable digits in the computation
    of the function.
taufac : float, optional
    float specifying the initial trust region. The default value is 1.
    The initial trust region is equal to taufac times the length of the
    first computed Gauss-Newton step. taufac must be less than 1.
sstol : float, optional
    float specifying the tolerance for convergence based on the relative
    change in the sum-of-squares. The default value is eps**(1/2) where eps
    is the smallest value such that 1 + eps &gt; 1 for double precision
    computation on the machine. sstol must be less than 1.
partol : float, optional
    float specifying the tolerance for convergence based on the relative
    change in the estimated parameters. The default value is eps**(2/3) for
    explicit models and ``eps**(1/3)`` for implicit models. partol must be less
    than 1.
maxit : int, optional
    integer specifying the maximum number of iterations to perform. For
    first runs, maxit is the total number of iterations performed and
    defaults to 50.  For restarts, maxit is the number of additional
    iterations to perform and defaults to 10.
stpb : array_like, optional
    sequence (``len(stpb) == len(beta0)``) of relative step sizes to compute
    finite difference derivatives wrt the parameters.
stpd : optional
    array (``stpd.shape == data.x.shape`` or ``stpd.shape == (m,)``) of relative
    step sizes to compute finite difference derivatives wrt the input
    variable errors. If stpd is a rank-1 array with length m (the
    dimensionality of the input variable), then the values are broadcast to
    all observations.
sclb : array_like, optional
    sequence (``len(stpb) == len(beta0)``) of scaling factors for the
    parameters.  The purpose of these scaling factors are to scale all of
    the parameters to around unity. Normally appropriate scaling factors
    are computed if this argument is not specified. Specify them yourself
    if the automatic procedure goes awry.
scld : array_like, optional
    array (scld.shape == data.x.shape or scld.shape == (m,)) of scaling
    factors for the *errors* in the input variables. Again, these factors
    are automatically computed if you do not provide them. If scld.shape ==
    (m,), then the scaling factors are broadcast to all observations.
work : ndarray, optional
    array to hold the double-valued working data for ODRPACK. When
    restarting, takes the value of self.output.work.
iwork : ndarray, optional
    array to hold the integer-valued working data for ODRPACK. When
    restarting, takes the value of self.output.iwork.

Attributes
----------
data : Data
    The data for this fit
model : Model
    The model used in fit
output : Output
    An instance if the Output class containing all of the returned
    data from an invocation of ODR.run() or ODR.restart()</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="argument" name="data" port_type="basic:Variant" show_port="True">
      <docstring>instance of the Data class</docstring>
    </inputPortSpec>
    <inputPortSpec arg="model" method_type="argument" name="model" port_type="basic:Variant" show_port="True">
      <docstring>instance of the Model class</docstring>
    </inputPortSpec>
    <inputPortSpec arg="beta0" method_type="argument" name="beta0" port_type="basic:List" show_port="True">
      <docstring>a rank-1 sequence of initial parameter values. Optional if
model provides an "estimate" function to estimate these values.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="delta0" depth="1" method_type="argument" name="delta0" port_type="basic:Float">
      <docstring>a (double-precision) float array to hold the initial values of
the errors in the input variables. Must be same shape as data.x</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ifixb" depth="1" method_type="argument" name="ifixb" port_type="basic:Integer">
      <docstring>sequence of integers with the same length as beta0 that determines
which parameters are held fixed. A value of 0 fixes the parameter,
a value &gt; 0 makes the parameter free.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ifixx" depth="1" method_type="argument" name="ifixx" port_type="basic:Integer">
      <docstring>an array of integers with the same shape as data.x that determines
which input observations are treated as fixed. One can use a sequence
of length m (the dimensionality of the input observations) to fix some
dimensions for all observations. A value of 0 fixes the observation,
a value &gt; 0 makes it free.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="job" method_type="argument" name="job" port_type="basic:Integer">
      <docstring>an integer telling ODRPACK what tasks to perform. See p. 31 of the
ODRPACK User's Guide if you absolutely must set the value here. Use the
method set_job post-initialization for a more readable interface.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iprint" method_type="argument" name="iprint" port_type="basic:Integer">
      <docstring>an integer telling ODRPACK what to print. See pp. 33-34 of the
ODRPACK User's Guide if you absolutely must set the value here. Use the
method set_iprint post-initialization for a more readable interface.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="errfile" method_type="argument" name="errfile">
      <docstring>string with the filename to print ODRPACK errors to. *Do Not Open
This File Yourself!*</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rptfile" method_type="argument" name="rptfile">
      <docstring>string with the filename to print ODRPACK summaries to. *Do Not
Open This File Yourself!*</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ndigit" method_type="argument" name="ndigit" port_type="basic:Integer">
      <docstring>integer specifying the number of reliable digits in the computation
of the function.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="taufac" method_type="argument" name="taufac" port_type="basic:Float">
      <docstring>float specifying the initial trust region. The default value is 1.
The initial trust region is equal to taufac times the length of the
first computed Gauss-Newton step. taufac must be less than 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sstol" method_type="argument" name="sstol" port_type="basic:Float">
      <docstring>float specifying the tolerance for convergence based on the relative
change in the sum-of-squares. The default value is eps**(1/2) where eps
is the smallest value such that 1 + eps &gt; 1 for double precision
computation on the machine. sstol must be less than 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="partol" method_type="argument" name="partol" port_type="basic:Float">
      <docstring>float specifying the tolerance for convergence based on the relative
change in the estimated parameters. The default value is eps**(2/3) for
explicit models and ``eps**(1/3)`` for implicit models. partol must be less
than 1.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxit" method_type="argument" name="maxit" port_type="basic:Integer">
      <docstring>integer specifying the maximum number of iterations to perform. For
first runs, maxit is the total number of iterations performed and
defaults to 50.  For restarts, maxit is the number of additional
iterations to perform and defaults to 10.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="stpb" method_type="argument" name="stpb" port_type="basic:List">
      <docstring>sequence (``len(stpb) == len(beta0)``) of relative step sizes to compute
finite difference derivatives wrt the parameters.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="stpd" method_type="argument" name="stpd" port_type="basic:Variant">
      <docstring>array (``stpd.shape == data.x.shape`` or ``stpd.shape == (m,)``) of relative
step sizes to compute finite difference derivatives wrt the input
variable errors. If stpd is a rank-1 array with length m (the
dimensionality of the input variable), then the values are broadcast to
all observations.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sclb" method_type="argument" name="sclb" port_type="basic:List">
      <docstring>sequence (``len(stpb) == len(beta0)``) of scaling factors for the
parameters.  The purpose of these scaling factors are to scale all of
the parameters to around unity. Normally appropriate scaling factors
are computed if this argument is not specified. Specify them yourself
if the automatic procedure goes awry.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scld" method_type="argument" name="scld" port_type="basic:List">
      <docstring>array (scld.shape == data.x.shape or scld.shape == (m,)) of scaling
factors for the *errors* in the input variables. Again, these factors
are automatically computed if you do not provide them. If scld.shape ==
(m,), then the scaling factors are broadcast to all observations.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="work" method_type="argument" name="work" port_type="basic:List">
      <docstring>array to hold the double-valued working data for ODRPACK. When
restarting, takes the value of self.output.work.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="iwork" method_type="argument" name="iwork" port_type="basic:List">
      <docstring>array to hold the integer-valued working data for ODRPACK. When
restarting, takes the value of self.output.iwork.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.ODR" module_name="ODRInspector" namespace="'odr'">
    <docstring>The ODR class gathers all information and coordinates the running of the
main fitting routine.

Members of instances of the ODR class have the same names as the arguments
to the initialization routine.

Parameters
----------
data : Data class instance
    instance of the Data class
model : Model class instance
    instance of the Model class

Other Parameters
----------------
beta0 : array_like of rank-1
    a rank-1 sequence of initial parameter values. Optional if
    model provides an "estimate" function to estimate these values.
delta0 : array_like of floats of rank-1, optional
    a (double-precision) float array to hold the initial values of
    the errors in the input variables. Must be same shape as data.x
ifixb : array_like of ints of rank-1, optional
    sequence of integers with the same length as beta0 that determines
    which parameters are held fixed. A value of 0 fixes the parameter,
    a value &gt; 0 makes the parameter free.
ifixx : array_like of ints with same shape as data.x, optional
    an array of integers with the same shape as data.x that determines
    which input observations are treated as fixed. One can use a sequence
    of length m (the dimensionality of the input observations) to fix some
    dimensions for all observations. A value of 0 fixes the observation,
    a value &gt; 0 makes it free.
job : int, optional
    an integer telling ODRPACK what tasks to perform. See p. 31 of the
    ODRPACK User's Guide if you absolutely must set the value here. Use the
    method set_job post-initialization for a more readable interface.
iprint : int, optional
    an integer telling ODRPACK what to print. See pp. 33-34 of the
    ODRPACK User's Guide if you absolutely must set the value here. Use the
    method set_iprint post-initialization for a more readable interface.
errfile : str, optional
    string with the filename to print ODRPACK errors to. *Do Not Open
    This File Yourself!*
rptfile : str, optional
    string with the filename to print ODRPACK summaries to. *Do Not
    Open This File Yourself!*
ndigit : int, optional
    integer specifying the number of reliable digits in the computation
    of the function.
taufac : float, optional
    float specifying the initial trust region. The default value is 1.
    The initial trust region is equal to taufac times the length of the
    first computed Gauss-Newton step. taufac must be less than 1.
sstol : float, optional
    float specifying the tolerance for convergence based on the relative
    change in the sum-of-squares. The default value is eps**(1/2) where eps
    is the smallest value such that 1 + eps &gt; 1 for double precision
    computation on the machine. sstol must be less than 1.
partol : float, optional
    float specifying the tolerance for convergence based on the relative
    change in the estimated parameters. The default value is eps**(2/3) for
    explicit models and ``eps**(1/3)`` for implicit models. partol must be less
    than 1.
maxit : int, optional
    integer specifying the maximum number of iterations to perform. For
    first runs, maxit is the total number of iterations performed and
    defaults to 50.  For restarts, maxit is the number of additional
    iterations to perform and defaults to 10.
stpb : array_like, optional
    sequence (``len(stpb) == len(beta0)``) of relative step sizes to compute
    finite difference derivatives wrt the parameters.
stpd : optional
    array (``stpd.shape == data.x.shape`` or ``stpd.shape == (m,)``) of relative
    step sizes to compute finite difference derivatives wrt the input
    variable errors. If stpd is a rank-1 array with length m (the
    dimensionality of the input variable), then the values are broadcast to
    all observations.
sclb : array_like, optional
    sequence (``len(stpb) == len(beta0)``) of scaling factors for the
    parameters.  The purpose of these scaling factors are to scale all of
    the parameters to around unity. Normally appropriate scaling factors
    are computed if this argument is not specified. Specify them yourself
    if the automatic procedure goes awry.
scld : array_like, optional
    array (scld.shape == data.x.shape or scld.shape == (m,)) of scaling
    factors for the *errors* in the input variables. Again, these factors
    are automatically computed if you do not provide them. If scld.shape ==
    (m,), then the scaling factors are broadcast to all observations.
work : ndarray, optional
    array to hold the double-valued working data for ODRPACK. When
    restarting, takes the value of self.output.work.
iwork : ndarray, optional
    array to hold the integer-valued working data for ODRPACK. When
    restarting, takes the value of self.output.iwork.

Attributes
----------
data : Data
    The data for this fit
model : Model
    The model used in fit
output : Output
    An instance if the Output class containing all of the returned
    data from an invocation of ODR.run() or ODR.restart()</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="attribute" name="data" port_type="basic:Variant" sort_key="1000">
      <docstring>The data for this fit</docstring>
    </inputPortSpec>
    <inputPortSpec arg="model" method_type="attribute" name="model" port_type="basic:Variant" sort_key="1001">
      <docstring>The model used in fit</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" method_type="attribute" name="output" port_type="basic:Variant" sort_key="1002">
      <docstring>An instance if the Output class containing all of the returned
data from an invocation of ODR.run() or ODR.restart()</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="data" method_type="attribute" name="data" port_type="basic:Variant" sort_key="1000">
      <docstring>The data for this fit</docstring>
    </outputPortSpec>
    <outputPortSpec arg="model" method_type="attribute" name="model" port_type="basic:Variant" sort_key="1001">
      <docstring>The model used in fit</docstring>
    </outputPortSpec>
    <outputPortSpec arg="output" method_type="attribute" name="output" port_type="basic:Variant" sort_key="1002">
      <docstring>An instance if the Output class containing all of the returned
data from an invocation of ODR.run() or ODR.restart()</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.Output" module_name="Output" namespace="'odr'">
    <docstring>The Output class stores the output of an ODR run.

Attributes
----------
beta : ndarray
    Estimated parameter values, of shape (q,).
sd_beta : ndarray
    Standard errors of the estimated parameters, of shape (p,).
cov_beta : ndarray
    Covariance matrix of the estimated parameters, of shape (p,p).
delta : ndarray, optional
    Array of estimated errors in input variables, of same shape as `x`.
eps : ndarray, optional
    Array of estimated errors in response variables, of same shape as `y`.
xplus : ndarray, optional
    Array of ``x + delta``.
y : ndarray, optional
    Array ``y = fcn(x + delta)``.
res_var : float, optional
    Residual variance.
sum_sqare : float, optional
    Sum of squares error.
sum_square_delta : float, optional
    Sum of squares of delta error.
sum_square_eps : float, optional
    Sum of squares of eps error.
inv_condnum : float, optional
    Inverse condition number (cf. ODRPACK UG p. 77).
rel_error : float, optional
    Relative error in function values computed within fcn.
work : ndarray, optional
    Final work array.
work_ind : dict, optional
    Indices into work for drawing out values (cf. ODRPACK UG p. 83).
info : int, optional
    Reason for returning, as output by ODRPACK (cf. ODRPACK UG p. 38).
stopreason : list of str, optional
    `info` interpreted into English.

Notes
-----
Takes one argument for initialization, the return value from the
function `odr`. The attributes listed as "optional" above are only
present if `odr` was run with ``full_output=1``.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="output" method_type="argument" name="output" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.Output" module_name="OutputInspector" namespace="'odr'">
    <docstring>The Output class stores the output of an ODR run.

Attributes
----------
beta : ndarray
    Estimated parameter values, of shape (q,).
sd_beta : ndarray
    Standard errors of the estimated parameters, of shape (p,).
cov_beta : ndarray
    Covariance matrix of the estimated parameters, of shape (p,p).
delta : ndarray, optional
    Array of estimated errors in input variables, of same shape as `x`.
eps : ndarray, optional
    Array of estimated errors in response variables, of same shape as `y`.
xplus : ndarray, optional
    Array of ``x + delta``.
y : ndarray, optional
    Array ``y = fcn(x + delta)``.
res_var : float, optional
    Residual variance.
sum_sqare : float, optional
    Sum of squares error.
sum_square_delta : float, optional
    Sum of squares of delta error.
sum_square_eps : float, optional
    Sum of squares of eps error.
inv_condnum : float, optional
    Inverse condition number (cf. ODRPACK UG p. 77).
rel_error : float, optional
    Relative error in function values computed within fcn.
work : ndarray, optional
    Final work array.
work_ind : dict, optional
    Indices into work for drawing out values (cf. ODRPACK UG p. 83).
info : int, optional
    Reason for returning, as output by ODRPACK (cf. ODRPACK UG p. 38).
stopreason : list of str, optional
    `info` interpreted into English.

Notes
-----
Takes one argument for initialization, the return value from the
function `odr`. The attributes listed as "optional" above are only
present if `odr` was run with ``full_output=1``.</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="beta" method_type="attribute" name="beta" port_type="basic:List" sort_key="1000">
      <docstring>Estimated parameter values, of shape (q,).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sd_beta" method_type="attribute" name="sd_beta" port_type="basic:List" sort_key="1001">
      <docstring>Standard errors of the estimated parameters, of shape (p,).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cov_beta" method_type="attribute" name="cov_beta" port_type="basic:List" sort_key="1002">
      <docstring>Covariance matrix of the estimated parameters, of shape (p,p).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="delta" method_type="attribute" name="delta" port_type="basic:List" sort_key="1003">
      <docstring>Array of estimated errors in input variables, of same shape as `x`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="eps" method_type="attribute" name="eps" port_type="basic:List" sort_key="1004">
      <docstring>Array of estimated errors in response variables, of same shape as `y`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xplus" method_type="attribute" name="xplus" port_type="basic:List" sort_key="1005">
      <docstring>Array of ``x + delta``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="attribute" name="y" port_type="basic:List" sort_key="1006">
      <docstring>Array ``y = fcn(x + delta)``.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="res_var" method_type="attribute" name="res_var" port_type="basic:Float" sort_key="1007">
      <docstring>Residual variance.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sum_sqare" method_type="attribute" name="sum_sqare" port_type="basic:Float" sort_key="1008">
      <docstring>Sum of squares error.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sum_square_delta" method_type="attribute" name="sum_square_delta" port_type="basic:Float" sort_key="1009">
      <docstring>Sum of squares of delta error.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sum_square_eps" method_type="attribute" name="sum_square_eps" port_type="basic:Float" sort_key="1010">
      <docstring>Sum of squares of eps error.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="inv_condnum" method_type="attribute" name="inv_condnum" port_type="basic:Float" sort_key="1011">
      <docstring>Inverse condition number (cf. ODRPACK UG p. 77).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rel_error" method_type="attribute" name="rel_error" port_type="basic:Float" sort_key="1012">
      <docstring>Relative error in function values computed within fcn.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="work" method_type="attribute" name="work" port_type="basic:List" sort_key="1013">
      <docstring>Final work array.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="work_ind" method_type="attribute" name="work_ind" port_type="basic:Dictionary" sort_key="1014">
      <docstring>Indices into work for drawing out values (cf. ODRPACK UG p. 83).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="info" method_type="attribute" name="info" port_type="basic:Integer" sort_key="1015">
      <docstring>Reason for returning, as output by ODRPACK (cf. ODRPACK UG p. 38).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="stopreason" depth="1" method_type="attribute" name="stopreason" sort_key="1016">
      <docstring>`info` interpreted into English.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="beta" method_type="attribute" name="beta" port_type="basic:List" sort_key="1000">
      <docstring>Estimated parameter values, of shape (q,).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sd_beta" method_type="attribute" name="sd_beta" port_type="basic:List" sort_key="1001">
      <docstring>Standard errors of the estimated parameters, of shape (p,).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="cov_beta" method_type="attribute" name="cov_beta" port_type="basic:List" sort_key="1002">
      <docstring>Covariance matrix of the estimated parameters, of shape (p,p).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="delta" method_type="attribute" name="delta" port_type="basic:List" sort_key="1003">
      <docstring>Array of estimated errors in input variables, of same shape as `x`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="eps" method_type="attribute" name="eps" port_type="basic:List" sort_key="1004">
      <docstring>Array of estimated errors in response variables, of same shape as `y`.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="xplus" method_type="attribute" name="xplus" port_type="basic:List" sort_key="1005">
      <docstring>Array of ``x + delta``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="y" method_type="attribute" name="y" port_type="basic:List" sort_key="1006">
      <docstring>Array ``y = fcn(x + delta)``.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="res_var" method_type="attribute" name="res_var" port_type="basic:Float" sort_key="1007">
      <docstring>Residual variance.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sum_sqare" method_type="attribute" name="sum_sqare" port_type="basic:Float" sort_key="1008">
      <docstring>Sum of squares error.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sum_square_delta" method_type="attribute" name="sum_square_delta" port_type="basic:Float" sort_key="1009">
      <docstring>Sum of squares of delta error.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="sum_square_eps" method_type="attribute" name="sum_square_eps" port_type="basic:Float" sort_key="1010">
      <docstring>Sum of squares of eps error.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="inv_condnum" method_type="attribute" name="inv_condnum" port_type="basic:Float" sort_key="1011">
      <docstring>Inverse condition number (cf. ODRPACK UG p. 77).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="rel_error" method_type="attribute" name="rel_error" port_type="basic:Float" sort_key="1012">
      <docstring>Relative error in function values computed within fcn.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="work" method_type="attribute" name="work" port_type="basic:List" sort_key="1013">
      <docstring>Final work array.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="work_ind" method_type="attribute" name="work_ind" port_type="basic:Dictionary" sort_key="1014">
      <docstring>Indices into work for drawing out values (cf. ODRPACK UG p. 83).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="info" method_type="attribute" name="info" port_type="basic:Integer" sort_key="1015">
      <docstring>Reason for returning, as output by ODRPACK (cf. ODRPACK UG p. 38).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="stopreason" depth="1" method_type="attribute" name="stopreason" sort_key="1016">
      <docstring>`info` interpreted into English.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.RealData" module_name="RealData" namespace="'odr'">
    <docstring>The data, with weightings as actual standard deviations and/or
covariances.

Parameters
----------
x : array_like
    x
y : array_like, optional
    y
sx, sy : array_like, optional
    Standard deviations of `x`.
    `sx` are standard deviations of `x` and are converted to weights by
    dividing 1.0 by their squares.
sy : array_like, optional
    Standard deviations of `y`.
    `sy` are standard deviations of `y` and are converted to weights by
    dividing 1.0 by their squares.
covx : array_like, optional
    Covariance of `x`
    `covx` is an array of covariance matrices of `x` and are converted to
    weights by performing a matrix inversion on each observation's
    covariance matrix.
covy : array_like, optional
    Covariance of `y`
    `covy` is an array of covariance matrices and are converted to
    weights by performing a matrix inversion on each observation's
    covariance matrix.
fix : array_like, optional
    The argument and member fix is the same as Data.fix and ODR.ifixx:
    It is an array of integers with the same shape as `x` that
    determines which input observations are treated as fixed. One can
    use a sequence of length m (the dimensionality of the input
    observations) to fix some dimensions for all observations. A value
    of 0 fixes the observation, a value &gt; 0 makes it free.
meta : dict, optional
    Free-form dictionary for metadata.

Notes
-----
The weights `wd` and `we` are computed from provided values as follows:

`sx` and `sy` are converted to weights by dividing 1.0 by their squares.
For example, ``wd = 1./numpy.power(`sx`, 2)``.

`covx` and `covy` are arrays of covariance matrices and are converted to
weights by performing a matrix inversion on each observation's covariance
matrix.  For example, ``we[i] = numpy.linalg.inv(covy[i])``.

These arguments follow the same structured argument conventions as wd and
we only restricted by their natures: `sx` and `sy` can't be rank-3, but
`covx` and `covy` can be.

Only set *either* `sx` or `covx` (not both). Setting both will raise an
exception.  Same with `sy` and `covy`.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" method_type="argument" name="x" port_type="basic:List" show_port="True">
      <docstring>x</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" method_type="argument" name="y" port_type="basic:List">
      <docstring>y</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sx" method_type="argument" name="sx" port_type="basic:List">
      <docstring>Standard deviations of `x`.
`sx` are standard deviations of `x` and are converted to weights by
dividing 1.0 by their squares.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sy" method_type="argument" name="sy" port_type="basic:List">
      <docstring>Standard deviations of `x`.
`sx` are standard deviations of `x` and are converted to weights by
dividing 1.0 by their squares.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sy" method_type="argument" name="sy" port_type="basic:List">
      <docstring>Standard deviations of `y`.
`sy` are standard deviations of `y` and are converted to weights by
dividing 1.0 by their squares.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="covx" method_type="argument" name="covx" port_type="basic:List">
      <docstring>Covariance of `x`
`covx` is an array of covariance matrices of `x` and are converted to
weights by performing a matrix inversion on each observation's
covariance matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="covy" method_type="argument" name="covy" port_type="basic:List">
      <docstring>Covariance of `y`
`covy` is an array of covariance matrices and are converted to
weights by performing a matrix inversion on each observation's
covariance matrix.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fix" method_type="argument" name="fix" port_type="basic:List">
      <docstring>The argument and member fix is the same as Data.fix and ODR.ifixx:
It is an array of integers with the same shape as `x` that
determines which input observations are treated as fixed. One can
use a sequence of length m (the dimensionality of the input
observations) to fix some dimensions for all observations. A value
of 0 fixes the observation, a value &gt; 0 makes it free.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="meta" method_type="argument" name="meta">
      <docstring>Free-form dictionary for metadata.</docstring>
      <defaults>[{}]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.odr_error" module_name="odr_error" namespace="'odr'">
    <docstring>Exception indicating an error in fitting.

This is raised by `scipy.odr` if an error occurs during fitting.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.odr.odr_stop" module_name="odr_stop" namespace="'odr'">
    <docstring>Exception stopping fitting.

You can raise this exception in your objective function to tell
`scipy.odr` to stop fitting.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.ConvexHull" module_name="ConvexHull" namespace="'spatial'">
    <docstring>ConvexHull(points, incremental=False, qhull_options=None)

Convex hulls in N dimensions.

.. versionadded:: 0.12.0

Parameters
----------
points : ndarray of floats, shape (npoints, ndim)
    Coordinates of points to construct a convex hull from
incremental : bool, optional
    Allow adding new points incrementally. This takes up some additional
    resources.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual
    for details. (Default: "Qx" for ndim &gt; 4 and "" otherwise)
    Option "Qt" is always enabled.

Attributes
----------
points : ndarray of double, shape (npoints, ndim)
    Coordinates of input points.
vertices : ndarray of ints, shape (nvertices,)
    Indices of points forming the vertices of the convex hull.
    For 2-D convex hulls, the vertices are in counterclockwise order.
    For other dimensions, they are in input order.
simplices : ndarray of ints, shape (nfacet, ndim)
    Indices of points forming the simplical facets of the convex hull.
neighbors : ndarray of ints, shape (nfacet, ndim)
    Indices of neighbor facets for each facet.
    The kth neighbor is opposite to the kth vertex.
    -1 denotes no neighbor.
equations : ndarray of double, shape (nfacet, ndim+1)
    [normal, offset] forming the hyperplane equation of the facet
    (see `Qhull documentation &lt;http://www.qhull.org/&gt;`__  for more).
coplanar : ndarray of int, shape (ncoplanar, 3)
    Indices of coplanar points and the corresponding indices of
    the nearest facets and nearest vertex indices.  Coplanar
    points are input points which were *not* included in the
    triangulation due to numerical precision issues.

    If option "Qc" is not specified, this list is not computed.

Raises
------
QhullError
    Raised when Qhull encounters an error condition, such as
    geometrical degeneracy when options to resolve are not enabled.
ValueError
    Raised if an incompatible array is given as input.

Notes
-----
The convex hull is computed using the 
`Qhull library &lt;http://www.qhull.org/&gt;`__.

Do not call the ``add_points`` method from a ``__del__``
destructor.

Examples
--------

Convex hull of a random set of points:

&gt;&gt;&gt; from scipy.spatial import ConvexHull
&gt;&gt;&gt; points = np.random.rand(30, 2)   # 30 random points in 2-D
&gt;&gt;&gt; hull = ConvexHull(points)

Plot it:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(points[:,0], points[:,1], 'o')
&gt;&gt;&gt; for simplex in hull.simplices:
...     plt.plot(points[simplex, 0], points[simplex, 1], 'k-')

We could also have directly used the vertices of the hull, which
for 2-D are guaranteed to be in counterclockwise order:

&gt;&gt;&gt; plt.plot(points[hull.vertices,0], points[hull.vertices,1], 'r--', lw=2)
&gt;&gt;&gt; plt.plot(points[hull.vertices[0],0], points[hull.vertices[0],1], 'ro')
&gt;&gt;&gt; plt.show()

References
----------
.. [Qhull] http://www.qhull.org/</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="argument" name="points" port_type="basic:Integer" show_port="True">
      <docstring>Coordinates of points to construct a convex hull from</docstring>
    </inputPortSpec>
    <inputPortSpec arg="incremental" method_type="argument" name="incremental" port_type="basic:Boolean">
      <docstring>Allow adding new points incrementally. This takes up some additional
resources.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="qhull_options" method_type="argument" name="qhull_options">
      <docstring>Additional options to pass to Qhull. See Qhull manual
for details. (Default: "Qx" for ndim &gt; 4 and "" otherwise)
Option "Qt" is always enabled.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.ConvexHull" module_name="ConvexHullInspector" namespace="'spatial'">
    <docstring>ConvexHull(points, incremental=False, qhull_options=None)

Convex hulls in N dimensions.

.. versionadded:: 0.12.0

Parameters
----------
points : ndarray of floats, shape (npoints, ndim)
    Coordinates of points to construct a convex hull from
incremental : bool, optional
    Allow adding new points incrementally. This takes up some additional
    resources.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual
    for details. (Default: "Qx" for ndim &gt; 4 and "" otherwise)
    Option "Qt" is always enabled.

Attributes
----------
points : ndarray of double, shape (npoints, ndim)
    Coordinates of input points.
vertices : ndarray of ints, shape (nvertices,)
    Indices of points forming the vertices of the convex hull.
    For 2-D convex hulls, the vertices are in counterclockwise order.
    For other dimensions, they are in input order.
simplices : ndarray of ints, shape (nfacet, ndim)
    Indices of points forming the simplical facets of the convex hull.
neighbors : ndarray of ints, shape (nfacet, ndim)
    Indices of neighbor facets for each facet.
    The kth neighbor is opposite to the kth vertex.
    -1 denotes no neighbor.
equations : ndarray of double, shape (nfacet, ndim+1)
    [normal, offset] forming the hyperplane equation of the facet
    (see `Qhull documentation &lt;http://www.qhull.org/&gt;`__  for more).
coplanar : ndarray of int, shape (ncoplanar, 3)
    Indices of coplanar points and the corresponding indices of
    the nearest facets and nearest vertex indices.  Coplanar
    points are input points which were *not* included in the
    triangulation due to numerical precision issues.

    If option "Qc" is not specified, this list is not computed.

Raises
------
QhullError
    Raised when Qhull encounters an error condition, such as
    geometrical degeneracy when options to resolve are not enabled.
ValueError
    Raised if an incompatible array is given as input.

Notes
-----
The convex hull is computed using the 
`Qhull library &lt;http://www.qhull.org/&gt;`__.

Do not call the ``add_points`` method from a ``__del__``
destructor.

Examples
--------

Convex hull of a random set of points:

&gt;&gt;&gt; from scipy.spatial import ConvexHull
&gt;&gt;&gt; points = np.random.rand(30, 2)   # 30 random points in 2-D
&gt;&gt;&gt; hull = ConvexHull(points)

Plot it:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(points[:,0], points[:,1], 'o')
&gt;&gt;&gt; for simplex in hull.simplices:
...     plt.plot(points[simplex, 0], points[simplex, 1], 'k-')

We could also have directly used the vertices of the hull, which
for 2-D are guaranteed to be in counterclockwise order:

&gt;&gt;&gt; plt.plot(points[hull.vertices,0], points[hull.vertices,1], 'r--', lw=2)
&gt;&gt;&gt; plt.plot(points[hull.vertices[0],0], points[hull.vertices[0],1], 'ro')
&gt;&gt;&gt; plt.show()

References
----------
.. [Qhull] http://www.qhull.org/</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="attribute" name="points" port_type="basic:Integer" sort_key="1000">
      <docstring>Coordinates of input points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vertices" depth="1" method_type="attribute" name="vertices" port_type="basic:Integer" sort_key="1001">
      <docstring>Indices of points forming the vertices of the convex hull.
For 2-D convex hulls, the vertices are in counterclockwise order.
For other dimensions, they are in input order.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="simplices" depth="1" method_type="attribute" name="simplices" port_type="basic:Integer" sort_key="1002">
      <docstring>Indices of points forming the simplical facets of the convex hull.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="neighbors" depth="1" method_type="attribute" name="neighbors" port_type="basic:Integer" sort_key="1003">
      <docstring>Indices of neighbor facets for each facet.
The kth neighbor is opposite to the kth vertex.
-1 denotes no neighbor.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="equations" method_type="attribute" name="equations" port_type="basic:List" sort_key="1004">
      <docstring>[normal, offset] forming the hyperplane equation of the facet
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__  for more).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coplanar" depth="1" method_type="attribute" name="coplanar" port_type="basic:Integer" sort_key="1005">
      <docstring>Indices of coplanar points and the corresponding indices of
the nearest facets and nearest vertex indices.  Coplanar
points are input points which were *not* included in the
triangulation due to numerical precision issues.

If option "Qc" is not specified, this list is not computed.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="points" depth="1" method_type="attribute" name="points" port_type="basic:Integer" sort_key="1000">
      <docstring>Coordinates of input points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vertices" depth="1" method_type="attribute" name="vertices" port_type="basic:Integer" sort_key="1001">
      <docstring>Indices of points forming the vertices of the convex hull.
For 2-D convex hulls, the vertices are in counterclockwise order.
For other dimensions, they are in input order.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="simplices" depth="1" method_type="attribute" name="simplices" port_type="basic:Integer" sort_key="1002">
      <docstring>Indices of points forming the simplical facets of the convex hull.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="neighbors" depth="1" method_type="attribute" name="neighbors" port_type="basic:Integer" sort_key="1003">
      <docstring>Indices of neighbor facets for each facet.
The kth neighbor is opposite to the kth vertex.
-1 denotes no neighbor.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="equations" method_type="attribute" name="equations" port_type="basic:List" sort_key="1004">
      <docstring>[normal, offset] forming the hyperplane equation of the facet
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__  for more).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="coplanar" depth="1" method_type="attribute" name="coplanar" port_type="basic:Integer" sort_key="1005">
      <docstring>Indices of coplanar points and the corresponding indices of
the nearest facets and nearest vertex indices.  Coplanar
points are input points which were *not* included in the
triangulation due to numerical precision issues.

If option "Qc" is not specified, this list is not computed.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.Delaunay" module_name="Delaunay" namespace="'spatial'">
    <docstring>Delaunay(points, furthest_site=False, incremental=False, qhull_options=None)

Delaunay tesselation in N dimensions.

.. versionadded:: 0.9

Parameters
----------
points : ndarray of floats, shape (npoints, ndim)
    Coordinates of points to triangulate
furthest_site : bool, optional
    Whether to compute a furthest-site Delaunay triangulation.
    Default: False

    .. versionadded:: 0.12.0
incremental : bool, optional
    Allow adding new points incrementally. This takes up some additional
    resources.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual for
    details. Option "Qt" is always enabled.
    Default:"Qbb Qc Qz Qx" for ndim &gt; 4 and "Qbb Qc Qz" otherwise.
    Incremental mode omits "Qz".

    .. versionadded:: 0.12.0

Attributes
----------
points : ndarray of double, shape (npoints, ndim)
    Coordinates of input points.
simplices : ndarray of ints, shape (nsimplex, ndim+1)
    Indices of the points forming the simplices in the triangulation.
    For 2-D, the points are oriented counterclockwise.
neighbors : ndarray of ints, shape (nsimplex, ndim+1)
    Indices of neighbor simplices for each simplex.
    The kth neighbor is opposite to the kth vertex.
    For simplices at the boundary, -1 denotes no neighbor.
equations : ndarray of double, shape (nsimplex, ndim+2)
    [normal, offset] forming the hyperplane equation of the facet
    on the paraboloid
    (see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).
paraboloid_scale, paraboloid_shift : float
    Scale and shift for the extra paraboloid dimension
    (see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).
transform : ndarray of double, shape (nsimplex, ndim+1, ndim)
    Affine transform from ``x`` to the barycentric coordinates ``c``.
    This is defined by::

        T c = x - r

    At vertex ``j``, ``c_j = 1`` and the other coordinates zero.

    For simplex ``i``, ``transform[i,:ndim,:ndim]`` contains
    inverse of the matrix ``T``, and ``transform[i,ndim,:]``
    contains the vector ``r``.

    If the simplex is degenerate or nearly degenerate, its
    barycentric transform contains NaNs.
vertex_to_simplex : ndarray of int, shape (npoints,)
    Lookup array, from a vertex, to some simplex which it is a part of.
    If qhull option "Qc" was not specified, the list will contain -1
    for points that are not vertices of the tesselation.
convex_hull : ndarray of int, shape (nfaces, ndim)
    Vertices of facets forming the convex hull of the point set.
    The array contains the indices of the points belonging to
    the (N-1)-dimensional facets that form the convex hull
    of the triangulation.

    .. note::

       Computing convex hulls via the Delaunay triangulation is
       inefficient and subject to increased numerical instability.
       Use `ConvexHull` instead.
coplanar : ndarray of int, shape (ncoplanar, 3)
    Indices of coplanar points and the corresponding indices of
    the nearest facet and the nearest vertex.  Coplanar
    points are input points which were *not* included in the
    triangulation due to numerical precision issues.

    If option "Qc" is not specified, this list is not computed.

    .. versionadded:: 0.12.0
vertices
    Same as `simplices`, but deprecated.
vertex_neighbor_vertices : tuple of two ndarrays of int; (indices, indptr)
    Neighboring vertices of vertices. The indices of neighboring
    vertices of vertex `k` are ``indptr[indices[k]:indices[k+1]]``.

Raises
------
QhullError
    Raised when Qhull encounters an error condition, such as
    geometrical degeneracy when options to resolve are not enabled.
ValueError
    Raised if an incompatible array is given as input.

Notes
-----
The tesselation is computed using the Qhull library 
`Qhull library &lt;http://www.qhull.org/&gt;`__.

.. note::

   Unless you pass in the Qhull option "QJ", Qhull does not
   guarantee that each input point appears as a vertex in the
   Delaunay triangulation. Omitted points are listed in the
   `coplanar` attribute.

Do not call the ``add_points`` method from a ``__del__``
destructor.

Examples
--------
Triangulation of a set of points:

&gt;&gt;&gt; points = np.array([[0, 0], [0, 1.1], [1, 0], [1, 1]])
&gt;&gt;&gt; from scipy.spatial import Delaunay
&gt;&gt;&gt; tri = Delaunay(points)

We can plot it:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.triplot(points[:,0], points[:,1], tri.simplices.copy())
&gt;&gt;&gt; plt.plot(points[:,0], points[:,1], 'o')
&gt;&gt;&gt; plt.show()

Point indices and coordinates for the two triangles forming the
triangulation:

&gt;&gt;&gt; tri.simplices
array([[3, 2, 0],
       [3, 1, 0]], dtype=int32)
&gt;&gt;&gt; points[tri.simplices]
array([[[ 1. ,  1. ],
        [ 1. ,  0. ],
        [ 0. ,  0. ]],
       [[ 1. ,  1. ],
        [ 0. ,  1.1],
        [ 0. ,  0. ]]])

Triangle 0 is the only neighbor of triangle 1, and it's opposite to
vertex 1 of triangle 1:

&gt;&gt;&gt; tri.neighbors[1]
array([-1,  0, -1], dtype=int32)
&gt;&gt;&gt; points[tri.simplices[1,1]]
array([ 0. ,  1.1])

We can find out which triangle points are in:

&gt;&gt;&gt; p = np.array([(0.1, 0.2), (1.5, 0.5)])
&gt;&gt;&gt; tri.find_simplex(p)
array([ 1, -1], dtype=int32)

We can also compute barycentric coordinates in triangle 1 for
these points:

&gt;&gt;&gt; b = tri.transform[1,:2].dot(p - tri.transform[1,2])
&gt;&gt;&gt; np.c_[b, 1 - b.sum(axis=1)]
array([[ 0.1       ,  0.2       ,  0.7       ],
       [ 1.27272727,  0.27272727, -0.54545455]])

The coordinates for the first point are all positive, meaning it
is indeed inside the triangle.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="argument" name="points" port_type="basic:Integer" show_port="True">
      <docstring>Coordinates of points to triangulate</docstring>
    </inputPortSpec>
    <inputPortSpec arg="furthest_site" method_type="argument" name="furthest_site" port_type="basic:Boolean">
      <docstring>Whether to compute a furthest-site Delaunay triangulation.
Default: False

.. versionadded:: 0.12.0</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="incremental" method_type="argument" name="incremental" port_type="basic:Boolean">
      <docstring>Allow adding new points incrementally. This takes up some additional
resources.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="qhull_options" method_type="argument" name="qhull_options">
      <docstring>Additional options to pass to Qhull. See Qhull manual for
details. Option "Qt" is always enabled.
Default:"Qbb Qc Qz Qx" for ndim &gt; 4 and "Qbb Qc Qz" otherwise.
Incremental mode omits "Qz".

.. versionadded:: 0.12.0</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.Delaunay" module_name="DelaunayInspector" namespace="'spatial'">
    <docstring>Delaunay(points, furthest_site=False, incremental=False, qhull_options=None)

Delaunay tesselation in N dimensions.

.. versionadded:: 0.9

Parameters
----------
points : ndarray of floats, shape (npoints, ndim)
    Coordinates of points to triangulate
furthest_site : bool, optional
    Whether to compute a furthest-site Delaunay triangulation.
    Default: False

    .. versionadded:: 0.12.0
incremental : bool, optional
    Allow adding new points incrementally. This takes up some additional
    resources.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual for
    details. Option "Qt" is always enabled.
    Default:"Qbb Qc Qz Qx" for ndim &gt; 4 and "Qbb Qc Qz" otherwise.
    Incremental mode omits "Qz".

    .. versionadded:: 0.12.0

Attributes
----------
points : ndarray of double, shape (npoints, ndim)
    Coordinates of input points.
simplices : ndarray of ints, shape (nsimplex, ndim+1)
    Indices of the points forming the simplices in the triangulation.
    For 2-D, the points are oriented counterclockwise.
neighbors : ndarray of ints, shape (nsimplex, ndim+1)
    Indices of neighbor simplices for each simplex.
    The kth neighbor is opposite to the kth vertex.
    For simplices at the boundary, -1 denotes no neighbor.
equations : ndarray of double, shape (nsimplex, ndim+2)
    [normal, offset] forming the hyperplane equation of the facet
    on the paraboloid
    (see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).
paraboloid_scale, paraboloid_shift : float
    Scale and shift for the extra paraboloid dimension
    (see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).
transform : ndarray of double, shape (nsimplex, ndim+1, ndim)
    Affine transform from ``x`` to the barycentric coordinates ``c``.
    This is defined by::

        T c = x - r

    At vertex ``j``, ``c_j = 1`` and the other coordinates zero.

    For simplex ``i``, ``transform[i,:ndim,:ndim]`` contains
    inverse of the matrix ``T``, and ``transform[i,ndim,:]``
    contains the vector ``r``.

    If the simplex is degenerate or nearly degenerate, its
    barycentric transform contains NaNs.
vertex_to_simplex : ndarray of int, shape (npoints,)
    Lookup array, from a vertex, to some simplex which it is a part of.
    If qhull option "Qc" was not specified, the list will contain -1
    for points that are not vertices of the tesselation.
convex_hull : ndarray of int, shape (nfaces, ndim)
    Vertices of facets forming the convex hull of the point set.
    The array contains the indices of the points belonging to
    the (N-1)-dimensional facets that form the convex hull
    of the triangulation.

    .. note::

       Computing convex hulls via the Delaunay triangulation is
       inefficient and subject to increased numerical instability.
       Use `ConvexHull` instead.
coplanar : ndarray of int, shape (ncoplanar, 3)
    Indices of coplanar points and the corresponding indices of
    the nearest facet and the nearest vertex.  Coplanar
    points are input points which were *not* included in the
    triangulation due to numerical precision issues.

    If option "Qc" is not specified, this list is not computed.

    .. versionadded:: 0.12.0
vertices
    Same as `simplices`, but deprecated.
vertex_neighbor_vertices : tuple of two ndarrays of int; (indices, indptr)
    Neighboring vertices of vertices. The indices of neighboring
    vertices of vertex `k` are ``indptr[indices[k]:indices[k+1]]``.

Raises
------
QhullError
    Raised when Qhull encounters an error condition, such as
    geometrical degeneracy when options to resolve are not enabled.
ValueError
    Raised if an incompatible array is given as input.

Notes
-----
The tesselation is computed using the Qhull library 
`Qhull library &lt;http://www.qhull.org/&gt;`__.

.. note::

   Unless you pass in the Qhull option "QJ", Qhull does not
   guarantee that each input point appears as a vertex in the
   Delaunay triangulation. Omitted points are listed in the
   `coplanar` attribute.

Do not call the ``add_points`` method from a ``__del__``
destructor.

Examples
--------
Triangulation of a set of points:

&gt;&gt;&gt; points = np.array([[0, 0], [0, 1.1], [1, 0], [1, 1]])
&gt;&gt;&gt; from scipy.spatial import Delaunay
&gt;&gt;&gt; tri = Delaunay(points)

We can plot it:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.triplot(points[:,0], points[:,1], tri.simplices.copy())
&gt;&gt;&gt; plt.plot(points[:,0], points[:,1], 'o')
&gt;&gt;&gt; plt.show()

Point indices and coordinates for the two triangles forming the
triangulation:

&gt;&gt;&gt; tri.simplices
array([[3, 2, 0],
       [3, 1, 0]], dtype=int32)
&gt;&gt;&gt; points[tri.simplices]
array([[[ 1. ,  1. ],
        [ 1. ,  0. ],
        [ 0. ,  0. ]],
       [[ 1. ,  1. ],
        [ 0. ,  1.1],
        [ 0. ,  0. ]]])

Triangle 0 is the only neighbor of triangle 1, and it's opposite to
vertex 1 of triangle 1:

&gt;&gt;&gt; tri.neighbors[1]
array([-1,  0, -1], dtype=int32)
&gt;&gt;&gt; points[tri.simplices[1,1]]
array([ 0. ,  1.1])

We can find out which triangle points are in:

&gt;&gt;&gt; p = np.array([(0.1, 0.2), (1.5, 0.5)])
&gt;&gt;&gt; tri.find_simplex(p)
array([ 1, -1], dtype=int32)

We can also compute barycentric coordinates in triangle 1 for
these points:

&gt;&gt;&gt; b = tri.transform[1,:2].dot(p - tri.transform[1,2])
&gt;&gt;&gt; np.c_[b, 1 - b.sum(axis=1)]
array([[ 0.1       ,  0.2       ,  0.7       ],
       [ 1.27272727,  0.27272727, -0.54545455]])

The coordinates for the first point are all positive, meaning it
is indeed inside the triangle.</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="attribute" name="points" port_type="basic:Integer" sort_key="1000">
      <docstring>Coordinates of input points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="simplices" depth="1" method_type="attribute" name="simplices" port_type="basic:Integer" sort_key="1001">
      <docstring>Indices of the points forming the simplices in the triangulation.
For 2-D, the points are oriented counterclockwise.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="neighbors" depth="1" method_type="attribute" name="neighbors" port_type="basic:Integer" sort_key="1002">
      <docstring>Indices of neighbor simplices for each simplex.
The kth neighbor is opposite to the kth vertex.
For simplices at the boundary, -1 denotes no neighbor.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="equations" method_type="attribute" name="equations" port_type="basic:List" sort_key="1003">
      <docstring>[normal, offset] forming the hyperplane equation of the facet
on the paraboloid
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="paraboloid_scale" method_type="attribute" name="paraboloid_scale" port_type="basic:Float" sort_key="1004">
      <docstring>Scale and shift for the extra paraboloid dimension
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="paraboloid_shift" method_type="attribute" name="paraboloid_shift" port_type="basic:Float" sort_key="1005">
      <docstring>Scale and shift for the extra paraboloid dimension
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).</docstring>
    </inputPortSpec>
    <inputPortSpec arg="transform" method_type="attribute" name="transform" port_type="basic:List" sort_key="1006">
      <docstring>Affine transform from ``x`` to the barycentric coordinates ``c``.
This is defined by::

    T c = x - r

At vertex ``j``, ``c_j = 1`` and the other coordinates zero.

For simplex ``i``, ``transform[i,:ndim,:ndim]`` contains
inverse of the matrix ``T``, and ``transform[i,ndim,:]``
contains the vector ``r``.

If the simplex is degenerate or nearly degenerate, its
barycentric transform contains NaNs.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vertex_to_simplex" depth="1" method_type="attribute" name="vertex_to_simplex" port_type="basic:Integer" sort_key="1007">
      <docstring>Lookup array, from a vertex, to some simplex which it is a part of.
If qhull option "Qc" was not specified, the list will contain -1
for points that are not vertices of the tesselation.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="convex_hull" depth="1" method_type="attribute" name="convex_hull" port_type="basic:Integer" sort_key="1008">
      <docstring>Vertices of facets forming the convex hull of the point set.

:type: ndarray of int, shape (nfaces, ndim)

The array contains the indices of the points
belonging to the (N-1)-dimensional facets that form the convex
hull of the triangulation.

.. note::

   Computing convex hulls via the Delaunay triangulation is
   inefficient and subject to increased numerical instability.
   Use `ConvexHull` instead.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="coplanar" depth="1" method_type="attribute" name="coplanar" port_type="basic:Integer" sort_key="1009">
      <docstring>Indices of coplanar points and the corresponding indices of
the nearest facet and the nearest vertex.  Coplanar
points are input points which were *not* included in the
triangulation due to numerical precision issues.

If option "Qc" is not specified, this list is not computed.

.. versionadded:: 0.12.0</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vertices" method_type="attribute" name="vertices" port_type="basic:Variant" sort_key="1010">
      <docstring>Same as `simplices`, but deprecated.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vertex_neighbor_vertices" depth="1" method_type="attribute" name="vertex_neighbor_vertices" port_type="basic:Integer" sort_key="1011">
      <docstring>Neighboring vertices of vertices.

Tuple of two ndarrays of int: (indices, indptr). The indices of
neighboring vertices of vertex `k` are
``indptr[indices[k]:indices[k+1]]``.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="points" depth="1" method_type="attribute" name="points" port_type="basic:Integer" sort_key="1000">
      <docstring>Coordinates of input points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="simplices" depth="1" method_type="attribute" name="simplices" port_type="basic:Integer" sort_key="1001">
      <docstring>Indices of the points forming the simplices in the triangulation.
For 2-D, the points are oriented counterclockwise.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="neighbors" depth="1" method_type="attribute" name="neighbors" port_type="basic:Integer" sort_key="1002">
      <docstring>Indices of neighbor simplices for each simplex.
The kth neighbor is opposite to the kth vertex.
For simplices at the boundary, -1 denotes no neighbor.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="equations" method_type="attribute" name="equations" port_type="basic:List" sort_key="1003">
      <docstring>[normal, offset] forming the hyperplane equation of the facet
on the paraboloid
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="paraboloid_scale" method_type="attribute" name="paraboloid_scale" port_type="basic:Float" sort_key="1004">
      <docstring>Scale and shift for the extra paraboloid dimension
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="paraboloid_shift" method_type="attribute" name="paraboloid_shift" port_type="basic:Float" sort_key="1005">
      <docstring>Scale and shift for the extra paraboloid dimension
(see `Qhull documentation &lt;http://www.qhull.org/&gt;`__ for more).</docstring>
    </outputPortSpec>
    <outputPortSpec arg="transform" method_type="attribute" name="transform" port_type="basic:List" sort_key="1006">
      <docstring>Affine transform from ``x`` to the barycentric coordinates ``c``.
This is defined by::

    T c = x - r

At vertex ``j``, ``c_j = 1`` and the other coordinates zero.

For simplex ``i``, ``transform[i,:ndim,:ndim]`` contains
inverse of the matrix ``T``, and ``transform[i,ndim,:]``
contains the vector ``r``.

If the simplex is degenerate or nearly degenerate, its
barycentric transform contains NaNs.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vertex_to_simplex" depth="1" method_type="attribute" name="vertex_to_simplex" port_type="basic:Integer" sort_key="1007">
      <docstring>Lookup array, from a vertex, to some simplex which it is a part of.
If qhull option "Qc" was not specified, the list will contain -1
for points that are not vertices of the tesselation.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="convex_hull" depth="1" method_type="attribute" name="convex_hull" port_type="basic:Integer" sort_key="1008">
      <docstring>Vertices of facets forming the convex hull of the point set.

:type: ndarray of int, shape (nfaces, ndim)

The array contains the indices of the points
belonging to the (N-1)-dimensional facets that form the convex
hull of the triangulation.

.. note::

   Computing convex hulls via the Delaunay triangulation is
   inefficient and subject to increased numerical instability.
   Use `ConvexHull` instead.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="coplanar" depth="1" method_type="attribute" name="coplanar" port_type="basic:Integer" sort_key="1009">
      <docstring>Indices of coplanar points and the corresponding indices of
the nearest facet and the nearest vertex.  Coplanar
points are input points which were *not* included in the
triangulation due to numerical precision issues.

If option "Qc" is not specified, this list is not computed.

.. versionadded:: 0.12.0</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vertices" method_type="attribute" name="vertices" port_type="basic:Variant" sort_key="1010">
      <docstring>Same as `simplices`, but deprecated.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vertex_neighbor_vertices" depth="1" method_type="attribute" name="vertex_neighbor_vertices" port_type="basic:Integer" sort_key="1011">
      <docstring>Neighboring vertices of vertices.

Tuple of two ndarrays of int: (indices, indptr). The indices of
neighboring vertices of vertex `k` are
``indptr[indices[k]:indices[k+1]]``.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.KDTree" module_name="KDTree" namespace="'spatial'">
    <docstring>kd-tree for quick nearest-neighbor lookup

This class provides an index into a set of k-dimensional points which
can be used to rapidly look up the nearest neighbors of any point.

Parameters
----------
data : (N,K) array_like
    The data points to be indexed. This array is not copied, and
    so modifying this data will result in bogus results.
leafsize : int, optional
    The number of points at which the algorithm switches over to
    brute-force.  Has to be positive.

Raises
------
RuntimeError
    The maximum recursion limit can be exceeded for large data
    sets.  If this happens, either increase the value for the `leafsize`
    parameter or increase the recursion limit by::

        &gt;&gt;&gt; import sys
        &gt;&gt;&gt; sys.setrecursionlimit(10000)

Notes
-----
The algorithm used is described in Maneewongvatana and Mount 1999.
The general idea is that the kd-tree is a binary tree, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.

During construction, the axis and splitting point are chosen by the
"sliding midpoint" rule, which ensures that the cells do not all
become long and thin.

The tree can be queried for the r closest neighbors of any given point
(optionally returning only those within some maximum distance of the
point). It can also be queried, with a substantial gain in efficiency,
for the r approximate closest neighbors.

For large dimensions (20 is already large) do not expect this to run
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.

The tree also supports all-neighbors queries, both with arrays of points
and with other kd-trees. These do use a reasonably efficient algorithm,
but the kd-tree is not necessarily the best data structure for this
sort of calculation.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="argument" name="data" port_type="basic:List" show_port="True">
      <docstring>The data points to be indexed. This array is not copied, and
so modifying this data will result in bogus results.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="leafsize" method_type="argument" name="leafsize" port_type="basic:Integer">
      <docstring>The number of points at which the algorithm switches over to
brute-force.  Has to be positive.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.Rectangle" module_name="Rectangle" namespace="'spatial'">
    <docstring>Hyperrectangle class.

Represents a Cartesian product of intervals.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mins" method_type="argument" name="mins" port_type="basic:Variant" show_port="True" />
    <inputPortSpec arg="maxes" method_type="argument" name="maxes" port_type="basic:Variant" show_port="True" />
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.Voronoi" module_name="Voronoi" namespace="'spatial'">
    <docstring>Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)

Voronoi diagrams in N dimensions.

.. versionadded:: 0.12.0

Parameters
----------
points : ndarray of floats, shape (npoints, ndim)
    Coordinates of points to construct a convex hull from
furthest_site : bool, optional
    Whether to compute a furthest-site Voronoi diagram. Default: False
incremental : bool, optional
    Allow adding new points incrementally. This takes up some additional
    resources.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual
    for details. (Default: "Qbb Qc Qz Qx" for ndim &gt; 4 and
    "Qbb Qc Qz" otherwise. Incremental mode omits "Qz".)

Attributes
----------
points : ndarray of double, shape (npoints, ndim)
    Coordinates of input points.
vertices : ndarray of double, shape (nvertices, ndim)
    Coordinates of the Voronoi vertices.
ridge_points : ndarray of ints, shape ``(nridges, 2)``
    Indices of the points between which each Voronoi ridge lies.
ridge_vertices : list of list of ints, shape ``(nridges, *)``
    Indices of the Voronoi vertices forming each Voronoi ridge.
regions : list of list of ints, shape ``(nregions, *)``
    Indices of the Voronoi vertices forming each Voronoi region.
    -1 indicates vertex outside the Voronoi diagram.
point_region : list of ints, shape (npoints)
    Index of the Voronoi region for each input point.
    If qhull option "Qc" was not specified, the list will contain -1
    for points that are not associated with a Voronoi region.

Raises
------
QhullError
    Raised when Qhull encounters an error condition, such as
    geometrical degeneracy when options to resolve are not enabled.
ValueError
    Raised if an incompatible array is given as input.

Notes
-----
The Voronoi diagram is computed using the 
`Qhull library &lt;http://www.qhull.org/&gt;`__.

Do not call the ``add_points`` method from a ``__del__``
destructor.

Examples
--------
Voronoi diagram for a set of point:

&gt;&gt;&gt; points = np.array([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2],
...                    [2, 0], [2, 1], [2, 2]])
&gt;&gt;&gt; from scipy.spatial import Voronoi, voronoi_plot_2d
&gt;&gt;&gt; vor = Voronoi(points)

Plot it:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; voronoi_plot_2d(vor)
&gt;&gt;&gt; plt.show()

The Voronoi vertices:

&gt;&gt;&gt; vor.vertices
array([[ 0.5,  0.5],
       [ 1.5,  0.5],
       [ 0.5,  1.5],
       [ 1.5,  1.5]])

There is a single finite Voronoi region, and four finite Voronoi
ridges:

&gt;&gt;&gt; vor.regions
[[], [-1, 0], [-1, 1], [1, -1, 0], [3, -1, 2], [-1, 3], [-1, 2], [3, 2, 0, 1], [2, -1, 0], [3, -1, 1]]
&gt;&gt;&gt; vor.ridge_vertices
[[-1, 0], [-1, 0], [-1, 1], [-1, 1], [0, 1], [-1, 3], [-1, 2], [2, 3], [-1, 3], [-1, 2], [0, 2], [1, 3]]

The ridges are perpendicular between lines drawn between the following
input points:

&gt;&gt;&gt; vor.ridge_points
array([[0, 1],
       [0, 3],
       [6, 3],
       [6, 7],
       [3, 4],
       [5, 8],
       [5, 2],
       [5, 4],
       [8, 7],
       [2, 1],
       [4, 1],
       [4, 7]], dtype=int32)</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="argument" name="points" port_type="basic:Integer" show_port="True">
      <docstring>Coordinates of points to construct a convex hull from</docstring>
    </inputPortSpec>
    <inputPortSpec arg="furthest_site" method_type="argument" name="furthest_site" port_type="basic:Boolean">
      <docstring>Whether to compute a furthest-site Voronoi diagram. Default: False</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="incremental" method_type="argument" name="incremental" port_type="basic:Boolean">
      <docstring>Allow adding new points incrementally. This takes up some additional
resources.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="qhull_options" method_type="argument" name="qhull_options">
      <docstring>Additional options to pass to Qhull. See Qhull manual
for details. (Default: "Qbb Qc Qz Qx" for ndim &gt; 4 and
"Qbb Qc Qz" otherwise. Incremental mode omits "Qz".)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.Voronoi" module_name="VoronoiInspector" namespace="'spatial'">
    <docstring>Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)

Voronoi diagrams in N dimensions.

.. versionadded:: 0.12.0

Parameters
----------
points : ndarray of floats, shape (npoints, ndim)
    Coordinates of points to construct a convex hull from
furthest_site : bool, optional
    Whether to compute a furthest-site Voronoi diagram. Default: False
incremental : bool, optional
    Allow adding new points incrementally. This takes up some additional
    resources.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual
    for details. (Default: "Qbb Qc Qz Qx" for ndim &gt; 4 and
    "Qbb Qc Qz" otherwise. Incremental mode omits "Qz".)

Attributes
----------
points : ndarray of double, shape (npoints, ndim)
    Coordinates of input points.
vertices : ndarray of double, shape (nvertices, ndim)
    Coordinates of the Voronoi vertices.
ridge_points : ndarray of ints, shape ``(nridges, 2)``
    Indices of the points between which each Voronoi ridge lies.
ridge_vertices : list of list of ints, shape ``(nridges, *)``
    Indices of the Voronoi vertices forming each Voronoi ridge.
regions : list of list of ints, shape ``(nregions, *)``
    Indices of the Voronoi vertices forming each Voronoi region.
    -1 indicates vertex outside the Voronoi diagram.
point_region : list of ints, shape (npoints)
    Index of the Voronoi region for each input point.
    If qhull option "Qc" was not specified, the list will contain -1
    for points that are not associated with a Voronoi region.

Raises
------
QhullError
    Raised when Qhull encounters an error condition, such as
    geometrical degeneracy when options to resolve are not enabled.
ValueError
    Raised if an incompatible array is given as input.

Notes
-----
The Voronoi diagram is computed using the 
`Qhull library &lt;http://www.qhull.org/&gt;`__.

Do not call the ``add_points`` method from a ``__del__``
destructor.

Examples
--------
Voronoi diagram for a set of point:

&gt;&gt;&gt; points = np.array([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2],
...                    [2, 0], [2, 1], [2, 2]])
&gt;&gt;&gt; from scipy.spatial import Voronoi, voronoi_plot_2d
&gt;&gt;&gt; vor = Voronoi(points)

Plot it:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; voronoi_plot_2d(vor)
&gt;&gt;&gt; plt.show()

The Voronoi vertices:

&gt;&gt;&gt; vor.vertices
array([[ 0.5,  0.5],
       [ 1.5,  0.5],
       [ 0.5,  1.5],
       [ 1.5,  1.5]])

There is a single finite Voronoi region, and four finite Voronoi
ridges:

&gt;&gt;&gt; vor.regions
[[], [-1, 0], [-1, 1], [1, -1, 0], [3, -1, 2], [-1, 3], [-1, 2], [3, 2, 0, 1], [2, -1, 0], [3, -1, 1]]
&gt;&gt;&gt; vor.ridge_vertices
[[-1, 0], [-1, 0], [-1, 1], [-1, 1], [0, 1], [-1, 3], [-1, 2], [2, 3], [-1, 3], [-1, 2], [0, 2], [1, 3]]

The ridges are perpendicular between lines drawn between the following
input points:

&gt;&gt;&gt; vor.ridge_points
array([[0, 1],
       [0, 3],
       [6, 3],
       [6, 7],
       [3, 4],
       [5, 8],
       [5, 2],
       [5, 4],
       [8, 7],
       [2, 1],
       [4, 1],
       [4, 7]], dtype=int32)</docstring>
    <inputPortSpec arg="Instance" max_conns="1" method_type="Instance" min_conns="1" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="points" depth="1" method_type="attribute" name="points" port_type="basic:Integer" sort_key="1000">
      <docstring>Coordinates of input points.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vertices" method_type="attribute" name="vertices" port_type="basic:List" sort_key="1001">
      <docstring>Coordinates of the Voronoi vertices.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ridge_points" depth="1" method_type="attribute" name="ridge_points" port_type="basic:Integer" sort_key="1002">
      <docstring>Indices of the points between which each Voronoi ridge lies.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ridge_vertices" depth="1" method_type="attribute" name="ridge_vertices" port_type="basic:Integer" sort_key="1003">
      <docstring>Indices of the Voronoi vertices forming each Voronoi ridge.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="regions" depth="1" method_type="attribute" name="regions" port_type="basic:Integer" sort_key="1004">
      <docstring>Indices of the Voronoi vertices forming each Voronoi region.
-1 indicates vertex outside the Voronoi diagram.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="point_region" depth="1" method_type="attribute" name="point_region" port_type="basic:Integer" sort_key="1005">
      <docstring>Index of the Voronoi region for each input point.
If qhull option "Qc" was not specified, the list will contain -1
for points that are not associated with a Voronoi region.</docstring>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
    <outputPortSpec arg="points" depth="1" method_type="attribute" name="points" port_type="basic:Integer" sort_key="1000">
      <docstring>Coordinates of input points.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="vertices" method_type="attribute" name="vertices" port_type="basic:List" sort_key="1001">
      <docstring>Coordinates of the Voronoi vertices.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ridge_points" depth="1" method_type="attribute" name="ridge_points" port_type="basic:Integer" sort_key="1002">
      <docstring>Indices of the points between which each Voronoi ridge lies.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="ridge_vertices" depth="1" method_type="attribute" name="ridge_vertices" port_type="basic:Integer" sort_key="1003">
      <docstring>Indices of the Voronoi vertices forming each Voronoi ridge.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="regions" depth="1" method_type="attribute" name="regions" port_type="basic:Integer" sort_key="1004">
      <docstring>Indices of the Voronoi vertices forming each Voronoi region.
-1 indicates vertex outside the Voronoi diagram.</docstring>
    </outputPortSpec>
    <outputPortSpec arg="point_region" depth="1" method_type="attribute" name="point_region" port_type="basic:Integer" sort_key="1005">
      <docstring>Index of the Voronoi region for each input point.
If qhull option "Qc" was not specified, the list will contain -1
for points that are not associated with a Voronoi region.</docstring>
    </outputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="scipy.spatial.cKDTree" module_name="cKDTree" namespace="'spatial'">
    <docstring>cKDTree(data, leafsize=16, compact_nodes=True, copy_data=False,
        balanced_tree=True)

kd-tree for quick nearest-neighbor lookup

This class provides an index into a set of k-dimensional points
which can be used to rapidly look up the nearest neighbors of any
point. 

The algorithm used is described in Maneewongvatana and Mount 1999. 
The general idea is that the kd-tree is a binary trie, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value. 

During construction, the axis and splitting point are chosen by the 
"sliding midpoint" rule, which ensures that the cells do not all
become long and thin. 

The tree can be queried for the r closest neighbors of any given point 
(optionally returning only those within some maximum distance of the 
point). It can also be queried, with a substantial gain in efficiency, 
for the r approximate closest neighbors.

For large dimensions (20 is already large) do not expect this to run 
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.

Parameters
----------
data : array_like, shape (n,m)
    The n data points of dimension m to be indexed. This array is 
    not copied unless this is necessary to produce a contiguous 
    array of doubles, and so modifying this data will result in 
    bogus results. The data are also copied if the kd-tree is built
    with copy_data=True.
leafsize : positive int, optional
    The number of points at which the algorithm switches over to
    brute-force. Default: 16.
compact_nodes : bool, optional    
    If True, the kd-tree is built to shrink the hyperrectangles to
    the actual data range. This usually gives a more compact tree and 
    faster queries at the expense of longer build time. Default: True.
copy_data : bool, optional
    If True the data is always copied to protect the kd-tree against 
    data corruption. Default: False.
balanced_tree : bool, optional    
    If True, the median is used to split the hyperrectangles instead of 
    the midpoint. This usually gives a more compact tree and 
    faster queries at the expense of longer build time. Default: True.</docstring>
    <inputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List">
      <docstring>The class instance to use (constructor will not be called)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" method_type="argument" name="data" port_type="basic:List" show_port="True">
      <docstring>The n data points of dimension m to be indexed. This array is 
not copied unless this is necessary to produce a contiguous 
array of doubles, and so modifying this data will result in 
bogus results. The data are also copied if the kd-tree is built
with copy_data=True.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="leafsize" method_type="argument" name="leafsize" port_type="basic:Integer">
      <docstring>The number of points at which the algorithm switches over to
brute-force. Default: 16.</docstring>
      <defaults>[16]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="compact_nodes" method_type="argument" name="compact_nodes" port_type="basic:Boolean">
      <docstring>If True, the kd-tree is built to shrink the hyperrectangles to
the actual data range. This usually gives a more compact tree and 
faster queries at the expense of longer build time. Default: True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="copy_data" method_type="argument" name="copy_data" port_type="basic:Boolean">
      <docstring>If True the data is always copied to protect the kd-tree against 
data corruption. Default: False.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="balanced_tree" method_type="argument" name="balanced_tree" port_type="basic:Boolean">
      <docstring>If True, the median is used to split the hyperrectangles instead of 
the midpoint. This usually gives a more compact tree and 
faster queries at the expense of longer build time. Default: True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="Instance" method_type="Instance" name="Instance" port_type="basic:List" show_port="True">
      <docstring>The class instance</docstring>
    </outputPortSpec>
  </moduleSpec>
</specs>
