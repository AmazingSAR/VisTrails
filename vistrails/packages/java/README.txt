# Generation of VisTrails modules from a Java library

Using the Jython version of Python, it is easy to wrap existing Java libraries and framework as VisTrails module, which can be added graphically to a pipeline. Because Java classes can be loaded and used seamlessly, it is only a matter of listing the modules and their ports and mapping them to classes and methods. However, for big Java packages, writing these mapping by hand is unacceptable.

This module implements automatic analysis of a Java library to create the corresponding VisTrails modules automatically.


# Approach

The Java language provides reflection facilities (java.lang.reflect) that allows to access the inheritance hierarchy of a class and the list of its methods with their return type and parameters. I chose to use these directly instead of Python's facilities, as Python has no notion of method overloading of static typing.

This is implemented in javareflect.py


# Source-code

Only one thing is missing from the .class file and thus cannot be obtained through Java's reflection facilities: the name of the parameters of a method. These are not fundamental to be able to emit VisTrails module, but if stub names are to be avoided (eg 'arg0', 'arg1', ...) for the input port names, these are rather important. Therefore, a simple Java parser has been written, that is able to extract the parameter names of every method from the source code of the library. This information is used when walking over the class files.

This is implemented in javaparser.py


# Generated modules

The following details of the Java language are problematic when translating to VisTrails modules:

  * Methods can be overloaded (even with same number of parameters)
  * Constructors can be overloaded
  * Classes can have static methods
  * Template type parameters (for a class, a parent class, a return/parameter type or a method)

These points leads to more VisTrails Module's than the initial Java classes.

A base Module called WekaBaseModule is used as an abstract base for all the autogenerated modules.

For each Java class 'NameOfTheClass', the following modules are generated:

  * NameOfTheClass: the base module, that also represent this type for VisTrails (i.e. ports can have type 'NameOfTheClass'). It only has the output ports constructed from the getters and is declared abstract. It inherits from the ParentClass module, or WekaBaseModule if the parent class is Object.
  * NameOfTheClass_get: a module used to call getters on a Java object. It inherits from the NameOfTheClass module, and has a single input port 'self'. It is not abstract. I don't think this functionality exists in the VTK package, so it might not be useful here either.
  * NameOfTheClass_N where N is a number: a module used to create an object. These are the main modules, inheriting from NameOfTheClass; one is created for each constructor of the Java class. It has input ports for all the constructor parameters and one for each setter, and a 'self' output port.
  * NameOfTheClass_someMethod: modules created for static methods, where someMethod is the name of the method. Does not inherit from NameOfTheClass, but directly from WekaBaseModule, as these modules don't necessarily return an object of this class.

The generation of the modules (through the type() builtin function) and their adding to the registry is done in module_generator.py


# Runtime

The implemented modules use mixins that provide the execution logic: ConstructorModuleMixin and GetterModuleMixin, defined in modules_runtime.py. The executing relies on class attributes that are added during the module generation as follows:

NameOfClass:
  (defined with type() in _create_module)
  _classloader = <URLClassLoader(...)>
  _classname = u'NameOfClass'
  (added in _populate_modules)
  _setters = set([u'setFoo', u'setBar'])
  _getters = set([u'getFoo', u'getBar'])
NameOfClass_get:
  (nothing here)
NameOfClass_1:
  _ctor_params = array(java.lang.Class, [
          (u'int[]', 'arg0'),
          (u'javax.swing.JLabel', 'arg1')])


# Issues

  * All modules are cacheable. While this shouldn't be a problem if methods don't have side-effects on other objects, it could be an issue with classes that show something (i.e. create a GUI) or some static methods.
  * It is not possible to obtain an object from a static method of a getter and call setters on it (unless a copy constructor is available).
  * While this module should be compatible with JPype, the analysis part (i.e. when the pickle cache file does not exist) does not work because of issues with reflection in JPype. If weka-methods.pickle is available, execution through JPype is functional.
