<specs>
  <customCode />
  <moduleSpec code_ref="matplotlib.pyplot.acorr" name="MplAcorr" output_type="tuple" superclass="MplPlot">
    <docstring>Plot the autocorrelation of `x`.

Parameters
----------

x : sequence of scalar

hold : boolean, optional, default: True

detrend : callable, optional, default: `mlab.detrend_none`
    x is detrended by the `detrend` callable. Default is no
    normalization.

normed : boolean, optional, default: True
    if True, normalize the data by the autocorrelation at the 0-th
    lag.

usevlines : boolean, optional, default: True
    if True, Axes.vlines is used to plot the vertical lines from the
    origin to the acorr. Otherwise, Axes.plot is used.

maxlags : integer, optional, default: 10
    number of lags to show. If None, will return all 2 * len(x) - 1
    lags.

Returns
-------
(lags, c, line, b) : where:

  - `lags` are a length 2`maxlags+1 lag vector.
  - `c` is the 2`maxlags+1 auto correlation vectorI
  - `line` is a `~matplotlib.lines.Line2D` instance returned by
    `plot`.
  - `b` is the x-axis.

Other parameters
-----------------
linestyle : `~matplotlib.lines.Line2D` prop, optional, default: None
    Only used if usevlines is False.

marker : string, optional, default: 'o'

Notes
-----
The cross correlation is performed with :func:`numpy.correlate` with
`mode` = 2.

Examples
--------

`~matplotlib.pyplot.xcorr` is top graph, and
`~matplotlib.pyplot.acorr` is bottom graph.

.. plot:: mpl_examples/pylab_examples/xcorr_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="normed" name="normed" port_type="basic:Boolean">
      <docstring>if True, normalize the data by the autocorrelation at the 0-th
lag.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="usevlines" name="usevlines" port_type="basic:Boolean">
      <docstring>if True, Axes.vlines is used to plot the vertical lines from the
origin to the acorr. Otherwise, Axes.plot is used.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="linestyle" name="linestyle">
      <docstring>Only used if usevlines is False.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" name="detrend">
      <docstring>x is detrended by the `detrend` callable. Default is no
normalization.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="maxlags" name="maxlags" port_type="basic:Integer">
      <docstring>number of lags to show. If None, will return all 2 * len(x) - 1
lags.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="marker" name="marker" port_type="basic:String" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="1" name="hold" port_type="basic:Boolean" />
    <inputPortSpec arg="data" arg_pos="2" name="data" />
    <outputPortSpec arg="lineCollection" compute_name="lineCollection" name="lineCollectionProperties" port_type="__property__" property_key="4" property_type="matplotlib.collections.LineCollection" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="2" property_type="matplotlib.lines.Line2D" />
    <outputPortSpec arg="xaxis" compute_name="xaxis" name="xaxisProperties" port_type="__property__" property_key="3" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.arrow" name="MplArrow" superclass="MplPlot">
    <docstring>Add an arrow to the axes.

Call signature:

arrow(x, y, dx, dy, **kwargs)

Draws arrow on specified axis from (x, y) to (x + dx, y + dy). Uses FancyArrow patch to construct the arrow.

The resulting arrow is affected by the axes aspect ratio and limits. This may produce an arrow whose head is not square with its stem. To create an arrow whose head is square with its stem, use :meth:`annotate` for example:

ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),     arrowprops=dict(arrowstyle="-&gt;"))

Optional kwargs control the arrow construction and properties:

%(FancyArrow)s

Example:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:Float" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:Float" required="True" />
    <inputPortSpec arg="hold" arg_pos="4" name="hold" />
    <inputPortSpec arg="dx" arg_pos="2" name="dx" port_type="basic:Float" required="True" />
    <inputPortSpec arg="dy" arg_pos="3" name="dy" port_type="basic:Float" required="True" />
    <inputPortSpec arg="arrow" constructor_arg="True" name="arrowProperties" port_type="__property__" property_type="matplotlib.patches.FancyArrow" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.axhline" name="MplAxhline" output_type="object" superclass="MplPlot">
    <docstring>Add a horizontal line across the axis.

Parameters
----------
y : scalar, optional, default: 0
    y position in data coordinates of the horizontal line.

xmin : scalar, optional, default: 0
    Should be between 0 and 1, 0 being the far left of the plot, 1 the
    far right of the plot.

xmax : scalar, optional, default: 1
    Should be between 0 and 1, 0 being the far left of the plot, 1 the
    far right of the plot.

Returns
-------
:class:`~matplotlib.lines.Line2D`

Notes
-----
kwargs are passed to :class:`~matplotlib.lines.Line2D` and can be used
to control the line properties.

Examples
--------

* draw a thick red hline at 'y' = 0 that spans the xrange::

    &gt;&gt;&gt; axhline(linewidth=4, color='r')

* draw a default hline at 'y' = 1 that spans the xrange::

    &gt;&gt;&gt; axhline(y=1)

* draw a default hline at 'y' = .5 that spans the middle half of
  the xrange::

    &gt;&gt;&gt; axhline(y=.5, xmin=0.25, xmax=0.75)

Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,
with the exception of 'transform':

%(Line2D)s

See also
--------
axhspan : for example plot and source code



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="y" arg_pos="0" name="y" port_type="basic:Float">
      <docstring>y position in data coordinates of the horizontal line.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xmin" arg_pos="1" name="xmin" port_type="basic:Float">
      <docstring>Should be between 0 and 1, 0 being the far left of the plot, 1 the
far right of the plot.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="3" name="hold" />
    <inputPortSpec arg="xmax" arg_pos="2" name="xmax" port_type="basic:Float">
      <docstring>Should be between 0 and 1, 0 being the far left of the plot, 1 the
far right of the plot.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="line" compute_name="line" name="lineProperties" port_type="__property__" property_key="0" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.axhspan" name="MplAxhspan" output_type="object" superclass="MplPlot">
    <docstring>Add a horizontal span (rectangle) across the axis.

Call signature:

axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs)

y coords are in data units and x coords are in axes (relative 0-1) units.

Draw a horizontal span (rectangle) from ymin to ymax. With the default values of xmin = 0 and xmax = 1, this always spans the xrange, regardless of the xlim settings, even if you change them, e.g., with the :meth:`set_xlim` command. That is, the horizontal extent is in axes coords: 0=left, 0.5=middle, 1.0=right but the y location is in data coordinates.

Return value is a :class:`matplotlib.patches.Polygon` instance.

Examples:

draw a gray rectangle from y = 0.25-0.75 that spans the horizontal extent of the axes:

&gt;&gt;&gt; axhspan(0.25, 0.75, facecolor='0.5', alpha=0.5)

Valid kwargs are :class:`~matplotlib.patches.Polygon` properties:

%(Polygon)s

Example:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="xmin" arg_pos="2" name="xmin" port_type="basic:Float">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="4" name="hold" />
    <inputPortSpec arg="ymin" arg_pos="0" name="ymin" port_type="basic:Float" required="True" />
    <inputPortSpec arg="ymax" arg_pos="1" name="ymax" port_type="basic:Float" required="True" />
    <inputPortSpec arg="xmax" arg_pos="3" name="xmax" port_type="basic:Float">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="patch" compute_name="patch" name="patchProperties" port_type="__property__" property_key="-1" property_type="matplotlib.patches.Polygon" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.axvline" name="MplAxvline" output_type="object" superclass="MplPlot">
    <docstring>Add a vertical line across the axes.

Parameters
----------
x : scalar, optional, default: 0
    x position in data coordinates of the vertical line.

ymin : scalar, optional, default: 0
    Should be between 0 and 1, 0 being the bottom of the plot, 1 the
    top of the plot.

ymax : scalar, optional, default: 1
    Should be between 0 and 1, 0 being the bottom of the plot, 1 the
    top of the plot.

Returns
-------
:class:`~matplotlib.lines.Line2D`


Examples
---------
* draw a thick red vline at *x* = 0 that spans the yrange::

    &gt;&gt;&gt; axvline(linewidth=4, color='r')

* draw a default vline at *x* = 1 that spans the yrange::

    &gt;&gt;&gt; axvline(x=1)

* draw a default vline at *x* = .5 that spans the middle half of
  the yrange::

    &gt;&gt;&gt; axvline(x=.5, ymin=0.25, ymax=0.75)

Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,
with the exception of 'transform':

%(Line2D)s

See also
--------
axhspan : for example plot and source code



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:Float">
      <docstring>x position in data coordinates of the vertical line.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="3" name="hold" />
    <inputPortSpec arg="ymin" arg_pos="1" name="ymin" port_type="basic:Float">
      <docstring>Should be between 0 and 1, 0 being the bottom of the plot, 1 the
top of the plot.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ymax" arg_pos="2" name="ymax" port_type="basic:Float">
      <docstring>Should be between 0 and 1, 0 being the bottom of the plot, 1 the
top of the plot.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="line" compute_name="line" name="lineProperties" port_type="__property__" property_key="0" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.axvspan" name="MplAxvspan" output_type="object" superclass="MplPlot">
    <docstring>Add a vertical span (rectangle) across the axes.

Call signature:

axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs)

x coords are in data units and y coords are in axes (relative 0-1) units.

Draw a vertical span (rectangle) from xmin to xmax.  With the default values of ymin = 0 and ymax = 1, this always spans the yrange, regardless of the ylim settings, even if you change them, e.g., with the :meth:`set_ylim` command.  That is, the vertical extent is in axes coords: 0=bottom, 0.5=middle, 1.0=top but the y location is in data coordinates.

Return value is the :class:`matplotlib.patches.Polygon` instance.

Examples:

draw a vertical green translucent rectangle from x=1.25 to 1.55 that spans the yrange of the axes:

&gt;&gt;&gt; axvspan(1.25, 1.55, facecolor='g', alpha=0.5)

Valid kwargs are :class:`~matplotlib.patches.Polygon` properties:

%(Polygon)s



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="xmin" arg_pos="0" name="xmin" port_type="basic:Float" required="True" />
    <inputPortSpec arg="hold" arg_pos="4" name="hold" />
    <inputPortSpec arg="ymin" arg_pos="2" name="ymin" port_type="basic:Float">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ymax" arg_pos="3" name="ymax" port_type="basic:Float">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xmax" arg_pos="1" name="xmax" port_type="basic:Float" required="True" />
    <outputPortSpec arg="patch" compute_name="patch" name="patchProperties" port_type="__property__" property_key="-1" property_type="matplotlib.patches.Polygon" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.bar" name="MplBar" output_type="object" superclass="MplPlot">
    <docstring>Make a bar plot.

Make a bar plot with rectangles bounded by:

  `left`, `left` + `width`, `bottom`, `bottom` + `height`
        (left, right, bottom and top edges)

Parameters
----------
left : sequence of scalars
    the x coordinates of the left sides of the bars

height : sequence of scalars
    the heights of the bars

width : scalar or array-like, optional
    the width(s) of the bars
    default: 0.8

bottom : scalar or array-like, optional
    the y coordinate(s) of the bars
    default: None

color : scalar or array-like, optional
    the colors of the bar faces

edgecolor : scalar or array-like, optional
    the colors of the bar edges

linewidth : scalar or array-like, optional
    width of bar edge(s). If None, use default
    linewidth; If 0, don't draw edges.
    default: None

tick_label : string or array-like, optional
    the tick labels of the bars
    default: None

xerr : scalar or array-like, optional
    if not None, will be used to generate errorbar(s) on the bar chart
    default: None

yerr : scalar or array-like, optional
    if not None, will be used to generate errorbar(s) on the bar chart
    default: None

ecolor : scalar or array-like, optional
    specifies the color of errorbar(s)
    default: None

capsize : scalar, optional
   determines the length in points of the error bar caps
   default: None, which will take the value from the
   ``errorbar.capsize`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.

error_kw : dict, optional
    dictionary of kwargs to be passed to errorbar method. *ecolor* and
    *capsize* may be specified here rather than as independent kwargs.

align : {'edge',  'center'}, optional
    If 'edge', aligns bars by their left edges (for vertical bars) and
    by their bottom edges (for horizontal bars). If 'center', interpret
    the `left` argument as the coordinates of the centers of the bars.
    To align on the align bars on the right edge pass a negative
    `width`.

orientation : {'vertical',  'horizontal'}, optional
    The orientation of the bars.

log : boolean, optional
    If true, sets the axis to be log scale.
    default: False

Returns
-------
bars : matplotlib.container.BarContainer
    Container with all of the bars + errorbars

Notes
-----
The optional arguments `color`, `edgecolor`, `linewidth`,
`xerr`, and `yerr` can be either scalars or sequences of
length equal to the number of bars.  This enables you to use
bar as the basis for stacked bar charts, or candlestick plots.
Detail: `xerr` and `yerr` are passed directly to
:meth:`errorbar`, so they can also have shape 2xN for
independent specification of lower and upper errors.

Other optional kwargs:

%(Rectangle)s

See also
--------
barh: Plot a horizontal bar plot.

Examples
--------

**Example:** A stacked bar chart.

.. plot:: mpl_examples/pylab_examples/bar_stacked.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'edgecolor', 'bottom', 'color', 'xerr', 'ecolor', 'tick_label', 'height', 'width', 'linewidth', 'yerr', 'left'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="edgecolor" name="edgecolor" port_type="basic:Color">
      <docstring>the colors of the bar edges
</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="linewidth" name="linewidth" port_type="basic:Float">
      <docstring>width of bar edge(s). If None, use default
linewidth; If 0, don't draw edges.
default: None
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="capsize" name="capsize" port_type="basic:Float">
      <docstring>determines the length in points of the error bar caps
default: None, which will take the value from the
``errorbar.capsize`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="orientation" name="orientation">
      <docstring>The orientation of the bars.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bottom" arg_pos="3" name="bottom" port_type="basic:Float">
      <docstring>the y coordinate(s) of the bars
default: None
</docstring>
      <alternateSpec arg="bottom" name="bottomSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="color" name="color" port_type="basic:Color">
      <docstring>the colors of the bar faces
</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="xerr" name="xerr" port_type="basic:Float">
      <docstring>if not None, will be used to generate errorbar(s) on the bar chart
default: None
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="align" name="align">
      <docstring>If 'edge', aligns bars by their left edges (for vertical bars) and
by their bottom edges (for horizontal bars). If 'center', interpret
the `left` argument as the coordinates of the centers of the bars.
To align on the align bars on the right edge pass a negative
`width`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ecolor" name="ecolor" port_type="basic:Color">
      <docstring>specifies the color of errorbar(s)
default: None
</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="tick_label" name="tick_label" port_type="basic:String">
      <docstring>the tick labels of the bars
default: None
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="height" arg_pos="1" name="height" port_type="basic:List" required="True">
      <docstring>the heights of the bars
</docstring>
      <alternateSpec arg="height" name="heightScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="width" arg_pos="2" name="width" port_type="basic:Float">
      <docstring>the width(s) of the bars
default: 0.8
</docstring>
      <defaults>[0.8]</defaults>
      <alternateSpec arg="width" name="widthSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="error_kw" name="error_kw">
      <docstring>dictionary of kwargs to be passed to errorbar method. *ecolor* and
*capsize* may be specified here rather than as independent kwargs.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="log" name="log" port_type="basic:Boolean">
      <docstring>If true, sets the axis to be log scale.
default: False</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="4" name="hold" />
    <inputPortSpec arg="data" arg_pos="5" name="data" />
    <inputPortSpec arg="yerr" name="yerr" port_type="basic:Float">
      <docstring>if not None, will be used to generate errorbar(s) on the bar chart
default: None
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="left" arg_pos="0" name="left" port_type="basic:List" required="False">
      <docstring>the x coordinates of the left sides of the bars
</docstring>
      <alternateSpec arg="left" name="leftScalar" port_type="basic:Float">
        <docstring>the x coordinate of the left side of the bar</docstring>
      </alternateSpec>
    </inputPortSpec>
    <outputPortSpec arg="rectangle" compute_name="rectangles" name="rectangleProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.Rectangle" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.barh" name="MplBarh" output_type="object" superclass="MplPlot">
    <docstring>Make a horizontal bar plot.

Make a horizontal bar plot with rectangles bounded by:

  `left`, `left` + `width`, `bottom`, `bottom` + `height`
        (left, right, bottom and top edges)

`bottom`, `width`, `height`, and `left` can be either scalars
or sequences

Parameters
----------
bottom : scalar or array-like
    the y coordinate(s) of the bars

width : scalar or array-like
    the width(s) of the bars

height : sequence of scalars, optional, default: 0.8
    the heights of the bars

left : sequence of scalars
    the x coordinates of the left sides of the bars

Returns
--------
`matplotlib.patches.Rectangle` instances.

Other parameters
----------------
color : scalar or array-like, optional
    the colors of the bars

edgecolor : scalar or array-like, optional
    the colors of the bar edges

linewidth : scalar or array-like, optional, default: None
    width of bar edge(s). If None, use default
    linewidth; If 0, don't draw edges.

tick_label : string or array-like, optional, default: None
    the tick labels of the bars

xerr : scalar or array-like, optional, default: None
    if not None, will be used to generate errorbar(s) on the bar chart

yerr : scalar or array-like, optional, default: None
    if not None, will be used to generate errorbar(s) on the bar chart

ecolor : scalar or array-like, optional, default: None
    specifies the color of errorbar(s)

capsize : scalar, optional
   determines the length in points of the error bar caps
   default: None, which will take the value from the
   ``errorbar.capsize`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.

error_kw :
    dictionary of kwargs to be passed to errorbar method. `ecolor` and
    `capsize` may be specified here rather than as independent kwargs.

align : ['edge' | 'center'], optional, default: 'edge'
    If `edge`, aligns bars by their left edges (for vertical bars) and
    by their bottom edges (for horizontal bars). If `center`, interpret
    the `left` argument as the coordinates of the centers of the bars.

orientation : 'vertical' | 'horizontal', optional, default: 'vertical'
    The orientation of the bars.

log : boolean, optional, default: False
    If true, sets the axis to be log scale

Notes
-----
The optional arguments `color`, `edgecolor`, `linewidth`,
`xerr`, and `yerr` can be either scalars or sequences of
length equal to the number of bars.  This enables you to use
bar as the basis for stacked bar charts, or candlestick plots.
Detail: `xerr` and `yerr` are passed directly to
:meth:`errorbar`, so they can also have shape 2xN for
independent specification of lower and upper errors.

Other optional kwargs:

%(Rectangle)s

See also
--------
bar: Plot a vertical bar plot.



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="edgecolor" name="edgecolor" port_type="basic:Color">
      <docstring>the colors of the bar edges
</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="linewidth" name="linewidth" port_type="basic:Float">
      <docstring>width of bar edge(s). If None, use default
linewidth; If 0, don't draw edges.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="capsize" name="capsize" port_type="basic:Float">
      <docstring>determines the length in points of the error bar caps
default: None, which will take the value from the
``errorbar.capsize`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="orientation" name="orientation" port_type="basic:String">
      <docstring>The orientation of the bars.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['vertical', u"'horizontal', optional, default: 'vertical'"]]</values>
    </inputPortSpec>
    <inputPortSpec arg="bottom" arg_pos="0" name="bottom" port_type="basic:List" required="True">
      <docstring>the y coordinate(s) of the bars
</docstring>
      <alternateSpec arg="bottom" name="bottomScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="color" name="color" port_type="basic:Color">
      <docstring>the colors of the bars
</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="xerr" name="xerr" port_type="basic:Float">
      <docstring>if not None, will be used to generate errorbar(s) on the bar chart
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="align" name="align" port_type="basic:String">
      <docstring>If `edge`, aligns bars by their left edges (for vertical bars) and
by their bottom edges (for horizontal bars). If `center`, interpret
the `left` argument as the coordinates of the centers of the bars.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['edge', 'center']]</values>
    </inputPortSpec>
    <inputPortSpec arg="ecolor" name="ecolor" port_type="basic:Color">
      <docstring>specifies the color of errorbar(s)
</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="tick_label" name="tick_label" port_type="basic:String">
      <docstring>the tick labels of the bars
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="height" arg_pos="2" name="heightSequence" port_type="basic:List">
      <docstring>the heights of the bars
</docstring>
      <alternateSpec arg="height" name="heightScalar" port_type="basic:Float">
        <defaults>[0.8]</defaults>
      </alternateSpec>
      <alternateSpec arg="height" name="heightSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="width" arg_pos="1" name="width" port_type="basic:List" required="True">
      <docstring>the width(s) of the bars
</docstring>
      <alternateSpec arg="width" name="widthScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="log" name="log" port_type="basic:Boolean">
      <docstring>If true, sets the axis to be log scale</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="4" name="hold" />
    <inputPortSpec arg="yerr" name="yerr" port_type="basic:Float">
      <docstring>if not None, will be used to generate errorbar(s) on the bar chart
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="left" arg_pos="3" name="left" port_type="basic:Float">
      <docstring>the x coordinates of the left sides of the bars</docstring>
      <alternateSpec arg="left" name="leftSequence" port_type="basic:List" />
    </inputPortSpec>
    <outputPortSpec arg="rectangle" compute_name="rectangles" name="rectangleProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.Rectangle" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.broken_barh" name="MplBrokenBarh" output_type="object" superclass="MplPlot">
    <docstring>Plot horizontal bars.

Call signature::

  broken_barh(self, xranges, yrange, **kwargs)

A collection of horizontal bars spanning *yrange* with a sequence of
*xranges*.

Required arguments:

  =========   ==============================
  Argument    Description
  =========   ==============================
  *xranges*   sequence of (*xmin*, *xwidth*)
  *yrange*    sequence of (*ymin*, *ywidth*)
  =========   ==============================

kwargs are
:class:`matplotlib.collections.BrokenBarHCollection`
properties:

%(BrokenBarHCollection)s

these can either be a single argument, i.e.,::

  facecolors = 'black'

or a sequence of arguments for the various bars, i.e.,::

  facecolors = ('black', 'red', 'green')

**Example:**

.. plot:: mpl_examples/pylab_examples/broken_barh.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All positional and all keyword arguments.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="xranges" arg_pos="0" name="xranges" port_type="basic:List" required="True">
      <docstring>sequence of (xmin, xwidth)</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="2" name="hold" />
    <inputPortSpec arg="data" arg_pos="3" name="data" />
    <inputPortSpec arg="yrange" arg_pos="1" name="yrange" port_type="basic:Float,basic:Float" required="True">
      <docstring>(ymin, ywidth)</docstring>
    </inputPortSpec>
    <outputPortSpec arg="brokenBarHCollection" compute_name="brokenBarHCollection" name="brokenBarHCollectionProperties" port_type="__property__" property_key="__none__" property_type="matplotlib.collections.BrokenBarHCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.boxplot" name="MplBoxplot" output_type="dict" superclass="MplPlot">
    <docstring>Make a box and whisker plot.

Call signature::

  boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
          positions=None, widths=None, patch_artist=False,
          bootstrap=None, usermedians=None, conf_intervals=None,
          meanline=False, showmeans=False, showcaps=True,
          showbox=True, showfliers=True, boxprops=None, labels=None,
          flierprops=None, medianprops=None, meanprops=None,
          capprops=None, whiskerprops=None, manage_xticks=True):

Make a box and whisker plot for each column of *x* or each
vector in sequence *x*.  The box extends from the lower to
upper quartile values of the data, with a line at the median.
The whiskers extend from the box to show the range of the
data.  Flier points are those past the end of the whiskers.

Parameters
----------

  x : Array or a sequence of vectors.
    The input data.

  notch : bool, default = False
    If False, produces a rectangular box plot.
    If True, will produce a notched box plot

  sym : str or None, default = None
    The default symbol for flier points.
    Enter an empty string ('') if you don't want to show fliers.
    If `None`, then the fliers default to 'b+'  If you want more
    control use the flierprops kwarg.

  vert : bool, default = True
    If True (default), makes the boxes vertical.
    If False, makes horizontal boxes.

  whis : float, sequence (default = 1.5) or string
    As a float, determines the reach of the whiskers past the first
    and third quartiles (e.g., Q3 + whis*IQR, IQR = interquartile
    range, Q3-Q1). Beyond the whiskers, data are considered outliers
    and are plotted as individual points. Set this to an unreasonably
    high value to force the whiskers to show the min and max values.
    Alternatively, set this to an ascending sequence of percentile
    (e.g., [5, 95]) to set the whiskers at specific percentiles of
    the data. Finally, *whis* can be the string 'range' to force the
    whiskers to the min and max of the data. In the edge case that
    the 25th and 75th percentiles are equivalent, *whis* will be
    automatically set to 'range'.

  bootstrap : None (default) or integer
    Specifies whether to bootstrap the confidence intervals
    around the median for notched boxplots. If bootstrap==None,
    no bootstrapping is performed, and notches are calculated
    using a Gaussian-based asymptotic approximation  (see McGill, R.,
    Tukey, J.W., and Larsen, W.A., 1978, and Kendall and Stuart,
    1967). Otherwise, bootstrap specifies the number of times to
    bootstrap the median to determine it's 95% confidence intervals.
    Values between 1000 and 10000 are recommended.

  usermedians : array-like or None (default)
    An array or sequence whose first dimension (or length) is
    compatible with *x*. This overrides the medians computed by
    matplotlib for each element of *usermedians* that is not None.
    When an element of *usermedians* == None, the median will be
    computed by matplotlib as normal.

  conf_intervals : array-like or None (default)
    Array or sequence whose first dimension (or length) is compatible
    with *x* and whose second dimension is 2. When the current element
    of *conf_intervals* is not None, the notch locations computed by
    matplotlib are overridden (assuming notch is True). When an
    element of *conf_intervals* is None, boxplot compute notches the
    method specified by the other kwargs (e.g., *bootstrap*).

  positions : array-like, default = [1, 2, ..., n]
    Sets the positions of the boxes. The ticks and limits
    are automatically set to match the positions.

  widths : array-like, default = 0.5
    Either a scalar or a vector and sets the width of each box. The
    default is 0.5, or ``0.15*(distance between extreme positions)``
    if that is smaller.

  labels : sequence or None (default)
        Labels for each dataset. Length must be compatible with
        dimensions  of *x*

  patch_artist : bool, default = False
    If False produces boxes with the Line2D artist
    If True produces boxes with the Patch artist

  showmeans : bool, default = False
    If True, will toggle one the rendering of the means

  showcaps : bool, default = True
    If True, will toggle one the rendering of the caps

  showbox : bool, default = True
    If True, will toggle one the rendering of box

  showfliers : bool, default = True
    If True, will toggle one the rendering of the fliers

  boxprops : dict or None (default)
    If provided, will set the plotting style of the boxes

  whiskerprops : dict or None (default)
    If provided, will set the plotting style of the whiskers

  capprops : dict or None (default)
    If provided, will set the plotting style of the caps

  flierprops : dict or None (default)
    If provided, will set the plotting style of the fliers

  medianprops : dict or None (default)
    If provided, will set the plotting style of the medians

  meanprops : dict or None (default)
    If provided, will set the plotting style of the means

  meanline : bool, default = False
    If True (and *showmeans* is True), will try to render the mean
    as a line spanning the full width of the box according to
    *meanprops*. Not recommended if *shownotches* is also True.
    Otherwise, means will be shown as points.

  manage_xticks : bool, default = True
    If the function should adjust the xlim and xtick locations.

Returns
-------

result : dict
    A dictionary mapping each component of the boxplot
    to a list of the :class:`matplotlib.lines.Line2D`
    instances created. That dictionary has the following keys
    (assuming vertical boxplots):

    - boxes: the main body of the boxplot showing the quartiles
      and the median's confidence intervals if enabled.
    - medians: horizonal lines at the median of each box.
    - whiskers: the vertical lines extending to the most extreme,
      n-outlier data points.
    - caps: the horizontal lines at the ends of the whiskers.
    - fliers: points representing data that extend beyond the
      whiskers (outliers).
    - means: points or lines representing the means.

Examples
--------

.. plot:: mpl_examples/statistics/boxplot_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All positional and all keyword arguments.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="usermedians" arg_pos="9" name="usermedians" />
    <inputPortSpec arg="labels" arg_pos="17" name="labels" />
    <inputPortSpec arg="meanline" arg_pos="11" name="meanline" port_type="basic:Boolean">
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="whis" arg_pos="4" name="whis" />
    <inputPortSpec arg="whiskerprops" arg_pos="22" name="whiskerprops" />
    <inputPortSpec arg="flierprops" arg_pos="18" name="flierprops" />
    <inputPortSpec arg="widths" arg_pos="6" name="widths" />
    <inputPortSpec arg="showfliers" arg_pos="15" name="showfliers" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="capprops" arg_pos="21" name="capprops" />
    <inputPortSpec arg="showmeans" arg_pos="12" name="showmeans" port_type="basic:Boolean">
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vert" arg_pos="3" name="vert" />
    <inputPortSpec arg="sym" arg_pos="2" name="sym" />
    <inputPortSpec arg="boxprops" arg_pos="16" name="boxprops" />
    <inputPortSpec arg="manage_xticks" arg_pos="23" name="manage_xticks" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="24" name="hold" />
    <inputPortSpec arg="data" arg_pos="25" name="data" />
    <inputPortSpec arg="positions" arg_pos="5" name="positions" />
    <inputPortSpec arg="bootstrap" arg_pos="8" name="bootstrap" />
    <inputPortSpec arg="showbox" arg_pos="14" name="showbox" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="meanprops" arg_pos="20" name="meanprops" />
    <inputPortSpec arg="medianprops" arg_pos="19" name="medianprops" />
    <inputPortSpec arg="patch_artist" arg_pos="7" name="patch_artist" port_type="basic:Boolean">
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True">
      <docstring>  The input data.

notch : bool, default = False
  If False, produces a rectangular box plot.
  If True, will produce a notched box plot

sym : str or None, default = None
  The default symbol for flier points.
  Enter an empty string ('') if you don't want to show fliers.
  If `None`, then the fliers default to 'b+'  If you want more
  control use the flierprops kwarg.

vert : bool, default = True
  If True (default), makes the boxes vertical.
  If False, makes horizontal boxes.

whis : float, sequence (default = 1.5) or string
  As a float, determines the reach of the whiskers past the first
  and third quartiles (e.g., Q3 + whis*IQR, IQR = interquartile
  range, Q3-Q1). Beyond the whiskers, data are considered outliers
  and are plotted as individual points. Set this to an unreasonably
  high value to force the whiskers to show the min and max values.
  Alternatively, set this to an ascending sequence of percentile
  (e.g., [5, 95]) to set the whiskers at specific percentiles of
  the data. Finally, *whis* can be the string 'range' to force the
  whiskers to the min and max of the data. In the edge case that
  the 25th and 75th percentiles are equivalent, *whis* will be
  automatically set to 'range'.

bootstrap : None (default) or integer
  Specifies whether to bootstrap the confidence intervals
  around the median for notched boxplots. If bootstrap==None,
  no bootstrapping is performed, and notches are calculated
  using a Gaussian-based asymptotic approximation  (see McGill, R.,
  Tukey, J.W., and Larsen, W.A., 1978, and Kendall and Stuart,
  1967). Otherwise, bootstrap specifies the number of times to
  bootstrap the median to determine it's 95% confidence intervals.
  Values between 1000 and 10000 are recommended.

usermedians : array-like or None (default)
  An array or sequence whose first dimension (or length) is
  compatible with *x*. This overrides the medians computed by
  matplotlib for each element of *usermedians* that is not None.
  When an element of *usermedians* == None, the median will be
  computed by matplotlib as normal.

conf_intervals : array-like or None (default)
  Array or sequence whose first dimension (or length) is compatible
  with *x* and whose second dimension is 2. When the current element
  of *conf_intervals* is not None, the notch locations computed by
  matplotlib are overridden (assuming notch is True). When an
  element of *conf_intervals* is None, boxplot compute notches the
  method specified by the other kwargs (e.g., *bootstrap*).

positions : array-like, default = [1, 2, ..., n]
  Sets the positions of the boxes. The ticks and limits
  are automatically set to match the positions.

widths : array-like, default = 0.5
  Either a scalar or a vector and sets the width of each box. The
  default is 0.5, or ``0.15*(distance between extreme positions)``
  if that is smaller.

labels : sequence or None (default)
      Labels for each dataset. Length must be compatible with
      dimensions  of *x*

patch_artist : bool, default = False
  If False produces boxes with the Line2D artist
  If True produces boxes with the Patch artist

showmeans : bool, default = False
  If True, will toggle one the rendering of the means

showcaps : bool, default = True
  If True, will toggle one the rendering of the caps

showbox : bool, default = True
  If True, will toggle one the rendering of box

showfliers : bool, default = True
  If True, will toggle one the rendering of the fliers

boxprops : dict or None (default)
  If provided, will set the plotting style of the boxes

whiskerprops : dict or None (default)
  If provided, will set the plotting style of the whiskers

capprops : dict or None (default)
  If provided, will set the plotting style of the caps

flierprops : dict or None (default)
  If provided, will set the plotting style of the fliers

medianprops : dict or None (default)
  If provided, will set the plotting style of the medians

meanprops : dict or None (default)
  If provided, will set the plotting style of the means

meanline : bool, default = False
  If True (and *showmeans* is True), will try to render the mean
  as a line spanning the full width of the box according to
  *meanprops*. Not recommended if *shownotches* is also True.
  Otherwise, means will be shown as points.

manage_xticks : bool, default = True
  If the function should adjust the xlim and xtick locations.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="notch" arg_pos="1" name="notch" />
    <inputPortSpec arg="showcaps" arg_pos="13" name="showcaps" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="conf_intervals" arg_pos="10" name="conf_intervals" />
    <outputPortSpec arg="box" compute_name="boxes" name="boxProperties" plural="True" port_type="__property__" property_key="boxes" property_type="matplotlib.artist.Line2D" />
    <outputPortSpec arg="flier" compute_name="fliers" name="flierProperties" plural="True" port_type="__property__" property_key="fliers" property_type="matplotlib.artist.Line2D" />
    <outputPortSpec arg="cap" compute_name="caps" name="capProperties" plural="True" port_type="__property__" property_key="caps" property_type="matplotlib.artist.Line2D" />
    <outputPortSpec arg="median" compute_name="medians" name="medianProperties" plural="True" port_type="__property__" property_key="medians" property_type="matplotlib.artist.Line2D" />
    <outputPortSpec arg="boxPatch" compute_name="boxPatches" name="boxPatchProperties" plural="True" port_type="__property__" property_key="boxPatches" property_type="matplotlib.artist.PathPatch" />
    <outputPortSpec arg="whisker" compute_name="whiskers" name="whiskerProperties" plural="True" port_type="__property__" property_key="whiskers" property_type="matplotlib.artist.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.cohere" name="MplCohere" superclass="MplPlot">
    <docstring>Plot the coherence between *x* and *y*.

Call signature::

  cohere(x, y, NFFT=256, Fs=2, Fc=0, detrend = mlab.detrend_none,
         window = mlab.window_hanning, noverlap=0, pad_to=None,
         sides='default', scale_by_freq=None, **kwargs)

Plot the coherence between *x* and *y*.  Coherence is the
normalized cross spectral density:

.. math::

  C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}

%(Spectral)s

%(PSD)s

  *noverlap*: integer
    The number of points of overlap between blocks.  The
    default value is 0 (no overlap).

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

The return value is a tuple (*Cxy*, *f*), where *f* are the
frequencies of the coherence vector.

kwargs are applied to the lines.

References:

  * Bendat &amp; Piersol -- Random Data: Analysis and Measurement
    Procedures, John Wiley &amp; Sons (1986)

kwargs control the :class:`~matplotlib.lines.Line2D`
properties of the coherence plot:

%(Line2D)s

**Example:**

.. plot:: mpl_examples/pylab_examples/cohere_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="Fs" arg_pos="3" name="Fs" port_type="basic:Integer">
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pad_to" arg_pos="8" name="pad_to" />
    <inputPortSpec arg="scale_by_freq" arg_pos="10" name="scale_by_freq" />
    <inputPortSpec arg="detrend" arg_pos="5" name="detrend">
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="window" arg_pos="6" name="window">
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Fc" arg_pos="4" name="Fc" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="NFFT" arg_pos="2" name="NFFT" port_type="basic:Integer">
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="11" name="hold" />
    <inputPortSpec arg="data" arg_pos="12" name="data" />
    <inputPortSpec arg="sides" arg_pos="9" name="sides" port_type="basic:String">
      <defaults>[u'default']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" arg_pos="7" name="noverlap" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="line" constructor_arg="True" name="lineProperties" port_type="__property__" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.clabel" name="MplClabel" output_type="object" superclass="MplPlot">
    <docstring>Label a contour plot.

Call signature:

clabel(cs, **kwargs)

Adds labels to line contours in cs, where cs is a :class:`~matplotlib.contour.ContourSet` object returned by contour.

clabel(cs, v, **kwargs)

only labels contours listed in v.

Optional keyword arguments:



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="inline_spacing" name="inline_spacing">
      <docstring>space in pixels to leave on each side of label when placing inline.  Defaults to 5.  This spacing will be exact for labels at locations where the contour is straight, less so for labels on curved contours.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="use_clabeltext" name="use_clabeltext" port_type="basic:String">
      <docstring>if True (default is False), ClabelText class (instead of matplotlib.Text) is used to create labels. ClabelText recalculates rotation angles of texts during the drawing time, therefore this can be used if aspect of the axes changes.</docstring>
      <defaults>['False)']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="fmt" name="fmt" port_type="basic:String">
      <docstring>a format string for the label. Default is '%1.3f' Alternatively, this can be a dictionary matching contour levels with arbitrary strings to use for each contour level (i.e., fmt[level]=string), or it can be any callable, such as a :class:`~matplotlib.ticker.Formatter` instance, that returns a string when called with a numeric contour level.</docstring>
      <defaults>['%1.3f']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="manual" name="manual">
      <docstring>if True, contour labels will be placed manually using mouse clicks.  Click the first button near a contour to add a label, click the second button (or potentially both mouse buttons at once) to finish adding labels.  The third button can be used to remove the last label added, but only if labels are not inline.  Alternatively, the keyboard can be used to select label locations (enter to end label placement, delete or backspace act like the third mouse button, and any other key will select a label location).

manual can be an iterable object of x,y tuples. Contour labels will be created as if mouse is clicked at each x,y positions.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cs" arg_pos="0" in_args="True" name="cs" port_type="MplContourSet" required="True" />
    <inputPortSpec arg="colors" name="colors" port_type="basic:Color">
      <docstring>if None, the color of each label matches the color of the corresponding contour

if one string color, e.g., colors = 'r' or colors = 'red', all labels will be plotted in this color

if a tuple of matplotlib color args (string, float, rgb, etc), different labels will be plotted in different colors in the order specified</docstring>
    </inputPortSpec>
    <inputPortSpec arg="fontsize" name="fontsize">
      <docstring>size in points or relative size e.g., 'smaller', 'x-large'</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rightside_up" name="rightside_up" port_type="basic:Boolean">
      <docstring>if True (default), label rotations will always be plus or minus 90 degrees from level.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="inline" name="inline" port_type="basic:Boolean">
      <docstring>controls whether the underlying contour is removed or not. Default is True.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="v" arg_pos="1" in_args="True" name="v" port_type="basic:List" />
    <outputPortSpec arg="text" compute_name="texts" name="textProperties" plural="True" port_type="__property__" property_key="__none__" property_type="matplotlib.text.Text" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.contour" name="MplContour" output_type="tuple" superclass="MplPlot">
    <docstring>Plot contours.

:func:`~matplotlib.pyplot.contour` and :func:`~matplotlib.pyplot.contourf` draw contour lines and filled contours, respectively.  Except as noted, function signatures and return values are the same for both versions.

:func:`~matplotlib.pyplot.contourf` differs from the MATLAB version in that it does not draw the polygon edges. To draw edges, add line contours with calls to :func:`~matplotlib.pyplot.contour`.

Call signatures:

contour(Z)

make a contour plot of an array Z. The level values are chosen automatically.

contour(X,Y,Z)

X, Y specify the (x, y) coordinates of the surface

contour(Z,N) contour(X,Y,Z,N)

contour up to N automatically-chosen levels.

contour(Z,V) contour(X,Y,Z,V)

draw contour lines at the values specified in sequence V

contourf(..., V)

fill the len(V)-1 regions between the values in V

contour(Z, **kwargs)

Use keyword args to control colors, linewidth, origin, cmap ... see below for more details.

X and Y must both be 2-D with the same shape as Z, or they must both be 1-D such that len(X) is the number of columns in Z and len(Y) is the number of rows in Z.

C = contour(...) returns a :class:`~matplotlib.contour.QuadContourSet` object.

Optional keyword arguments:



contour-only keyword arguments:



contourf-only keyword arguments:



Note: contourf fills intervals that are closed at the top; that is, for boundaries z1 and z2, the filled region is:

z1 &lt; z &lt;= z2

There is one exception: if the lowest boundary coincides with the minimum value of the z array, then that minimum value will be included in the lowest interval.

Examples:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="origin" name="origin" port_type="basic:String">
      <docstring>If None, the first value of Z will correspond to the lower left corner, location (0,0). If 'image', the rc value for image.origin will be used.

This keyword is not active if X and Y are specified in the call to contour.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['upper', 'lower', 'image']]</values>
    </inputPortSpec>
    <inputPortSpec arg="linestyles" name="linestyles" port_type="basic:String">
      <docstring>If linestyles is None, the default is 'solid' unless the lines are monochrome.  In that case, negative contours will take their linestyle from the matplotlibrc contour.negative_linestyle setting.

linestyles can also be an iterable of the above strings specifying a set of linestyles to be used. If this iterable is shorter than the number of contour levels it will be repeated as necessary.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['solid', 'dashed', 'dashdot', 'dotted']]</values>
      <defaults>['solid']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xunits" name="xunits" port_type="basic:String">
      <docstring>Override axis units by specifying an instance of a :class:`matplotlib.units.ConversionInterface`.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['registered units']]</values>
    </inputPortSpec>
    <inputPortSpec arg="extend" name="extendSequence" port_type="basic:List">
      <docstring>Unless this is 'neither', contour levels are automatically added to one or both ends of the range so that all data are included. These added ranges are then mapped to the special colormap values which default to the ends of the colormap range, but can be set via :meth:`matplotlib.colors.Colormap.set_under` and :meth:`matplotlib.colors.Colormap.set_over` methods.</docstring>
      <alternateSpec arg="extend" name="extendScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['neither', 'both', 'min', 'max']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="vmin" name="vminSequence" port_type="basic:List">
      <docstring>If not None, either or both of these values will be supplied to the :class:`matplotlib.colors.Normalize` instance, overriding the default color scaling based on levels.</docstring>
      <alternateSpec arg="vmin" name="vminScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="linewidths" name="linewidths" port_type="basic:String">
      <docstring>If linewidths is None, the default width in lines.linewidth in matplotlibrc is used.

If a number, all levels will be plotted with this linewidth.

If a tuple, different levels will be plotted with different linewidths in the order specified.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['number', 'tuple of numbers']]</values>
    </inputPortSpec>
    <inputPortSpec arg="hatches" name="hatches" port_type="basic:List">
      <docstring>A list of cross hatch patterns to use on the filled areas. If None, no hatching will be added to the contour. Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="levels" name="levels" port_type="basic:List">
      <docstring>A list of floating point numbers indicating the level curves to draw; e.g., to draw just the zero contour pass levels=[0]</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nchunk" name="nchunk" port_type="basic:Integer">
      <docstring>If 0, no subdivision of the domain.  Specify a positive integer to divide the domain into subdomains of nchunk by nchunk quads. Chunking reduces the maximum length of polygons generated by the contouring algorithm which reduces the rendering workload passed on to the backend and also requires slightly less RAM.  It can however introduce rendering artifacts at chunk boundaries depending on the backend, the antialiased flag and value of alpha.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[0]]</values>
    </inputPortSpec>
    <inputPortSpec arg="locator" name="locator" port_type="basic:String">
      <docstring>If locator is None, the default :class:`~matplotlib.ticker.MaxNLocator` is used. The locator is used to determine the contour levels if they are not given explicitly via the V argument.</docstring>
      <entry_types>None</entry_types>
      <values>None</values>
    </inputPortSpec>
    <inputPortSpec arg="colors" name="colors">
      <docstring>If None, the colormap specified by cmap will be used.

If a string, like 'r' or 'red', all levels will be plotted in this color.

If a tuple of matplotlib color args (string, float, rgb, etc), different levels will be plotted in different colors in the order specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmap" name="cmap" port_type="basic:Color">
      <docstring>A cm :class:`~matplotlib.colors.Colormap` instance or None. If cmap is None and colors is None, a default Colormap is used.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="yunits" name="yunits" port_type="basic:String">
      <docstring>Override axis units by specifying an instance of a :class:`matplotlib.units.ConversionInterface`.</docstring>
      <entry_types>None</entry_types>
      <values>None</values>
    </inputPortSpec>
    <inputPortSpec arg="extent" name="extent" port_type="basic:String">
      <docstring>If origin is not None, then extent is interpreted as in :func:`matplotlib.pyplot.imshow`: it gives the outer pixel boundaries. In this case, the position of Z[0,0] is the center of the pixel, not a corner. If origin is None, then (x0, y0) is the position of Z[0,0], and (x1, y1) is the position of Z[-1,-1].

This keyword is not active if X and Y are specified in the call to contour.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['(x0,x1,y0,y1)']]</values>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>The alpha blending value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vmax" name="vmaxSequence" port_type="basic:List">
      <docstring>If not None, either or both of these values will be supplied to the :class:`matplotlib.colors.Normalize` instance, overriding the default color scaling based on levels.</docstring>
      <alternateSpec arg="vmax" name="vmaxScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="corner_mask" name="corner_mask">
      <docstring>Enable/disable corner masking, which only has an effect if Z is a masked array.  If False, any quad touching a masked point is masked out.  If True, only the triangular corners of quads nearest those points are always masked out, other triangular corners comprising three unmasked points are contoured as usual. If 'legacy', the old contouring algorithm is used, which is equivalent to False and is deprecated, only remaining whilst the new algorithm is tested fully.

If not specified, the default is taken from rcParams['contour.corner_mask'], which is True unless it has been modified.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['legacy']]</values>
      <defaults>['taken']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Z" arg_pos="2" in_args="True" name="Z" port_type="basic:List" required="True" />
    <inputPortSpec arg="antialiased" name="antialiased" port_type="basic:Boolean">
      <docstring>enable antialiasing, overriding the defaults.  For filled contours, the default is True.  For line contours, it is taken from rcParams['lines.antialiased'].</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="normSequence" port_type="basic:List">
      <docstring>A :class:`matplotlib.colors.Normalize` instance for scaling data values to colors. If norm is None and colors is None, the default linear scaling is used.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="V" arg_pos="3" in_args="True" name="V" port_type="basic:List" />
    <inputPortSpec arg="Y" arg_pos="1" in_args="True" name="Y" port_type="basic:List" />
    <inputPortSpec arg="X" arg_pos="0" in_args="True" name="X" port_type="basic:List" />
    <inputPortSpec arg="N" arg_pos="4" in_args="True" name="N" port_type="basic:Integer" />
    <outputPortSpec arg="contourSet" compute_name="contourSet" name="contourSet" port_type="MplQuadContourSet" property_key="0" />
    <outputPortSpec arg="lineCollection" compute_name="lineCollections" name="lineCollectionProperties" plural="True" port_type="__property__" property_key="1" property_type="matplotlib.collections.LineCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.contourf" name="MplContourf" output_type="tuple" superclass="MplPlot">
    <docstring>Plot contours.

:func:`~matplotlib.pyplot.contour` and :func:`~matplotlib.pyplot.contourf` draw contour lines and filled contours, respectively.  Except as noted, function signatures and return values are the same for both versions.

:func:`~matplotlib.pyplot.contourf` differs from the MATLAB version in that it does not draw the polygon edges. To draw edges, add line contours with calls to :func:`~matplotlib.pyplot.contour`.

Call signatures:

contour(Z)

make a contour plot of an array Z. The level values are chosen automatically.

contour(X,Y,Z)

X, Y specify the (x, y) coordinates of the surface

contour(Z,N) contour(X,Y,Z,N)

contour up to N automatically-chosen levels.

contour(Z,V) contour(X,Y,Z,V)

draw contour lines at the values specified in sequence V

contourf(..., V)

fill the len(V)-1 regions between the values in V

contour(Z, **kwargs)

Use keyword args to control colors, linewidth, origin, cmap ... see below for more details.

X and Y must both be 2-D with the same shape as Z, or they must both be 1-D such that len(X) is the number of columns in Z and len(Y) is the number of rows in Z.

C = contour(...) returns a :class:`~matplotlib.contour.QuadContourSet` object.

Optional keyword arguments:

extent: [ None | (x0,x1,y0,y1) ]

If origin is not None, then extent is interpreted as in :func:`matplotlib.pyplot.imshow`: it gives the outer pixel boundaries. In this case, the position of Z[0,0] is the center of the pixel, not a corner. If origin is None, then (x0, y0) is the position of Z[0,0], and (x1, y1) is the position of Z[-1,-1].

This keyword is not active if X and Y are specified in the call to contour.

contour-only keyword arguments:



contourf-only keyword arguments:



Note: contourf fills intervals that are closed at the top; that is, for boundaries z1 and z2, the filled region is:

z1 &lt; z &lt;= z2

There is one exception: if the lowest boundary coincides with the minimum value of the z array, then that minimum value will be included in the lowest interval.

Examples:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="origin" name="origin" port_type="basic:String">
      <docstring>If None, the first value of Z will correspond to the lower left corner, location (0,0). If 'image', the rc value for image.origin will be used.

This keyword is not active if X and Y are specified in the call to contour.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['upper', 'lower', 'image']]</values>
    </inputPortSpec>
    <inputPortSpec arg="linestyles" name="linestyles" port_type="basic:String">
      <docstring>If linestyles is None, the default is 'solid' unless the lines are monochrome.  In that case, negative contours will take their linestyle from the matplotlibrc contour.negative_linestyle setting.

linestyles can also be an iterable of the above strings specifying a set of linestyles to be used. If this iterable is shorter than the number of contour levels it will be repeated as necessary.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['solid', 'dashed', 'dashdot', 'dotted']]</values>
      <defaults>['solid']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vmin" name="vminSequence" port_type="basic:List">
      <docstring>If not None, either or both of these values will be supplied to the :class:`matplotlib.colors.Normalize` instance, overriding the default color scaling based on levels.</docstring>
      <alternateSpec arg="vmin" name="vminScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="hatches" name="hatches" port_type="basic:List">
      <docstring>A list of cross hatch patterns to use on the filled areas. If None, no hatching will be added to the contour. Hatching is supported in the PostScript, PDF, SVG and Agg backends only.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="levels" name="levels" port_type="basic:List">
      <docstring>A list of floating point numbers indicating the level curves to draw; e.g., to draw just the zero contour pass levels=[0]</docstring>
    </inputPortSpec>
    <inputPortSpec arg="linewidths" name="linewidths" port_type="basic:String">
      <docstring>If linewidths is None, the default width in lines.linewidth in matplotlibrc is used.

If a number, all levels will be plotted with this linewidth.

If a tuple, different levels will be plotted with different linewidths in the order specified.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['number', 'tuple of numbers']]</values>
    </inputPortSpec>
    <inputPortSpec arg="colors" name="colors">
      <docstring>If None, the colormap specified by cmap will be used.

If a string, like 'r' or 'red', all levels will be plotted in this color.

If a tuple of matplotlib color args (string, float, rgb, etc), different levels will be plotted in different colors in the order specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmap" name="cmap" port_type="basic:Color">
      <docstring>A cm :class:`~matplotlib.colors.Colormap` instance or None. If cmap is None and colors is None, a default Colormap is used.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>The alpha blending value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vmax" name="vmaxSequence" port_type="basic:List">
      <docstring>If not None, either or both of these values will be supplied to the :class:`matplotlib.colors.Normalize` instance, overriding the default color scaling based on levels.</docstring>
      <alternateSpec arg="vmax" name="vmaxScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="corner_mask" name="corner_mask">
      <docstring>Enable/disable corner masking, which only has an effect if Z is a masked array.  If False, any quad touching a masked point is masked out.  If True, only the triangular corners of quads nearest those points are always masked out, other triangular corners comprising three unmasked points are contoured as usual. If 'legacy', the old contouring algorithm is used, which is equivalent to False and is deprecated, only remaining whilst the new algorithm is tested fully.

If not specified, the default is taken from rcParams['contour.corner_mask'], which is True unless it has been modified.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['legacy']]</values>
      <defaults>['taken']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Z" arg_pos="2" in_args="True" name="Z" port_type="basic:List" required="True" />
    <inputPortSpec arg="norm" name="normSequence" port_type="basic:List">
      <docstring>A :class:`matplotlib.colors.Normalize` instance for scaling data values to colors. If norm is None and colors is None, the default linear scaling is used.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="N" arg_pos="4" in_args="True" name="N" port_type="basic:Integer" />
    <inputPortSpec arg="V" arg_pos="3" in_args="True" name="V" port_type="basic:List" />
    <inputPortSpec arg="Y" arg_pos="1" in_args="True" name="Y" port_type="basic:List" />
    <inputPortSpec arg="X" arg_pos="0" in_args="True" name="X" port_type="basic:List" />
    <outputPortSpec arg="contourSet" compute_name="contourSet" name="contourSet" port_type="MplQuadContourSet" property_key="0" />
    <outputPortSpec arg="polyCollection" compute_name="polyCollections" name="polyCollectionProperties" plural="True" port_type="__property__" property_key="1" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.csd" name="MplCsd" superclass="MplPlot">
    <docstring>Plot the cross-spectral density.

Call signature::

  csd(x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
      window=mlab.window_hanning, noverlap=0, pad_to=None,
      sides='default', scale_by_freq=None, return_line=None, **kwargs)

The cross spectral density :math:`P_{xy}` by Welch's average
periodogram method.  The vectors *x* and *y* are divided into
*NFFT* length segments.  Each segment is detrended by function
*detrend* and windowed by function *window*.  *noverlap* gives
the length of the overlap between segments.  The product of
the direct FFTs of *x* and *y* are averaged over each segment
to compute :math:`P_{xy}`, with a scaling to correct for power
loss due to windowing.

If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero
padded to *NFFT*.

  *x*, *y*: 1-D arrays or sequences
    Arrays or sequences containing the data

%(Spectral)s

%(PSD)s

  *noverlap*: integer
    The number of points of overlap between segments.
    The default value is 0 (no overlap).

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

  *return_line*: bool
    Whether to include the line object plotted in the returned values.
    Default is False.

If *return_line* is False, returns the tuple (*Pxy*, *freqs*).
If *return_line* is True, returns the tuple (*Pxy*, *freqs*. *line*):

  *Pxy*: 1-D array
    The values for the cross spectrum `P_{xy}` before scaling
    (complex valued)

  *freqs*: 1-D array
    The frequencies corresponding to the elements in *Pxy*

  *line*: a :class:`~matplotlib.lines.Line2D` instance
    The line created by this function.
    Only returend if *return_line* is True.

For plotting, the power is plotted as
:math:`10\log_{10}(P_{xy})` for decibels, though `P_{xy}` itself
is returned.

References:
  Bendat &amp; Piersol -- Random Data: Analysis and Measurement
  Procedures, John Wiley &amp; Sons (1986)

kwargs control the Line2D properties:

%(Line2D)s

**Example:**

.. plot:: mpl_examples/pylab_examples/csd_demo.py

.. seealso::

    :func:`psd`
        :func:`psd` is the equivalent to setting y=x.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="return_line" arg_pos="11" name="return_line" />
    <inputPortSpec arg="Fs" arg_pos="3" name="Fs" port_type="basic:Integer">
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pad_to" arg_pos="8" name="pad_to" />
    <inputPortSpec arg="scale_by_freq" arg_pos="10" name="scale_by_freq" />
    <inputPortSpec arg="detrend" arg_pos="5" name="detrend" />
    <inputPortSpec arg="window" arg_pos="6" name="window" />
    <inputPortSpec arg="Fc" arg_pos="4" name="Fc" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="NFFT" arg_pos="2" name="NFFT" port_type="basic:Integer">
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="12" name="hold" />
    <inputPortSpec arg="data" arg_pos="13" name="data" />
    <inputPortSpec arg="sides" arg_pos="9" name="sides" port_type="basic:String">
      <defaults>['default']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" arg_pos="7" name="noverlap" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="line" constructor_arg="True" name="lineProperties" port_type="__property__" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.errorbar" name="MplErrorbar" output_type="tuple" superclass="MplPlot">
    <docstring>Plot an errorbar graph.

Call signature::

  errorbar(x, y, yerr=None, xerr=None,
           fmt='', ecolor=None, elinewidth=None, capsize=None,
           barsabove=False, lolims=False, uplims=False,
           xlolims=False, xuplims=False, errorevery=1,
           capthick=None)

Plot *x* versus *y* with error deltas in *yerr* and *xerr*.
Vertical errorbars are plotted if *yerr* is not *None*.
Horizontal errorbars are plotted if *xerr* is not *None*.

*x*, *y*, *xerr*, and *yerr* can all be scalars, which plots a
single error bar at *x*, *y*.

Optional keyword arguments:

  *xerr*/*yerr*: [ scalar | N, Nx1, or 2xN array-like ]
    If a scalar number, len(N) array-like object, or an Nx1
    array-like object, errorbars are drawn at +/-value relative
    to the data.

    If a sequence of shape 2xN, errorbars are drawn at -row1
    and +row2 relative to the data.

  *fmt*: [ '' | 'none' | plot format string ]
    The plot format symbol. If *fmt* is 'none' (case-insensitive),
    only the errorbars are plotted.  This is used for adding
    errorbars to a bar plot, for example.  Default is '',
    an empty plot format string; properties are
    then identical to the defaults for :meth:`plot`.

  *ecolor*: [ *None* | mpl color ]
    A matplotlib color arg which gives the color the errorbar lines;
    if *None*, use the color of the line connecting the markers.

  *elinewidth*: scalar
    The linewidth of the errorbar lines. If *None*, use the linewidth.

  *capsize*: scalar
    The length of the error bar caps in points; if *None*, it will
    take the value from ``errorbar.capsize``
    :data:`rcParam&lt;matplotlib.rcParams&gt;`.

  *capthick*: scalar
    An alias kwarg to *markeredgewidth* (a.k.a. - *mew*). This
    setting is a more sensible name for the property that
    controls the thickness of the error bar cap in points. For
    backwards compatibility, if *mew* or *markeredgewidth* are given,
    then they will over-ride *capthick*.  This may change in future
    releases.

  *barsabove*: [ *True* | *False* ]
    if *True*, will plot the errorbars above the plot
    symbols. Default is below.

  *lolims* / *uplims* / *xlolims* / *xuplims*: [ *False* | *True* ]
    These arguments can be used to indicate that a value gives
    only upper/lower limits. In that case a caret symbol is
    used to indicate this. lims-arguments may be of the same
    type as *xerr* and *yerr*.  To use limits with inverted
    axes, :meth:`set_xlim` or :meth:`set_ylim` must be called
    before :meth:`errorbar`.

  *errorevery*: positive integer
    subsamples the errorbars. e.g., if errorevery=5, errorbars for
    every 5-th datapoint will be plotted. The data plot itself still
    shows all data points.

All other keyword arguments are passed on to the plot command for the
markers. For example, this code makes big red squares with
thick green edges::

  x,y,yerr = rand(3,10)
  errorbar(x, y, yerr, marker='s',
           mfc='red', mec='green', ms=20, mew=4)

where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
property names, *markerfacecolor*, *markeredgecolor*, *markersize*
and *markeredgewith*.

valid kwargs for the marker properties are

%(Line2D)s

Returns (*plotline*, *caplines*, *barlinecols*):

    *plotline*: :class:`~matplotlib.lines.Line2D` instance
        *x*, *y* plot markers and/or line

    *caplines*: list of error bar cap
        :class:`~matplotlib.lines.Line2D` instances
    *barlinecols*: list of
        :class:`~matplotlib.collections.LineCollection` instances for
        the horizontal and vertical error ranges.

**Example:**

.. plot:: mpl_examples/statistics/errorbar_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x', 'yerr', 'xerr'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="lolims" arg_pos="9" name="lolims" port_type="basic:Boolean">
      <docstring>These arguments can be used to indicate that a value gives only upper/lower limits. In that case a caret symbol is used to indicate this. lims-arguments may be of the same type as xerr and yerr.  To use limits with inverted axes, :meth:`set_xlim` or :meth:`set_ylim` must be called before :meth:`errorbar`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="capsize" arg_pos="7" name="capsize" port_type="basic:Float">
      <docstring>The length of the error bar caps in points; if None, it will take the value from errorbar.capsize :data:`rcParam&lt;matplotlib.rcParams&gt;`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="uplims" arg_pos="10" name="uplims" port_type="basic:Boolean">
      <docstring>These arguments can be used to indicate that a value gives only upper/lower limits. In that case a caret symbol is used to indicate this. lims-arguments may be of the same type as xerr and yerr.  To use limits with inverted axes, :meth:`set_xlim` or :meth:`set_ylim` must be called before :meth:`errorbar`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xlolims" arg_pos="11" name="xlolims" port_type="basic:Boolean">
      <docstring>These arguments can be used to indicate that a value gives only upper/lower limits. In that case a caret symbol is used to indicate this. lims-arguments may be of the same type as xerr and yerr.  To use limits with inverted axes, :meth:`set_xlim` or :meth:`set_ylim` must be called before :meth:`errorbar`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="barsabove" arg_pos="8" name="barsabove">
      <docstring>if True, will plot the errorbars above the plot symbols. Default is below.</docstring>
      <defaults>['below']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xerr" arg_pos="3" name="xerr" port_type="basic:List">
      <docstring>If a scalar number, len(N) array-like object, or an Nx1 array-like object, errorbars are drawn +/- value.

If a sequence of shape 2xN, errorbars are drawn at -row1 and +row2</docstring>
      <entry_types>None</entry_types>
      <values>None</values>
      <alternateSpec arg="xerr" name="xerrScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="fmt" arg_pos="4" name="fmt" port_type="basic:String">
      <docstring>The plot format symbol. If fmt is 'none' (case-insensitive), only the errorbars are plotted.  This is used for adding errorbars to a bar plot, for example.  Default is '', an empty plot format string; properties are then identical to the defaults for :meth:`plot`.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['', 'none']]</values>
      <defaults>[u'']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ecolor" arg_pos="5" name="ecolor" port_type="basic:Color">
      <docstring>A matplotlib color arg which gives the color the errorbar lines; if None, use the color of the line connecting the markers.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="errorevery" arg_pos="13" name="errorevery" port_type="basic:Integer">
      <docstring>subsamples the errorbars. e.g., if errorevery=5, errorbars for every 5-th datapoint will be plotted. The data plot itself still shows all data points.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="capthick" arg_pos="14" name="capthick" port_type="basic:Float">
      <docstring>An alias kwarg to markeredgewidth (a.k.a. - mew). This setting is a more sensible name for the property that controls the thickness of the error bar cap in points. For backwards compatibility, if mew or markeredgewidth are given, then they will over-ride capthick.  This may change in future releases.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xuplims" arg_pos="12" name="xuplims" port_type="basic:Boolean">
      <docstring>These arguments can be used to indicate that a value gives only upper/lower limits. In that case a caret symbol is used to indicate this. lims-arguments may be of the same type as xerr and yerr.  To use limits with inverted axes, :meth:`set_xlim` or :meth:`set_ylim` must be called before :meth:`errorbar`.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="elinewidth" arg_pos="6" name="elinewidth" port_type="basic:Float">
      <docstring>The linewidth of the errorbar lines. If None, use the linewidth.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="15" name="hold" />
    <inputPortSpec arg="data" arg_pos="16" name="data" />
    <inputPortSpec arg="yerr" arg_pos="2" name="yerr" port_type="basic:List">
      <docstring>If a scalar number, len(N) array-like object, or an Nx1 array-like object, errorbars are drawn +/- value.

If a sequence of shape 2xN, errorbars are drawn at -row1 and +row2</docstring>
      <entry_types>None</entry_types>
      <values>None</values>
      <alternateSpec arg="yerr" name="yerrScalar" port_type="basic:Float" />
    </inputPortSpec>
    <outputPortSpec arg="capline" compute_name="caplines" name="caplineProperties" plural="True" port_type="__property__" property_key="1" property_type="matplotlib.lines.Line2D" />
    <outputPortSpec arg="barline" compute_name="barlines" name="barlineProperties" plural="True" port_type="__property__" property_key="2" property_type="matplotlib.collections.LineCollection" />
    <outputPortSpec arg="plotline" compute_name="plotline" name="plotlineProperties" port_type="__property__" property_key="0" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.fill" name="MplFill" output_type="object" superclass="MplPlot">
    <docstring>Plot filled polygons.

Call signature::

  fill(*args, **kwargs)

*args* is a variable length argument, allowing for multiple
*x*, *y* pairs with an optional color format string; see
:func:`~matplotlib.pyplot.plot` for details on the argument
parsing.  For example, to plot a polygon with vertices at *x*,
*y* in blue.::

  ax.fill(x,y, 'b' )

An arbitrary number of *x*, *y*, *color* groups can be specified::

  ax.fill(x1, y1, 'g', x2, y2, 'r')

Return value is a list of :class:`~matplotlib.patches.Patch`
instances that were added.

The same color strings that :func:`~matplotlib.pyplot.plot`
supports are supported by the fill format string.

If you would like to fill below a curve, e.g., shade a region
between 0 and *y* along *x*, use :meth:`fill_between`

The *closed* kwarg will close the polygon when *True* (default).

kwargs control the :class:`~matplotlib.patches.Polygon` properties:

%(Polygon)s

**Example:**

.. plot:: mpl_examples/lines_bars_and_markers/fill_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True" />
    <outputPortSpec arg="polygon" compute_name="polygons" name="polygonProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.patches.Polygon" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.fill_between" name="MplFillBetween" output_type="object" superclass="MplPlot">
    <docstring>Make filled polygons between two curves.


Create a :class:`~matplotlib.collections.PolyCollection`
filling the regions between *y1* and *y2* where
``where==True``

Parameters
----------
x : array
    An N-length array of the x data

y1 : array
    An N-length array (or scalar) of the y data

y2 : array
    An N-length array (or scalar) of the y data

where : array, optional
    If `None`, default to fill between everywhere.  If not `None`,
    it is an N-length numpy boolean array and the fill will
    only happen over the regions where ``where==True``.

interpolate : bool, optional
    If `True`, interpolate between the two lines to find the
    precise point of intersection.  Otherwise, the start and
    end points of the filled region will only occur on explicit
    values in the *x* array.

step : {'pre', 'post', 'mid'}, optional
    If not None, fill with step logic.


Notes
-----

Additional Keyword args passed on to the
:class:`~matplotlib.collections.PolyCollection`.

kwargs control the :class:`~matplotlib.patches.Polygon` properties:

%(PolyCollection)s

Examples
--------

.. plot:: mpl_examples/pylab_examples/fill_between_demo.py

See Also
--------

    :meth:`fill_betweenx`
        for filling between two sets of x-values

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y1', 'x', 'y2', 'where'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="hold" arg_pos="6" name="hold" />
    <inputPortSpec arg="data" arg_pos="7" name="data" />
    <inputPortSpec arg="interpolate" arg_pos="4" name="interpolate" port_type="basic:Boolean">
      <docstring>If `True`, interpolate between the two lines to find the
precise point of intersection.  Otherwise, the start and
end points of the filled region will only occur on explicit
values in the *x* array.
</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="step" arg_pos="5" name="step">
      <docstring>If not None, fill with step logic.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y1" arg_pos="1" in_args="True" name="y1" port_type="basic:List" required="True">
      <docstring>An N-length array of the y data</docstring>
      <alternateSpec arg="y1" name="y1Scalar" port_type="basic:Float">
        <docstring>A scalar y-value</docstring>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True">
      <docstring>An N-length array of the x data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y2" arg_pos="2" name="y2" port_type="basic:Float">
      <docstring>A scalar y-value</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="y2" name="y2Sequence" port_type="basic:List">
        <docstring>An N-length array of the y data</docstring>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="where" arg_pos="3" name="where" port_type="basic:List">
      <docstring>An N-length boolean array that specifies where the fill is effective</docstring>
    </inputPortSpec>
    <outputPortSpec arg="polyCollection" compute_name="polyCollection" name="polyCollectionProperties" port_type="__property__" property_key="__none__" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.fill_betweenx" name="MplFillBetweenx" output_type="object" superclass="MplPlot">
    <docstring>Make filled polygons between two horizontal curves.

Call signature:

fill_between(y, x1, x2=0, where=None, **kwargs)

Create a :class:`~matplotlib.collections.PolyCollection` filling the regions between x1 and x2 where where==True



kwargs control the :class:`~matplotlib.patches.Polygon` properties:

%(PolyCollection)s

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="hold" arg_pos="5" name="hold" />
    <inputPortSpec arg="data" arg_pos="6" name="data" />
    <inputPortSpec arg="x2" arg_pos="2" name="x2" port_type="basic:Float">
      <docstring>A scalar x-value</docstring>
      <defaults>[0]</defaults>
      <alternateSpec arg="x2" name="x2Sequence" port_type="basic:List">
        <docstring>An N-length array of the x data</docstring>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="step" arg_pos="4" name="step">
      <docstring>If not None, fill with step logic.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="0" in_args="True" name="y" port_type="basic:List" required="True">
      <docstring>An N-length array of the y data</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x1" arg_pos="1" in_args="True" name="x1" port_type="basic:List" required="True">
      <docstring>An N-length array of the x data</docstring>
      <alternateSpec arg="x1" name="x1Scalar" port_type="basic:Float">
        <docstring>A scalar x-value</docstring>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="where" arg_pos="3" name="where" port_type="basic:List">
      <docstring>An N-length boolean array that specifies where the fill is effective</docstring>
    </inputPortSpec>
    <outputPortSpec arg="polyCollection" compute_name="polyCollection" name="polyCollectionProperties" port_type="__property__" property_key="__none__" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.hexbin" name="MplHexbin" output_type="object" superclass="MplPlot">
    <docstring>Make a hexagonal binning plot.

Call signature::

   hexbin(x, y, C = None, gridsize = 100, bins = None,
          xscale = 'linear', yscale = 'linear',
          cmap=None, norm=None, vmin=None, vmax=None,
          alpha=None, linewidths=None, edgecolors='none'
          reduce_C_function = np.mean, mincnt=None, marginals=True
          **kwargs)

Make a hexagonal binning plot of *x* versus *y*, where *x*,
*y* are 1-D sequences of the same length, *N*. If *C* is *None*
(the default), this is a histogram of the number of occurences
of the observations at (x[i],y[i]).

If *C* is specified, it specifies values at the coordinate
(x[i],y[i]). These values are accumulated for each hexagonal
bin and then reduced according to *reduce_C_function*, which
defaults to numpy's mean function (np.mean). (If *C* is
specified, it must also be a 1-D sequence of the same length
as *x* and *y*.)

*x*, *y* and/or *C* may be masked arrays, in which case only
unmasked points will be plotted.

Optional keyword arguments:

*gridsize*: [ 100 | integer ]
   The number of hexagons in the *x*-direction, default is
   100. The corresponding number of hexagons in the
   *y*-direction is chosen such that the hexagons are
   approximately regular. Alternatively, gridsize can be a
   tuple with two elements specifying the number of hexagons
   in the *x*-direction and the *y*-direction.

*bins*: [ *None* | 'log' | integer | sequence ]
   If *None*, no binning is applied; the color of each hexagon
   directly corresponds to its count value.

   If 'log', use a logarithmic scale for the color
   map. Internally, :math:`log_{10}(i+1)` is used to
   determine the hexagon color.

   If an integer, divide the counts in the specified number
   of bins, and color the hexagons accordingly.

   If a sequence of values, the values of the lower bound of
   the bins to be used.

*xscale*: [ 'linear' | 'log' ]
   Use a linear or log10 scale on the horizontal axis.

*scale*: [ 'linear' | 'log' ]
   Use a linear or log10 scale on the vertical axis.

*mincnt*: [ *None* | a positive integer ]
   If not *None*, only display cells with more than *mincnt*
   number of points in the cell

*marginals*: [ *True* | *False* ]
   if marginals is *True*, plot the marginal density as
   colormapped rectagles along the bottom of the x-axis and
   left of the y-axis

*extent*: [ *None* | scalars (left, right, bottom, top) ]
   The limits of the bins. The default assigns the limits
   based on gridsize, x, y, xscale and yscale.

Other keyword arguments controlling color mapping and normalization
arguments:

*cmap*: [ *None* | Colormap ]
   a :class:`matplotlib.colors.Colormap` instance. If *None*,
   defaults to rc ``image.cmap``.

*norm*: [ *None* | Normalize ]
   :class:`matplotlib.colors.Normalize` instance is used to
   scale luminance data to 0,1.

*vmin* / *vmax*: scalar
   *vmin* and *vmax* are used in conjunction with *norm* to normalize
   luminance data.  If either are *None*, the min and max of the color
   array *C* is used.  Note if you pass a norm instance, your settings
   for *vmin* and *vmax* will be ignored.

*alpha*: scalar between 0 and 1, or *None*
   the alpha value for the patches

*linewidths*: [ *None* | scalar ]
   If *None*, defaults to rc lines.linewidth. Note that this
   is a tuple, and if you set the linewidths argument you
   must set it as a sequence of floats, as required by
   :class:`~matplotlib.collections.RegularPolyCollection`.

Other keyword arguments controlling the Collection properties:

*edgecolors*: [ *None* | ``'none'`` | mpl color | color sequence ]
   If ``'none'``, draws the edges in the same color as the fill color.
   This is the default, as it avoids unsightly unpainted pixels
   between the hexagons.

   If *None*, draws the outlines in the default color.

   If a matplotlib color arg or sequence of rgba tuples, draws the
   outlines in the specified color.

Here are the standard descriptions of all the
:class:`~matplotlib.collections.Collection` kwargs:

%(Collection)s

The return value is a
:class:`~matplotlib.collections.PolyCollection` instance; use
:meth:`~matplotlib.collections.PolyCollection.get_array` on
this :class:`~matplotlib.collections.PolyCollection` to get
the counts in each hexagon. If *marginals* is *True*, horizontal
bar and vertical bar (both PolyCollections) will be attached
to the return collection as attributes *hbar* and *vbar*.


**Example:**

.. plot:: mpl_examples/pylab_examples/hexbin_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="vmax" arg_pos="11" name="vmax" port_type="basic:Color">
      <docstring>vmin and vmax are used in conjunction with norm to normalize luminance data.  If either are None, the min and max of the color array C is used.  Note if you pass a norm instance, your settings for vmin and vmax will be ignored.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="edgecolors" arg_pos="14" name="edgecolors">
      <docstring>If 'none', draws the edges in the same color as the fill color. This is the default, as it avoids unsightly unpainted pixels between the hexagons.

If None, draws the outlines in the default color.

If a matplotlib color arg or sequence of rgba tuples, draws the outlines in the specified color.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['none']]</values>
      <defaults>[u'none']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="C" arg_pos="2" name="C" port_type="basic:List" />
    <inputPortSpec arg="gridsize" arg_pos="3" name="gridsize" port_type="basic:Integer">
      <docstring>The number of hexagons in the x-direction, default is 100. The corresponding number of hexagons in the y-direction is chosen such that the hexagons are approximately regular. Alternatively, gridsize can be a tuple with two elements specifying the number of hexagons in the x-direction and the y-direction.</docstring>
      <entry_types>None</entry_types>
      <values>None</values>
      <defaults>[100]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vmin" arg_pos="10" name="vmin" port_type="basic:Color">
      <docstring>vmin and vmax are used in conjunction with norm to normalize luminance data.  If either are None, the min and max of the color array C is used.  Note if you pass a norm instance, your settings for vmin and vmax will be ignored.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="yscale" arg_pos="6" name="yscale" port_type="basic:String">
      <defaults>[u'linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="reduce_C_function" arg_pos="15" name="reduce_C_function">
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="linewidths" arg_pos="13" name="linewidthsSequence" port_type="basic:List">
      <docstring>If None, defaults to rc lines.linewidth. Note that this is a tuple, and if you set the linewidths argument you must set it as a sequence of floats, as required by :class:`~matplotlib.collections.RegularPolyCollection`.</docstring>
      <alternateSpec arg="linewidths" name="linewidthsScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="xscale" arg_pos="5" name="xscale" port_type="basic:String">
      <docstring>Use a linear or log10 scale on the horizontal axis.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'log']]</values>
      <defaults>[u'linear']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cmap" arg_pos="8" name="cmap" port_type="basic:Color">
      <docstring>a :class:`matplotlib.colors.Colormap` instance. If None, defaults to rc image.cmap.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="norm" arg_pos="9" name="normSequence" port_type="basic:List">
      <docstring>:class:`matplotlib.colors.Normalize` instance is used to scale luminance data to 0,1.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="extent" arg_pos="7" name="extent" port_type="basic:Float">
      <docstring>The limits of the bins. The default assigns the limits based on gridsize, x, y, xscale and yscale.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" arg_pos="12" name="alpha" port_type="basic:Float">
      <docstring>the alpha value for the patches</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="18" name="hold" />
    <inputPortSpec arg="mincnt" arg_pos="16" name="mincnt" port_type="basic:Integer">
      <docstring>If not None, only display cells with more than mincnt number of points in the cell</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" arg_pos="19" name="data" />
    <inputPortSpec arg="marginals" arg_pos="17" name="marginals" port_type="basic:Boolean">
      <docstring>if marginals is True, plot the marginal density as colormapped rectagles along the bottom of the x-axis and left of the y-axis</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bins" arg_pos="4" name="bins" port_type="basic:Integer">
      <docstring>If None, no binning is applied; the color of each hexagon directly corresponds to its count value.

If 'log', use a logarithmic scale for the color map. Internally, log_{10}(i+1) is used to determine the hexagon color.

If an integer, divide the counts in the specified number of bins, and color the hexagons accordingly.

If a sequence of values, the values of the lower bound of the bins to be used.</docstring>
      <translations>translate_color</translations>
      <entry_types>None</entry_types>
      <values>None</values>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:String">
      <docstring>Use a linear or log10 scale on the vertical axis.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['linear', 'log']]</values>
    </inputPortSpec>
    <outputPortSpec arg="polyCollection" compute_name="polyCollection" name="polyCollectionProperties" port_type="__property__" property_key="-1" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.hist" name="MplHist" output_type="tuple" superclass="MplPlot">
    <docstring>Plot a histogram.

Compute and draw the histogram of *x*. The return value is a
tuple (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*,
[*patches0*, *patches1*,...]) if the input contains multiple
data.

Multiple data can be provided via *x* as a list of datasets
of potentially different length ([*x0*, *x1*, ...]), or as
a 2-D ndarray in which each column is a dataset.  Note that
the ndarray form is transposed relative to the list form.

Masked arrays are not supported at present.

Parameters
----------
x : (n,) array or sequence of (n,) arrays
    Input values, this takes either a single array or a sequency of
    arrays which are not required to be of the same length

bins : integer or array_like, optional
    If an integer is given, `bins + 1` bin edges are returned,
    consistently with :func:`numpy.histogram` for numpy version &gt;=
    1.3.

    Unequally spaced bins are supported if `bins` is a sequence.

    default is 10

range : tuple or None, optional
    The lower and upper range of the bins. Lower and upper outliers
    are ignored. If not provided, `range` is (x.min(), x.max()). Range
    has no effect if `bins` is a sequence.

    If `bins` is a sequence or `range` is specified, autoscaling
    is based on the specified bin range instead of the
    range of x.

    Default is ``None``

normed : boolean, optional
    If `True`, the first element of the return tuple will
    be the counts normalized to form a probability density, i.e.,
    ``n/(len(x)`dbin)``, i.e., the integral of the histogram will sum
    to 1. If *stacked* is also *True*, the sum of the histograms is
    normalized to 1.

    Default is ``False``

weights : (n, ) array_like or None, optional
    An array of weights, of the same shape as `x`.  Each value in `x`
    only contributes its associated weight towards the bin count
    (instead of 1).  If `normed` is True, the weights are normalized,
    so that the integral of the density over the range remains 1.

    Default is ``None``

cumulative : boolean, optional
    If `True`, then a histogram is computed where each bin gives the
    counts in that bin plus all bins for smaller values. The last bin
    gives the total number of datapoints.  If `normed` is also `True`
    then the histogram is normalized such that the last bin equals 1.
    If `cumulative` evaluates to less than 0 (e.g., -1), the direction
    of accumulation is reversed.  In this case, if `normed` is also
    `True`, then the histogram is normalized such that the first bin
    equals 1.

    Default is ``False``

bottom : array_like, scalar, or None
    Location of the bottom baseline of each bin.  If a scalar,
    the base line for each bin is shifted by the same amount.
    If an array, each bin is shifted independently and the length
    of bottom must match the number of bins.  If None, defaults to 0.

    Default is ``None``

histtype : {'bar', 'barstacked', 'step',  'stepfilled'}, optional
    The type of histogram to draw.

    - 'bar' is a traditional bar-type histogram.  If multiple data
      are given the bars are aranged side by side.

    - 'barstacked' is a bar-type histogram where multiple
      data are stacked on top of each other.

    - 'step' generates a lineplot that is by default
      unfilled.

    - 'stepfilled' generates a lineplot that is by default
      filled.

    Default is 'bar'

align : {'left', 'mid', 'right'}, optional
    Controls how the histogram is plotted.

        - 'left': bars are centered on the left bin edges.

        - 'mid': bars are centered between the bin edges.

        - 'right': bars are centered on the right bin edges.

    Default is 'mid'

orientation : {'horizontal', 'vertical'}, optional
    If 'horizontal', `~matplotlib.pyplot.barh` will be used for
    bar-type histograms and the *bottom* kwarg will be the left edges.

rwidth : scalar or None, optional
    The relative width of the bars as a fraction of the bin width.  If
    `None`, automatically compute the width.

    Ignored if `histtype` is 'step' or 'stepfilled'.

    Default is ``None``

log : boolean, optional
    If `True`, the histogram axis will be set to a log scale. If `log`
    is `True` and `x` is a 1D array, empty bins will be filtered out
    and only the non-empty (`n`, `bins`, `patches`) will be returned.

    Default is ``False``

color : color or array_like of colors or None, optional
    Color spec or sequence of color specs, one per dataset.  Default
    (`None`) uses the standard line color sequence.

    Default is ``None``

label : string or None, optional
    String, or sequence of strings to match multiple datasets.  Bar
    charts yield multiple patches per dataset, but only the first gets
    the label, so that the legend command will work as expected.

    default is ``None``

stacked : boolean, optional
    If `True`, multiple data are stacked on top of each other If
    `False` multiple data are aranged side by side if histtype is
    'bar' or on top of each other if histtype is 'step'

    Default is ``False``

Returns
-------
n : array or list of arrays
    The values of the histogram bins. See **normed** and **weights**
    for a description of the possible semantics. If input **x** is an
    array, then this is an array of length **nbins**. If input is a
    sequence arrays ``[data1, data2,..]``, then this is a list of
    arrays with the values of the histograms for each of the arrays
    in the same order.

bins : array
    The edges of the bins. Length nbins + 1 (nbins left edges and right
    edge of last bin).  Always a single array even when multiple data
    sets are passed in.

patches : list or list of lists
    Silent list of individual patches used to create the histogram
    or list of such list if multiple input datasets.

Other Parameters
----------------
kwargs : `~matplotlib.patches.Patch` properties

See also
--------
hist2d : 2D histograms

Notes
-----
Until numpy release 1.5, the underlying numpy histogram function was
incorrect with `normed`=`True` if bin sizes were unequal.  MPL
inherited that error.  It is now corrected within MPL when using
earlier numpy versions.

Examples
--------
.. plot:: mpl_examples/statistics/histogram_demo_features.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'x', 'weights'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="rwidth" arg_pos="10" name="rwidth" port_type="basic:Float">
      <docstring>The relative width of the bars as a fraction of the bin width.  If
`None`, automatically compute the width.

Ignored if `histtype` is 'step' or 'stepfilled'.

Default is ``None``
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="normed" arg_pos="3" name="normed" port_type="basic:Boolean">
      <docstring>If `True`, the first element of the return tuple will
be the counts normalized to form a probability density, i.e.,
``n/(len(x)`dbin)``, i.e., the integral of the histogram will sum
to 1. If *stacked* is also *True*, the sum of the histograms is
normalized to 1.

Default is ``False``
</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="stacked" arg_pos="14" name="stacked" port_type="basic:Boolean">
      <docstring>If `True`, multiple data are stacked on top of each other If
`False` multiple data are aranged side by side if histtype is
'bar' or on top of each other if histtype is 'step'

Default is ``False``</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="orientation" arg_pos="9" name="orientation" port_type="basic:String">
      <docstring>If 'horizontal', `~matplotlib.pyplot.barh` will be used for
bar-type histograms and the *bottom* kwarg will be the left edges.
</docstring>
      <defaults>[u'vertical']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="bottom" arg_pos="6" name="bottom" port_type="basic:Float">
      <docstring>Location of the bottom baseline of each bin.  If a scalar,
the base line for each bin is shifted by the same amount.
If an array, each bin is shifted independently and the length
of bottom must match the number of bins.  If None, defaults to 0.

Default is ``None``
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="color" arg_pos="12" name="color" port_type="basic:Color">
      <docstring>Color spec or sequence of color specs, one per dataset.  Default
(`None`) uses the standard line color sequence.

Default is ``None``
</docstring>
      <translations>None</translations>
    </inputPortSpec>
    <inputPortSpec arg="histtype" arg_pos="7" name="histtype" port_type="basic:String">
      <docstring>The type of histogram to draw.

- 'bar' is a traditional bar-type histogram.  If multiple data
  are given the bars are aranged side by side.

- 'barstacked' is a bar-type histogram where multiple
  data are stacked on top of each other.

- 'step' generates a lineplot that is by default
  unfilled.

- 'stepfilled' generates a lineplot that is by default
  filled.

Default is 'bar'
</docstring>
      <defaults>[u'bar']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="align" arg_pos="8" name="align" port_type="basic:String">
      <docstring>Controls how the histogram is plotted.

    - 'left': bars are centered on the left bin edges.

    - 'mid': bars are centered between the bin edges.

    - 'right': bars are centered on the right bin edges.

Default is 'mid'
</docstring>
      <defaults>[u'mid']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cumulative" arg_pos="5" name="cumulative" port_type="basic:Boolean">
      <docstring>If `True`, then a histogram is computed where each bin gives the
counts in that bin plus all bins for smaller values. The last bin
gives the total number of datapoints.  If `normed` is also `True`
then the histogram is normalized such that the last bin equals 1.
If `cumulative` evaluates to less than 0 (e.g., -1), the direction
of accumulation is reversed.  In this case, if `normed` is also
`True`, then the histogram is normalized such that the first bin
equals 1.

Default is ``False``
</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="label" arg_pos="13" name="label" port_type="basic:String">
      <docstring>String, or sequence of strings to match multiple datasets.  Bar
charts yield multiple patches per dataset, but only the first gets
the label, so that the legend command will work as expected.

default is ``None``
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="range" arg_pos="2" name="range">
      <docstring>The lower and upper range of the bins. Lower and upper outliers
are ignored. If not provided, `range` is (x.min(), x.max()). Range
has no effect if `bins` is a sequence.

If `bins` is a sequence or `range` is specified, autoscaling
is based on the specified bin range instead of the
range of x.

Default is ``None``
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" arg_pos="4" name="weights">
      <docstring>An array of weights, of the same shape as `x`.  Each value in `x`
only contributes its associated weight towards the bin count
(instead of 1).  If `normed` is True, the weights are normalized,
so that the integral of the density over the range remains 1.

Default is ``None``
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True">
      <docstring>Input values, this takes either a single array or a sequency of
arrays which are not required to be of the same length
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="15" name="hold" />
    <inputPortSpec arg="data" arg_pos="16" name="data" />
    <inputPortSpec arg="bins" arg_pos="1" name="bins" port_type="basic:Integer">
      <docstring>If an integer is given, `bins + 1` bin edges are returned,
consistently with :func:`numpy.histogram` for numpy version &gt;=
1.3.

Unequally spaced bins are supported if `bins` is a sequence.

default is 10
</docstring>
      <defaults>[10]</defaults>
      <alternateSpec arg="bins" name="binsSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="log" arg_pos="11" name="log" port_type="basic:Boolean">
      <docstring>If `True`, the histogram axis will be set to a log scale. If `log`
is `True` and `x` is a 1D array, empty bins will be filtered out
and only the non-empty (`n`, `bins`, `patches`) will be returned.

Default is ``False``
</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="rectangle" compute_name="rectangles" name="rectangleProperties" plural="True" port_type="__property__" property_key="2" property_type="matplotlib.patches.Rectangle" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.hist2d" name="MplHist2d" superclass="MplPlot">
    <docstring>Make a 2D histogram plot.

Parameters
----------
x, y: array_like, shape (n, )
    Input values

bins: [None | int | [int, int] | array_like | [array, array]]

    The bin specification:

        - If int, the number of bins for the two dimensions
          (nx=ny=bins).

        - If [int, int], the number of bins in each dimension
          (nx, ny = bins).

        - If array_like, the bin edges for the two dimensions
          (x_edges=y_edges=bins).

        - If [array, array], the bin edges in each dimension
          (x_edges, y_edges = bins).

    The default value is 10.

range : array_like shape(2, 2), optional, default: None
     The leftmost and rightmost edges of the bins along each dimension
     (if not specified explicitly in the bins parameters): [[xmin,
     xmax], [ymin, ymax]]. All values outside of this range will be
     considered outliers and not tallied in the histogram.

normed : boolean, optional, default: False
     Normalize histogram.

weights : array_like, shape (n, ), optional, default: None
    An array of values w_i weighing each sample (x_i, y_i).

cmin : scalar, optional, default: None
     All bins that has count less than cmin will not be displayed and
     these count values in the return value count histogram will also
     be set to nan upon return

cmax : scalar, optional, default: None
     All bins that has count more than cmax will not be displayed (set
     to none before passing to imshow) and these count values in the
     return value count histogram will also be set to nan upon return

Returns
-------
The return value is ``(counts, xedges, yedges, Image)``.

Other parameters
-----------------
kwargs : :meth:`pcolorfast` properties.

See also
--------
hist : 1D histogram

Notes
-----
Rendering the histogram with a logarithmic color scale is
accomplished by passing a :class:`colors.LogNorm` instance to
the *norm* keyword argument. Likewise, power-law normalization
(similar in effect to gamma correction) can be accomplished with
:class:`colors.PowerNorm`.

Examples
--------
.. plot:: mpl_examples/pylab_examples/hist2d_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x', 'weights'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="normed" arg_pos="4" name="normed" port_type="basic:Boolean">
      <docstring>Normalize histogram.
</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cmin" arg_pos="6" name="cmin" port_type="basic:Float">
      <docstring>All bins that has count less than cmin will not be displayed and
these count values in the return value count histogram will also
be set to nan upon return
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="range" arg_pos="3" name="range">
      <docstring>The leftmost and rightmost edges of the bins along each dimension
(if not specified explicitly in the bins parameters): [[xmin,
xmax], [ymin, ymax]]. All values outside of this range will be
considered outliers and not tallied in the histogram.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="weights" arg_pos="5" name="weights">
      <docstring>An array of values w_i weighing each sample (x_i, y_i).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" port_type="basic:Color">
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="8" name="hold" />
    <inputPortSpec arg="cmax" arg_pos="7" name="cmax" port_type="basic:Float">
      <docstring>All bins that has count more than cmax will not be displayed (set
to none before passing to imshow) and these count values in the
return value count histogram will also be set to nan upon return</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" arg_pos="9" name="data" />
    <inputPortSpec arg="bins" arg_pos="2" name="bins" port_type="basic:Integer">
      <defaults>[10]</defaults>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.hlines" name="MplHlines" output_type="object" superclass="MplPlot">
    <docstring>Plot horizontal lines at each `y` from `xmin` to `xmax`.

Parameters
----------
y : scalar or sequence of scalar
    y-indexes where to plot the lines.

xmin, xmax : scalar or 1D array_like
    Respective beginning and end of each line. If scalars are
    provided, all lines will have same length.

colors : array_like of colors, optional, default: 'k'

linestyles : ['solid' | 'dashed' | 'dashdot' | 'dotted'], optional

label : string, optional, default: ''

Returns
-------
lines : `~matplotlib.collections.LineCollection`

Other parameters
----------------
kwargs :  `~matplotlib.collections.LineCollection` properties.

See also
--------
vlines : vertical lines

Examples
--------
.. plot:: mpl_examples/pylab_examples/vline_hline_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'xmin', 'xmax'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="linestyles" arg_pos="4" name="linestyles" port_type="basic:String">
      <entry_types>['enum']</entry_types>
      <values>[['solid', 'dashed', 'dashdot', 'dotted']]</values>
      <defaults>[u'solid']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="label" arg_pos="5" name="label" port_type="basic:String">
      <defaults>[u'']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xmin" arg_pos="1" name="xminScalar" port_type="basic:Float" required="True">
      <docstring>Respective beginning and end of each line. If scalars are
provided, all lines will have same length.
</docstring>
      <alternateSpec arg="xmin" name="xminSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="colors" arg_pos="3" name="colorsSequence" port_type="basic:List">
      <alternateSpec arg="colors" name="colorsScalar" port_type="basic:String">
        <defaults>[u'k']</defaults>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="xmax" arg_pos="2" name="xmaxScalar" port_type="basic:Float" required="True">
      <docstring>can be scalars or len(x) numpy arrays.  If they are scalars, then the respective values are constant, else the widths of the lines are determined by xmin and xmax.</docstring>
      <alternateSpec arg="xmax" name="xmaxSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" />
    <inputPortSpec arg="y" arg_pos="0" name="y" port_type="basic:List" required="True">
      <docstring>y-indexes where to plot the lines.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="6" name="hold" />
    <inputPortSpec arg="data" arg_pos="7" name="data" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.collections.LineCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.imshow" name="MplImshow" superclass="MplPlot">
    <docstring>Display an image on the axes.

Call signature:

imshow(X, cmap=None, norm=None, aspect=None, interpolation=None,        alpha=None, vmin=None, vmax=None, origin=None, extent=None,        **kwargs)

Display the image in X to current axes.  X may be a float array, a uint8 array or a PIL image. If X is an array, X can have the following shapes:

MxN -- luminance (grayscale, float array only)

MxNx3 -- RGB (float or uint8 array)

MxNx4 -- RGBA (float or uint8 array)

The value for each component of MxNx3 and MxNx4 float arrays should be in the range 0.0 to 1.0; MxN float arrays may be normalised.

An :class:`matplotlib.image.AxesImage` instance is returned.

Keyword arguments:

interpolation:

Acceptable values are None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos'

If interpolation is None, default to rc image.interpolation. See also the filternorm and filterrad parameters

If interpolation is 'none', then no interpolation is performed on the Agg, ps and pdf backends. Other backends will fall back to 'nearest'.

Additional kwargs are :class:`~matplotlib.artist.Artist` properties:

%(Artist)s

Example:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="origin" arg_pos="8" name="origin" port_type="basic:String">
      <docstring>Place the [0,0] index of the array in the upper left or lower left
corner of the axes. If None, default to rc `image.origin`.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['upper', 'lower']]</values>
    </inputPortSpec>
    <inputPortSpec arg="imlim" arg_pos="13" name="imlim" />
    <inputPortSpec arg="extent" arg_pos="9" name="extent" port_type="basic:Float">
      <docstring>The location, in data-coordinates, of the lower-left and
upper-right corners. If `None`, the image is positioned such that
the pixel centers fall on zero-based (row, column) indices.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vmin" arg_pos="6" name="vmin" port_type="basic:Float">
      <docstring>`vmin` and `vmax` are used in conjunction with norm to normalize
luminance data.  Note if you pass a `norm` instance, your
settings for `vmin` and `vmax` will be ignored.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="url" arg_pos="15" name="url" />
    <inputPortSpec arg="resample" arg_pos="14" name="resample" />
    <inputPortSpec arg="kwargs" name="kwargs" />
    <inputPortSpec arg="shape" arg_pos="10" name="shape" port_type="basic:Float">
      <docstring>For raw buffer images
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmap" arg_pos="1" name="cmap" port_type="basic:List">
      <docstring>If None, default to rc `image.cmap` value. `cmap` is ignored when
`X` has RGB(A) information
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="filterrad" arg_pos="12" name="filterrad" port_type="basic:Float">
      <docstring>The filter radius for filters that have a radius parameter, i.e.
when interpolation is one of: 'sinc', 'lanczos' or 'blackman'</docstring>
      <defaults>[4.0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="filternorm" arg_pos="11" name="filternorm" port_type="basic:Float">
      <docstring>A parameter for the antigrain image resize filter.  From the
antigrain documentation, if `filternorm` = 1, the filter
normalizes integer values and corrects the rounding errors. It
doesn't do anything with the source floating point values, it
corrects only integers according to the rule of 1.0 which means
that any sum of pixel weights must be equal to 1.0.  So, the
filter function must produce a graph of the proper shape.
</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="aspect" arg_pos="3" name="aspect">
      <docstring>If 'auto', changes the image aspect ratio to match that of the
axes.

If 'equal', and `extent` is None, changes the axes aspect ratio to
match that of the image. If `extent` is not `None`, the axes
aspect ratio is changed to match that of the extent.

If None, default to rc ``image.aspect`` value.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['auto', 'equal']]</values>
    </inputPortSpec>
    <inputPortSpec arg="alpha" arg_pos="5" name="alpha" port_type="basic:Float">
      <docstring>The alpha blending value, between 0 (transparent) and 1 (opaque)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vmax" arg_pos="7" name="vmax" port_type="basic:Float">
      <docstring>`vmin` and `vmax` are used in conjunction with norm to normalize
luminance data.  Note if you pass a `norm` instance, your
settings for `vmin` and `vmax` will be ignored.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="X" arg_pos="0" name="X" port_type="basic:List" required="True">
      <docstring>Display the image in `X` to current axes.  `X` may be a float
array, a uint8 array or a PIL image. If `X` is an array, it
can have the following shapes:

- MxN -- luminance (grayscale, float array only)
- MxNx3 -- RGB (float or uint8 array)
- MxNx4 -- RGBA (float or uint8 array)

The value for each component of MxNx3 and MxNx4 float arrays
should be in the range 0.0 to 1.0; MxN float arrays may be
normalised.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="16" name="hold" />
    <inputPortSpec arg="data" arg_pos="17" name="data" />
    <inputPortSpec arg="norm" arg_pos="2" name="norm" port_type="basic:List">
      <docstring>A `~matplotlib.colors.Normalize` instance is used to scale
luminance data to 0, 1. If `None`, use the default
func:`normalize`. `norm` is only used if `X` is an array of
floats.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="interpolation" arg_pos="4" name="interpolation" port_type="basic:String">
      <docstring>Acceptable values are 'none', 'nearest', 'bilinear', 'bicubic',
'spline16', 'spline36', 'hanning', 'hamming', 'hermite', 'kaiser',
'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc',
'lanczos'

If `interpolation` is None, default to rc `image.interpolation`.
See also the `filternorm` and `filterrad` parameters.
If `interpolation` is 'none', then no interpolation is performed
on the Agg, ps and pdf backends. Other backends will fall back to
'nearest'.
</docstring>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.loglog" name="MplLoglog" output_type="object" superclass="MplPlot">
    <docstring>Make a plot with log scaling on both the x and y axis.

Call signature:

loglog(*args, **kwargs)

:func:`~matplotlib.pyplot.loglog` supports all the keyword arguments of :func:`~matplotlib.pyplot.plot` and :meth:`matplotlib.axes.Axes.set_xscale` / :meth:`matplotlib.axes.Axes.set_yscale`.

Notable keyword arguments:



The remaining valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

%(Line2D)s

Example:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="nonposx" name="nonposx" port_type="basic:String">
      <docstring>Non-positive values in x or y can be masked as invalid, or clipped to a very small positive number</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['mask', 'clip']]</values>
    </inputPortSpec>
    <inputPortSpec arg="nonposy" name="nonposy" port_type="basic:String">
      <docstring>Non-positive values in x or y can be masked as invalid, or clipped to a very small positive number</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['mask', 'clip']]</values>
    </inputPortSpec>
    <inputPortSpec arg="basex" name="basex" port_type="basic:Float">
      <docstring>Base of the x/y logarithm</docstring>
    </inputPortSpec>
    <inputPortSpec arg="basey" name="basey" port_type="basic:Float">
      <docstring>Base of the x/y logarithm</docstring>
    </inputPortSpec>
    <inputPortSpec arg="subsx" name="subsx" port_type="basic:List">
      <docstring>The location of the minor x/y ticks; None defaults to autosubs, which depend on the number of decades in the plot; see :meth:`matplotlib.axes.Axes.set_xscale` / :meth:`matplotlib.axes.Axes.set_yscale` for details</docstring>
    </inputPortSpec>
    <inputPortSpec arg="subsy" name="subsy" port_type="basic:List">
      <docstring>The location of the minor x/y ticks; None defaults to autosubs, which depend on the number of decades in the plot; see :meth:`matplotlib.axes.Axes.set_xscale` / :meth:`matplotlib.axes.Axes.set_yscale` for details</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.pcolor" name="MplPcolor" output_type="object" superclass="MplPlot">
    <docstring>Create a pseudocolor plot of a 2-D array.

.. note::

    pcolor can be very slow for large arrays; consider
    using the similar but much faster
    :func:`~matplotlib.pyplot.pcolormesh` instead.

Call signatures::

  pcolor(C, **kwargs)
  pcolor(X, Y, C, **kwargs)

*C* is the array of color values.

*X* and *Y*, if given, specify the (*x*, *y*) coordinates of
the colored quadrilaterals; the quadrilateral for C[i,j] has
corners at::

  (X[i,   j],   Y[i,   j]),
  (X[i,   j+1], Y[i,   j+1]),
  (X[i+1, j],   Y[i+1, j]),
  (X[i+1, j+1], Y[i+1, j+1]).

Ideally the dimensions of *X* and *Y* should be one greater
than those of *C*; if the dimensions are the same, then the
last row and column of *C* will be ignored.

Note that the column index corresponds to the
*x*-coordinate, and the row index corresponds to *y*; for
details, see the :ref:`Grid Orientation
&lt;axes-pcolor-grid-orientation&gt;` section below.

If either or both of *X* and *Y* are 1-D arrays or column vectors,
they will be expanded as needed into the appropriate 2-D arrays,
making a rectangular grid.

*X*, *Y* and *C* may be masked arrays.  If either C[i, j], or one
of the vertices surrounding C[i,j] (*X* or *Y* at [i, j], [i+1, j],
[i, j+1],[i+1, j+1]) is masked, nothing is plotted.

Keyword arguments:

  *cmap*: [ *None* | Colormap ]
    A :class:`matplotlib.colors.Colormap` instance. If *None*, use
    rc settings.

  *norm*: [ *None* | Normalize ]
    An :class:`matplotlib.colors.Normalize` instance is used
    to scale luminance data to 0,1. If *None*, defaults to
    :func:`normalize`.

  *vmin*/*vmax*: [ *None* | scalar ]
    *vmin* and *vmax* are used in conjunction with *norm* to
    normalize luminance data.  If either is *None*, it
    is autoscaled to the respective min or max
    of the color array *C*.  If not *None*, *vmin* or
    *vmax* passed in here override any pre-existing values
    supplied in the *norm* instance.

  *shading*: [ 'flat' | 'faceted' ]
    If 'faceted', a black grid is drawn around each rectangle; if
    'flat', edges are not drawn. Default is 'flat', contrary to
    MATLAB.

    This kwarg is deprecated; please use 'edgecolors' instead:
      * shading='flat' -- edgecolors='none'
      * shading='faceted  -- edgecolors='k'

  *edgecolors*: [ *None* | ``'none'`` | color | color sequence]
    If *None*, the rc setting is used by default.

    If ``'none'``, edges will not be visible.

    An mpl color or sequence of colors will set the edge color

  *alpha*: ``0 &lt;= scalar &lt;= 1``   or *None*
    the alpha blending value

  *snap*: bool
    Whether to snap the mesh to pixel boundaries.

Return value is a :class:`matplotlib.collections.Collection`
instance.

.. _axes-pcolor-grid-orientation:

The grid orientation follows the MATLAB convention: an
array *C* with shape (*nrows*, *ncolumns*) is plotted with
the column number as *X* and the row number as *Y*, increasing
up; hence it is plotted the way the array would be printed,
except that the *Y* axis is reversed.  That is, *C* is taken
as *C*(*y*, *x*).

Similarly for :func:`meshgrid`::

  x = np.arange(5)
  y = np.arange(3)
  X, Y = np.meshgrid(x, y)

is equivalent to::

  X = array([[0, 1, 2, 3, 4],
             [0, 1, 2, 3, 4],
             [0, 1, 2, 3, 4]])

  Y = array([[0, 0, 0, 0, 0],
             [1, 1, 1, 1, 1],
             [2, 2, 2, 2, 2]])

so if you have::

  C = rand(len(x), len(y))

then you need to transpose C::

  pcolor(X, Y, C.T)

or::

  pcolor(C.T)

MATLAB :func:`pcolor` always discards the last row and column
of *C*, but matplotlib displays the last row and column if *X* and
*Y* are not specified, or if *X* and *Y* have one more row and
column than *C*.

kwargs can be used to control the
:class:`~matplotlib.collections.PolyCollection` properties:

%(PolyCollection)s

.. note::

    The default *antialiaseds* is False if the default
    *edgecolors*="none" is used.  This eliminates artificial lines
    at patch boundaries, and works regardless of the value of
    alpha.  If *edgecolors* is not "none", then the default
    *antialiaseds* is taken from
    rcParams['patch.antialiased'], which defaults to *True*.
    Stroking the edges may be preferred if *alpha* is 1, but
    will cause artifacts otherwise.

.. seealso::

    :func:`~matplotlib.pyplot.pcolormesh`
        For an explanation of the differences between
        pcolor and pcolormesh.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All positional and all keyword arguments.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="edgecolors" name="edgecolors">
      <docstring>If None, the rc setting is used by default.

If 'none', edges will not be visible.

An mpl color or sequence of colors will set the edge color</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['none']]</values>
    </inputPortSpec>
    <inputPortSpec arg="vmin" name="vmin" port_type="basic:Color">
      <docstring>vmin and vmax are used in conjunction with norm to normalize luminance data.  If either is None, it is autoscaled to the respective min or max of the color array C.  If not None, vmin or vmax passed in here override any pre-existing values supplied in the norm instance.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="snap" name="snap">
      <docstring>Whether to snap the mesh to pixel boundaries.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmap" name="cmap" port_type="basic:Color">
      <docstring>A :class:`matplotlib.colors.Colormap` instance. If None, use rc settings.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>the alpha blending value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vmax" name="vmax" port_type="basic:Color">
      <docstring>vmin and vmax are used in conjunction with norm to normalize luminance data.  If either is None, it is autoscaled to the respective min or max of the color array C.  If not None, vmin or vmax passed in here override any pre-existing values supplied in the norm instance.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="shading" name="shading" port_type="basic:String">
      <docstring>If 'faceted', a black grid is drawn around each rectangle; if 'flat', edges are not drawn. Default is 'flat', contrary to MATLAB.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['flat', 'faceted']]</values>
      <defaults>['flat']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="normSequence" port_type="basic:List">
      <docstring>An :class:`matplotlib.colors.Normalize` instance is used to scale luminance data to 0,1. If None, defaults to :func:`normalize`.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="Y" arg_pos="1" in_args="True" name="Y" port_type="basic:List" />
    <inputPortSpec arg="X" arg_pos="0" in_args="True" name="X" port_type="basic:List" />
    <inputPortSpec arg="Z" arg_pos="2" in_args="True" name="Z" port_type="basic:List" required="True" />
    <outputPortSpec arg="polyCollection" compute_name="polyCollection" name="polyCollectionProperties" port_type="__property__" property_key="0" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.pcolormesh" name="MplPcolormesh" superclass="MplPlot">
    <docstring>Plot a quadrilateral mesh.

Call signatures::

  pcolormesh(C)
  pcolormesh(X, Y, C)
  pcolormesh(C, **kwargs)

Create a pseudocolor plot of a 2-D array.

pcolormesh is similar to :func:`~matplotlib.pyplot.pcolor`,
but uses a different mechanism and returns a different
object; pcolor returns a
:class:`~matplotlib.collections.PolyCollection` but pcolormesh
returns a
:class:`~matplotlib.collections.QuadMesh`.  It is much faster,
so it is almost always preferred for large arrays.

*C* may be a masked array, but *X* and *Y* may not.  Masked
array support is implemented via *cmap* and *norm*; in
contrast, :func:`~matplotlib.pyplot.pcolor` simply does not
draw quadrilaterals with masked colors or vertices.

Keyword arguments:

  *cmap*: [ *None* | Colormap ]
    A :class:`matplotlib.colors.Colormap` instance. If *None*, use
    rc settings.

  *norm*: [ *None* | Normalize ]
    A :class:`matplotlib.colors.Normalize` instance is used to
    scale luminance data to 0,1. If *None*, defaults to
    :func:`normalize`.

  *vmin*/*vmax*: [ *None* | scalar ]
    *vmin* and *vmax* are used in conjunction with *norm* to
    normalize luminance data.  If either is *None*, it
    is autoscaled to the respective min or max
    of the color array *C*.  If not *None*, *vmin* or
    *vmax* passed in here override any pre-existing values
    supplied in the *norm* instance.

  *shading*: [ 'flat' | 'gouraud' ]
    'flat' indicates a solid color for each quad.  When
    'gouraud', each quad will be Gouraud shaded.  When gouraud
    shading, edgecolors is ignored.

  *edgecolors*: [*None* | ``'None'`` | ``'face'`` | color |
                 color sequence]

    If *None*, the rc setting is used by default.

    If ``'None'``, edges will not be visible.

    If ``'face'``, edges will have the same color as the faces.

    An mpl color or sequence of colors will set the edge color

  *alpha*: ``0 &lt;= scalar &lt;= 1``  or *None*
    the alpha blending value

Return value is a :class:`matplotlib.collections.QuadMesh`
object.

kwargs can be used to control the
:class:`matplotlib.collections.QuadMesh` properties:

%(QuadMesh)s

.. seealso::

    :func:`~matplotlib.pyplot.pcolor`
        For an explanation of the grid orientation and the
        expansion of 1-D *X* and/or *Y* to 2-D arrays.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All positional and all keyword arguments.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="edgecolors" name="edgecolors">
      <docstring>color sequence]

If None, the rc setting is used by default.

If 'None', edges will not be visible.

If 'face', edges will have the same color as the faces.

An mpl color or sequence of colors will set the edge color</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['[None', 'None', 'face', '']]</values>
    </inputPortSpec>
    <inputPortSpec arg="vmin" name="vmin" port_type="basic:Color">
      <docstring>vmin and vmax are used in conjunction with norm to normalize luminance data.  If either is None, it is autoscaled to the respective min or max of the color array C.  If not None, vmin or vmax passed in here override any pre-existing values supplied in the norm instance.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="cmap" name="cmap" port_type="basic:Color">
      <docstring>A :class:`matplotlib.colors.Colormap` instance. If None, use rc settings.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>the alpha blending value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="vmax" name="vmax" port_type="basic:Color">
      <docstring>vmin and vmax are used in conjunction with norm to normalize luminance data.  If either is None, it is autoscaled to the respective min or max of the color array C.  If not None, vmin or vmax passed in here override any pre-existing values supplied in the norm instance.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="shading" name="shadingSequence" port_type="basic:List">
      <docstring>'flat' indicates a solid color for each quad.  When 'gouraud', each quad will be Gouraud shaded.  When gouraud shading, edgecolors is ignored.</docstring>
      <alternateSpec arg="shading" name="shadingScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['flat', 'gouraud']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="normSequence" port_type="basic:List">
      <docstring>A :class:`matplotlib.colors.Normalize` instance is used to scale luminance data to 0,1. If None, defaults to :func:`normalize`.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.pie" name="MplPie" output_type="tuple" superclass="MplPlot">
    <docstring>Plot a pie chart.

Call signature::

  pie(x, explode=None, labels=None,
      colors=('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'),
      autopct=None, pctdistance=0.6, shadow=False,
      labeldistance=1.1, startangle=None, radius=None,
      counterclock=True, wedgeprops=None, textprops=None,
      center = (0, 0), frame = False )

Make a pie chart of array *x*.  The fractional area of each
wedge is given by x/sum(x).  If sum(x) &lt;= 1, then the values
of x give the fractional area directly and the array will not
be normalized.  The wedges are plotted counterclockwise,
by default starting from the x-axis.

Keyword arguments:

  *explode*: [ *None* | len(x) sequence ]
    If not *None*, is a ``len(x)`` array which specifies the
    fraction of the radius with which to offset each wedge.

  *colors*: [ *None* | color sequence ]
    A sequence of matplotlib color args through which the pie chart
    will cycle.

  *labels*: [ *None* | len(x) sequence of strings ]
    A sequence of strings providing the labels for each wedge

  *autopct*: [ *None* | format string | format function ]
    If not *None*, is a string or function used to label the wedges
    with their numeric value.  The label will be placed inside the
    wedge.  If it is a format string, the label will be ``fmt%pct``.
    If it is a function, it will be called.

  *pctdistance*: scalar
    The ratio between the center of each pie slice and the
    start of the text generated by *autopct*.  Ignored if
    *autopct* is *None*; default is 0.6.

  *labeldistance*: scalar
    The radial distance at which the pie labels are drawn

  *shadow*: [ *False* | *True* ]
    Draw a shadow beneath the pie.

  *startangle*: [ *None* | Offset angle ]
    If not *None*, rotates the start of the pie chart by *angle*
    degrees counterclockwise from the x-axis.

  *radius*: [ *None* | scalar ]
  The radius of the pie, if *radius* is *None* it will be set to 1.

  *counterclock*: [ *False* | *True* ]
    Specify fractions direction, clockwise or counterclockwise.

  *wedgeprops*: [ *None* | dict of key value pairs ]
    Dict of arguments passed to the wedge objects making the pie.
    For example, you can pass in wedgeprops = { 'linewidth' : 3 }
    to set the width of the wedge border lines equal to 3.
    For more details, look at the doc/arguments of the wedge object.
    By default `clip_on=False`.

  *textprops*: [ *None* | dict of key value pairs ]
    Dict of arguments to pass to the text objects.

  *center*: [ (0,0) | sequence of 2 scalars ]
  Center position of the chart.

  *frame*: [ *False* | *True* ]
    Plot axes frame with the chart.

The pie chart will probably look best if the figure and axes are
square, or the Axes aspect is equal.  e.g.::

  figure(figsize=(8,8))
  ax = axes([0.1, 0.1, 0.8, 0.8])

or::

  axes(aspect=1)

Return value:
  If *autopct* is *None*, return the tuple (*patches*, *texts*):

    - *patches* is a sequence of
      :class:`matplotlib.patches.Wedge` instances

    - *texts* is a list of the label
      :class:`matplotlib.text.Text` instances.

  If *autopct* is not *None*, return the tuple (*patches*,
  *texts*, *autotexts*), where *patches* and *texts* are as
  above, and *autotexts* is a list of
  :class:`~matplotlib.text.Text` instances for the numeric
  labels.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'explode', 'x', 'colors', 'labels'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="autopct" arg_pos="4" name="autopct" port_type="basic:String">
      <docstring>If not None, is a string or function used to label the wedges with their numeric value.  The label will be placed inside the wedge.  If it is a format string, the label will be fmt%pct. If it is a function, it will be called.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['format function']]</values>
    </inputPortSpec>
    <inputPortSpec arg="pctdistance" arg_pos="5" name="pctdistance" port_type="basic:Float">
      <docstring>The ratio between the center of each pie slice and the start of the text generated by autopct.  Ignored if autopct is None; default is 0.6.</docstring>
      <defaults>[0.6]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="center" arg_pos="13" name="center">
      <defaults>[(0, 0)]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="textprops" arg_pos="12" name="textprops" />
    <inputPortSpec arg="counterclock" arg_pos="10" name="counterclock" port_type="basic:Boolean">
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="labels" arg_pos="2" name="labels" port_type="basic:List">
      <docstring>A sequence of strings providing the labels for each wedge</docstring>
    </inputPortSpec>
    <inputPortSpec arg="wedgeprops" arg_pos="11" name="wedgeprops" />
    <inputPortSpec arg="explode" arg_pos="1" name="explodeSequence" port_type="basic:List">
      <docstring>If not None, is a len(x) array which specifies the fraction of the radius with which to offset each wedge.</docstring>
      <alternateSpec arg="explode" name="explodeScalar" port_type="basic:String" />
    </inputPortSpec>
    <inputPortSpec arg="colors" arg_pos="3" name="colorsSequence" port_type="basic:List">
      <docstring>A sequence of matplotlib color args through which the pie chart will cycle.</docstring>
      <alternateSpec arg="colors" name="colorsScalar" port_type="basic:Color" />
    </inputPortSpec>
    <inputPortSpec arg="radius" arg_pos="9" name="radius" />
    <inputPortSpec arg="frame" arg_pos="14" name="frame" port_type="basic:Boolean">
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="startangle" arg_pos="8" name="startangle" port_type="basic:String">
      <docstring>If not None, rotates the start of the pie chart by angle degrees counterclockwise from the x-axis.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['Offset angle']]</values>
    </inputPortSpec>
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="shadow" arg_pos="6" name="shadow" port_type="basic:Boolean">
      <docstring>Draw a shadow beneath the pie.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="15" name="hold" />
    <inputPortSpec arg="data" arg_pos="16" name="data" />
    <inputPortSpec arg="labeldistance" arg_pos="7" name="labeldistance" port_type="basic:Float">
      <docstring>The radial distance at which the pie labels are drawn</docstring>
      <defaults>[1.1]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="autotext" compute_name="autotexts" name="autotextProperties" plural="True" port_type="__property__" property_key="2" property_type="matplotlib.text.Text" />
    <outputPortSpec arg="wedge" compute_name="wedges" name="wedgeProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.patches.Wedge" />
    <outputPortSpec arg="text" compute_name="texts" name="textProperties" plural="True" port_type="__property__" property_key="1" property_type="matplotlib.text.Text" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.plot_date" name="MplPlotDate" output_type="object" superclass="MplPlot">
    <docstring>Plot with data with dates.

Call signature::

   plot_date(x, y, fmt='bo', tz=None, xdate=True,
             ydate=False, **kwargs)

Similar to the :func:`~matplotlib.pyplot.plot` command, except
the *x* or *y* (or both) data is considered to be dates, and the
axis is labeled accordingly.

*x* and/or *y* can be a sequence of dates represented as float
days since 0001-01-01 UTC.

Keyword arguments:

  *fmt*: string
    The plot format string.

  *tz*: [ *None* | timezone string | :class:`tzinfo` instance]
    The time zone to use in labeling dates. If *None*, defaults to rc
    value.

  *xdate*: [ *True* | *False* ]
    If *True*, the *x*-axis will be labeled with dates.

  *ydate*: [ *False* | *True* ]
    If *True*, the *y*-axis will be labeled with dates.

Note if you are using custom date tickers and formatters, it
may be necessary to set the formatters/locators after the call
to :meth:`plot_date` since :meth:`plot_date` will set the
default tick locator to
:class:`matplotlib.dates.AutoDateLocator` (if the tick
locator is not already set to a
:class:`matplotlib.dates.DateLocator` instance) and the
default tick formatter to
:class:`matplotlib.dates.AutoDateFormatter` (if the tick
formatter is not already set to a
:class:`matplotlib.dates.DateFormatter` instance).

Valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

%(Line2D)s

.. seealso::

   :mod:`~matplotlib.dates` for helper functions

   :func:`~matplotlib.dates.date2num`,
   :func:`~matplotlib.dates.num2date` and
   :func:`~matplotlib.dates.drange` for help on creating the required
   floating point dates.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="tz" arg_pos="3" name="tz" port_type="basic:String">
      <docstring>The time zone to use in labeling dates. If None, defaults to rc value.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[[':class:`tzinfo` instance']]</values>
    </inputPortSpec>
    <inputPortSpec arg="fmt" arg_pos="2" name="fmt" port_type="basic:String">
      <docstring>The plot format string.</docstring>
      <defaults>[u'o']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="ydate" arg_pos="5" name="ydate" port_type="basic:Boolean">
      <docstring>If True, the y-axis will be labeled with dates.</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="xdate" arg_pos="4" name="xdate" port_type="basic:Boolean">
      <docstring>If True, the x-axis will be labeled with dates.</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="6" name="hold" />
    <inputPortSpec arg="data" arg_pos="7" name="data" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.psd" name="MplPsd" superclass="MplPlot">
    <docstring>Plot the power spectral density.

Call signature::

  psd(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
      window=mlab.window_hanning, noverlap=0, pad_to=None,
      sides='default', scale_by_freq=None, return_line=None, **kwargs)

The power spectral density :math:`P_{xx}` by Welch's average
periodogram method.  The vector *x* is divided into *NFFT* length
segments.  Each segment is detrended by function *detrend* and
windowed by function *window*.  *noverlap* gives the length of
the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
with a scaling to correct for power loss due to windowing.

If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.

  *x*: 1-D array or sequence
    Array or sequence containing the data

%(Spectral)s

%(PSD)s

  *noverlap*: integer
    The number of points of overlap between segments.
    The default value is 0 (no overlap).

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

  *return_line*: bool
    Whether to include the line object plotted in the returned values.
    Default is False.

If *return_line* is False, returns the tuple (*Pxx*, *freqs*).
If *return_line* is True, returns the tuple (*Pxx*, *freqs*. *line*):

  *Pxx*: 1-D array
    The values for the power spectrum `P_{xx}` before scaling
    (real valued)

  *freqs*: 1-D array
    The frequencies corresponding to the elements in *Pxx*

  *line*: a :class:`~matplotlib.lines.Line2D` instance
    The line created by this function.
    Only returend if *return_line* is True.

For plotting, the power is plotted as
:math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
is returned.

References:
  Bendat &amp; Piersol -- Random Data: Analysis and Measurement
  Procedures, John Wiley &amp; Sons (1986)

kwargs control the :class:`~matplotlib.lines.Line2D` properties:

%(Line2D)s

**Example:**

.. plot:: mpl_examples/pylab_examples/psd_demo.py

.. seealso::

    :func:`specgram`
        :func:`specgram` differs in the default overlap; in not
        returning the mean of the segment periodograms; in  returning
        the times of the segments; and in plotting a colormap instead
        of a line.

    :func:`magnitude_spectrum`
        :func:`magnitude_spectrum` plots the magnitude spectrum.

    :func:`csd`
        :func:`csd` plots the spectral density between two signals.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="return_line" arg_pos="10" name="return_line" />
    <inputPortSpec arg="Fs" arg_pos="2" name="Fs" port_type="basic:Integer">
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pad_to" arg_pos="7" name="pad_to" />
    <inputPortSpec arg="scale_by_freq" arg_pos="9" name="scale_by_freq" />
    <inputPortSpec arg="detrend" arg_pos="4" name="detrend" />
    <inputPortSpec arg="window" arg_pos="5" name="window" />
    <inputPortSpec arg="Fc" arg_pos="3" name="Fc" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="NFFT" arg_pos="1" name="NFFT" port_type="basic:Integer">
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="11" name="hold" />
    <inputPortSpec arg="data" arg_pos="12" name="data" />
    <inputPortSpec arg="sides" arg_pos="8" name="sides" port_type="basic:String">
      <defaults>['default']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" arg_pos="6" name="noverlap" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="line" constructor_arg="True" name="lineProperties" port_type="__property__" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.quiver" name="MplQuiver" output_type="object" superclass="MplPlot">
    <docstring>Plot a 2-D field of arrows.

call signatures:

quiver(U, V, **kw) quiver(U, V, C, **kw) quiver(X, Y, U, V, **kw) quiver(X, Y, U, V, C, **kw)

Arguments:



All arguments may be 1-D or 2-D arrays or sequences. If X and Y are absent, they will be generated as a uniform grid.  If U and V are 2-D arrays but X and Y are 1-D, and if len(X) and len(Y) match the column and row dimensions of U, then X and Y will be expanded with :func:`numpy.meshgrid`.

U, V, C may be masked arrays, but masked X, Y are not supported at present.

Keyword arguments:



The defaults give a slightly swept-back arrow; to make the head a triangle, make headaxislength the same as headlength. To make the arrow more pointed, reduce headwidth or increase headlength and headaxislength. To make the head smaller relative to the shaft, scale down all the head parameters. You will probably do best to leave minshaft alone.

linewidths and edgecolors can be used to customize the arrow outlines. Additional :class:`~matplotlib.collections.PolyCollection` keyword arguments:

agg_filter: unknown alpha: float or None animated: [True | False] antialiased or antialiaseds: Boolean or sequence of booleans array: unknown axes: an :class:`~matplotlib.axes.Axes` instance clim: a length 2 sequence of floats clip_box: a :class:`matplotlib.transforms.Bbox` instance clip_on: [True | False] clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ] cmap: a colormap or registered colormap name color: matplotlib color arg or sequence of rgba tuples contains: a callable function edgecolor or edgecolors: matplotlib color spec or sequence of specs facecolor or facecolors: matplotlib color spec or sequence of specs figure: a :class:`matplotlib.figure.Figure` instance gid: an id string hatch: [ '/' | '\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ] label: string or anything printable with '%s' conversion. linestyle or linestyles or dashes: ['solid' | 'dashed', 'dashdot', 'dotted' |                    (offset, on-off-dash-seq) |                    '-' | '--' | '-.' | ':' | 'None' |                    ' ' | ''] linewidth or lw or linewidths: float or sequence of floats norm: unknown offset_position: unknown offsets: float or sequence of floats path_effects: unknown picker: [None|float|boolean|callable] pickradius: unknown rasterized: [True | False | None] sketch_params: unknown snap: unknown transform: :class:`~matplotlib.transforms.Transform` instance url: a url string urls: unknown visible: [True | False] zorder: any number

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="headaxislength" name="headaxislength" port_type="basic:Float">
      <docstring>Head length at shaft intersection, default is 4.5</docstring>
      <defaults>[4.5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="C" arg_pos="4" in_args="True" name="C" port_type="basic:List">
      <docstring>None</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scale" name="scale" port_type="basic:List">
      <docstring>Data units per arrow length unit, e.g., m/s per plot width; a smaller scale parameter makes the arrow longer.  If None, a simple autoscaling algorithm is used, based on the average vector length and the number of vectors.  The arrow length unit is given by the scale_units parameter</docstring>
    </inputPortSpec>
    <inputPortSpec arg="width" name="width" port_type="basic:List">
      <docstring>Shaft width in arrow units; default depends on choice of units, above, and number of vectors; a typical starting value is about 0.005 times the width of the plot.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="headlength" name="headlength" port_type="basic:Float">
      <docstring>Head length as multiple of shaft width, default is 5</docstring>
      <defaults>[5]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="minlength" name="minlength" port_type="basic:Float">
      <docstring>Minimum length as a multiple of shaft width; if an arrow length is less than this, plot a dot (hexagon) of this diameter instead. Default is 1.</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="minshaft" name="minshaft" port_type="basic:Float">
      <docstring>Length below which arrow scales, in units of head length. Do not set this to less than 1, or small arrows will look terrible! Default is 1</docstring>
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pivot" name="pivot" port_type="basic:String">
      <docstring>The part of the arrow that is at the grid point; the arrow rotates about this point, hence the name pivot.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['tail', 'mid', 'middle', 'tip']]</values>
    </inputPortSpec>
    <inputPortSpec arg="units" name="units" port_type="basic:String">
      <docstring>Arrow units; the arrow dimensions except for length are in multiples of this unit.

'width' or 'height': the width or height of the axes

'dots' or 'inches': pixels or inches, based on the figure dpi

'x', 'y', or 'xy': X, Y, or sqrt(X^2+Y^2) data units

The arrows scale differently depending on the units.  For 'x' or 'y', the arrows get larger as one zooms in; for other units, the arrow size is independent of the zoom state.  For 'width or 'height', the arrow size increases with the width and height of the axes, respectively, when the window is resized; for 'dots' or 'inches', resizing does not change the arrows.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['width', 'height', 'dots', 'inches', 'x', 'y', 'xy']]</values>
    </inputPortSpec>
    <inputPortSpec arg="headwidth" name="headwidth" port_type="basic:Float">
      <docstring>Head width as multiple of shaft width, default is 3</docstring>
      <defaults>[3]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="U" arg_pos="2" in_args="True" name="U" port_type="basic:List" required="True">
      <docstring>None</docstring>
    </inputPortSpec>
    <inputPortSpec arg="angles" name="angles" port_type="basic:String">
      <docstring>With the default 'uv', the arrow axis aspect ratio is 1, so that if U*==*V the orientation of the arrow on the plot is 45 degrees CCW from the horizontal axis (positive to the right). With 'xy', the arrow points from (x,y) to (x+u, y+v). Use this for plotting a gradient field, for example. Alternatively, arbitrary angles may be specified as an array of values in degrees, CCW from the horizontal axis. Note: inverting a data axis will correspondingly invert the arrows only with angles='xy'.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['uv', 'xy', 'array']]</values>
    </inputPortSpec>
    <inputPortSpec arg="V" arg_pos="3" in_args="True" name="V" port_type="basic:List" required="True">
      <docstring>None</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Y" arg_pos="1" in_args="True" name="Y" port_type="basic:List">
      <docstring>None</docstring>
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="X" arg_pos="0" in_args="True" name="X" port_type="basic:List">
      <docstring>None</docstring>
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="scale_units" name="scale_units" port_type="basic:List">
      <docstring>For example, if scale_units is 'inches', scale is 2.0, and (u,v) = (1,0), then the vector will be 0.5 inches long. If scale_units is 'width', then the vector will be half the width of the axes.

If scale_units is 'x' then the vector will be 0.5 x-axis units.  To plot vectors in the x-y plane, with u and v having the same units as x and y, use "angles='xy', scale_units='xy', scale=1".</docstring>
    </inputPortSpec>
    <inputPortSpec arg="color" name="color" port_type="basic:Color">
      <docstring>This is a synonym for the :class:`~matplotlib.collections.PolyCollection` facecolor kwarg. If C has been set, color has no effect.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <outputPortSpec arg="polyCollection" compute_name="polyCollection" name="polyCollectionProperties" port_type="__property__" property_key="0" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.quiverkey" name="MplQuiverkey" superclass="MplPlot">
    <docstring>Add a key to a quiver plot.

Call signature:

quiverkey(Q, X, Y, U, label, **kw)

Arguments:



Keyword arguments:



Any additional keyword arguments are used to override vector properties taken from Q.

The positioning of the key depends on X, Y, coordinates, and labelpos.  If labelpos is 'N' or 'S', X, Y give the position of the middle of the key arrow.  If labelpos is 'E', X, Y positions the head, and if labelpos is 'W', X, Y positions the tail; in either of these two cases, X, Y is somewhere in the middle of the arrow+label key object.

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="color" name="color" port_type="basic:Color">
      <docstring>overrides face and edge colors from Q.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="coordinates" name="coordinatesSequence" port_type="basic:List">
      <docstring>Coordinate system and units for X, Y: 'axes' and 'figure' are normalized coordinate systems with 0,0 in the lower left and 1,1 in the upper right; 'data' are the axes data coordinates (used for the locations of the vectors in the quiver plot itself); 'inches' is position in the figure in inches, with 0,0 at the lower left corner.</docstring>
      <alternateSpec arg="coordinates" name="coordinatesScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['axes', 'figure', 'data', 'inches']]</values>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="label" arg_pos="4" name="label" port_type="basic:String" required="True">
      <docstring>A string with the length and units of the key</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Q" arg_pos="0" name="Q" required="True">
      <docstring>The Quiver instance returned by a call to quiver.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labelcolor" name="labelcolor" port_type="basic:Color">
      <docstring>defaults to default :class:`~matplotlib.text.Text` color.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="fontproperties" name="fontproperties">
      <docstring>A dictionary with keyword arguments accepted by the :class:`~matplotlib.font_manager.FontProperties` initializer: family, style, variant, size, weight</docstring>
    </inputPortSpec>
    <inputPortSpec arg="U" arg_pos="3" name="U" required="True">
      <docstring>The length of the key</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labelpos" name="labelpos" port_type="basic:String">
      <docstring>Position the label above, below, to the right, to the left of the arrow, respectively.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['N', 'S', 'E', 'W']]</values>
    </inputPortSpec>
    <inputPortSpec arg="Y" arg_pos="2" name="Y" required="True">
      <docstring>The location of the key; additional explanation follows.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="X" arg_pos="1" name="X" required="True">
      <docstring>The location of the key; additional explanation follows.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labelsep" name="labelsep" port_type="basic:Float">
      <docstring>Distance in inches between the arrow and the label.  Default is 0.1</docstring>
      <defaults>[0.1]</defaults>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.scatter" name="MplScatter" output_type="object" superclass="MplPlot">
    <docstring>Make a scatter plot of x vs y, where x and y are sequence like objects
of the same lengths.

Parameters
----------
x, y : array_like, shape (n, )
    Input data

s : scalar or array_like, shape (n, ), optional, default: 20
    size in points^2.

c : color or sequence of color, optional, default : 'b'
    `c` can be a single color format string, or a sequence of color
    specifications of length `N`, or a sequence of `N` numbers to be
    mapped to colors using the `cmap` and `norm` specified via kwargs
    (see below). Note that `c` should not be a single numeric RGB or
    RGBA sequence because that is indistinguishable from an array of
    values to be colormapped.  `c` can be a 2-D array in which the
    rows are RGB or RGBA, however, including the case of a single
    row to specify the same color for all points.

marker : `~matplotlib.markers.MarkerStyle`, optional, default: 'o'
    See `~matplotlib.markers` for more information on the different
    styles of markers scatter supports. `marker` can be either
    an instance of the class or the text shorthand for a particular
    marker.

cmap : `~matplotlib.colors.Colormap`, optional, default: None
    A `~matplotlib.colors.Colormap` instance or registered name.
    `cmap` is only used if `c` is an array of floats. If None,
    defaults to rc `image.cmap`.

norm : `~matplotlib.colors.Normalize`, optional, default: None
    A `~matplotlib.colors.Normalize` instance is used to scale
    luminance data to 0, 1. `norm` is only used if `c` is an array of
    floats. If `None`, use the default :func:`normalize`.

vmin, vmax : scalar, optional, default: None
    `vmin` and `vmax` are used in conjunction with `norm` to normalize
    luminance data.  If either are `None`, the min and max of the
    color array is used.  Note if you pass a `norm` instance, your
    settings for `vmin` and `vmax` will be ignored.

alpha : scalar, optional, default: None
    The alpha blending value, between 0 (transparent) and 1 (opaque)

linewidths : scalar or array_like, optional, default: None
    If None, defaults to (lines.linewidth,).

edgecolors : color or sequence of color, optional, default: None
    If None, defaults to (patch.edgecolor).
    If 'face', the edge color will always be the same as
    the face color.  If it is 'none', the patch boundary will not
    be drawn.  For non-filled markers, the `edgecolors` kwarg
    is ignored; color is determined by `c`.

Returns
-------
paths : `~matplotlib.collections.PathCollection`

Other parameters
----------------
kwargs : `~matplotlib.collections.Collection` properties

Notes
------
Any or all of `x`, `y`, `s`, and `c` may be masked arrays, in
which case all masks will be combined and only unmasked points
will be plotted.

Fundamentally, scatter works with 1-D arrays; `x`, `y`, `s`,
and `c` may be input as 2-D arrays, but within scatter
they will be flattened. The exception is `c`, which
will be flattened only if its size matches the size of `x`
and `y`.

Examples
--------
.. plot:: mpl_examples/shapes_and_collections/scatter_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'edgecolors', 'c', 'facecolor', 'color', 'linewidths', 's', 'y', 'x', 'facecolors'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="vmax" arg_pos="8" name="vmax" port_type="basic:Float">
      <docstring>`vmin` and `vmax` are used in conjunction with `norm` to normalize
luminance data.  If either are `None`, the min and max of the
color array is used.  Note if you pass a `norm` instance, your
settings for `vmin` and `vmax` will be ignored.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="edgecolors" arg_pos="12" name="edgecolors" port_type="basic:Color">
      <docstring>If None, defaults to (patch.edgecolor).
If 'face', the edge color will always be the same as
the face color.  If it is 'none', the patch boundary will not
be drawn.  For non-filled markers, the `edgecolors` kwarg
is ignored; color is determined by `c`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="c" arg_pos="3" name="c" port_type="basic:Color">
      <docstring>`c` can be a single color format string, or a sequence of color
specifications of length `N`, or a sequence of `N` numbers to be
mapped to colors using the `cmap` and `norm` specified via kwargs
(see below). Note that `c` should not be a single numeric RGB or
RGBA sequence because that is indistinguishable from an array of
values to be colormapped.  `c` can be a 2-D array in which the
rows are RGB or RGBA, however, including the case of a single
row to specify the same color for all points.
</docstring>
      <translations>translate_color</translations>
      <alternateSpec arg="c" name="cSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="vmin" arg_pos="7" name="vmin" port_type="basic:Float">
      <docstring>`vmin` and `vmax` are used in conjunction with `norm` to normalize
luminance data.  If either are `None`, the min and max of the
color array is used.  Note if you pass a `norm` instance, your
settings for `vmin` and `vmax` will be ignored.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" />
    <inputPortSpec arg="linewidths" arg_pos="10" name="linewidths" port_type="basic:Float">
      <docstring>If None, defaults to (lines.linewidth,).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="marker" arg_pos="4" name="marker" port_type="basic:String">
      <docstring>See `~matplotlib.markers` for more information on the different
styles of markers scatter supports. `marker` can be either
an instance of the class or the text shorthand for a particular
marker.
</docstring>
      <defaults>[u'o']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="s" arg_pos="2" name="s" port_type="basic:Float">
      <docstring>size in points^2.
</docstring>
      <defaults>[20]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cmap" arg_pos="5" name="cmap" port_type="basic:List">
      <docstring>A `~matplotlib.colors.Colormap` instance or registered name.
`cmap` is only used if `c` is an array of floats. If None,
defaults to rc `image.cmap`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="verts" arg_pos="11" name="verts" />
    <inputPortSpec arg="alpha" arg_pos="9" name="alpha" port_type="basic:Float">
      <docstring>The alpha blending value, between 0 (transparent) and 1 (opaque)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True">
      <docstring>Input data
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True">
      <docstring>Input data
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="13" name="hold" />
    <inputPortSpec arg="data" arg_pos="14" name="data" />
    <inputPortSpec arg="norm" arg_pos="6" name="norm" port_type="basic:List">
      <docstring>A `~matplotlib.colors.Normalize` instance is used to scale
luminance data to 0, 1. `norm` is only used if `c` is an array of
floats. If `None`, use the default :func:`normalize`.
</docstring>
    </inputPortSpec>
    <outputPortSpec arg="pathCollection" compute_name="pathCollection" name="pathCollectionProperties" port_type="__property__" property_key="0" property_type="matplotlib.collections.PathCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.semilogx" name="MplSemilogx" output_type="object" superclass="MplPlot">
    <docstring>Make a plot with log scaling on the x axis.

Call signature:

semilogx(*args, **kwargs)

:func:`semilogx` supports all the keyword arguments of :func:`~matplotlib.pyplot.plot` and :meth:`matplotlib.axes.Axes.set_xscale`.

Notable keyword arguments:



The remaining valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

%(Line2D)s



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="basex" name="basex" port_type="basic:Float">
      <docstring>Base of the x logarithm</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nonposx" name="nonposx" port_type="basic:String">
      <docstring>Non-positive values in x can be masked as invalid, or clipped to a very small positive number</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['mask', 'clip']]</values>
    </inputPortSpec>
    <inputPortSpec arg="subsx" name="subsx" port_type="basic:List">
      <docstring>The location of the minor xticks; None defaults to autosubs, which depend on the number of decades in the plot; see :meth:`~matplotlib.axes.Axes.set_xscale` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.semilogy" name="MplSemilogy" output_type="object" superclass="MplPlot">
    <docstring>Make a plot with log scaling on the y axis.

call signature:

semilogy(*args, **kwargs)

:func:`semilogy` supports all the keyword arguments of :func:`~matplotlib.pylab.plot` and :meth:`matplotlib.axes.Axes.set_yscale`.

Notable keyword arguments:



The remaining valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

%(Line2D)s



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="basey" name="basey" port_type="basic:Float">
      <docstring>Base of the y logarithm</docstring>
    </inputPortSpec>
    <inputPortSpec arg="nonposy" name="nonposy" port_type="basic:String">
      <docstring>Non-positive values in y can be masked as invalid, or clipped to a very small positive number</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['mask', 'clip']]</values>
    </inputPortSpec>
    <inputPortSpec arg="subsy" name="subsy" port_type="basic:List">
      <docstring>The location of the minor yticks; None defaults to autosubs, which depend on the number of decades in the plot; see :meth:`~matplotlib.axes.Axes.set_yscale` for details.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.specgram" name="MplSpecgram" superclass="MplPlot">
    <docstring>Plot a spectrogram.

Call signature::

  specgram(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
           window=mlab.window_hanning, noverlap=128,
           cmap=None, xextent=None, pad_to=None, sides='default',
           scale_by_freq=None, mode='default', scale='default',
           **kwargs)

Compute and plot a spectrogram of data in *x*.  Data are split into
*NFFT* length segments and the spectrum of each section is
computed.  The windowing function *window* is applied to each
segment, and the amount of overlap of each segment is
specified with *noverlap*. The spectrogram is plotted as a colormap
(using imshow).

*x*: 1-D array or sequence
    Array or sequence containing the data

%(Spectral)s

%(PSD)s

  *mode*: [ 'default' | 'psd' | 'magnitude' | 'angle' | 'phase' ]
    What sort of spectrum to use.  Default is 'psd'. which takes
    the power spectral density.  'complex' returns the complex-valued
    frequency spectrum.  'magnitude' returns the magnitude spectrum.
    'angle' returns the phase spectrum without unwrapping.  'phase'
    returns the phase spectrum with unwrapping.

  *noverlap*: integer
    The number of points of overlap between blocks.  The
    default value is 128.

  *scale*: [ 'default' | 'linear' | 'dB' ]
    The scaling of the values in the *spec*.  'linear' is no scaling.
    'dB' returns the values in dB scale.  When *mode* is 'psd',
    this is dB power (10 * log10).  Otherwise this is dB amplitude
    (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
    'magnitude' and 'linear' otherwise.  This must be 'linear'
    if *mode* is 'angle' or 'phase'.

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

  *cmap*:
    A :class:`matplotlib.colors.Colormap` instance; if *None*, use
    default determined by rc

  *xextent*:
    The image extent along the x-axis. xextent = (xmin,xmax)
    The default is (0,max(bins)), where bins is the return
    value from :func:`~matplotlib.mlab.specgram`

  *kwargs*:
    Additional kwargs are passed on to imshow which makes the
    specgram image

.. note::

    *detrend* and *scale_by_freq* only apply when *mode* is set to
    'psd'

Returns the tuple (*spectrum*, *freqs*, *t*, *im*):

  *spectrum*: 2-D array
    columns are the periodograms of successive segments

  *freqs*: 1-D array
    The frequencies corresponding to the rows in *spectrum*

  *t*: 1-D array
    The times corresponding to midpoints of segments (i.e the columns
    in *spectrum*)

  *im*: instance of class :class:`~matplotlib.image.AxesImage`
    The image created by imshow containing the spectrogram

**Example:**

.. plot:: mpl_examples/pylab_examples/specgram_demo.py

.. seealso::

    :func:`psd`
        :func:`psd` differs in the default overlap; in returning
        the mean of the segment periodograms; in not returning
        times; and in generating a line plot instead of colormap.

    :func:`magnitude_spectrum`
        A single spectrum, similar to having a single segment when
        *mode* is 'magnitude'.  Plots a line instead of a colormap.

    :func:`angle_spectrum`
        A single spectrum, similar to having a single segment when
        *mode* is 'angle'.  Plots a line instead of a colormap.

    :func:`phase_spectrum`
        A single spectrum, similar to having a single segment when
        *mode* is 'phase'.  Plots a line instead of a colormap.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="scale" arg_pos="13" name="scale" port_type="basic:String">
      <defaults>['default']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="Fs" arg_pos="2" name="Fs" port_type="basic:Integer">
      <defaults>[2]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="vmin" arg_pos="14" name="vmin" />
    <inputPortSpec arg="pad_to" arg_pos="9" name="pad_to" />
    <inputPortSpec arg="scale_by_freq" arg_pos="11" name="scale_by_freq" />
    <inputPortSpec arg="xextent" arg_pos="8" name="xextent" />
    <inputPortSpec arg="detrend" arg_pos="4" name="detrend" />
    <inputPortSpec arg="window" arg_pos="5" name="window" />
    <inputPortSpec arg="Fc" arg_pos="3" name="Fc" port_type="basic:Integer">
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="mode" arg_pos="12" name="mode" port_type="basic:String">
      <defaults>['default']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="NFFT" arg_pos="1" name="NFFT" port_type="basic:Integer">
      <defaults>[256]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cmap" arg_pos="7" name="cmap" />
    <inputPortSpec arg="vmax" arg_pos="15" name="vmax" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="16" name="hold" />
    <inputPortSpec arg="data" arg_pos="17" name="data" />
    <inputPortSpec arg="sides" arg_pos="10" name="sides" port_type="basic:String">
      <defaults>['default']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="noverlap" arg_pos="6" name="noverlap" port_type="basic:Integer">
      <defaults>[128]</defaults>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.stackplot" name="MplStackplot" superclass="MplPlot">
    <docstring>Draws a stacked area plot.

x : 1d array of dimension N

Keyword arguments:

labels : A list or tuple of labels to assign to each data series.

Returns r : A list of :class:`~matplotlib.collections.PolyCollection`, one for each element in the stacked area plot.

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="x" arg_pos="0" name="x" required="True" />
    <inputPortSpec arg="baseline" name="baseline">
      <docstring>Method used to calculate the baseline. 'zero' is just a simple stacked plot. 'sym' is symmetric around zero and is sometimes called ThemeRiver.  'wiggle' minimizes the sum of the squared slopes. 'weighted_wiggle' does the same but weights to account for size of each layer. It is also called Streamgraph-layout. More details can be found at http://www.leebyron.com/else/streamgraph/.</docstring>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.stem" name="MplStem" output_type="tuple" superclass="MplPlot">
    <docstring>Create a stem plot.

Call signatures::

  stem(y, linefmt='b-', markerfmt='bo', basefmt='r-')
  stem(x, y, linefmt='b-', markerfmt='bo', basefmt='r-')

A stem plot plots vertical lines (using *linefmt*) at each *x*
location from the baseline to *y*, and places a marker there
using *markerfmt*.  A horizontal line at 0 is is plotted using
*basefmt*.

If no *x* values are provided, the default is (0, 1, ..., len(y) - 1)

Return value is a tuple (*markerline*, *stemlines*,
*baseline*).

.. seealso::
    This
    `document &lt;http://www.mathworks.com/help/techdoc/ref/stem.html&gt;`_
    for details.


**Example:**

.. plot:: mpl_examples/pylab_examples/stem_plot.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All positional and all keyword arguments.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <outputPortSpec arg="stemline" compute_name="stemlines" name="stemlineProperties" plural="True" port_type="__property__" property_key="1" property_type="matplotlib.lines.Line2D" />
    <outputPortSpec arg="markerline" compute_name="markerline" name="markerlineProperties" port_type="__property__" property_key="0" property_type="matplotlib.lines.Line2D" />
    <outputPortSpec arg="baseline" compute_name="baseline" name="baselineProperties" port_type="__property__" property_key="2" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.step" name="MplStep" output_type="object" superclass="MplPlot">
    <docstring>Make a step plot.

Call signature::

  step(x, y, *args, **kwargs)

Additional keyword args to :func:`step` are the same as those
for :func:`~matplotlib.pyplot.plot`.

*x* and *y* must be 1-D sequences, and it is assumed, but not checked,
that *x* is uniformly increasing.

Keyword arguments:

*where*: [ 'pre' | 'post' | 'mid'  ]
  If 'pre' (the default), the interval from x[i] to x[i+1] has level
  y[i+1].

  If 'post', that interval has level y[i].

  If 'mid', the jumps in *y* occur half-way between the
  *x*-values.

Return value is a list of lines that were added.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="where" name="where" port_type="basic:String">
      <docstring>If 'pre' (the default), the interval from x[i] to x[i+1] has level y[i+1].

If 'post', that interval has level y[i].

If 'mid', the jumps in y occur half-way between the x-values.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['pre', 'post', 'mid']]</values>
    </inputPortSpec>
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.streamplot" name="MplStreamplot" superclass="MplPlot">
    <docstring>Draws streamlines of a vector flow.

Returns:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="zorder" arg_pos="13" name="zorder" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="hold" arg_pos="15" name="hold" />
    <inputPortSpec arg="arrowstyle" arg_pos="10" name="arrowstyle" port_type="basic:String">
      <defaults>[u'-|&gt;']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="density" arg_pos="4" name="density" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="color" arg_pos="6" name="color" />
    <inputPortSpec arg="minlength" arg_pos="11" name="minlength" port_type="basic:Float">
      <defaults>[0.1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="transform" arg_pos="12" name="transform" />
    <inputPortSpec arg="arrowsize" arg_pos="9" name="arrowsize" port_type="basic:Integer">
      <defaults>[1]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="cmap" arg_pos="7" name="cmap" />
    <inputPortSpec arg="u" arg_pos="2" name="u" required="True" />
    <inputPortSpec arg="v" arg_pos="3" name="v" required="True" />
    <inputPortSpec arg="y" arg_pos="1" name="y" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" required="True" />
    <inputPortSpec arg="start_points" arg_pos="14" name="start_points" />
    <inputPortSpec arg="linewidth" arg_pos="5" name="linewidth" />
    <inputPortSpec arg="data" arg_pos="16" name="data" />
    <inputPortSpec arg="norm" arg_pos="8" name="norm" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.tricontour" name="MplTricontour" superclass="MplPlot">
    <docstring>Draw contours on an unstructured triangular grid. :func:`~matplotlib.pyplot.tricontour` and :func:`~matplotlib.pyplot.tricontourf` draw contour lines and filled contours, respectively.  Except as noted, function signatures and return values are the same for both versions.

The triangulation can be specified in one of two ways; either:

tricontour(triangulation, ...)

where triangulation is a :class:`matplotlib.tri.Triangulation` object, or

tricontour(x, y, ...) tricontour(x, y, triangles, ...) tricontour(x, y, triangles=triangles, ...) tricontour(x, y, mask=mask, ...) tricontour(x, y, triangles, mask=mask, ...)

in which case a Triangulation object will be created.  See :class:`~matplotlib.tri.Triangulation` for a explanation of these possibilities.

The remaining arguments may be:

tricontour(..., Z)

where Z is the array of values to contour, one per point in the triangulation.  The level values are chosen automatically.

tricontour(..., Z, N)

contour N automatically-chosen levels.

tricontour(..., Z, V)

draw contour lines at the values specified in sequence V

tricontourf(..., Z, V)

fill the (len(V)-1) regions between the values in V

tricontour(Z, **kwargs)

Use keyword args to control colors, linewidth, origin, cmap ... see below for more details.

C = tricontour(...) returns a :class:`~matplotlib.contour.TriContourSet` object.

Optional keyword arguments:

extent: [ None | (x0,x1,y0,y1) ]

If origin is not None, then extent is interpreted as in :func:`matplotlib.pyplot.imshow`: it gives the outer pixel boundaries. In this case, the position of Z[0,0] is the center of the pixel, not a corner. If origin is None, then (x0, y0) is the position of Z[0,0], and (x1, y1) is the position of Z[-1,-1].

This keyword is not active if X and Y are specified in the call to contour.

tricontour-only keyword arguments:



tricontourf-only keyword arguments:



Note: tricontourf fills intervals that are closed at the top; that is, for boundaries z1 and z2, the filled region is:

z1 &lt; z &lt;= z2

There is one exception: if the lowest boundary coincides with the minimum value of the z array, then that minimum value will be included in the lowest interval.

Examples:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="origin" name="origin" port_type="basic:String">
      <docstring>If None, the first value of Z will correspond to the lower left corner, location (0,0). If 'image', the rc value for image.origin will be used.

This keyword is not active if X and Y are specified in the call to contour.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['upper', 'lower', 'image']]</values>
    </inputPortSpec>
    <inputPortSpec arg="linestyles" name="linestyles" port_type="basic:String">
      <docstring>If linestyles is None, the 'solid' is used.

linestyles can also be an iterable of the above strings specifying a set of linestyles to be used. If this iterable is shorter than the number of contour levels it will be repeated as necessary.

If contour is using a monochrome colormap and the contour level is less than 0, then the linestyle specified in contour.negative_linestyle in matplotlibrc will be used.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['solid', 'dashed', 'dashdot', 'dotted']]</values>
    </inputPortSpec>
    <inputPortSpec arg="levels" name="levels" port_type="basic:List">
      <docstring>A list of floating point numbers indicating the level curves to draw; e.g., to draw just the zero contour pass levels=[0]</docstring>
    </inputPortSpec>
    <inputPortSpec arg="linewidths" name="linewidths" port_type="basic:String">
      <docstring>If linewidths is None, the default width in lines.linewidth in matplotlibrc is used.

If a number, all levels will be plotted with this linewidth.

If a tuple, different levels will be plotted with different linewidths in the order specified</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['number', 'tuple of numbers']]</values>
    </inputPortSpec>
    <inputPortSpec arg="colors" name="colors">
      <docstring>If None, the colormap specified by cmap will be used.

If a string, like 'r' or 'red', all levels will be plotted in this color.

If a tuple of matplotlib color args (string, float, rgb, etc), different levels will be plotted in different colors in the order specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmap" name="cmap" port_type="basic:Color">
      <docstring>A cm :class:`~matplotlib.colors.Colormap` instance or None. If cmap is None and colors is None, a default Colormap is used.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="antialiased" name="antialiased" port_type="basic:Boolean">
      <docstring>enable antialiasing</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>The alpha blending value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="normSequence" port_type="basic:List">
      <docstring>A :class:`matplotlib.colors.Normalize` instance for scaling data values to colors. If norm is None and colors is None, the default linear scaling is used.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.tricontourf" name="MplTricontourf" superclass="MplPlot">
    <docstring>Draw contours on an unstructured triangular grid. :func:`~matplotlib.pyplot.tricontour` and :func:`~matplotlib.pyplot.tricontourf` draw contour lines and filled contours, respectively.  Except as noted, function signatures and return values are the same for both versions.

The triangulation can be specified in one of two ways; either:

tricontour(triangulation, ...)

where triangulation is a :class:`matplotlib.tri.Triangulation` object, or

tricontour(x, y, ...) tricontour(x, y, triangles, ...) tricontour(x, y, triangles=triangles, ...) tricontour(x, y, mask=mask, ...) tricontour(x, y, triangles, mask=mask, ...)

in which case a Triangulation object will be created.  See :class:`~matplotlib.tri.Triangulation` for a explanation of these possibilities.

The remaining arguments may be:

tricontour(..., Z)

where Z is the array of values to contour, one per point in the triangulation.  The level values are chosen automatically.

tricontour(..., Z, N)

contour N automatically-chosen levels.

tricontour(..., Z, V)

draw contour lines at the values specified in sequence V

tricontourf(..., Z, V)

fill the (len(V)-1) regions between the values in V

tricontour(Z, **kwargs)

Use keyword args to control colors, linewidth, origin, cmap ... see below for more details.

C = tricontour(...) returns a :class:`~matplotlib.contour.TriContourSet` object.

Optional keyword arguments:

extent: [ None | (x0,x1,y0,y1) ]

If origin is not None, then extent is interpreted as in :func:`matplotlib.pyplot.imshow`: it gives the outer pixel boundaries. In this case, the position of Z[0,0] is the center of the pixel, not a corner. If origin is None, then (x0, y0) is the position of Z[0,0], and (x1, y1) is the position of Z[-1,-1].

This keyword is not active if X and Y are specified in the call to contour.

tricontour-only keyword arguments:



tricontourf-only keyword arguments:



Note: tricontourf fills intervals that are closed at the top; that is, for boundaries z1 and z2, the filled region is:

z1 &lt; z &lt;= z2

There is one exception: if the lowest boundary coincides with the minimum value of the z array, then that minimum value will be included in the lowest interval.

Examples:

Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="origin" name="origin" port_type="basic:String">
      <docstring>If None, the first value of Z will correspond to the lower left corner, location (0,0). If 'image', the rc value for image.origin will be used.

This keyword is not active if X and Y are specified in the call to contour.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['upper', 'lower', 'image']]</values>
    </inputPortSpec>
    <inputPortSpec arg="linestyles" name="linestyles" port_type="basic:String">
      <docstring>If linestyles is None, the 'solid' is used.

linestyles can also be an iterable of the above strings specifying a set of linestyles to be used. If this iterable is shorter than the number of contour levels it will be repeated as necessary.

If contour is using a monochrome colormap and the contour level is less than 0, then the linestyle specified in contour.negative_linestyle in matplotlibrc will be used.</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['solid', 'dashed', 'dashdot', 'dotted']]</values>
    </inputPortSpec>
    <inputPortSpec arg="levels" name="levels" port_type="basic:List">
      <docstring>A list of floating point numbers indicating the level curves to draw; e.g., to draw just the zero contour pass levels=[0]</docstring>
    </inputPortSpec>
    <inputPortSpec arg="linewidths" name="linewidths" port_type="basic:String">
      <docstring>If linewidths is None, the default width in lines.linewidth in matplotlibrc is used.

If a number, all levels will be plotted with this linewidth.

If a tuple, different levels will be plotted with different linewidths in the order specified</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['number', 'tuple of numbers']]</values>
    </inputPortSpec>
    <inputPortSpec arg="colors" name="colors">
      <docstring>If None, the colormap specified by cmap will be used.

If a string, like 'r' or 'red', all levels will be plotted in this color.

If a tuple of matplotlib color args (string, float, rgb, etc), different levels will be plotted in different colors in the order specified.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="cmap" name="cmap" port_type="basic:Color">
      <docstring>A cm :class:`~matplotlib.colors.Colormap` instance or None. If cmap is None and colors is None, a default Colormap is used.</docstring>
      <translations>translate_color</translations>
    </inputPortSpec>
    <inputPortSpec arg="antialiased" name="antialiased" port_type="basic:Boolean">
      <docstring>enable antialiasing</docstring>
    </inputPortSpec>
    <inputPortSpec arg="alpha" name="alpha" port_type="basic:Float">
      <docstring>The alpha blending value</docstring>
    </inputPortSpec>
    <inputPortSpec arg="norm" name="normSequence" port_type="basic:List">
      <docstring>A :class:`matplotlib.colors.Normalize` instance for scaling data values to colors. If norm is None and colors is None, the default linear scaling is used.</docstring>
      <alternateSpec arg="norm" name="normScalar" port_type="basic:String">
        <entry_types>['enum']</entry_types>
        <values>[['Normalize']]</values>
      </alternateSpec>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.tripcolor" name="MplTripcolor" superclass="MplPlot">
    <docstring>Create a pseudocolor plot of an unstructured triangular grid.

The triangulation can be specified in one of two ways; either:

tripcolor(triangulation, ...)

where triangulation is a :class:`matplotlib.tri.Triangulation` object, or

tripcolor(x, y, ...) tripcolor(x, y, triangles, ...) tripcolor(x, y, triangles=triangles, ...) tripcolor(x, y, mask=mask, ...) tripcolor(x, y, triangles, mask=mask, ...)

in which case a Triangulation object will be created.  See :class:`~matplotlib.tri.Triangulation` for a explanation of these possibilities.

The next argument must be C, the array of color values, either one per point in the triangulation if color values are defined at points, or one per triangle in the triangulation if color values are defined at triangles. If there are the same number of points and triangles in the triangulation it is assumed that color values are defined at points; to force the use of color values at triangles use the kwarg facecolors*=C instead of just *C.

shading may be 'flat' (the default) or 'gouraud'. If shading is 'flat' and C values are defined at points, the color values used for each triangle are from the mean C of the triangle's three points. If shading is 'gouraud' then color values must be defined at points.

The remaining kwargs are the same as for :meth:`~matplotlib.axes.Axes.pcolor`.

Example:



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.triplot" name="MplTriplot" superclass="MplPlot">
    <docstring>Draw a unstructured triangular grid as lines and/or markers.

The triangulation to plot can be specified in one of two ways; either:

triplot(triangulation, ...)

where triangulation is a :class:`matplotlib.tri.Triangulation` object, or

triplot(x, y, ...) triplot(x, y, triangles, ...) triplot(x, y, triangles=triangles, ...) triplot(x, y, mask=mask, ...) triplot(x, y, triangles, mask=mask, ...)

in which case a Triangulation object will be created.  See :class:`~matplotlib.tri.Triangulation` for a explanation of these possibilities.

The remaining args and kwargs are the same as for :meth:`~matplotlib.axes.Axes.plot`.

Return a list of 2 :class:`~matplotlib.lines.Line2D` containing respectively:

the lines plotted for triangles edges

the markers plotted for triangles nodes

Example:



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.vlines" name="MplVlines" superclass="MplPlot">
    <docstring>Plot vertical lines.

Plot vertical lines at each `x` from `ymin` to `ymax`.

Parameters
----------
x : scalar or 1D array_like
    x-indexes where to plot the lines.

ymin, ymax : scalar or 1D array_like
    Respective beginning and end of each line. If scalars are
    provided, all lines will have same length.

colors : array_like of colors, optional, default: 'k'

linestyles : ['solid' | 'dashed' | 'dashdot' | 'dotted'], optional

label : string, optional, default: ''

Returns
-------
lines : `~matplotlib.collections.LineCollection`

Other parameters
----------------
kwargs : `~matplotlib.collections.LineCollection` properties.

See also
--------
hlines : horizontal lines

Examples
---------
.. plot:: mpl_examples/pylab_examples/vline_hline_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'x', 'colors', 'ymin', 'ymax'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="hold" arg_pos="6" name="hold" />
    <inputPortSpec arg="ymax" arg_pos="2" name="ymax" port_type="basic:Float" required="True">
      <docstring>Respective beginning and end of each line. If scalars are
provided, all lines will have same length.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="linestyles" arg_pos="4" name="linestyles" port_type="basic:String">
      <entry_types>['enum']</entry_types>
      <values>[['solid', 'dashed', 'dashdot', 'dotted']]</values>
      <defaults>[u'solid']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="label" arg_pos="5" name="label" port_type="basic:String">
      <defaults>[u'']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="colors" arg_pos="3" name="colorsSequence" port_type="basic:List">
      <alternateSpec arg="colors" name="colorsScalar" port_type="basic:String">
        <defaults>[u'k']</defaults>
      </alternateSpec>
    </inputPortSpec>
    <inputPortSpec arg="kwargs" name="kwargs" />
    <inputPortSpec arg="x" arg_pos="0" name="xSequence" port_type="basic:List" required="True">
      <docstring>x-indexes where to plot the lines.
</docstring>
      <alternateSpec arg="x" name="xScalar" port_type="basic:Float" />
    </inputPortSpec>
    <inputPortSpec arg="ymin" arg_pos="1" name="ymin" port_type="basic:Float" required="True">
      <docstring>Respective beginning and end of each line. If scalars are
provided, all lines will have same length.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="data" arg_pos="7" name="data" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.xcorr" name="MplXcorr" output_type="tuple" superclass="MplPlot">
    <docstring>Plot the cross correlation between *x* and *y*.

Parameters
----------

x : sequence of scalars of length n

y : sequence of scalars of length n

hold : boolean, optional, default: True

detrend : callable, optional, default: `mlab.detrend_none`
    x is detrended by the `detrend` callable. Default is no
    normalization.

normed : boolean, optional, default: True
    if True, normalize the data by the autocorrelation at the 0-th
    lag.

usevlines : boolean, optional, default: True
    if True, Axes.vlines is used to plot the vertical lines from the
    origin to the acorr. Otherwise, Axes.plot is used.

maxlags : integer, optional, default: 10
    number of lags to show. If None, will return all 2 * len(x) - 1
    lags.

Returns
-------
(lags, c, line, b) : where:

  - `lags` are a length 2`maxlags+1 lag vector.
  - `c` is the 2`maxlags+1 auto correlation vectorI
  - `line` is a `~matplotlib.lines.Line2D` instance returned by
    `plot`.
  - `b` is the x-axis (none, if plot is used).

Other parameters
-----------------
linestyle : `~matplotlib.lines.Line2D` prop, optional, default: None
    Only used if usevlines is False.

marker : string, optional, default: 'o'

Notes
-----
The cross correlation is performed with :func:`numpy.correlate` with
`mode` = 2.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="normed" arg_pos="2" name="normed" port_type="basic:Boolean">
      <docstring>if True, normalize the data by the autocorrelation at the 0-th
lag.
</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="usevlines" arg_pos="4" name="usevlines" port_type="basic:Boolean">
      <docstring>if True, Axes.vlines is used to plot the vertical lines from the
origin to the acorr. Otherwise, Axes.plot is used.
</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="linestyle" name="linestyle">
      <docstring>Only used if usevlines is False.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="detrend" arg_pos="3" name="detrend">
      <docstring>x is detrended by the `detrend` callable. Default is no
normalization.
</docstring>
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="maxlags" arg_pos="5" name="maxlags" port_type="basic:Integer">
      <docstring>number of lags to show. If None, will return all 2 * len(x) - 1
lags.</docstring>
      <defaults>[10]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" name="x" port_type="basic:List" required="True" />
    <inputPortSpec arg="hold" arg_pos="6" name="hold" port_type="basic:Boolean" />
    <inputPortSpec arg="data" arg_pos="7" name="data" />
    <inputPortSpec arg="marker" name="marker" port_type="basic:String" />
    <outputPortSpec arg="lineCollection" compute_name="lineCollection" name="lineCollectionProperties" port_type="__property__" property_key="4" property_type="matplotlib.collections.LineCollection" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="2" property_type="matplotlib.lines.Line2D" />
    <outputPortSpec arg="xaxis" compute_name="xaxis" name="xaxisProperties" port_type="__property__" property_key="3" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.barbs" name="MplBarbs" output_type="object" superclass="MplPlot">
    <docstring>
Plot a 2-D field of barbs.

Call signatures::

  barb(U, V, **kw)
  barb(U, V, C, **kw)
  barb(X, Y, U, V, **kw)
  barb(X, Y, U, V, C, **kw)

Arguments:

  *X*, *Y*:
    The x and y coordinates of the barb locations
    (default is head of barb; see *pivot* kwarg)

  *U*, *V*:
    Give the x and y components of the barb shaft

  *C*:
    An optional array used to map colors to the barbs

All arguments may be 1-D or 2-D arrays or sequences. If *X* and *Y*
are absent, they will be generated as a uniform grid.  If *U* and *V*
are 2-D arrays but *X* and *Y* are 1-D, and if ``len(X)`` and ``len(Y)``
match the column and row dimensions of *U*, then *X* and *Y* will be
expanded with :func:`numpy.meshgrid`.

*U*, *V*, *C* may be masked arrays, but masked *X*, *Y* are not
supported at present.

Keyword arguments:

  *length*:
    Length of the barb in points; the other parts of the barb
    are scaled against this.
    Default is 9

  *pivot*: [ 'tip' | 'middle' ]
    The part of the arrow that is at the grid point; the arrow rotates
    about this point, hence the name *pivot*.  Default is 'tip'

  *barbcolor*: [ color | color sequence ]
    Specifies the color all parts of the barb except any flags.  This
    parameter is analagous to the *edgecolor* parameter for polygons,
    which can be used instead. However this parameter will override
    facecolor.

  *flagcolor*: [ color | color sequence ]
    Specifies the color of any flags on the barb.  This parameter is
    analagous to the *facecolor* parameter for polygons, which can be
    used instead. However this parameter will override facecolor.  If
    this is not set (and *C* has not either) then *flagcolor* will be
    set to match *barbcolor* so that the barb has a uniform color. If
    *C* has been set, *flagcolor* has no effect.

  *sizes*:
    A dictionary of coefficients specifying the ratio of a given
    feature to the length of the barb. Only those values one wishes to
    override need to be included.  These features include:

        - 'spacing' - space between features (flags, full/half barbs)

        - 'height' - height (distance from shaft to top) of a flag or
          full barb

        - 'width' - width of a flag, twice the width of a full barb

        - 'emptybarb' - radius of the circle used for low magnitudes

  *fill_empty*:
    A flag on whether the empty barbs (circles) that are drawn should
    be filled with the flag color.  If they are not filled, they will
    be drawn such that no color is applied to the center.  Default is
    False

  *rounding*:
    A flag to indicate whether the vector magnitude should be rounded
    when allocating barb components.  If True, the magnitude is
    rounded to the nearest multiple of the half-barb increment.  If
    False, the magnitude is simply truncated to the next lowest
    multiple.  Default is True

  *barb_increments*:
    A dictionary of increments specifying values to associate with
    different parts of the barb. Only those values one wishes to
    override need to be included.

        - 'half' - half barbs (Default is 5)

        - 'full' - full barbs (Default is 10)

        - 'flag' - flags (default is 50)

  *flip_barb*:
    Either a single boolean flag or an array of booleans.  Single
    boolean indicates whether the lines and flags should point
    opposite to normal for all barbs.  An array (which should be the
    same size as the other data arrays) indicates whether to flip for
    each individual barb.  Normal behavior is for the barbs and lines
    to point right (comes from wind barbs having these features point
    towards low pressure in the Northern Hemisphere.)  Default is
    False

Barbs are traditionally used in meteorology as a way to plot the speed
and direction of wind observations, but can technically be used to
plot any two dimensional vector quantity.  As opposed to arrows, which
give vector magnitude by the length of the arrow, the barbs give more
quantitative information about the vector magnitude by putting slanted
lines or a triangle for various increments in magnitude, as show
schematically below::

 :     /\    \
 :    /  \    \
 :   /    \    \    \
 :  /      \    \    \
 : ------------------------------

.. note the double \ at the end of each line to make the figure
.. render correctly

The largest increment is given by a triangle (or "flag"). After those
come full lines (barbs). The smallest increment is a half line.  There
is only, of course, ever at most 1 half line.  If the magnitude is
small and only needs a single half-line and no full lines or
triangles, the half-line is offset from the end of the barb so that it
can be easily distinguished from barbs with a single full line.  The
magnitude for the barb shown above would nominally be 65, using the
standard increments of 50, 10, and 5.

linewidths and edgecolors can be used to customize the barb.
Additional :class:`~matplotlib.collections.PolyCollection` keyword
arguments:

  agg_filter: unknown
  alpha: float or None         
  animated: [True | False]         
  antialiased or antialiaseds: Boolean or sequence of booleans         
  array: unknown
  axes: an :class:`~matplotlib.axes.Axes` instance         
  clim: a length 2 sequence of floats         
  clip_box: a :class:`matplotlib.transforms.Bbox` instance         
  clip_on: [True | False]         
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]         
  cmap: a colormap or registered colormap name         
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function         
  edgecolor or edgecolors: matplotlib color spec or sequence of specs         
  facecolor or facecolors: matplotlib color spec or sequence of specs         
  figure: a :class:`matplotlib.figure.Figure` instance         
  gid: an id string         
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]         
  label: string or anything printable with '%s' conversion.         
  linestyle or linestyles or dashes: ['solid' | 'dashed', 'dashdot', 'dotted' |                    (offset, on-off-dash-seq) |                    ``'-'`` | ``'--'`` | ``'-.'`` | ``':'`` | ``'None'`` |                    ``' '`` | ``''``]
  linewidth or lw or linewidths: float or sequence of floats         
  norm: unknown
  offset_position: unknown
  offsets: float or sequence of floats         
  path_effects: unknown
  picker: [None|float|boolean|callable]         
  pickradius: unknown
  rasterized: [True | False | None]         
  sketch_params: unknown
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance         
  url: a url string         
  urls: unknown
  visible: [True | False]         
  zorder: any number         


**Example:**

.. plot:: mpl_examples/pylab_examples/barb_demo.py

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All positional and all keyword arguments.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="barbcolor" name="barbcolor" port_type="basic:Color">
      <docstring>Specifies the color all parts of the barb except any flags.  This parameter is analagous to the edgecolor parameter for polygons, which can be used instead. However this parameter will override facecolor.</docstring>
      <translations>translate_color</translations>
      <alternateSpec arg="barbcolor" name="barbcolorSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="C" arg_pos="4" in_args="True" name="C" port_type="basic:List">
      <docstring>An optional array used to map colors to the barbs</docstring>
    </inputPortSpec>
    <inputPortSpec arg="sizes" name="sizes" port_type="basic:Dictionary">
      <docstring>A dictionary of coefficients specifying the ratio of a given feature to the length of the barb. Only those values one wishes to override need to be included.  These features include:

'spacing' - space between features (flags, full/half barbs)

'height' - height (distance from shaft to top) of a flag or full barb

'width' - width of a flag, twice the width of a full barb

'emptybarb' - radius of the circle used for low magnitudes</docstring>
    </inputPortSpec>
    <inputPortSpec arg="rounding" name="rounding" port_type="basic:Boolean">
      <docstring>A flag to indicate whether the vector magnitude should be rounded when allocating barb components.  If True, the magnitude is rounded to the nearest multiple of the half-barb increment.  If False, the magnitude is simply truncated to the next lowest multiple.  Default is True</docstring>
      <defaults>[True]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="pivot" name="pivot" port_type="basic:String">
      <docstring>The part of the arrow that is at the grid point; the arrow rotates about this point, hence the name pivot.  Default is 'tip'</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['tip', 'middle']]</values>
      <defaults>['tip']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="flip_barb" name="flip_barb" port_type="basic:Boolean">
      <docstring>Either a single boolean flag or an array of booleans.  Single boolean indicates whether the lines and flags should point opposite to normal for all barbs.  An array (which should be the same size as the other data arrays) indicates whether to flip for each individual barb.  Normal behavior is for the barbs and lines to point right (comes from wind barbs having these features point towards low pressure in the Northern Hemisphere.)  Default is False</docstring>
      <defaults>[False]</defaults>
      <alternateSpec arg="flip_barb" name="flip_barbSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="length" name="length" port_type="basic:Integer">
      <docstring>Length of the barb in points; the other parts of the barb are scaled against this. Default is 9</docstring>
      <defaults>[9]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="barb_increments" name="barb_increments" port_type="basic:Dictionary">
      <docstring>A dictionary of increments specifying values to associate with different parts of the barb. Only those values one wishes to override need to be included.

'half' - half barbs (Default is 5)

'full' - full barbs (Default is 10)

'flag' - flags (default is 50)</docstring>
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="U" arg_pos="2" in_args="True" name="U" port_type="basic:List" required="True">
      <docstring>Give the x and y components of the barb shaft</docstring>
    </inputPortSpec>
    <inputPortSpec arg="V" arg_pos="3" in_args="True" name="V" port_type="basic:List" required="True">
      <docstring>Give the x and y components of the barb shaft</docstring>
    </inputPortSpec>
    <inputPortSpec arg="Y" arg_pos="1" in_args="True" name="Y" port_type="basic:List">
      <docstring>The x and y coordinates of the barb locations (default is head of barb; see pivot kwarg)</docstring>
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="X" arg_pos="0" in_args="True" name="X" port_type="basic:List">
      <docstring>The x and y coordinates of the barb locations (default is head of barb; see pivot kwarg)</docstring>
      <defaults>None</defaults>
    </inputPortSpec>
    <inputPortSpec arg="flagcolor" name="flagcolor" port_type="basic:Color">
      <docstring>Specifies the color of any flags on the barb.  This parameter is analagous to the facecolor parameter for polygons, which can be used instead. However this parameter will override facecolor.  If this is not set (and C has not either) then flagcolor will be set to match barbcolor so that the barb has a uniform color. If C has been set, flagcolor has no effect.</docstring>
      <translations>translate_color</translations>
      <alternateSpec arg="flagcolor" name="flagcolorSequence" port_type="basic:List" />
    </inputPortSpec>
    <inputPortSpec arg="fill_empty" name="fill_empty" port_type="basic:Boolean">
      <docstring>A flag on whether the empty barbs (circles) that are drawn should be filled with the flag color.  If they are not filled, they will be drawn such that no color is applied to the center.  Default is False</docstring>
      <defaults>[False]</defaults>
    </inputPortSpec>
    <outputPortSpec arg="polyCollection" compute_name="polyCollection" name="polyCollectionProperties" port_type="__property__" property_key="__none__" property_type="matplotlib.collections.PolyCollection" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.spy" name="MplSpy" output_type="tuple" superclass="MplPlot">
    <docstring>Plot the sparsity pattern on a 2-D array.

``spy(Z)`` plots the sparsity pattern of the 2-D array *Z*.

Parameters
----------

Z : sparse array (n, m)
    The array to be plotted.

precision : float, optional, default: 0
    If *precision* is 0, any non-zero value will be plotted; else,
    values of :math:`|Z| &gt; precision` will be plotted.

    For :class:`scipy.sparse.spmatrix` instances, there is a special
    case: if *precision* is 'present', any value present in the array
    will be plotted, even if it is identically zero.

origin : ["upper", "lower"], optional, default: "upper"
    Place the [0,0] index of the array in the upper left or lower left
    corner of the axes.

aspect : ['auto' | 'equal' | scalar], optional, default: "equal"

    If 'equal', and `extent` is None, changes the axes aspect ratio to
    match that of the image. If `extent` is not `None`, the axes
    aspect ratio is changed to match that of the extent.


    If 'auto', changes the image aspect ratio to match that of the
    axes.

    If None, default to rc ``image.aspect`` value.

Two plotting styles are available: image or marker. Both
are available for full arrays, but only the marker style
works for :class:`scipy.sparse.spmatrix` instances.

If *marker* and *markersize* are *None*, an image will be
returned and any remaining kwargs are passed to
:func:`~matplotlib.pyplot.imshow`; else, a
:class:`~matplotlib.lines.Line2D` object will be returned with
the value of marker determining the marker type, and any
remaining kwargs passed to the
:meth:`~matplotlib.axes.Axes.plot` method.

If *marker* and *markersize* are *None*, useful kwargs include:

* *cmap*
* *alpha*

See also
--------
imshow : for image options.
plot : for plotting options



Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="origin" name="origin">
      <docstring>Place the [0,0] index of the array in the upper left or lower left
corner of the axes.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="are available for full arrays" name="are available for full arrays" />
    <inputPortSpec arg="hold" arg_pos="5" name="hold" />
    <inputPortSpec arg="an image will be" name="an image will be" />
    <inputPortSpec arg="returned and any remaining kwargs are passed to" name="returned and any remaining kwargs are passed to" />
    <inputPortSpec arg="* *alpha*" name="* *alpha*" />
    <inputPortSpec arg="markersize" arg_pos="3" name="markersize" />
    <inputPortSpec arg="but only the marker style" name="but only the marker style" />
    <inputPortSpec arg="precision" arg_pos="1" name="precision" port_type="basic:Float">
      <docstring>If *precision* is 0, any non-zero value will be plotted; else,
values of :math:`|Z| &gt; precision` will be plotted.

For :class:`scipy.sparse.spmatrix` instances, there is a special
case: if *precision* is 'present', any value present in the array
will be plotted, even if it is identically zero.
</docstring>
      <defaults>[0]</defaults>
    </inputPortSpec>
    <inputPortSpec arg="If *marker* and *markersize* are *None*" name="If *marker* and *markersize* are *None*" />
    <inputPortSpec arg="the value of marker determining the marker type" name="the value of marker determining the marker type" />
    <inputPortSpec arg="remaining kwargs passed to the" name="remaining kwargs passed to the" />
    <inputPortSpec arg="aspect" arg_pos="4" name="aspect">
      <docstring>
If 'equal', and `extent` is None, changes the axes aspect ratio to
match that of the image. If `extent` is not `None`, the axes
aspect ratio is changed to match that of the extent.

If 'auto', changes the image aspect ratio to match that of the
axes.

If None, default to rc ``image.aspect`` value.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['auto', 'equal']]</values>
      <defaults>[u'equal']</defaults>
    </inputPortSpec>
    <inputPortSpec arg="* *cmap*" name="* *cmap*" />
    <inputPortSpec arg="marker" arg_pos="2" name="marker" />
    <inputPortSpec arg="Z" arg_pos="0" name="Z" port_type="basic:List" required="True">
      <docstring>The array to be plotted.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="and any" name="and any" />
    <outputPortSpec arg="image" compute_name="image" name="imageProperties" port_type="__property__" property_key="0" property_type="matplotlib.image.AxesImage" />
    <outputPortSpec arg="marks" compute_name="marks" name="marksProperties" port_type="__property__" property_key="1" property_type="matplotlib.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.polar" name="MplPolar" output_type="object" superclass="MplPlot">
    <docstring>Make a polar plot.

call signature:

polar(theta, r, **kwargs)

Multiple theta, r arguments are supported, with format strings, as in :func:`~matplotlib.pyplot.plot`.</docstring>
    <inputPortSpec arg="theta" arg_pos="0" in_args="True" name="theta" port_type="basic:List" required="True" />
    <inputPortSpec arg="r" arg_pos="1" in_args="True" name="r" port_type="basic:List" required="True" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.legend" name="MplLegend" superclass="MplPlot">
    <docstring>Place a legend on the current axes.

Call signature:

legend(*args, **kwargs)

Places legend at location loc.  Labels are a sequence of strings and loc can be a string or an integer specifying the legend location.

To make a legend with existing lines:

legend()

:meth:`legend` by itself will try and build a legend using the label property of the lines/patches/collections.  You can set the label of a line by doing:

plot(x, y, label='my data')

or:

line.set_label('my data').

If label is set to '_nolegend_', the item will not be shown in legend.

To automatically generate the legend from labels:

legend( ('label1', 'label2', 'label3') )

To make a legend for a list of lines and labels:

legend( (line1, line2, line3), ('label1', 'label2', 'label3') )

To make a legend at a given location, using a location argument:

legend( ('label1', 'label2', 'label3'), loc='upper left')

or:

legend( (line1, line2, line3),  ('label1', 'label2', 'label3'), loc=2)

The location codes are



Users can specify any arbitrary location for the legend using the bbox_to_anchor keyword argument. bbox_to_anchor can be an instance of BboxBase(or its derivatives) or a tuple of 2 or 4 floats. For example,

loc = 'upper right', bbox_to_anchor = (0.5, 0.5)

will place the legend so that the upper right corner of the legend at the center of the axes.

The legend location can be specified in other coordinate, by using the bbox_transform keyword.

The loc itslef can be a 2-tuple giving x,y of the lower-left corner of the legend in axes coords (bbox_to_anchor is ignored).

Keyword arguments:

fontsize: [ size in points | 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' ]

Set the font size.  May be either a size string, relative to the default font size, or an absolute font size in points. This argument is only used if prop is not specified.

Padding and spacing between various elements use following keywords parameters. These values are measure in font-size units. E.g., a fontsize of 10 points and a handlelength=5 implies a handlelength of 50 points.  Values from rcParams will be used if None.

Not all kinds of artist are supported by the legend command. See LINK (FIXME) for details.

Example:</docstring>
    <inputPortSpec arg="fancybox" name="fancybox">
      <docstring>Control whether round edges should be enabled around
the :class:`~matplotlib.patches.FancyBboxPatch` which
makes up the legend's background.
Default is ``None`` which will take the value from the
``legend.fancybox`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="handlelength" name="handlelength" port_type="basic:Float">
      <docstring>The length of the legend handles.
Measured in font-size units.
Default is ``None`` which will take the value from the
``legend.handlelength`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="labelspacing" name="labelspacing" port_type="basic:Float">
      <docstring>The vertical space between the legend entries.
Measured in font-size units.
Default is ``None`` which will take the value from the
``legend.labelspacing`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="columnspacing" name="columnspacing" port_type="basic:Float">
      <docstring>The spacing between columns.
Measured in font-size units.
Default is ``None`` which will take the value from the
``legend.columnspacing`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="handletextpad" name="handletextpad" port_type="basic:Float">
      <docstring>The pad between the legend handle and text.
Measured in font-size units.
Default is ``None`` which will take the value from the
``legend.handletextpad`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="ncol" name="ncol" port_type="basic:Integer">
      <docstring>The number of columns that the legend has. Default is 1.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="borderaxespad" name="borderaxespad" port_type="basic:Float">
      <docstring>The pad between the axes and legend border.
Measured in font-size units.
Default is ``None`` which will take the value from the
``legend.borderaxespad`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="loc" name="loc" port_type="basic:Float">
      <docstring>The location of the legend. Possible codes are:

    ===============   =============
    Location String   Location Code
    ===============   =============
    'best'            0
    'upper right'     1
    'upper left'      2
    'lower left'      3
    'lower right'     4
    'right'           5
    'center left'     6
    'center right'    7
    'lower center'    8
    'upper center'    9
    'center'          10
    ===============   =============

Alternatively can be a 2-tuple giving ``x, y`` of the lower-left
corner of the legend in axes coordinates (in which case
``bbox_to_anchor`` will be ignored).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox_to_anchor" name="bbox_to_anchor" port_type="basic:Float">
      <docstring>Specify any arbitrary location for the legend in `bbox_transform`
coordinates (default Axes coordinates).

For example, to put the legend's upper right hand corner in the
center of the axes the following keywords can be used::

   loc='upper right', bbox_to_anchor=(0.5, 0.5)
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="title" name="title">
      <docstring>The legend's title. Default is no title (``None``).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="numpoints" name="numpoints">
      <docstring>The number of marker points in the legend when creating a legend
entry for a line/:class:`matplotlib.lines.Line2D`.
Default is ``None`` which will take the value from the
``legend.numpoints`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="prop" name="prop">
      <docstring>The font properties of the legend. If None (default), the current
:data:`matplotlib.rcParams` will be used.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="borderpad" name="borderpad" port_type="basic:Float">
      <docstring>The fractional whitespace inside the legend border.
Measured in font-size units.
Default is ``None`` which will take the value from the
``legend.borderpad`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scatterpoints" name="scatterpoints">
      <docstring>The number of marker points in the legend when creating a legend
entry for a scatter plot/
:class:`matplotlib.collections.PathCollection`.
Default is ``None`` which will take the value from the
``legend.scatterpoints`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="shadow" name="shadow">
      <docstring>Control whether to draw a shadow behind the legend.
Default is ``None`` which will take the value from the
``legend.shadow`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="framealpha" name="framealpha" port_type="basic:Float">
      <docstring>Control the alpha transparency of the legend's frame.
Default is ``None`` which will take the value from the
``legend.framealpha`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="handler_map" name="handler_map">
      <docstring>The custom dictionary mapping instances or types to a legend
handler. This `handler_map` updates the default handler map
found at :func:`matplotlib.legend.Legend.get_legend_handler_map`.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="scatteryoffsets" name="scatteryoffsets" port_type="basic:Float">
      <docstring>The vertical offset (relative to the font size) for the markers
created for a scatter plot legend entry. 0.0 is at the base the
legend text, and 1.0 is at the top. To draw all markers at the
same height, set to ``[0.5]``. Default ``[0.375, 0.5, 0.3125]``.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="markerscale" name="markerscale" port_type="basic:Float">
      <docstring>The relative size of legend markers compared with the originally
drawn ones. Default is ``None`` which will take the value from
the ``legend.markerscale`` :data:`rcParam &lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="frameon" name="frameon">
      <docstring>Control whether a frame should be drawn around the legend.
Default is ``None`` which will take the value from the
``legend.frameon`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="mode" name="mode">
      <docstring>If `mode` is set to ``"expand"`` the legend will be horizontally
expanded to fill the axes area (or `bbox_to_anchor` if defines
the legend's size).
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="bbox_transform" name="bbox_transform">
      <docstring>The transform for the bounding box (`bbox_to_anchor`). For a value
of ``None`` (default) the Axes'
:data:`~matplotlib.axes.Axes.transAxes` transform will be used.
</docstring>
    </inputPortSpec>
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.annotate" name="MplAnnotate" output_type="object" superclass="MplPlot">
    <docstring>Create an annotation: a piece of text referring to a data
point.

Parameters
----------
s : string
    label

xy : (x, y)
    position of element to annotate

xytext : (x, y) , optional, default: None
    position of the label `s`

xycoords : string, optional, default: "data"
    string that indicates what type of coordinates `xy` is. Examples:
    "figure points", "figure pixels", "figure fraction", "axes
    points", .... See `matplotlib.text.Annotation` for more details.

textcoords : string, optional
    string that indicates what type of coordinates `text` is. Examples:
    "figure points", "figure pixels", "figure fraction", "axes
    points", .... See `matplotlib.text.Annotation` for more details.
    Default is None.

arrowprops : `matplotlib.lines.Line2D` properties, optional
    Dictionary of line properties for the arrow that connects
    the annotation to the point. If the dictionnary has a key
    `arrowstyle`, a `~matplotlib.patches.FancyArrowPatch`
    instance is created and drawn.  See
    `matplotlib.text.Annotation` for more details on valid
    options. Default is None.

Returns
-------
a : `~matplotlib.text.Annotation`


Notes
-----

*arrowprops*, if not *None*, is a dictionary of line properties
(see :class:`matplotlib.lines.Line2D`) for the arrow that connects
annotation to the point.

If the dictionary has a key *arrowstyle*, a
`~matplotlib.patches.FancyArrowPatch` instance is created with
the given dictionary and is drawn. Otherwise, a
`~matplotlib.patches.YAArrow` patch instance is created and
drawn. Valid keys for `~matplotlib.patches.YAArrow` are:


=========   ===========================================================
Key         Description
=========   ===========================================================
width       the width of the arrow in points
frac        the fraction of the arrow length occupied by the head
headwidth   the width of the base of the arrow head in points
shrink      oftentimes it is convenient to have the arrowtip
            and base a bit away from the text and point being
            annotated.  If *d* is the distance between the text and
            annotated point, shrink will shorten the arrow so the tip
            and base are shink percent of the distance *d* away from
            the endpoints.  i.e., ``shrink=0.05 is 5%%``
?           any key for :class:`matplotlib.patches.polygon`
=========   ===========================================================


Valid keys for `~matplotlib.patches.FancyArrowPatch` are:


===============  ======================================================
Key              Description
===============  ======================================================
arrowstyle       the arrow style
connectionstyle  the connection style
relpos           default is (0.5, 0.5)
patchA           default is bounding box of the text
patchB           default is None
shrinkA          default is 2 points
shrinkB          default is 2 points
mutation_scale   default is text size (in points)
mutation_aspect  default is 1.
?                any key for :class:`matplotlib.patches.PathPatch`
===============  ======================================================


*xycoords* and *textcoords* are strings that indicate the
coordinates of *xy* and *xytext*, and may be one of the
following values:

=================   ===================================================
Property            Description
=================   ===================================================
'figure points'     points from the lower left corner of the figure
'figure pixels'     pixels from the lower left corner of the figure
'figure fraction'   0,0 is lower left of figure and 1,1 is upper right
'axes points'       points from lower left corner of axes
'axes pixels'       pixels from lower left corner of axes
'axes fraction'     0,0 is lower left of axes and 1,1 is upper right
'data'              use the coordinate system of the object being
                    annotated (default)
'offset points'     Specify an offset (in points) from the *xy* value

'polar'             you can specify *theta*, *r* for the annotation,
                    even in cartesian plots.  Note that if you
                    are using a polar axes, you do not need
                    to specify polar for the coordinate
                    system since that is the native "data" coordinate
                    system.
=================   ===================================================

If a 'points' or 'pixels' option is specified, values will be
added to the bottom-left and if negative, values will be
subtracted from the top-right.  e.g.::

  # 10 points to the right of the left border of the axes and
  # 5 points below the top border
  xy=(10,-5), xycoords='axes points'

You may use an instance of
:class:`~matplotlib.transforms.Transform` or
:class:`~matplotlib.artist.Artist`. See
:ref:`plotting-guide-annotation` for more details.

The *annotation_clip* attribute controls the visibility of the
annotation when it goes outside the axes area. If `True`, the
annotation will only be drawn when the *xy* is inside the
axes. If `False`, the annotation will always be drawn
regardless of its position.  The default is `None`, which
behave as `True` only if *xycoords* is "data".

Additional kwargs are `~matplotlib.text.Text` properties:

%(Text)s

Examples
--------

.. plot:: mpl_examples/pylab_examples/annotation_demo2.py</docstring>
    <inputPortSpec arg="xycoords" name="xycoords" port_type="basic:String">
      <docstring>string that indicates what type of coordinates `xy` is. Examples:
"figure points", "figure pixels", "figure fraction", "axes
points", .... See `matplotlib.text.Annotation` for more details.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['figure points', 'figure pixels', 'figure fraction', 'axes points', 'axes pixels', 'axes fraction', 'data', 'offset points', 'polar']]</values>
    </inputPortSpec>
    <inputPortSpec arg="xytext" name="xytext" port_type="basic:Float, basic:Float">
      <docstring>position of the label `s`
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="s" name="s" port_type="basic:String">
      <docstring>label
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="xy" name="xy" port_type="basic:Float,basic:Float">
      <docstring>position of element to annotate
</docstring>
    </inputPortSpec>
    <inputPortSpec arg="textcoords" name="textcoords" port_type="basic:String">
      <docstring>string that indicates what type of coordinates `text` is. Examples:
"figure points", "figure pixels", "figure fraction", "axes
points", .... See `matplotlib.text.Annotation` for more details.
Default is None.
</docstring>
      <entry_types>['enum']</entry_types>
      <values>[['figure points', 'figure pixels', 'figure fraction', 'axes points', 'axes pixels', 'axes fraction', 'data', 'offset points', 'polar']]</values>
    </inputPortSpec>
    <inputPortSpec arg="arrowprops" name="arrowprops">
      <docstring>Dictionary of line properties for the arrow that connects
the annotation to the point. If the dictionnary has a key
`arrowstyle`, a `~matplotlib.patches.FancyArrowPatch`
instance is created and drawn.  See
`matplotlib.text.Annotation` for more details on valid
options. Default is None.</docstring>
    </inputPortSpec>
    <inputPortSpec arg="arrow_patch" in_kwargs="False" name="fancyArrowProperties" port_type="MplFancyArrowPatchProperties" />
    <inputPortSpec arg="arrow" in_kwargs="False" name="arrowProperties" port_type="MplYAArrowProperties" />
    <outputPortSpec arg="annotation" compute_name="annotation" name="annotationProperties" port_type="__property__" property_key="0" property_type="matplotlib.text.Annotation" />
  </moduleSpec>
  <moduleSpec code_ref="matplotlib.pyplot.plot" name="MplLinePlot" output_type="object" superclass="MplPlot">
    <docstring>Plot lines and/or markers to the
:class:`~matplotlib.axes.Axes`.  *args* is a variable length
argument, allowing for multiple *x*, *y* pairs with an
optional format string.  For example, each of the following is
legal::

    plot(x, y)        # plot x and y using default line style and color
    plot(x, y, 'bo')  # plot x and y using blue circle markers
    plot(y)           # plot y using x as index array 0..N-1
    plot(y, 'r+')     # ditto, but with red plusses

If *x* and/or *y* is 2-dimensional, then the corresponding columns
will be plotted.

If used with labeled data, make sure that the color spec is not
included as an element in data, as otherwise the last case
``plot("v","r", data={"v":..., "r":...)``
can be interpreted as the first case which would do ``plot(v, r)``
using the default line style and color.

If not used with labeled data (i.e., without a data argument),
an arbitrary number of *x*, *y*, *fmt* groups can be specified, as in::

    a.plot(x1, y1, 'g^', x2, y2, 'g-')

Return value is a list of lines that were added.

By default, each line is assigned a different style specified by a
'style cycle'.  To change this behavior, you can edit the
axes.prop_cycle rcParam.

The following format string characters are accepted to control
the line style or marker:

================    ===============================
character           description
================    ===============================
``'-'``             solid line style
``'--'``            dashed line style
``'-.'``            dash-dot line style
``':'``             dotted line style
``'.'``             point marker
``','``             pixel marker
``'o'``             circle marker
``'v'``             triangle_down marker
``'^'``             triangle_up marker
``'&lt;'``             triangle_left marker
``'&gt;'``             triangle_right marker
``'1'``             tri_down marker
``'2'``             tri_up marker
``'3'``             tri_left marker
``'4'``             tri_right marker
``'s'``             square marker
``'p'``             pentagon marker
``'*'``             star marker
``'h'``             hexagon1 marker
``'H'``             hexagon2 marker
``'+'``             plus marker
``'x'``             x marker
``'D'``             diamond marker
``'d'``             thin_diamond marker
``'|'``             vline marker
``'_'``             hline marker
================    ===============================


The following color abbreviations are supported:

==========  ========
character   color
==========  ========
'b'         blue
'g'         green
'r'         red
'c'         cyan
'm'         magenta
'y'         yellow
'k'         black
'w'         white
==========  ========

In addition, you can specify colors in many weird and
wonderful ways, including full names (``'green'``), hex
strings (``'#008000'``), RGB or RGBA tuples (``(0,1,0,1)``) or
grayscale intensities as a string (``'0.8'``).  Of these, the
string specifications can be used in place of a ``fmt`` group,
but the tuple forms can be used only as ``kwargs``.

Line styles and colors are combined in a single format string, as in
``'bo'`` for blue circles.

The *kwargs* can be used to set line properties (any property that has
a ``set_*`` method).  You can use this to set a line label (for auto
legends), linewidth, anitialising, marker face color, etc.  Here is an
example::

    plot([1,2,3], [1,2,3], 'go-', label='line 1', linewidth=2)
    plot([1,2,3], [1,4,9], 'rs',  label='line 2')
    axis([0, 4, 0, 10])
    legend()

If you make multiple lines with one plot command, the kwargs
apply to all those lines, e.g.::

    plot(x1, y1, x2, y2, antialised=False)

Neither line will be antialiased.

You do not need to use format strings, which are just
abbreviations.  All of the line properties can be controlled
by keyword arguments.  For example, you can set the color,
marker, linestyle, and markercolor with::

    plot(x, y, color='green', linestyle='dashed', marker='o',
         markerfacecolor='blue', markersize=12).

See :class:`~matplotlib.lines.Line2D` for details.

The kwargs are :class:`~matplotlib.lines.Line2D` properties:

%(Line2D)s

kwargs *scalex* and *scaley*, if defined, are passed on to
:meth:`~matplotlib.axes.Axes.autoscale_view` to determine
whether the *x* and *y* axes are autoscaled; the default is
*True*.

Notes
-----

In addition to the above described arguments, this function can take a
**data** keyword argument. If such a **data** argument is given, the
following arguments are replaced by **data[&lt;arg&gt;]**:

* All arguments with the following names: 'y', 'x'.




Additional kwargs: hold = [True|False] overrides default hold state</docstring>
    <inputPortSpec arg="marker" name="marker">
      <translations>{'tri_down marker': '1', 'pentagon marker': 'p', 'hline marker': '_', 'pixel marker': ',', 'triangle_up marker': '^', 'point marker': '.', 'square marker': 's', 'hexagon2 marker': 'H', 'tri_right marker': '4', 'plus marker': '+', 'vline marker': '|', 'triangle_left marker': '&lt;', 'triangle_down marker': 'v', 'triangle_right marker': '&gt;', 'tri_left marker': '3', 'x marker': 'x', 'circle marker': 'o', 'dashed line style': '--', 'hexagon1 marker': 'h', 'dash-dot line style': '-.', 'dotted line style': ':', 'solid line style': '-', 'tri_up marker': '2', 'star marker': '*', 'diamond marker': 'D', 'thin_diamond marker': 'd'}</translations>
      <entry_types>['enum']</entry_types>
      <values>[['solid line style', 'dashed line style', 'dash-dot line style', 'dotted line style', 'point marker', 'pixel marker', 'circle marker', 'triangle_down marker', 'triangle_up marker', 'triangle_left marker', 'triangle_right marker', 'tri_down marker', 'tri_up marker', 'tri_left marker', 'tri_right marker', 'square marker', 'pentagon marker', 'star marker', 'hexagon1 marker', 'hexagon2 marker', 'plus marker', 'x marker', 'diamond marker', 'thin_diamond marker', 'vline marker', 'hline marker']]</values>
    </inputPortSpec>
    <inputPortSpec arg="y" arg_pos="1" in_args="True" name="y" port_type="basic:List" required="True" />
    <inputPortSpec arg="x" arg_pos="0" in_args="True" name="x" port_type="basic:List" />
    <outputPortSpec arg="line" compute_name="lines" name="lineProperties" plural="True" port_type="__property__" property_key="0" property_type="matplotlib.artist.lines.Line2D" />
  </moduleSpec>
</specs>
